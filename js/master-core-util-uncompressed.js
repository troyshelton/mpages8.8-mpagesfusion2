//! moment.js
//! version : 2.17.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):a.moment=b()}(this,function(){"use strict";function a(){return od.apply(null,arguments)}
// This is done to register the method called with moment()
// without creating circular dependencies.
function b(a){od=a}function c(a){return a instanceof Array||"[object Array]"===Object.prototype.toString.call(a)}function d(a){
// IE8 will treat undefined and null as object if it wasn't for
// input != null
return null!=a&&"[object Object]"===Object.prototype.toString.call(a)}function e(a){var b;for(b in a)
// even if its not own property I'd still call it non-empty
return!1;return!0}function f(a){return"number"==typeof a||"[object Number]"===Object.prototype.toString.call(a)}function g(a){return a instanceof Date||"[object Date]"===Object.prototype.toString.call(a)}function h(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function i(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function j(a,b){for(var c in b)i(b,c)&&(a[c]=b[c]);return i(b,"toString")&&(a.toString=b.toString),i(b,"valueOf")&&(a.valueOf=b.valueOf),a}function k(a,b,c,d){return rb(a,b,c,d,!0).utc()}function l(){
// We need to deep clone this object.
return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null}}function m(a){return null==a._pf&&(a._pf=l()),a._pf}function n(a){if(null==a._isValid){var b=m(a),c=qd.call(b.parsedDateParts,function(a){return null!=a}),d=!isNaN(a._d.getTime())&&b.overflow<0&&!b.empty&&!b.invalidMonth&&!b.invalidWeekday&&!b.nullInput&&!b.invalidFormat&&!b.userInvalidated&&(!b.meridiem||b.meridiem&&c);if(a._strict&&(d=d&&0===b.charsLeftOver&&0===b.unusedTokens.length&&void 0===b.bigHour),null!=Object.isFrozen&&Object.isFrozen(a))return d;a._isValid=d}return a._isValid}function o(a){var b=k(NaN);return null!=a?j(m(b),a):m(b).userInvalidated=!0,b}function p(a){return void 0===a}function q(a,b){var c,d,e;if(p(b._isAMomentObject)||(a._isAMomentObject=b._isAMomentObject),p(b._i)||(a._i=b._i),p(b._f)||(a._f=b._f),p(b._l)||(a._l=b._l),p(b._strict)||(a._strict=b._strict),p(b._tzm)||(a._tzm=b._tzm),p(b._isUTC)||(a._isUTC=b._isUTC),p(b._offset)||(a._offset=b._offset),p(b._pf)||(a._pf=m(b)),p(b._locale)||(a._locale=b._locale),rd.length>0)for(c in rd)d=rd[c],e=b[d],p(e)||(a[d]=e);return a}
// Moment prototype object
function r(b){q(this,b),this._d=new Date(null!=b._d?b._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),
// Prevent infinite loop in case updateOffset creates new moment
// objects.
sd===!1&&(sd=!0,a.updateOffset(this),sd=!1)}function s(a){return a instanceof r||null!=a&&null!=a._isAMomentObject}function t(a){return a<0?Math.ceil(a)||0:Math.floor(a)}function u(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=t(b)),c}
// compare two arrays, return the number of differences
function v(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;d<e;d++)(c&&a[d]!==b[d]||!c&&u(a[d])!==u(b[d]))&&g++;return g+f}function w(b){a.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+b)}function x(b,c){var d=!0;return j(function(){if(null!=a.deprecationHandler&&a.deprecationHandler(null,b),d){for(var e,f=[],g=0;g<arguments.length;g++){if(e="","object"==typeof arguments[g]){e+="\n["+g+"] ";for(var h in arguments[0])e+=h+": "+arguments[0][h]+", ";e=e.slice(0,-2)}else e=arguments[g];f.push(e)}w(b+"\nArguments: "+Array.prototype.slice.call(f).join("")+"\n"+(new Error).stack),d=!1}return c.apply(this,arguments)},c)}function y(b,c){null!=a.deprecationHandler&&a.deprecationHandler(b,c),td[b]||(w(c),td[b]=!0)}function z(a){return a instanceof Function||"[object Function]"===Object.prototype.toString.call(a)}function A(a){var b,c;for(c in a)b=a[c],z(b)?this[c]=b:this["_"+c]=b;this._config=a,
// Lenient ordinal parsing accepts just a number in addition to
// number + (possibly) stuff coming from _ordinalParseLenient.
this._ordinalParseLenient=new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)}function B(a,b){var c,e=j({},a);for(c in b)i(b,c)&&(d(a[c])&&d(b[c])?(e[c]={},j(e[c],a[c]),j(e[c],b[c])):null!=b[c]?e[c]=b[c]:delete e[c]);for(c in a)i(a,c)&&!i(b,c)&&d(a[c])&&(
// make sure changes to properties don't modify parent config
e[c]=j({},e[c]));return e}function C(a){null!=a&&this.set(a)}function D(a,b,c){var d=this._calendar[a]||this._calendar.sameElse;return z(d)?d.call(b,c):d}function E(a){var b=this._longDateFormat[a],c=this._longDateFormat[a.toUpperCase()];return b||!c?b:(this._longDateFormat[a]=c.replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a])}function F(){return this._invalidDate}function G(a){return this._ordinal.replace("%d",a)}function H(a,b,c,d){var e=this._relativeTime[c];return z(e)?e(a,b,c,d):e.replace(/%d/i,a)}function I(a,b){var c=this._relativeTime[a>0?"future":"past"];return z(c)?c(b):c.replace(/%s/i,b)}function J(a,b){var c=a.toLowerCase();Dd[c]=Dd[c+"s"]=Dd[b]=a}function K(a){return"string"==typeof a?Dd[a]||Dd[a.toLowerCase()]:void 0}function L(a){var b,c,d={};for(c in a)i(a,c)&&(b=K(c),b&&(d[b]=a[c]));return d}function M(a,b){Ed[a]=b}function N(a){var b=[];for(var c in a)b.push({unit:c,priority:Ed[c]});return b.sort(function(a,b){return a.priority-b.priority}),b}function O(b,c){return function(d){return null!=d?(Q(this,b,d),a.updateOffset(this,c),this):P(this,b)}}function P(a,b){return a.isValid()?a._d["get"+(a._isUTC?"UTC":"")+b]():NaN}function Q(a,b,c){a.isValid()&&a._d["set"+(a._isUTC?"UTC":"")+b](c)}
// MOMENTS
function R(a){return a=K(a),z(this[a])?this[a]():this}function S(a,b){if("object"==typeof a){a=L(a);for(var c=N(a),d=0;d<c.length;d++)this[c[d].unit](a[c[d].unit])}else if(a=K(a),z(this[a]))return this[a](b);return this}function T(a,b,c){var d=""+Math.abs(a),e=b-d.length,f=a>=0;return(f?c?"+":"":"-")+Math.pow(10,Math.max(0,e)).toString().substr(1)+d}
// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function U(a,b,c,d){var e=d;"string"==typeof d&&(e=function(){return this[d]()}),a&&(Id[a]=e),b&&(Id[b[0]]=function(){return T(e.apply(this,arguments),b[1],b[2])}),c&&(Id[c]=function(){return this.localeData().ordinal(e.apply(this,arguments),a)})}function V(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function W(a){var b,c,d=a.match(Fd);for(b=0,c=d.length;b<c;b++)Id[d[b]]?d[b]=Id[d[b]]:d[b]=V(d[b]);return function(b){var e,f="";for(e=0;e<c;e++)f+=d[e]instanceof Function?d[e].call(b,a):d[e];return f}}
// format date using native date object
function X(a,b){return a.isValid()?(b=Y(b,a.localeData()),Hd[b]=Hd[b]||W(b),Hd[b](a)):a.localeData().invalidDate()}function Y(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Gd.lastIndex=0;d>=0&&Gd.test(a);)a=a.replace(Gd,c),Gd.lastIndex=0,d-=1;return a}function Z(a,b,c){$d[a]=z(b)?b:function(a,d){return a&&c?c:b}}function $(a,b){return i($d,a)?$d[a](b._strict,b._locale):new RegExp(_(a))}
// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function _(a){return aa(a.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e}))}function aa(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function ba(a,b){var c,d=b;for("string"==typeof a&&(a=[a]),f(b)&&(d=function(a,c){c[b]=u(a)}),c=0;c<a.length;c++)_d[a[c]]=d}function ca(a,b){ba(a,function(a,c,d,e){d._w=d._w||{},b(a,d._w,d,e)})}function da(a,b,c){null!=b&&i(_d,a)&&_d[a](b,c._a,c,a)}function ea(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function fa(a,b){return a?c(this._months)?this._months[a.month()]:this._months[(this._months.isFormat||ke).test(b)?"format":"standalone"][a.month()]:this._months}function ga(a,b){return a?c(this._monthsShort)?this._monthsShort[a.month()]:this._monthsShort[ke.test(b)?"format":"standalone"][a.month()]:this._monthsShort}function ha(a,b,c){var d,e,f,g=a.toLocaleLowerCase();if(!this._monthsParse)for(
// this is not used
this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],d=0;d<12;++d)f=k([2e3,d]),this._shortMonthsParse[d]=this.monthsShort(f,"").toLocaleLowerCase(),this._longMonthsParse[d]=this.months(f,"").toLocaleLowerCase();return c?"MMM"===b?(e=je.call(this._shortMonthsParse,g),e!==-1?e:null):(e=je.call(this._longMonthsParse,g),e!==-1?e:null):"MMM"===b?(e=je.call(this._shortMonthsParse,g),e!==-1?e:(e=je.call(this._longMonthsParse,g),e!==-1?e:null)):(e=je.call(this._longMonthsParse,g),e!==-1?e:(e=je.call(this._shortMonthsParse,g),e!==-1?e:null))}function ia(a,b,c){var d,e,f;if(this._monthsParseExact)return ha.call(this,a,b,c);
// TODO: add sorting
// Sorting makes sure if one month (or abbr) is a prefix of another
// see sorting in computeMonthsParse
for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;d<12;d++){
// test the regex
if(
// make the regex if we don't have it already
e=k([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp("^"+this.months(e,"").replace(".","")+"$","i"),this._shortMonthsParse[d]=new RegExp("^"+this.monthsShort(e,"").replace(".","")+"$","i")),c||this._monthsParse[d]||(f="^"+this.months(e,"")+"|^"+this.monthsShort(e,""),this._monthsParse[d]=new RegExp(f.replace(".",""),"i")),c&&"MMMM"===b&&this._longMonthsParse[d].test(a))return d;if(c&&"MMM"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}}
// MOMENTS
function ja(a,b){var c;if(!a.isValid())
// No op
return a;if("string"==typeof b)if(/^\d+$/.test(b))b=u(b);else
// TODO: Another silent failure?
if(b=a.localeData().monthsParse(b),!f(b))return a;return c=Math.min(a.date(),ea(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a}function ka(b){return null!=b?(ja(this,b),a.updateOffset(this,!0),this):P(this,"Month")}function la(){return ea(this.year(),this.month())}function ma(a){return this._monthsParseExact?(i(this,"_monthsRegex")||oa.call(this),a?this._monthsShortStrictRegex:this._monthsShortRegex):(i(this,"_monthsShortRegex")||(this._monthsShortRegex=ne),this._monthsShortStrictRegex&&a?this._monthsShortStrictRegex:this._monthsShortRegex)}function na(a){return this._monthsParseExact?(i(this,"_monthsRegex")||oa.call(this),a?this._monthsStrictRegex:this._monthsRegex):(i(this,"_monthsRegex")||(this._monthsRegex=oe),this._monthsStrictRegex&&a?this._monthsStrictRegex:this._monthsRegex)}function oa(){function a(a,b){return b.length-a.length}var b,c,d=[],e=[],f=[];for(b=0;b<12;b++)
// make the regex if we don't have it already
c=k([2e3,b]),d.push(this.monthsShort(c,"")),e.push(this.months(c,"")),f.push(this.months(c,"")),f.push(this.monthsShort(c,""));for(
// Sorting makes sure if one month (or abbr) is a prefix of another it
// will match the longer piece.
d.sort(a),e.sort(a),f.sort(a),b=0;b<12;b++)d[b]=aa(d[b]),e[b]=aa(e[b]);for(b=0;b<24;b++)f[b]=aa(f[b]);this._monthsRegex=new RegExp("^("+f.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+e.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+d.join("|")+")","i")}
// HELPERS
function pa(a){return qa(a)?366:365}function qa(a){return a%4===0&&a%100!==0||a%400===0}function ra(){return qa(this.year())}function sa(a,b,c,d,e,f,g){
//can't just apply() to create a date:
//http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
var h=new Date(a,b,c,d,e,f,g);
//the date constructor remaps years 0-99 to 1900-1999
return a<100&&a>=0&&isFinite(h.getFullYear())&&h.setFullYear(a),h}function ta(a){var b=new Date(Date.UTC.apply(null,arguments));
//the Date.UTC function remaps years 0-99 to 1900-1999
return a<100&&a>=0&&isFinite(b.getUTCFullYear())&&b.setUTCFullYear(a),b}
// start-of-first-week - start-of-year
function ua(a,b,c){var// first-week day -- which january is always in the first week (4 for iso, 1 for other)
d=7+b-c,
// first-week day local weekday -- which local weekday is fwd
e=(7+ta(a,0,d).getUTCDay()-b)%7;return-e+d-1}
//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function va(a,b,c,d,e){var f,g,h=(7+c-d)%7,i=ua(a,d,e),j=1+7*(b-1)+h+i;return j<=0?(f=a-1,g=pa(f)+j):j>pa(a)?(f=a+1,g=j-pa(a)):(f=a,g=j),{year:f,dayOfYear:g}}function wa(a,b,c){var d,e,f=ua(a.year(),b,c),g=Math.floor((a.dayOfYear()-f-1)/7)+1;return g<1?(e=a.year()-1,d=g+xa(e,b,c)):g>xa(a.year(),b,c)?(d=g-xa(a.year(),b,c),e=a.year()+1):(e=a.year(),d=g),{week:d,year:e}}function xa(a,b,c){var d=ua(a,b,c),e=ua(a+1,b,c);return(pa(a)-d+e)/7}
// HELPERS
// LOCALES
function ya(a){return wa(a,this._week.dow,this._week.doy).week}function za(){return this._week.dow}function Aa(){return this._week.doy}
// MOMENTS
function Ba(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),"d")}function Ca(a){var b=wa(this,1,4).week;return null==a?b:this.add(7*(a-b),"d")}
// HELPERS
function Da(a,b){return"string"!=typeof a?a:isNaN(a)?(a=b.weekdaysParse(a),"number"==typeof a?a:null):parseInt(a,10)}function Ea(a,b){return"string"==typeof a?b.weekdaysParse(a)%7||7:isNaN(a)?null:a}function Fa(a,b){return a?c(this._weekdays)?this._weekdays[a.day()]:this._weekdays[this._weekdays.isFormat.test(b)?"format":"standalone"][a.day()]:this._weekdays}function Ga(a){return a?this._weekdaysShort[a.day()]:this._weekdaysShort}function Ha(a){return a?this._weekdaysMin[a.day()]:this._weekdaysMin}function Ia(a,b,c){var d,e,f,g=a.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],d=0;d<7;++d)f=k([2e3,1]).day(d),this._minWeekdaysParse[d]=this.weekdaysMin(f,"").toLocaleLowerCase(),this._shortWeekdaysParse[d]=this.weekdaysShort(f,"").toLocaleLowerCase(),this._weekdaysParse[d]=this.weekdays(f,"").toLocaleLowerCase();return c?"dddd"===b?(e=je.call(this._weekdaysParse,g),e!==-1?e:null):"ddd"===b?(e=je.call(this._shortWeekdaysParse,g),e!==-1?e:null):(e=je.call(this._minWeekdaysParse,g),e!==-1?e:null):"dddd"===b?(e=je.call(this._weekdaysParse,g),e!==-1?e:(e=je.call(this._shortWeekdaysParse,g),e!==-1?e:(e=je.call(this._minWeekdaysParse,g),e!==-1?e:null))):"ddd"===b?(e=je.call(this._shortWeekdaysParse,g),e!==-1?e:(e=je.call(this._weekdaysParse,g),e!==-1?e:(e=je.call(this._minWeekdaysParse,g),e!==-1?e:null))):(e=je.call(this._minWeekdaysParse,g),e!==-1?e:(e=je.call(this._weekdaysParse,g),e!==-1?e:(e=je.call(this._shortWeekdaysParse,g),e!==-1?e:null)))}function Ja(a,b,c){var d,e,f;if(this._weekdaysParseExact)return Ia.call(this,a,b,c);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),d=0;d<7;d++){
// test the regex
if(
// make the regex if we don't have it already
e=k([2e3,1]).day(d),c&&!this._fullWeekdaysParse[d]&&(this._fullWeekdaysParse[d]=new RegExp("^"+this.weekdays(e,"").replace(".",".?")+"$","i"),this._shortWeekdaysParse[d]=new RegExp("^"+this.weekdaysShort(e,"").replace(".",".?")+"$","i"),this._minWeekdaysParse[d]=new RegExp("^"+this.weekdaysMin(e,"").replace(".",".?")+"$","i")),this._weekdaysParse[d]||(f="^"+this.weekdays(e,"")+"|^"+this.weekdaysShort(e,"")+"|^"+this.weekdaysMin(e,""),this._weekdaysParse[d]=new RegExp(f.replace(".",""),"i")),c&&"dddd"===b&&this._fullWeekdaysParse[d].test(a))return d;if(c&&"ddd"===b&&this._shortWeekdaysParse[d].test(a))return d;if(c&&"dd"===b&&this._minWeekdaysParse[d].test(a))return d;if(!c&&this._weekdaysParse[d].test(a))return d}}
// MOMENTS
function Ka(a){if(!this.isValid())return null!=a?this:NaN;var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=Da(a,this.localeData()),this.add(a-b,"d")):b}function La(a){if(!this.isValid())return null!=a?this:NaN;var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,"d")}function Ma(a){if(!this.isValid())return null!=a?this:NaN;
// behaves the same as moment#day except
// as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
// as a setter, sunday should belong to the previous week.
if(null!=a){var b=Ea(a,this.localeData());return this.day(this.day()%7?b:b-7)}return this.day()||7}function Na(a){return this._weekdaysParseExact?(i(this,"_weekdaysRegex")||Qa.call(this),a?this._weekdaysStrictRegex:this._weekdaysRegex):(i(this,"_weekdaysRegex")||(this._weekdaysRegex=ue),this._weekdaysStrictRegex&&a?this._weekdaysStrictRegex:this._weekdaysRegex)}function Oa(a){return this._weekdaysParseExact?(i(this,"_weekdaysRegex")||Qa.call(this),a?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(i(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=ve),this._weekdaysShortStrictRegex&&a?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)}function Pa(a){return this._weekdaysParseExact?(i(this,"_weekdaysRegex")||Qa.call(this),a?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(i(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=we),this._weekdaysMinStrictRegex&&a?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)}function Qa(){function a(a,b){return b.length-a.length}var b,c,d,e,f,g=[],h=[],i=[],j=[];for(b=0;b<7;b++)
// make the regex if we don't have it already
c=k([2e3,1]).day(b),d=this.weekdaysMin(c,""),e=this.weekdaysShort(c,""),f=this.weekdays(c,""),g.push(d),h.push(e),i.push(f),j.push(d),j.push(e),j.push(f);for(
// Sorting makes sure if one weekday (or abbr) is a prefix of another it
// will match the longer piece.
g.sort(a),h.sort(a),i.sort(a),j.sort(a),b=0;b<7;b++)h[b]=aa(h[b]),i[b]=aa(i[b]),j[b]=aa(j[b]);this._weekdaysRegex=new RegExp("^("+j.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+h.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+g.join("|")+")","i")}
// FORMATTING
function Ra(){return this.hours()%12||12}function Sa(){return this.hours()||24}function Ta(a,b){U(a,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),b)})}
// PARSING
function Ua(a,b){return b._meridiemParse}
// LOCALES
function Va(a){
// IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
// Using charAt should be more compatible.
return"p"===(a+"").toLowerCase().charAt(0)}function Wa(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"}function Xa(a){return a?a.toLowerCase().replace("_","-"):a}
// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function Ya(a){for(var b,c,d,e,f=0;f<a.length;){for(e=Xa(a[f]).split("-"),b=e.length,c=Xa(a[f+1]),c=c?c.split("-"):null;b>0;){if(d=Za(e.slice(0,b).join("-")))return d;if(c&&c.length>=b&&v(e,c,!0)>=b-1)
//the next array item is better than a shallower substring of this one
break;b--}f++}return null}function Za(a){var b=null;
// TODO: Find a better way to register and load all the locales in Node
if(!Be[a]&&"undefined"!=typeof module&&module&&module.exports)try{b=xe._abbr,require("./locale/"+a),
// because defineLocale currently also sets the global locale, we
// want to undo that for lazy loaded locales
$a(b)}catch(a){}return Be[a]}
// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function $a(a,b){var c;
// moment.duration._locale = moment._locale = data;
return a&&(c=p(b)?bb(a):_a(a,b),c&&(xe=c)),xe._abbr}function _a(a,b){if(null!==b){var c=Ae;if(b.abbr=a,null!=Be[a])y("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),c=Be[a]._config;else if(null!=b.parentLocale){if(null==Be[b.parentLocale])return Ce[b.parentLocale]||(Ce[b.parentLocale]=[]),Ce[b.parentLocale].push({name:a,config:b}),null;c=Be[b.parentLocale]._config}
// backwards compat for now: also set the locale
// make sure we set the locale AFTER all child locales have been
// created, so we won't end up with the child locale set.
return Be[a]=new C(B(c,b)),Ce[a]&&Ce[a].forEach(function(a){_a(a.name,a.config)}),$a(a),Be[a]}
// useful for testing
return delete Be[a],null}function ab(a,b){if(null!=b){var c,d=Ae;
// MERGE
null!=Be[a]&&(d=Be[a]._config),b=B(d,b),c=new C(b),c.parentLocale=Be[a],Be[a]=c,
// backwards compat for now: also set the locale
$a(a)}else
// pass null for config to unupdate, useful for tests
null!=Be[a]&&(null!=Be[a].parentLocale?Be[a]=Be[a].parentLocale:null!=Be[a]&&delete Be[a]);return Be[a]}
// returns locale data
function bb(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return xe;if(!c(a)){if(
//short-circuit everything else
b=Za(a))return b;a=[a]}return Ya(a)}function cb(){return wd(Be)}function db(a){var b,c=a._a;return c&&m(a).overflow===-2&&(b=c[be]<0||c[be]>11?be:c[ce]<1||c[ce]>ea(c[ae],c[be])?ce:c[de]<0||c[de]>24||24===c[de]&&(0!==c[ee]||0!==c[fe]||0!==c[ge])?de:c[ee]<0||c[ee]>59?ee:c[fe]<0||c[fe]>59?fe:c[ge]<0||c[ge]>999?ge:-1,m(a)._overflowDayOfYear&&(b<ae||b>ce)&&(b=ce),m(a)._overflowWeeks&&b===-1&&(b=he),m(a)._overflowWeekday&&b===-1&&(b=ie),m(a).overflow=b),a}
// date from iso format
function eb(a){var b,c,d,e,f,g,h=a._i,i=De.exec(h)||Ee.exec(h);if(i){for(m(a).iso=!0,b=0,c=Ge.length;b<c;b++)if(Ge[b][1].exec(i[1])){e=Ge[b][0],d=Ge[b][2]!==!1;break}if(null==e)return void(a._isValid=!1);if(i[3]){for(b=0,c=He.length;b<c;b++)if(He[b][1].exec(i[3])){
// match[2] should be 'T' or space
f=(i[2]||" ")+He[b][0];break}if(null==f)return void(a._isValid=!1)}if(!d&&null!=f)return void(a._isValid=!1);if(i[4]){if(!Fe.exec(i[4]))return void(a._isValid=!1);g="Z"}a._f=e+(f||"")+(g||""),kb(a)}else a._isValid=!1}
// date from iso format or fallback
function fb(b){var c=Ie.exec(b._i);return null!==c?void(b._d=new Date(+c[1])):(eb(b),void(b._isValid===!1&&(delete b._isValid,a.createFromInputFallback(b))))}
// Pick the first defined of two or three arguments.
function gb(a,b,c){return null!=a?a:null!=b?b:c}function hb(b){
// hooks is actually the exported moment object
var c=new Date(a.now());return b._useUTC?[c.getUTCFullYear(),c.getUTCMonth(),c.getUTCDate()]:[c.getFullYear(),c.getMonth(),c.getDate()]}
// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function ib(a){var b,c,d,e,f=[];if(!a._d){
// Default to current date.
// * if no year, month, day of month are given, default to today
// * if day of month is given, default month and year
// * if month is given, default only year
// * if year is given, don't default anything
for(d=hb(a),
//compute day of the year from weeks and weekdays
a._w&&null==a._a[ce]&&null==a._a[be]&&jb(a),
//if the day of the year is set, figure out what it is
a._dayOfYear&&(e=gb(a._a[ae],d[ae]),a._dayOfYear>pa(e)&&(m(a)._overflowDayOfYear=!0),c=ta(e,0,a._dayOfYear),a._a[be]=c.getUTCMonth(),a._a[ce]=c.getUTCDate()),b=0;b<3&&null==a._a[b];++b)a._a[b]=f[b]=d[b];
// Zero out whatever was not defaulted, including time
for(;b<7;b++)a._a[b]=f[b]=null==a._a[b]?2===b?1:0:a._a[b];
// Check for 24:00:00.000
24===a._a[de]&&0===a._a[ee]&&0===a._a[fe]&&0===a._a[ge]&&(a._nextDay=!0,a._a[de]=0),a._d=(a._useUTC?ta:sa).apply(null,f),
// Apply timezone offset from input. The actual utcOffset can be changed
// with parseZone.
null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[de]=24)}}function jb(a){var b,c,d,e,f,g,h,i;if(b=a._w,null!=b.GG||null!=b.W||null!=b.E)f=1,g=4,
// TODO: We need to take the current isoWeekYear, but that depends on
// how we interpret now (local, utc, fixed offset). So create
// a now version of current config (take local/utc/offset flags, and
// create now).
c=gb(b.GG,a._a[ae],wa(sb(),1,4).year),d=gb(b.W,1),e=gb(b.E,1),(e<1||e>7)&&(i=!0);else{f=a._locale._week.dow,g=a._locale._week.doy;var j=wa(sb(),f,g);c=gb(b.gg,a._a[ae],j.year),
// Default to current week.
d=gb(b.w,j.week),null!=b.d?(
// weekday -- low day numbers are considered next week
e=b.d,(e<0||e>6)&&(i=!0)):null!=b.e?(
// local weekday -- counting starts from begining of week
e=b.e+f,(b.e<0||b.e>6)&&(i=!0)):
// default to begining of week
e=f}d<1||d>xa(c,f,g)?m(a)._overflowWeeks=!0:null!=i?m(a)._overflowWeekday=!0:(h=va(c,d,e,f,g),a._a[ae]=h.year,a._dayOfYear=h.dayOfYear)}
// date from string and format string
function kb(b){
// TODO: Move this to another part of the creation flow to prevent circular deps
if(b._f===a.ISO_8601)return void eb(b);b._a=[],m(b).empty=!0;
// This array is used to make a Date, either with `new Date` or `Date.UTC`
var c,d,e,f,g,h=""+b._i,i=h.length,j=0;for(e=Y(b._f,b._locale).match(Fd)||[],c=0;c<e.length;c++)f=e[c],d=(h.match($(f,b))||[])[0],
// console.log('token', token, 'parsedInput', parsedInput,
//         'regex', getParseRegexForToken(token, config));
d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&m(b).unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),j+=d.length),
// don't parse if it's not a known token
Id[f]?(d?m(b).empty=!1:m(b).unusedTokens.push(f),da(f,d,b)):b._strict&&!d&&m(b).unusedTokens.push(f);
// add remaining unparsed input length to the string
m(b).charsLeftOver=i-j,h.length>0&&m(b).unusedInput.push(h),
// clear _12h flag if hour is <= 12
b._a[de]<=12&&m(b).bigHour===!0&&b._a[de]>0&&(m(b).bigHour=void 0),m(b).parsedDateParts=b._a.slice(0),m(b).meridiem=b._meridiem,
// handle meridiem
b._a[de]=lb(b._locale,b._a[de],b._meridiem),ib(b),db(b)}function lb(a,b,c){var d;
// Fallback
return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&b<12&&(b+=12),d||12!==b||(b=0),b):b}
// date from string and array of format strings
function mb(a){var b,c,d,e,f;if(0===a._f.length)return m(a).invalidFormat=!0,void(a._d=new Date(NaN));for(e=0;e<a._f.length;e++)f=0,b=q({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._f=a._f[e],kb(b),n(b)&&(
// if there is any input that was not parsed add a penalty for that format
f+=m(b).charsLeftOver,
//or tokens
f+=10*m(b).unusedTokens.length,m(b).score=f,(null==d||f<d)&&(d=f,c=b));j(a,c||b)}function nb(a){if(!a._d){var b=L(a._i);a._a=h([b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],function(a){return a&&parseInt(a,10)}),ib(a)}}function ob(a){var b=new r(db(pb(a)));
// Adding is smart enough around DST
return b._nextDay&&(b.add(1,"d"),b._nextDay=void 0),b}function pb(a){var b=a._i,d=a._f;return a._locale=a._locale||bb(a._l),null===b||void 0===d&&""===b?o({nullInput:!0}):("string"==typeof b&&(a._i=b=a._locale.preparse(b)),s(b)?new r(db(b)):(g(b)?a._d=b:c(d)?mb(a):d?kb(a):qb(a),n(a)||(a._d=null),a))}function qb(b){var d=b._i;void 0===d?b._d=new Date(a.now()):g(d)?b._d=new Date(d.valueOf()):"string"==typeof d?fb(b):c(d)?(b._a=h(d.slice(0),function(a){return parseInt(a,10)}),ib(b)):"object"==typeof d?nb(b):f(d)?
// from milliseconds
b._d=new Date(d):a.createFromInputFallback(b)}function rb(a,b,f,g,h){var i={};
// object construction must be done this way.
// https://github.com/moment/moment/issues/1423
return f!==!0&&f!==!1||(g=f,f=void 0),(d(a)&&e(a)||c(a)&&0===a.length)&&(a=void 0),i._isAMomentObject=!0,i._useUTC=i._isUTC=h,i._l=f,i._i=a,i._f=b,i._strict=g,ob(i)}function sb(a,b,c,d){return rb(a,b,c,d,!1)}
// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function tb(a,b){var d,e;if(1===b.length&&c(b[0])&&(b=b[0]),!b.length)return sb();for(d=b[0],e=1;e<b.length;++e)b[e].isValid()&&!b[e][a](d)||(d=b[e]);return d}
// TODO: Use [].sort instead?
function ub(){var a=[].slice.call(arguments,0);return tb("isBefore",a)}function vb(){var a=[].slice.call(arguments,0);return tb("isAfter",a)}function wb(a){var b=L(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;
// representation for dateAddRemove
this._milliseconds=+k+1e3*j+// 1000
6e4*i+// 1000 * 60
1e3*h*60*60,//using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
// Because of dateAddRemove treats 24 hours as different from a
// day when working around DST, we need to store them separately
this._days=+g+7*f,
// It is impossible translate months into days without knowing
// which months you are are talking about, so we have to store
// it separately.
this._months=+e+3*d+12*c,this._data={},this._locale=bb(),this._bubble()}function xb(a){return a instanceof wb}function yb(a){return a<0?Math.round(-1*a)*-1:Math.round(a)}
// FORMATTING
function zb(a,b){U(a,0,0,function(){var a=this.utcOffset(),c="+";return a<0&&(a=-a,c="-"),c+T(~~(a/60),2)+b+T(~~a%60,2)})}function Ab(a,b){var c=(b||"").match(a);if(null===c)return null;var d=c[c.length-1]||[],e=(d+"").match(Me)||["-",0,0],f=+(60*e[1])+u(e[2]);return 0===f?0:"+"===e[0]?f:-f}
// Return a moment from input, that is local/utc/zone equivalent to model.
function Bb(b,c){var d,e;
// Use low-level api, because this fn is low-level api.
return c._isUTC?(d=c.clone(),e=(s(b)||g(b)?b.valueOf():sb(b).valueOf())-d.valueOf(),d._d.setTime(d._d.valueOf()+e),a.updateOffset(d,!1),d):sb(b).local()}function Cb(a){
// On Firefox.24 Date#getTimezoneOffset returns a floating point.
// https://github.com/moment/moment/pull/1871
return 15*-Math.round(a._d.getTimezoneOffset()/15)}
// MOMENTS
// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function Db(b,c){var d,e=this._offset||0;if(!this.isValid())return null!=b?this:NaN;if(null!=b){if("string"==typeof b){if(b=Ab(Xd,b),null===b)return this}else Math.abs(b)<16&&(b=60*b);return!this._isUTC&&c&&(d=Cb(this)),this._offset=b,this._isUTC=!0,null!=d&&this.add(d,"m"),e!==b&&(!c||this._changeInProgress?Tb(this,Ob(b-e,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,a.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?e:Cb(this)}function Eb(a,b){return null!=a?("string"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}function Fb(a){return this.utcOffset(0,a)}function Gb(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(Cb(this),"m")),this}function Hb(){if(null!=this._tzm)this.utcOffset(this._tzm);else if("string"==typeof this._i){var a=Ab(Wd,this._i);null!=a?this.utcOffset(a):this.utcOffset(0,!0)}return this}function Ib(a){return!!this.isValid()&&(a=a?sb(a).utcOffset():0,(this.utcOffset()-a)%60===0)}function Jb(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Kb(){if(!p(this._isDSTShifted))return this._isDSTShifted;var a={};if(q(a,this),a=pb(a),a._a){var b=a._isUTC?k(a._a):sb(a._a);this._isDSTShifted=this.isValid()&&v(a._a,b.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted}function Lb(){return!!this.isValid()&&!this._isUTC}function Mb(){return!!this.isValid()&&this._isUTC}function Nb(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}function Ob(a,b){var c,d,e,g=a,
// matching against regexp is expensive, do it on demand
h=null;// checks for null or undefined
return xb(a)?g={ms:a._milliseconds,d:a._days,M:a._months}:f(a)?(g={},b?g[b]=a:g.milliseconds=a):(h=Ne.exec(a))?(c="-"===h[1]?-1:1,g={y:0,d:u(h[ce])*c,h:u(h[de])*c,m:u(h[ee])*c,s:u(h[fe])*c,ms:u(yb(1e3*h[ge]))*c}):(h=Oe.exec(a))?(c="-"===h[1]?-1:1,g={y:Pb(h[2],c),M:Pb(h[3],c),w:Pb(h[4],c),d:Pb(h[5],c),h:Pb(h[6],c),m:Pb(h[7],c),s:Pb(h[8],c)}):null==g?g={}:"object"==typeof g&&("from"in g||"to"in g)&&(e=Rb(sb(g.from),sb(g.to)),g={},g.ms=e.milliseconds,g.M=e.months),d=new wb(g),xb(a)&&i(a,"_locale")&&(d._locale=a._locale),d}function Pb(a,b){
// We'd normally use ~~inp for this, but unfortunately it also
// converts floats to ints.
// inp may be undefined, so careful calling replace on it.
var c=a&&parseFloat(a.replace(",","."));
// apply sign while we're at it
return(isNaN(c)?0:c)*b}function Qb(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,"M").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,"M"),c}function Rb(a,b){var c;return a.isValid()&&b.isValid()?(b=Bb(b,a),a.isBefore(b)?c=Qb(a,b):(c=Qb(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c):{milliseconds:0,months:0}}
// TODO: remove 'name' arg after deprecation is removed
function Sb(a,b){return function(c,d){var e,f;
//invert the arguments, but complain about it
return null===d||isNaN(+d)||(y(b,"moment()."+b+"(period, number) is deprecated. Please use moment()."+b+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),f=c,c=d,d=f),c="string"==typeof c?+c:c,e=Ob(c,d),Tb(this,e,a),this}}function Tb(b,c,d,e){var f=c._milliseconds,g=yb(c._days),h=yb(c._months);b.isValid()&&(e=null==e||e,f&&b._d.setTime(b._d.valueOf()+f*d),g&&Q(b,"Date",P(b,"Date")+g*d),h&&ja(b,P(b,"Month")+h*d),e&&a.updateOffset(b,g||h))}function Ub(a,b){var c=a.diff(b,"days",!0);return c<-6?"sameElse":c<-1?"lastWeek":c<0?"lastDay":c<1?"sameDay":c<2?"nextDay":c<7?"nextWeek":"sameElse"}function Vb(b,c){
// We want to compare the start of today, vs this.
// Getting start-of-today depends on whether we're local/utc/offset or not.
var d=b||sb(),e=Bb(d,this).startOf("day"),f=a.calendarFormat(this,e)||"sameElse",g=c&&(z(c[f])?c[f].call(this,d):c[f]);return this.format(g||this.localeData().calendar(f,this,sb(d)))}function Wb(){return new r(this)}function Xb(a,b){var c=s(a)?a:sb(a);return!(!this.isValid()||!c.isValid())&&(b=K(p(b)?"millisecond":b),"millisecond"===b?this.valueOf()>c.valueOf():c.valueOf()<this.clone().startOf(b).valueOf())}function Yb(a,b){var c=s(a)?a:sb(a);return!(!this.isValid()||!c.isValid())&&(b=K(p(b)?"millisecond":b),"millisecond"===b?this.valueOf()<c.valueOf():this.clone().endOf(b).valueOf()<c.valueOf())}function Zb(a,b,c,d){return d=d||"()",("("===d[0]?this.isAfter(a,c):!this.isBefore(a,c))&&(")"===d[1]?this.isBefore(b,c):!this.isAfter(b,c))}function $b(a,b){var c,d=s(a)?a:sb(a);return!(!this.isValid()||!d.isValid())&&(b=K(b||"millisecond"),"millisecond"===b?this.valueOf()===d.valueOf():(c=d.valueOf(),this.clone().startOf(b).valueOf()<=c&&c<=this.clone().endOf(b).valueOf()))}function _b(a,b){return this.isSame(a,b)||this.isAfter(a,b)}function ac(a,b){return this.isSame(a,b)||this.isBefore(a,b)}function bc(a,b,c){var d,e,f,g;// 1000
// 1000 * 60
// 1000 * 60 * 60
// 1000 * 60 * 60 * 24, negate dst
// 1000 * 60 * 60 * 24 * 7, negate dst
return this.isValid()?(d=Bb(a,this),d.isValid()?(e=6e4*(d.utcOffset()-this.utcOffset()),b=K(b),"year"===b||"month"===b||"quarter"===b?(g=cc(this,d),"quarter"===b?g/=3:"year"===b&&(g/=12)):(f=this-d,g="second"===b?f/1e3:"minute"===b?f/6e4:"hour"===b?f/36e5:"day"===b?(f-e)/864e5:"week"===b?(f-e)/6048e5:f),c?g:t(g)):NaN):NaN}function cc(a,b){
// difference in months
var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),
// b is in (anchor - 1 month, anchor + 1 month)
f=a.clone().add(e,"months");
//check for negative zero, return zero if negative zero
// linear across the month
// linear across the month
return b-f<0?(c=a.clone().add(e-1,"months"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,"months"),d=(b-f)/(c-f)),-(e+d)||0}function dc(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function ec(){var a=this.clone().utc();return 0<a.year()&&a.year()<=9999?z(Date.prototype.toISOString)?this.toDate().toISOString():X(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):X(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")}/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function fc(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var a="moment",b="";this.isLocal()||(a=0===this.utcOffset()?"moment.utc":"moment.parseZone",b="Z");var c="["+a+'("]',d=0<this.year()&&this.year()<=9999?"YYYY":"YYYYYY",e="-MM-DD[T]HH:mm:ss.SSS",f=b+'[")]';return this.format(c+d+e+f)}function gc(b){b||(b=this.isUtc()?a.defaultFormatUtc:a.defaultFormat);var c=X(this,b);return this.localeData().postformat(c)}function hc(a,b){return this.isValid()&&(s(a)&&a.isValid()||sb(a).isValid())?Ob({to:this,from:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function ic(a){return this.from(sb(),a)}function jc(a,b){return this.isValid()&&(s(a)&&a.isValid()||sb(a).isValid())?Ob({from:this,to:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function kc(a){return this.to(sb(),a)}
// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function lc(a){var b;return void 0===a?this._locale._abbr:(b=bb(a),null!=b&&(this._locale=b),this)}function mc(){return this._locale}function nc(a){
// the following switch intentionally omits break keywords
// to utilize falling through the cases.
switch(a=K(a)){case"year":this.month(0);/* falls through */
case"quarter":case"month":this.date(1);/* falls through */
case"week":case"isoWeek":case"day":case"date":this.hours(0);/* falls through */
case"hour":this.minutes(0);/* falls through */
case"minute":this.seconds(0);/* falls through */
case"second":this.milliseconds(0)}
// weeks are a special case
// quarters are also special
return"week"===a&&this.weekday(0),"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this}function oc(a){
// 'date' is an alias for 'day', so it should be considered as such.
return a=K(a),void 0===a||"millisecond"===a?this:("date"===a&&(a="day"),this.startOf(a).add(1,"isoWeek"===a?"week":a).subtract(1,"ms"))}function pc(){return this._d.valueOf()-6e4*(this._offset||0)}function qc(){return Math.floor(this.valueOf()/1e3)}function rc(){return new Date(this.valueOf())}function sc(){var a=this;return[a.year(),a.month(),a.date(),a.hour(),a.minute(),a.second(),a.millisecond()]}function tc(){var a=this;return{years:a.year(),months:a.month(),date:a.date(),hours:a.hours(),minutes:a.minutes(),seconds:a.seconds(),milliseconds:a.milliseconds()}}function uc(){
// new Date(NaN).toJSON() === null
return this.isValid()?this.toISOString():null}function vc(){return n(this)}function wc(){return j({},m(this))}function xc(){return m(this).overflow}function yc(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}function zc(a,b){U(0,[a,a.length],0,b)}
// MOMENTS
function Ac(a){return Ec.call(this,a,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function Bc(a){return Ec.call(this,a,this.isoWeek(),this.isoWeekday(),1,4)}function Cc(){return xa(this.year(),1,4)}function Dc(){var a=this.localeData()._week;return xa(this.year(),a.dow,a.doy)}function Ec(a,b,c,d,e){var f;return null==a?wa(this,d,e).year:(f=xa(a,d,e),b>f&&(b=f),Fc.call(this,a,b,c,d,e))}function Fc(a,b,c,d,e){var f=va(a,b,c,d,e),g=ta(f.year,0,f.dayOfYear);return this.year(g.getUTCFullYear()),this.month(g.getUTCMonth()),this.date(g.getUTCDate()),this}
// MOMENTS
function Gc(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)}
// HELPERS
// MOMENTS
function Hc(a){var b=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==a?b:this.add(a-b,"d")}function Ic(a,b){b[ge]=u(1e3*("0."+a))}
// MOMENTS
function Jc(){return this._isUTC?"UTC":""}function Kc(){return this._isUTC?"Coordinated Universal Time":""}function Lc(a){return sb(1e3*a)}function Mc(){return sb.apply(null,arguments).parseZone()}function Nc(a){return a}function Oc(a,b,c,d){var e=bb(),f=k().set(d,b);return e[c](f,a)}function Pc(a,b,c){if(f(a)&&(b=a,a=void 0),a=a||"",null!=b)return Oc(a,b,c,"month");var d,e=[];for(d=0;d<12;d++)e[d]=Oc(a,d,c,"month");return e}
// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function Qc(a,b,c,d){"boolean"==typeof a?(f(b)&&(c=b,b=void 0),b=b||""):(b=a,c=b,a=!1,f(b)&&(c=b,b=void 0),b=b||"");var e=bb(),g=a?e._week.dow:0;if(null!=c)return Oc(b,(c+g)%7,d,"day");var h,i=[];for(h=0;h<7;h++)i[h]=Oc(b,(h+g)%7,d,"day");return i}function Rc(a,b){return Pc(a,b,"months")}function Sc(a,b){return Pc(a,b,"monthsShort")}function Tc(a,b,c){return Qc(a,b,c,"weekdays")}function Uc(a,b,c){return Qc(a,b,c,"weekdaysShort")}function Vc(a,b,c){return Qc(a,b,c,"weekdaysMin")}function Wc(){var a=this._data;return this._milliseconds=Ze(this._milliseconds),this._days=Ze(this._days),this._months=Ze(this._months),a.milliseconds=Ze(a.milliseconds),a.seconds=Ze(a.seconds),a.minutes=Ze(a.minutes),a.hours=Ze(a.hours),a.months=Ze(a.months),a.years=Ze(a.years),this}function Xc(a,b,c,d){var e=Ob(b,c);return a._milliseconds+=d*e._milliseconds,a._days+=d*e._days,a._months+=d*e._months,a._bubble()}
// supports only 2.0-style add(1, 's') or add(duration)
function Yc(a,b){return Xc(this,a,b,1)}
// supports only 2.0-style subtract(1, 's') or subtract(duration)
function Zc(a,b){return Xc(this,a,b,-1)}function $c(a){return a<0?Math.floor(a):Math.ceil(a)}function _c(){var a,b,c,d,e,f=this._milliseconds,g=this._days,h=this._months,i=this._data;
// if we have a mix of positive and negative values, bubble down first
// check: https://github.com/moment/moment/issues/2166
// The following code bubbles up values, see the tests for
// examples of what that means.
// convert days to months
// 12 months -> 1 year
return f>=0&&g>=0&&h>=0||f<=0&&g<=0&&h<=0||(f+=864e5*$c(bd(h)+g),g=0,h=0),i.milliseconds=f%1e3,a=t(f/1e3),i.seconds=a%60,b=t(a/60),i.minutes=b%60,c=t(b/60),i.hours=c%24,g+=t(c/24),e=t(ad(g)),h+=e,g-=$c(bd(e)),d=t(h/12),h%=12,i.days=g,i.months=h,i.years=d,this}function ad(a){
// 400 years have 146097 days (taking into account leap year rules)
// 400 years have 12 months === 4800
return 4800*a/146097}function bd(a){
// the reverse of daysToMonths
return 146097*a/4800}function cd(a){var b,c,d=this._milliseconds;if(a=K(a),"month"===a||"year"===a)return b=this._days+d/864e5,c=this._months+ad(b),"month"===a?c:c/12;switch(
// handle milliseconds separately because of floating point math errors (issue #1867)
b=this._days+Math.round(bd(this._months)),a){case"week":return b/7+d/6048e5;case"day":return b+d/864e5;case"hour":return 24*b+d/36e5;case"minute":return 1440*b+d/6e4;case"second":return 86400*b+d/1e3;
// Math.floor prevents floating point math errors here
case"millisecond":return Math.floor(864e5*b)+d;default:throw new Error("Unknown unit "+a)}}
// TODO: Use this.as('ms')?
function dd(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*u(this._months/12)}function ed(a){return function(){return this.as(a)}}function fd(a){return a=K(a),this[a+"s"]()}function gd(a){return function(){return this._data[a]}}function hd(){return t(this.days()/7)}
// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function id(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function jd(a,b,c){var d=Ob(a).abs(),e=of(d.as("s")),f=of(d.as("m")),g=of(d.as("h")),h=of(d.as("d")),i=of(d.as("M")),j=of(d.as("y")),k=e<pf.s&&["s",e]||f<=1&&["m"]||f<pf.m&&["mm",f]||g<=1&&["h"]||g<pf.h&&["hh",g]||h<=1&&["d"]||h<pf.d&&["dd",h]||i<=1&&["M"]||i<pf.M&&["MM",i]||j<=1&&["y"]||["yy",j];return k[2]=b,k[3]=+a>0,k[4]=c,id.apply(null,k)}
// This function allows you to set the rounding function for relative time strings
function kd(a){return void 0===a?of:"function"==typeof a&&(of=a,!0)}
// This function allows you to set a threshold for relative time strings
function ld(a,b){return void 0!==pf[a]&&(void 0===b?pf[a]:(pf[a]=b,!0))}function md(a){var b=this.localeData(),c=jd(this,!a,b);return a&&(c=b.pastFuture(+this,c)),b.postformat(c)}function nd(){
// for ISO strings we do not use the normal bubbling rules:
//  * milliseconds bubble up until they become hours
//  * days do not bubble at all
//  * months bubble up until they become years
// This is because there is no context-free conversion between hours and days
// (think of clock changes)
// and also not between days and months (28-31 days per month)
var a,b,c,d=qf(this._milliseconds)/1e3,e=qf(this._days),f=qf(this._months);
// 3600 seconds -> 60 minutes -> 1 hour
a=t(d/60),b=t(a/60),d%=60,a%=60,
// 12 months -> 1 year
c=t(f/12),f%=12;
// inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
var g=c,h=f,i=e,j=b,k=a,l=d,m=this.asSeconds();return m?(m<0?"-":"")+"P"+(g?g+"Y":"")+(h?h+"M":"")+(i?i+"D":"")+(j||k||l?"T":"")+(j?j+"H":"")+(k?k+"M":"")+(l?l+"S":""):"P0D"}var od,pd;pd=Array.prototype.some?Array.prototype.some:function(a){for(var b=Object(this),c=b.length>>>0,d=0;d<c;d++)if(d in b&&a.call(this,b[d],d,b))return!0;return!1};var qd=pd,rd=a.momentProperties=[],sd=!1,td={};a.suppressDeprecationWarnings=!1,a.deprecationHandler=null;var ud;ud=Object.keys?Object.keys:function(a){var b,c=[];for(b in a)i(a,b)&&c.push(b);return c};var vd,wd=ud,xd={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},yd={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},zd="Invalid date",Ad="%d",Bd=/\d{1,2}/,Cd={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},Dd={},Ed={},Fd=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,Gd=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Hd={},Id={},Jd=/\d/,Kd=/\d\d/,Ld=/\d{3}/,Md=/\d{4}/,Nd=/[+-]?\d{6}/,Od=/\d\d?/,Pd=/\d\d\d\d?/,Qd=/\d\d\d\d\d\d?/,Rd=/\d{1,3}/,Sd=/\d{1,4}/,Td=/[+-]?\d{1,6}/,Ud=/\d+/,Vd=/[+-]?\d+/,Wd=/Z|[+-]\d\d:?\d\d/gi,Xd=/Z|[+-]\d\d(?::?\d\d)?/gi,Yd=/[+-]?\d+(\.\d{1,3})?/,Zd=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,$d={},_d={},ae=0,be=1,ce=2,de=3,ee=4,fe=5,ge=6,he=7,ie=8;vd=Array.prototype.indexOf?Array.prototype.indexOf:function(a){
// I know
var b;for(b=0;b<this.length;++b)if(this[b]===a)return b;return-1};var je=vd;
// FORMATTING
U("M",["MM",2],"Mo",function(){return this.month()+1}),U("MMM",0,0,function(a){return this.localeData().monthsShort(this,a)}),U("MMMM",0,0,function(a){return this.localeData().months(this,a)}),
// ALIASES
J("month","M"),
// PRIORITY
M("month",8),
// PARSING
Z("M",Od),Z("MM",Od,Kd),Z("MMM",function(a,b){return b.monthsShortRegex(a)}),Z("MMMM",function(a,b){return b.monthsRegex(a)}),ba(["M","MM"],function(a,b){b[be]=u(a)-1}),ba(["MMM","MMMM"],function(a,b,c,d){var e=c._locale.monthsParse(a,d,c._strict);
// if we didn't find a month name, mark the date as invalid.
null!=e?b[be]=e:m(c).invalidMonth=a});
// LOCALES
var ke=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,le="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),me="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),ne=Zd,oe=Zd;
// FORMATTING
U("Y",0,0,function(){var a=this.year();return a<=9999?""+a:"+"+a}),U(0,["YY",2],0,function(){return this.year()%100}),U(0,["YYYY",4],0,"year"),U(0,["YYYYY",5],0,"year"),U(0,["YYYYYY",6,!0],0,"year"),
// ALIASES
J("year","y"),
// PRIORITIES
M("year",1),
// PARSING
Z("Y",Vd),Z("YY",Od,Kd),Z("YYYY",Sd,Md),Z("YYYYY",Td,Nd),Z("YYYYYY",Td,Nd),ba(["YYYYY","YYYYYY"],ae),ba("YYYY",function(b,c){c[ae]=2===b.length?a.parseTwoDigitYear(b):u(b)}),ba("YY",function(b,c){c[ae]=a.parseTwoDigitYear(b)}),ba("Y",function(a,b){b[ae]=parseInt(a,10)}),
// HOOKS
a.parseTwoDigitYear=function(a){return u(a)+(u(a)>68?1900:2e3)};
// MOMENTS
var pe=O("FullYear",!0);
// FORMATTING
U("w",["ww",2],"wo","week"),U("W",["WW",2],"Wo","isoWeek"),
// ALIASES
J("week","w"),J("isoWeek","W"),
// PRIORITIES
M("week",5),M("isoWeek",5),
// PARSING
Z("w",Od),Z("ww",Od,Kd),Z("W",Od),Z("WW",Od,Kd),ca(["w","ww","W","WW"],function(a,b,c,d){b[d.substr(0,1)]=u(a)});var qe={dow:0,// Sunday is the first day of the week.
doy:6};
// FORMATTING
U("d",0,"do","day"),U("dd",0,0,function(a){return this.localeData().weekdaysMin(this,a)}),U("ddd",0,0,function(a){return this.localeData().weekdaysShort(this,a)}),U("dddd",0,0,function(a){return this.localeData().weekdays(this,a)}),U("e",0,0,"weekday"),U("E",0,0,"isoWeekday"),
// ALIASES
J("day","d"),J("weekday","e"),J("isoWeekday","E"),
// PRIORITY
M("day",11),M("weekday",11),M("isoWeekday",11),
// PARSING
Z("d",Od),Z("e",Od),Z("E",Od),Z("dd",function(a,b){return b.weekdaysMinRegex(a)}),Z("ddd",function(a,b){return b.weekdaysShortRegex(a)}),Z("dddd",function(a,b){return b.weekdaysRegex(a)}),ca(["dd","ddd","dddd"],function(a,b,c,d){var e=c._locale.weekdaysParse(a,d,c._strict);
// if we didn't get a weekday name, mark the date as invalid
null!=e?b.d=e:m(c).invalidWeekday=a}),ca(["d","e","E"],function(a,b,c,d){b[d]=u(a)});
// LOCALES
var re="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),se="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),te="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),ue=Zd,ve=Zd,we=Zd;U("H",["HH",2],0,"hour"),U("h",["hh",2],0,Ra),U("k",["kk",2],0,Sa),U("hmm",0,0,function(){return""+Ra.apply(this)+T(this.minutes(),2)}),U("hmmss",0,0,function(){return""+Ra.apply(this)+T(this.minutes(),2)+T(this.seconds(),2)}),U("Hmm",0,0,function(){return""+this.hours()+T(this.minutes(),2)}),U("Hmmss",0,0,function(){return""+this.hours()+T(this.minutes(),2)+T(this.seconds(),2)}),Ta("a",!0),Ta("A",!1),
// ALIASES
J("hour","h"),
// PRIORITY
M("hour",13),Z("a",Ua),Z("A",Ua),Z("H",Od),Z("h",Od),Z("HH",Od,Kd),Z("hh",Od,Kd),Z("hmm",Pd),Z("hmmss",Qd),Z("Hmm",Pd),Z("Hmmss",Qd),ba(["H","HH"],de),ba(["a","A"],function(a,b,c){c._isPm=c._locale.isPM(a),c._meridiem=a}),ba(["h","hh"],function(a,b,c){b[de]=u(a),m(c).bigHour=!0}),ba("hmm",function(a,b,c){var d=a.length-2;b[de]=u(a.substr(0,d)),b[ee]=u(a.substr(d)),m(c).bigHour=!0}),ba("hmmss",function(a,b,c){var d=a.length-4,e=a.length-2;b[de]=u(a.substr(0,d)),b[ee]=u(a.substr(d,2)),b[fe]=u(a.substr(e)),m(c).bigHour=!0}),ba("Hmm",function(a,b,c){var d=a.length-2;b[de]=u(a.substr(0,d)),b[ee]=u(a.substr(d))}),ba("Hmmss",function(a,b,c){var d=a.length-4,e=a.length-2;b[de]=u(a.substr(0,d)),b[ee]=u(a.substr(d,2)),b[fe]=u(a.substr(e))});var xe,ye=/[ap]\.?m?\.?/i,ze=O("Hours",!0),Ae={calendar:xd,longDateFormat:yd,invalidDate:zd,ordinal:Ad,ordinalParse:Bd,relativeTime:Cd,months:le,monthsShort:me,week:qe,weekdays:re,weekdaysMin:te,weekdaysShort:se,meridiemParse:ye},Be={},Ce={},De=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Ee=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Fe=/Z|[+-]\d\d(?::?\d\d)?/,Ge=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],
// YYYYMM is NOT allowed by the standard
["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],He=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],Ie=/^\/?Date\((\-?\d+)/i;a.createFromInputFallback=x("value provided is not in a recognized ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(a){a._d=new Date(a._i+(a._useUTC?" UTC":""))}),
// constant that refers to the ISO standard
a.ISO_8601=function(){};var Je=x("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var a=sb.apply(null,arguments);return this.isValid()&&a.isValid()?a<this?this:a:o()}),Ke=x("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var a=sb.apply(null,arguments);return this.isValid()&&a.isValid()?a>this?this:a:o()}),Le=function(){return Date.now?Date.now():+new Date};zb("Z",":"),zb("ZZ",""),
// PARSING
Z("Z",Xd),Z("ZZ",Xd),ba(["Z","ZZ"],function(a,b,c){c._useUTC=!0,c._tzm=Ab(Xd,a)});
// HELPERS
// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var Me=/([\+\-]|\d\d)/gi;
// HOOKS
// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
a.updateOffset=function(){};
// ASP.NET json date format regex
var Ne=/^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,Oe=/^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;Ob.fn=wb.prototype;var Pe=Sb(1,"add"),Qe=Sb(-1,"subtract");a.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",a.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Re=x("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(a){return void 0===a?this.localeData():this.locale(a)});
// FORMATTING
U(0,["gg",2],0,function(){return this.weekYear()%100}),U(0,["GG",2],0,function(){return this.isoWeekYear()%100}),zc("gggg","weekYear"),zc("ggggg","weekYear"),zc("GGGG","isoWeekYear"),zc("GGGGG","isoWeekYear"),
// ALIASES
J("weekYear","gg"),J("isoWeekYear","GG"),
// PRIORITY
M("weekYear",1),M("isoWeekYear",1),
// PARSING
Z("G",Vd),Z("g",Vd),Z("GG",Od,Kd),Z("gg",Od,Kd),Z("GGGG",Sd,Md),Z("gggg",Sd,Md),Z("GGGGG",Td,Nd),Z("ggggg",Td,Nd),ca(["gggg","ggggg","GGGG","GGGGG"],function(a,b,c,d){b[d.substr(0,2)]=u(a)}),ca(["gg","GG"],function(b,c,d,e){c[e]=a.parseTwoDigitYear(b)}),
// FORMATTING
U("Q",0,"Qo","quarter"),
// ALIASES
J("quarter","Q"),
// PRIORITY
M("quarter",7),
// PARSING
Z("Q",Jd),ba("Q",function(a,b){b[be]=3*(u(a)-1)}),
// FORMATTING
U("D",["DD",2],"Do","date"),
// ALIASES
J("date","D"),
// PRIOROITY
M("date",9),
// PARSING
Z("D",Od),Z("DD",Od,Kd),Z("Do",function(a,b){return a?b._ordinalParse:b._ordinalParseLenient}),ba(["D","DD"],ce),ba("Do",function(a,b){b[ce]=u(a.match(Od)[0],10)});
// MOMENTS
var Se=O("Date",!0);
// FORMATTING
U("DDD",["DDDD",3],"DDDo","dayOfYear"),
// ALIASES
J("dayOfYear","DDD"),
// PRIORITY
M("dayOfYear",4),
// PARSING
Z("DDD",Rd),Z("DDDD",Ld),ba(["DDD","DDDD"],function(a,b,c){c._dayOfYear=u(a)}),
// FORMATTING
U("m",["mm",2],0,"minute"),
// ALIASES
J("minute","m"),
// PRIORITY
M("minute",14),
// PARSING
Z("m",Od),Z("mm",Od,Kd),ba(["m","mm"],ee);
// MOMENTS
var Te=O("Minutes",!1);
// FORMATTING
U("s",["ss",2],0,"second"),
// ALIASES
J("second","s"),
// PRIORITY
M("second",15),
// PARSING
Z("s",Od),Z("ss",Od,Kd),ba(["s","ss"],fe);
// MOMENTS
var Ue=O("Seconds",!1);
// FORMATTING
U("S",0,0,function(){return~~(this.millisecond()/100)}),U(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),U(0,["SSS",3],0,"millisecond"),U(0,["SSSS",4],0,function(){return 10*this.millisecond()}),U(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),U(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),U(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),U(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),U(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),
// ALIASES
J("millisecond","ms"),
// PRIORITY
M("millisecond",16),
// PARSING
Z("S",Rd,Jd),Z("SS",Rd,Kd),Z("SSS",Rd,Ld);var Ve;for(Ve="SSSS";Ve.length<=9;Ve+="S")Z(Ve,Ud);for(Ve="S";Ve.length<=9;Ve+="S")ba(Ve,Ic);
// MOMENTS
var We=O("Milliseconds",!1);
// FORMATTING
U("z",0,0,"zoneAbbr"),U("zz",0,0,"zoneName");var Xe=r.prototype;Xe.add=Pe,Xe.calendar=Vb,Xe.clone=Wb,Xe.diff=bc,Xe.endOf=oc,Xe.format=gc,Xe.from=hc,Xe.fromNow=ic,Xe.to=jc,Xe.toNow=kc,Xe.get=R,Xe.invalidAt=xc,Xe.isAfter=Xb,Xe.isBefore=Yb,Xe.isBetween=Zb,Xe.isSame=$b,Xe.isSameOrAfter=_b,Xe.isSameOrBefore=ac,Xe.isValid=vc,Xe.lang=Re,Xe.locale=lc,Xe.localeData=mc,Xe.max=Ke,Xe.min=Je,Xe.parsingFlags=wc,Xe.set=S,Xe.startOf=nc,Xe.subtract=Qe,Xe.toArray=sc,Xe.toObject=tc,Xe.toDate=rc,Xe.toISOString=ec,Xe.inspect=fc,Xe.toJSON=uc,Xe.toString=dc,Xe.unix=qc,Xe.valueOf=pc,Xe.creationData=yc,
// Year
Xe.year=pe,Xe.isLeapYear=ra,
// Week Year
Xe.weekYear=Ac,Xe.isoWeekYear=Bc,
// Quarter
Xe.quarter=Xe.quarters=Gc,
// Month
Xe.month=ka,Xe.daysInMonth=la,
// Week
Xe.week=Xe.weeks=Ba,Xe.isoWeek=Xe.isoWeeks=Ca,Xe.weeksInYear=Dc,Xe.isoWeeksInYear=Cc,
// Day
Xe.date=Se,Xe.day=Xe.days=Ka,Xe.weekday=La,Xe.isoWeekday=Ma,Xe.dayOfYear=Hc,
// Hour
Xe.hour=Xe.hours=ze,
// Minute
Xe.minute=Xe.minutes=Te,
// Second
Xe.second=Xe.seconds=Ue,
// Millisecond
Xe.millisecond=Xe.milliseconds=We,
// Offset
Xe.utcOffset=Db,Xe.utc=Fb,Xe.local=Gb,Xe.parseZone=Hb,Xe.hasAlignedHourOffset=Ib,Xe.isDST=Jb,Xe.isLocal=Lb,Xe.isUtcOffset=Mb,Xe.isUtc=Nb,Xe.isUTC=Nb,
// Timezone
Xe.zoneAbbr=Jc,Xe.zoneName=Kc,
// Deprecations
Xe.dates=x("dates accessor is deprecated. Use date instead.",Se),Xe.months=x("months accessor is deprecated. Use month instead",ka),Xe.years=x("years accessor is deprecated. Use year instead",pe),Xe.zone=x("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",Eb),Xe.isDSTShifted=x("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",Kb);var Ye=C.prototype;Ye.calendar=D,Ye.longDateFormat=E,Ye.invalidDate=F,Ye.ordinal=G,Ye.preparse=Nc,Ye.postformat=Nc,Ye.relativeTime=H,Ye.pastFuture=I,Ye.set=A,
// Month
Ye.months=fa,Ye.monthsShort=ga,Ye.monthsParse=ia,Ye.monthsRegex=na,Ye.monthsShortRegex=ma,
// Week
Ye.week=ya,Ye.firstDayOfYear=Aa,Ye.firstDayOfWeek=za,
// Day of Week
Ye.weekdays=Fa,Ye.weekdaysMin=Ha,Ye.weekdaysShort=Ga,Ye.weekdaysParse=Ja,Ye.weekdaysRegex=Na,Ye.weekdaysShortRegex=Oa,Ye.weekdaysMinRegex=Pa,
// Hours
Ye.isPM=Va,Ye.meridiem=Wa,$a("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===u(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),
// Side effect imports
a.lang=x("moment.lang is deprecated. Use moment.locale instead.",$a),a.langData=x("moment.langData is deprecated. Use moment.localeData instead.",bb);var Ze=Math.abs,$e=ed("ms"),_e=ed("s"),af=ed("m"),bf=ed("h"),cf=ed("d"),df=ed("w"),ef=ed("M"),ff=ed("y"),gf=gd("milliseconds"),hf=gd("seconds"),jf=gd("minutes"),kf=gd("hours"),lf=gd("days"),mf=gd("months"),nf=gd("years"),of=Math.round,pf={s:45,// seconds to minute
m:45,// minutes to hour
h:22,// hours to day
d:26,// days to month
M:11},qf=Math.abs,rf=wb.prototype;
// Deprecations
// Side effect imports
// FORMATTING
// PARSING
// Side effect imports
return rf.abs=Wc,rf.add=Yc,rf.subtract=Zc,rf.as=cd,rf.asMilliseconds=$e,rf.asSeconds=_e,rf.asMinutes=af,rf.asHours=bf,rf.asDays=cf,rf.asWeeks=df,rf.asMonths=ef,rf.asYears=ff,rf.valueOf=dd,rf._bubble=_c,rf.get=fd,rf.milliseconds=gf,rf.seconds=hf,rf.minutes=jf,rf.hours=kf,rf.days=lf,rf.weeks=hd,rf.months=mf,rf.years=nf,rf.humanize=md,rf.toISOString=nd,rf.toString=nd,rf.toJSON=nd,rf.locale=lc,rf.localeData=mc,rf.toIsoString=x("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",nd),rf.lang=Re,U("X",0,0,"unix"),U("x",0,0,"valueOf"),Z("x",Vd),Z("X",Yd),ba("X",function(a,b,c){c._d=new Date(1e3*parseFloat(a,10))}),ba("x",function(a,b,c){c._d=new Date(u(a))}),a.version="2.17.1",b(sb),a.fn=Xe,a.min=ub,a.max=vb,a.now=Le,a.utc=k,a.unix=Lc,a.months=Rc,a.isDate=g,a.locale=$a,a.invalid=o,a.duration=Ob,a.isMoment=s,a.weekdays=Tc,a.parseZone=Mc,a.localeData=bb,a.isDuration=xb,a.monthsShort=Sc,a.weekdaysMin=Vc,a.defineLocale=_a,a.updateLocale=ab,a.locales=cb,a.weekdaysShort=Uc,a.normalizeUnits=K,a.relativeTimeRounding=kd,a.relativeTimeThreshold=ld,a.calendarFormat=Ub,a.prototype=Xe,a});//! moment-timezone.js
//! version : 0.5.32
//! Copyright (c) JS Foundation and other contributors
//! license : MIT
//! github.com/moment/moment-timezone
!function(a,i){"use strict";"object"==typeof module&&module.exports?module.exports=i(require("moment")):"function"==typeof define&&define.amd?define(["moment"],i):i(a.moment)}(this,function(c){"use strict";void 0===c.version&&c.default&&(c=c.default);var i,A={},n={},t={},s={},u={};c&&"string"==typeof c.version||O("Moment Timezone requires Moment.js. See https://momentjs.com/timezone/docs/#/use-it/browser/");var a=c.version.split("."),e=+a[0],r=+a[1];function m(a){return 96<a?a-87:64<a?a-29:a-48}function o(a){var i=0,e=a.split("."),r=e[0],o=e[1]||"",c=1,A=0,n=1;for(45===a.charCodeAt(0)&&(n=-(i=1));i<r.length;i++)A=60*A+m(r.charCodeAt(i));for(i=0;i<o.length;i++)c/=60,A+=m(o.charCodeAt(i))*c;return A*n}function f(a){for(var i=0;i<a.length;i++)a[i]=o(a[i])}function l(a,i){for(var e=[],r=0;r<i.length;r++)e[r]=a[i[r]];return e}function p(a){var i=a.split("|"),e=i[2].split(" "),r=i[3].split(""),o=i[4].split(" ");return f(e),f(r),f(o),function(a,i){for(var e=0;e<i;e++)a[e]=Math.round((a[e-1]||0)+6e4*a[e]);a[i-1]=1/0}(o,r.length),{name:i[0],abbrs:l(i[1].split(" "),r),offsets:l(e,r),untils:o,population:0|i[5]}}function M(a){a&&this._set(p(a))}function d(a,i){this.name=a,this.zones=i}function b(a){var i=a.toTimeString(),e=i.match(/\([a-z ]+\)/i);"GMT"===(e=e&&e[0]?(e=e[0].match(/[A-Z]/g))?e.join(""):void 0:(e=i.match(/[A-Z]{3,5}/g))?e[0]:void 0)&&(e=void 0),this.at=+a,this.abbr=e,this.offset=a.getTimezoneOffset()}function h(a){this.zone=a,this.offsetScore=0,this.abbrScore=0}function g(){for(var a,i,e=(new Date).getFullYear()-2,r=new b(new Date(e,0,1)),o=[r],c=1;c<48;c++)(i=new b(new Date(e,c,1))).offset!==r.offset&&(a=function(a,i){for(var e,r;r=6e4*((i.at-a.at)/12e4|0);)(e=new b(new Date(a.at+r))).offset===a.offset?a=e:i=e;return a}(r,i),o.push(a),o.push(new b(new Date(a.at+6e4)))),r=i;for(c=0;c<4;c++)o.push(new b(new Date(e+c,0,1))),o.push(new b(new Date(e+c,6,1)));return o}function E(a,i){return a.offsetScore!==i.offsetScore?a.offsetScore-i.offsetScore:a.abbrScore!==i.abbrScore?a.abbrScore-i.abbrScore:a.zone.population!==i.zone.population?i.zone.population-a.zone.population:i.zone.name.localeCompare(a.zone.name)}function z(){try{var a=Intl.DateTimeFormat().resolvedOptions().timeZone;if(a&&3<a.length){var i=s[P(a)];if(i)return i;O("Moment Timezone found "+a+" from the Intl api, but did not have that data loaded.")}}catch(a){}for(var e,r,o=g(),c=o.length,A=function(a){for(var i,e,r=a.length,o={},c=[],A=0;A<r;A++)for(i in e=u[a[A].offset]||{})e.hasOwnProperty(i)&&(o[i]=!0);for(A in o)o.hasOwnProperty(A)&&c.push(s[A]);return c}(o),n=[],t=0;t<A.length;t++){for(e=new h(T(A[t])),r=0;r<c;r++)e.scoreOffsetAt(o[r]);n.push(e)}return n.sort(E),0<n.length?n[0].zone.name:void 0}function P(a){return(a||"").toLowerCase().replace(/\//g,"_")}function S(a){var i,e,r,o;for("string"==typeof a&&(a=[a]),i=0;i<a.length;i++)o=P(e=(r=a[i].split("|"))[0]),A[o]=a[i],s[o]=e,function(a,i){var e,r;for(f(i),e=0;e<i.length;e++)r=i[e],u[r]=u[r]||{},u[r][a]=!0}(o,r[2].split(" "))}function T(a,i){a=P(a);var e,r=A[a];return r instanceof M?r:"string"==typeof r?(r=new M(r),A[a]=r):n[a]&&i!==T&&(e=T(n[a],T))?((r=A[a]=new M)._set(e),r.name=s[a],r):null}function _(a){var i,e,r,o;for("string"==typeof a&&(a=[a]),i=0;i<a.length;i++)r=P((e=a[i].split("|"))[0]),o=P(e[1]),n[r]=o,s[r]=e[0],n[o]=r,s[o]=e[1]}function k(a){S(a.zones),_(a.links),function(a){var i,e,r,o;if(a&&a.length)for(i=0;i<a.length;i++)e=(o=a[i].split("|"))[0].toUpperCase(),r=o[1].split(" "),t[e]=new d(e,r)}(a.countries),L.dataVersion=a.version}function B(a){return B.didShowError||(B.didShowError=!0,O("moment.tz.zoneExists('"+a+"') has been deprecated in favor of !moment.tz.zone('"+a+"')")),!!T(a)}function C(a){var i="X"===a._f||"x"===a._f;return!(!a._a||void 0!==a._tzm||i)}function O(a){"undefined"!=typeof console&&"function"==typeof console.error&&console.error(a)}function L(a){var i=Array.prototype.slice.call(arguments,0,-1),e=arguments[arguments.length-1],r=T(e),o=c.utc.apply(null,i);return r&&!c.isMoment(a)&&C(o)&&o.add(r.parse(o),"minutes"),o.tz(e),o}(e<2||2==e&&r<6)&&O("Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js "+c.version+". See momentjs.com"),M.prototype={_set:function(a){this.name=a.name,this.abbrs=a.abbrs,this.untils=a.untils,this.offsets=a.offsets,this.population=a.population},_index:function(a){for(var i=+a,e=this.untils,r=0;r<e.length;r++)if(i<e[r])return r},countries:function(){var i=this.name;return Object.keys(t).filter(function(a){return-1!==t[a].zones.indexOf(i)})},parse:function(a){for(var i,e,r,o=+a,c=this.offsets,A=this.untils,n=A.length-1,t=0;t<n;t++)if(i=c[t],e=c[t+1],r=c[t?t-1:t],i<e&&L.moveAmbiguousForward?i=e:r<i&&L.moveInvalidForward&&(i=r),o<A[t]-6e4*i)return c[t];return c[n]},abbr:function(a){return this.abbrs[this._index(a)]},offset:function(a){return O("zone.offset has been deprecated in favor of zone.utcOffset"),this.offsets[this._index(a)]},utcOffset:function(a){return this.offsets[this._index(a)]}},h.prototype.scoreOffsetAt=function(a){this.offsetScore+=Math.abs(this.zone.utcOffset(a.at)-a.offset),this.zone.abbr(a.at).replace(/[^A-Z]/g,"")!==a.abbr&&this.abbrScore++},L.version="0.5.32",L.dataVersion="",L._zones=A,L._links=n,L._names=s,L._countries=t,L.add=S,L.link=_,L.load=k,L.zone=T,L.zoneExists=B,L.guess=function(a){return i&&!a||(i=z()),i},L.names=function(){var a,i=[];for(a in s)s.hasOwnProperty(a)&&(A[a]||A[n[a]])&&s[a]&&i.push(s[a]);return i.sort()},L.Zone=M,L.unpack=p,L.unpackBase60=o,L.needsOffset=C,L.moveInvalidForward=!0,L.moveAmbiguousForward=!1,L.countries=function(){return Object.keys(t)},L.zonesForCountry=function(a,i){var e;if(e=(e=a).toUpperCase(),!(a=t[e]||null))return null;var r=a.zones.sort();return i?r.map(function(a){return{name:a,offset:T(a).utcOffset(new Date)}}):r};var y,N=c.fn;function D(a){return function(){return this._z?this._z.abbr(this):a.call(this)}}function v(a){return function(){return this._z=null,a.apply(this,arguments)}}c.tz=L,c.defaultZone=null,c.updateOffset=function(a,i){var e,r,o=c.defaultZone;void 0===a._z&&(o&&C(a)&&!a._isUTC&&(a._d=c.utc(a._a)._d,a.utc().add(o.parse(a),"minutes")),a._z=o),a._z&&(r=a._z.utcOffset(a),Math.abs(r)<16&&(r/=60),void 0!==a.utcOffset?(e=a._z,a.utcOffset(-r,i),a._z=e):a.zone(r,i))},N.tz=function(a,i){if(a){if("string"!=typeof a)throw new Error("Time zone name must be a string, got "+a+" ["+typeof a+"]");return this._z=T(a),this._z?c.updateOffset(this,i):O("Moment Timezone has no data for "+a+". See http://momentjs.com/timezone/docs/#/data-loading/."),this}if(this._z)return this._z.name},N.zoneName=D(N.zoneName),N.zoneAbbr=D(N.zoneAbbr),N.utc=v(N.utc),c.tz.setDefault=function(a){return(e<2||2==e&&r<9)&&O("Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js "+c.version+"."),c.defaultZone=a?T(a):null,c};var G=c.momentProperties;return"[object Array]"===Object.prototype.toString.call(G)?(G.push("_z"),G.push("_a")):G&&(G._z=null),k({version:"2020a",zones:["Africa/Abidjan|GMT|0|0||48e5","Africa/Nairobi|EAT|-30|0||47e5","Africa/Algiers|CET|-10|0||26e5","Africa/Lagos|WAT|-10|0||17e6","Africa/Maputo|CAT|-20|0||26e5","Africa/Cairo|EET|-20|0||15e6","Africa/Casablanca|+00 +01|0 -10|010101010101010101010101010101|1O9e0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0|32e5","Europe/Paris|CET CEST|-10 -20|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e6","Africa/Johannesburg|SAST|-20|0||84e5","Africa/Khartoum|EAT CAT|-30 -20|01|1Usl0|51e5","Africa/Sao_Tome|GMT WAT|0 -10|010|1UQN0 2q00|","Africa/Windhoek|CAT WAT|-20 -10|0101010|1Oc00 11B0 1nX0 11B0 1nX0 11B0|32e4","America/Adak|HST HDT|a0 90|01010101010101010101010|1O100 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|326","America/Anchorage|AKST AKDT|90 80|01010101010101010101010|1O0X0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|30e4","America/Santo_Domingo|AST|40|0||29e5","America/Fortaleza|-03|30|0||34e5","America/Asuncion|-03 -04|30 40|01010101010101010101010|1O6r0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0|28e5","America/Panama|EST|50|0||15e5","America/Mexico_City|CST CDT|60 50|01010101010101010101010|1Oc80 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|20e6","America/Managua|CST|60|0||22e5","America/La_Paz|-04|40|0||19e5","America/Lima|-05|50|0||11e6","America/Denver|MST MDT|70 60|01010101010101010101010|1O0V0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e5","America/Campo_Grande|-03 -04|30 40|0101010101|1NTf0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|77e4","America/Cancun|CST EST|60 50|01|1NKU0|63e4","America/Caracas|-0430 -04|4u 40|01|1QMT0|29e5","America/Chicago|CST CDT|60 50|01010101010101010101010|1O0U0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|92e5","America/Chihuahua|MST MDT|70 60|01010101010101010101010|1Oc90 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|81e4","America/Phoenix|MST|70|0||42e5","America/Whitehorse|PST PDT MST|80 70 70|010101010102|1O0W0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0|23e3","America/New_York|EST EDT|50 40|01010101010101010101010|1O0T0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e6","America/Los_Angeles|PST PDT|80 70|01010101010101010101010|1O0W0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e6","America/Fort_Nelson|PST MST|80 70|01|1O0W0|39e2","America/Halifax|AST ADT|40 30|01010101010101010101010|1O0S0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|39e4","America/Godthab|-03 -02|30 20|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e3","America/Grand_Turk|EST EDT AST|50 40 40|0121010101010101010|1O0T0 1zb0 5Ip0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2","America/Havana|CST CDT|50 40|01010101010101010101010|1O0R0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0|21e5","America/Metlakatla|PST AKST AKDT|80 90 80|01212120121212121212121|1PAa0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 uM0 jB0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2","America/Miquelon|-03 -02|30 20|01010101010101010101010|1O0R0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|61e2","America/Montevideo|-02 -03|20 30|01|1O0Q0|17e5","America/Noronha|-02|20|0||30e2","America/Port-au-Prince|EST EDT|50 40|010101010101010101010|1O0T0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5","Antarctica/Palmer|-03 -04|30 40|010|1QSr0 Ap0|40","America/Santiago|-03 -04|30 40|010101010101010101010|1QSr0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0|62e5","America/Sao_Paulo|-02 -03|20 30|0101010101|1NTe0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|20e6","Atlantic/Azores|-01 +00|10 0|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|25e4","America/St_Johns|NST NDT|3u 2u|01010101010101010101010|1O0Ru 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4","Antarctica/Casey|+08 +11|-80 -b0|010|1RWg0 3m10|10","Asia/Bangkok|+07|-70|0||15e6","Asia/Vladivostok|+10|-a0|0||60e4","Pacific/Bougainville|+11|-b0|0||18e4","Asia/Tashkent|+05|-50|0||23e5","Pacific/Auckland|NZDT NZST|-d0 -c0|01010101010101010101010|1ObO0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00|14e5","Asia/Baghdad|+03|-30|0||66e5","Antarctica/Troll|+00 +02|0 -20|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|40","Asia/Dhaka|+06|-60|0||16e6","Asia/Amman|EET EEST|-20 -30|01010101010101010101010|1O8m0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0|25e5","Asia/Kamchatka|+12|-c0|0||18e4","Asia/Baku|+04 +05|-40 -50|010|1O9c0 1o00|27e5","Asia/Barnaul|+06 +07|-60 -70|01|1QyI0|","Asia/Beirut|EET EEST|-20 -30|01010101010101010101010|1O9a0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0|22e5","Asia/Kuala_Lumpur|+08|-80|0||71e5","Asia/Kolkata|IST|-5u|0||15e6","Asia/Chita|+08 +09|-80 -90|01|1QyG0|33e4","Asia/Ulaanbaatar|+08 +09|-80 -90|01010|1O8G0 1cJ0 1cP0 1cJ0|12e5","Asia/Shanghai|CST|-80|0||23e6","Asia/Colombo|+0530|-5u|0||22e5","Asia/Damascus|EET EEST|-20 -30|01010101010101010101010|1O8m0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0|26e5","Asia/Yakutsk|+09|-90|0||28e4","Asia/Dubai|+04|-40|0||39e5","Asia/Famagusta|EET EEST +03|-20 -30 -30|0101201010101010101010|1O9d0 1o00 11A0 15U0 2Ks0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|","Asia/Gaza|EET EEST|-20 -30|01010101010101010101010|1O8K0 1nz0 1220 1qL0 WN0 1qL0 WN0 1qL0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 Wo0 1rc0 11c0 1oo0 11c0 1oo0 11c0 1oo0|18e5","Asia/Hong_Kong|HKT|-80|0||73e5","Asia/Hovd|+07 +08|-70 -80|01010|1O8H0 1cJ0 1cP0 1cJ0|81e3","Europe/Istanbul|EET EEST +03|-20 -30 -30|01012|1O9d0 1tA0 U00 15w0|13e6","Asia/Jakarta|WIB|-70|0||31e6","Asia/Jayapura|WIT|-90|0||26e4","Asia/Jerusalem|IST IDT|-20 -30|01010101010101010101010|1O8o0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0|81e4","Asia/Kabul|+0430|-4u|0||46e5","Asia/Karachi|PKT|-50|0||24e6","Asia/Kathmandu|+0545|-5J|0||12e5","Asia/Magadan|+10 +11|-a0 -b0|01|1QJQ0|95e3","Asia/Makassar|WITA|-80|0||15e5","Asia/Manila|PST|-80|0||24e6","Europe/Athens|EET EEST|-20 -30|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|35e5","Asia/Novosibirsk|+06 +07|-60 -70|01|1Rmk0|15e5","Asia/Pyongyang|KST KST|-90 -8u|010|1P4D0 6BA0|29e5","Asia/Qyzylorda|+06 +05|-60 -50|01|1Xei0|73e4","Asia/Rangoon|+0630|-6u|0||48e5","Asia/Sakhalin|+10 +11|-a0 -b0|01|1QyE0|58e4","Asia/Seoul|KST|-90|0||23e6","Asia/Tehran|+0330 +0430|-3u -4u|01010101010101010101010|1O6ku 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0|14e6","Asia/Tokyo|JST|-90|0||38e6","Asia/Tomsk|+06 +07|-60 -70|01|1QXU0|10e5","Europe/Lisbon|WET WEST|0 -10|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e5","Atlantic/Cape_Verde|-01|10|0||50e4","Australia/Sydney|AEDT AEST|-b0 -a0|01010101010101010101010|1ObQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0|40e5","Australia/Adelaide|ACDT ACST|-au -9u|01010101010101010101010|1ObQu 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0|11e5","Australia/Brisbane|AEST|-a0|0||20e5","Australia/Darwin|ACST|-9u|0||12e4","Australia/Eucla|+0845|-8J|0||368","Australia/Lord_Howe|+11 +1030|-b0 -au|01010101010101010101010|1ObP0 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu|347","Australia/Perth|AWST|-80|0||18e5","Pacific/Easter|-05 -06|50 60|010101010101010101010|1QSr0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0|30e2","Europe/Dublin|GMT IST|0 -10|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5","Etc/GMT-1|+01|-10|0||","Pacific/Fakaofo|+13|-d0|0||483","Pacific/Kiritimati|+14|-e0|0||51e2","Etc/GMT-2|+02|-20|0||","Pacific/Tahiti|-10|a0|0||18e4","Pacific/Niue|-11|b0|0||12e2","Etc/GMT+12|-12|c0|0||","Pacific/Galapagos|-06|60|0||25e3","Etc/GMT+7|-07|70|0||","Pacific/Pitcairn|-08|80|0||56","Pacific/Gambier|-09|90|0||125","Etc/UTC|UTC|0|0||","Europe/Ulyanovsk|+03 +04|-30 -40|01|1QyL0|13e5","Europe/London|GMT BST|0 -10|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|10e6","Europe/Chisinau|EET EEST|-20 -30|01010101010101010101010|1O9c0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|67e4","Europe/Moscow|MSK|-30|0||16e6","Europe/Saratov|+03 +04|-30 -40|01|1Sfz0|","Europe/Volgograd|+03 +04|-30 -40|01|1WQL0|10e5","Pacific/Honolulu|HST|a0|0||37e4","MET|MET MEST|-10 -20|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|","Pacific/Chatham|+1345 +1245|-dJ -cJ|01010101010101010101010|1ObO0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00|600","Pacific/Apia|+14 +13|-e0 -d0|01010101010101010101010|1ObO0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00|37e3","Pacific/Fiji|+13 +12|-d0 -c0|01010101010101010101010|1NF20 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 s00 20o0 pc0 20o0 s00 20o0 pc0 20o0 pc0 20o0 pc0 20o0 pc0 20o0|88e4","Pacific/Guam|ChST|-a0|0||17e4","Pacific/Marquesas|-0930|9u|0||86e2","Pacific/Pago_Pago|SST|b0|0||37e2","Pacific/Norfolk|+1130 +11 +12|-bu -b0 -c0|012121212121212|1PoCu 9Jcu 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0|25e4","Pacific/Tongatapu|+13 +14|-d0 -e0|010|1S4d0 s00|75e3"],links:["Africa/Abidjan|Africa/Accra","Africa/Abidjan|Africa/Bamako","Africa/Abidjan|Africa/Banjul","Africa/Abidjan|Africa/Bissau","Africa/Abidjan|Africa/Conakry","Africa/Abidjan|Africa/Dakar","Africa/Abidjan|Africa/Freetown","Africa/Abidjan|Africa/Lome","Africa/Abidjan|Africa/Monrovia","Africa/Abidjan|Africa/Nouakchott","Africa/Abidjan|Africa/Ouagadougou","Africa/Abidjan|Africa/Timbuktu","Africa/Abidjan|America/Danmarkshavn","Africa/Abidjan|Atlantic/Reykjavik","Africa/Abidjan|Atlantic/St_Helena","Africa/Abidjan|Etc/GMT","Africa/Abidjan|Etc/GMT+0","Africa/Abidjan|Etc/GMT-0","Africa/Abidjan|Etc/GMT0","Africa/Abidjan|Etc/Greenwich","Africa/Abidjan|GMT","Africa/Abidjan|GMT+0","Africa/Abidjan|GMT-0","Africa/Abidjan|GMT0","Africa/Abidjan|Greenwich","Africa/Abidjan|Iceland","Africa/Algiers|Africa/Tunis","Africa/Cairo|Africa/Tripoli","Africa/Cairo|Egypt","Africa/Cairo|Europe/Kaliningrad","Africa/Cairo|Libya","Africa/Casablanca|Africa/El_Aaiun","Africa/Johannesburg|Africa/Maseru","Africa/Johannesburg|Africa/Mbabane","Africa/Lagos|Africa/Bangui","Africa/Lagos|Africa/Brazzaville","Africa/Lagos|Africa/Douala","Africa/Lagos|Africa/Kinshasa","Africa/Lagos|Africa/Libreville","Africa/Lagos|Africa/Luanda","Africa/Lagos|Africa/Malabo","Africa/Lagos|Africa/Ndjamena","Africa/Lagos|Africa/Niamey","Africa/Lagos|Africa/Porto-Novo","Africa/Maputo|Africa/Blantyre","Africa/Maputo|Africa/Bujumbura","Africa/Maputo|Africa/Gaborone","Africa/Maputo|Africa/Harare","Africa/Maputo|Africa/Kigali","Africa/Maputo|Africa/Lubumbashi","Africa/Maputo|Africa/Lusaka","Africa/Nairobi|Africa/Addis_Ababa","Africa/Nairobi|Africa/Asmara","Africa/Nairobi|Africa/Asmera","Africa/Nairobi|Africa/Dar_es_Salaam","Africa/Nairobi|Africa/Djibouti","Africa/Nairobi|Africa/Juba","Africa/Nairobi|Africa/Kampala","Africa/Nairobi|Africa/Mogadishu","Africa/Nairobi|Indian/Antananarivo","Africa/Nairobi|Indian/Comoro","Africa/Nairobi|Indian/Mayotte","America/Adak|America/Atka","America/Adak|US/Aleutian","America/Anchorage|America/Juneau","America/Anchorage|America/Nome","America/Anchorage|America/Sitka","America/Anchorage|America/Yakutat","America/Anchorage|US/Alaska","America/Campo_Grande|America/Cuiaba","America/Chicago|America/Indiana/Knox","America/Chicago|America/Indiana/Tell_City","America/Chicago|America/Knox_IN","America/Chicago|America/Matamoros","America/Chicago|America/Menominee","America/Chicago|America/North_Dakota/Beulah","America/Chicago|America/North_Dakota/Center","America/Chicago|America/North_Dakota/New_Salem","America/Chicago|America/Rainy_River","America/Chicago|America/Rankin_Inlet","America/Chicago|America/Resolute","America/Chicago|America/Winnipeg","America/Chicago|CST6CDT","America/Chicago|Canada/Central","America/Chicago|US/Central","America/Chicago|US/Indiana-Starke","America/Chihuahua|America/Mazatlan","America/Chihuahua|Mexico/BajaSur","America/Denver|America/Boise","America/Denver|America/Cambridge_Bay","America/Denver|America/Edmonton","America/Denver|America/Inuvik","America/Denver|America/Ojinaga","America/Denver|America/Shiprock","America/Denver|America/Yellowknife","America/Denver|Canada/Mountain","America/Denver|MST7MDT","America/Denver|Navajo","America/Denver|US/Mountain","America/Fortaleza|America/Araguaina","America/Fortaleza|America/Argentina/Buenos_Aires","America/Fortaleza|America/Argentina/Catamarca","America/Fortaleza|America/Argentina/ComodRivadavia","America/Fortaleza|America/Argentina/Cordoba","America/Fortaleza|America/Argentina/Jujuy","America/Fortaleza|America/Argentina/La_Rioja","America/Fortaleza|America/Argentina/Mendoza","America/Fortaleza|America/Argentina/Rio_Gallegos","America/Fortaleza|America/Argentina/Salta","America/Fortaleza|America/Argentina/San_Juan","America/Fortaleza|America/Argentina/San_Luis","America/Fortaleza|America/Argentina/Tucuman","America/Fortaleza|America/Argentina/Ushuaia","America/Fortaleza|America/Bahia","America/Fortaleza|America/Belem","America/Fortaleza|America/Buenos_Aires","America/Fortaleza|America/Catamarca","America/Fortaleza|America/Cayenne","America/Fortaleza|America/Cordoba","America/Fortaleza|America/Jujuy","America/Fortaleza|America/Maceio","America/Fortaleza|America/Mendoza","America/Fortaleza|America/Paramaribo","America/Fortaleza|America/Recife","America/Fortaleza|America/Rosario","America/Fortaleza|America/Santarem","America/Fortaleza|Antarctica/Rothera","America/Fortaleza|Atlantic/Stanley","America/Fortaleza|Etc/GMT+3","America/Godthab|America/Nuuk","America/Halifax|America/Glace_Bay","America/Halifax|America/Goose_Bay","America/Halifax|America/Moncton","America/Halifax|America/Thule","America/Halifax|Atlantic/Bermuda","America/Halifax|Canada/Atlantic","America/Havana|Cuba","America/La_Paz|America/Boa_Vista","America/La_Paz|America/Guyana","America/La_Paz|America/Manaus","America/La_Paz|America/Porto_Velho","America/La_Paz|Brazil/West","America/La_Paz|Etc/GMT+4","America/Lima|America/Bogota","America/Lima|America/Eirunepe","America/Lima|America/Guayaquil","America/Lima|America/Porto_Acre","America/Lima|America/Rio_Branco","America/Lima|Brazil/Acre","America/Lima|Etc/GMT+5","America/Los_Angeles|America/Ensenada","America/Los_Angeles|America/Santa_Isabel","America/Los_Angeles|America/Tijuana","America/Los_Angeles|America/Vancouver","America/Los_Angeles|Canada/Pacific","America/Los_Angeles|Mexico/BajaNorte","America/Los_Angeles|PST8PDT","America/Los_Angeles|US/Pacific","America/Los_Angeles|US/Pacific-New","America/Managua|America/Belize","America/Managua|America/Costa_Rica","America/Managua|America/El_Salvador","America/Managua|America/Guatemala","America/Managua|America/Regina","America/Managua|America/Swift_Current","America/Managua|America/Tegucigalpa","America/Managua|Canada/Saskatchewan","America/Mexico_City|America/Bahia_Banderas","America/Mexico_City|America/Merida","America/Mexico_City|America/Monterrey","America/Mexico_City|Mexico/General","America/New_York|America/Detroit","America/New_York|America/Fort_Wayne","America/New_York|America/Indiana/Indianapolis","America/New_York|America/Indiana/Marengo","America/New_York|America/Indiana/Petersburg","America/New_York|America/Indiana/Vevay","America/New_York|America/Indiana/Vincennes","America/New_York|America/Indiana/Winamac","America/New_York|America/Indianapolis","America/New_York|America/Iqaluit","America/New_York|America/Kentucky/Louisville","America/New_York|America/Kentucky/Monticello","America/New_York|America/Louisville","America/New_York|America/Montreal","America/New_York|America/Nassau","America/New_York|America/Nipigon","America/New_York|America/Pangnirtung","America/New_York|America/Thunder_Bay","America/New_York|America/Toronto","America/New_York|Canada/Eastern","America/New_York|EST5EDT","America/New_York|US/East-Indiana","America/New_York|US/Eastern","America/New_York|US/Michigan","America/Noronha|Atlantic/South_Georgia","America/Noronha|Brazil/DeNoronha","America/Noronha|Etc/GMT+2","America/Panama|America/Atikokan","America/Panama|America/Cayman","America/Panama|America/Coral_Harbour","America/Panama|America/Jamaica","America/Panama|EST","America/Panama|Jamaica","America/Phoenix|America/Creston","America/Phoenix|America/Dawson_Creek","America/Phoenix|America/Hermosillo","America/Phoenix|MST","America/Phoenix|US/Arizona","America/Santiago|Chile/Continental","America/Santo_Domingo|America/Anguilla","America/Santo_Domingo|America/Antigua","America/Santo_Domingo|America/Aruba","America/Santo_Domingo|America/Barbados","America/Santo_Domingo|America/Blanc-Sablon","America/Santo_Domingo|America/Curacao","America/Santo_Domingo|America/Dominica","America/Santo_Domingo|America/Grenada","America/Santo_Domingo|America/Guadeloupe","America/Santo_Domingo|America/Kralendijk","America/Santo_Domingo|America/Lower_Princes","America/Santo_Domingo|America/Marigot","America/Santo_Domingo|America/Martinique","America/Santo_Domingo|America/Montserrat","America/Santo_Domingo|America/Port_of_Spain","America/Santo_Domingo|America/Puerto_Rico","America/Santo_Domingo|America/St_Barthelemy","America/Santo_Domingo|America/St_Kitts","America/Santo_Domingo|America/St_Lucia","America/Santo_Domingo|America/St_Thomas","America/Santo_Domingo|America/St_Vincent","America/Santo_Domingo|America/Tortola","America/Santo_Domingo|America/Virgin","America/Sao_Paulo|Brazil/East","America/St_Johns|Canada/Newfoundland","America/Whitehorse|America/Dawson","America/Whitehorse|Canada/Yukon","Antarctica/Palmer|America/Punta_Arenas","Asia/Baghdad|Antarctica/Syowa","Asia/Baghdad|Asia/Aden","Asia/Baghdad|Asia/Bahrain","Asia/Baghdad|Asia/Kuwait","Asia/Baghdad|Asia/Qatar","Asia/Baghdad|Asia/Riyadh","Asia/Baghdad|Etc/GMT-3","Asia/Baghdad|Europe/Kirov","Asia/Baghdad|Europe/Minsk","Asia/Bangkok|Antarctica/Davis","Asia/Bangkok|Asia/Ho_Chi_Minh","Asia/Bangkok|Asia/Krasnoyarsk","Asia/Bangkok|Asia/Novokuznetsk","Asia/Bangkok|Asia/Phnom_Penh","Asia/Bangkok|Asia/Saigon","Asia/Bangkok|Asia/Vientiane","Asia/Bangkok|Etc/GMT-7","Asia/Bangkok|Indian/Christmas","Asia/Dhaka|Antarctica/Vostok","Asia/Dhaka|Asia/Almaty","Asia/Dhaka|Asia/Bishkek","Asia/Dhaka|Asia/Dacca","Asia/Dhaka|Asia/Kashgar","Asia/Dhaka|Asia/Omsk","Asia/Dhaka|Asia/Qostanay","Asia/Dhaka|Asia/Thimbu","Asia/Dhaka|Asia/Thimphu","Asia/Dhaka|Asia/Urumqi","Asia/Dhaka|Etc/GMT-6","Asia/Dhaka|Indian/Chagos","Asia/Dubai|Asia/Muscat","Asia/Dubai|Asia/Tbilisi","Asia/Dubai|Asia/Yerevan","Asia/Dubai|Etc/GMT-4","Asia/Dubai|Europe/Samara","Asia/Dubai|Indian/Mahe","Asia/Dubai|Indian/Mauritius","Asia/Dubai|Indian/Reunion","Asia/Gaza|Asia/Hebron","Asia/Hong_Kong|Hongkong","Asia/Jakarta|Asia/Pontianak","Asia/Jerusalem|Asia/Tel_Aviv","Asia/Jerusalem|Israel","Asia/Kamchatka|Asia/Anadyr","Asia/Kamchatka|Etc/GMT-12","Asia/Kamchatka|Kwajalein","Asia/Kamchatka|Pacific/Funafuti","Asia/Kamchatka|Pacific/Kwajalein","Asia/Kamchatka|Pacific/Majuro","Asia/Kamchatka|Pacific/Nauru","Asia/Kamchatka|Pacific/Tarawa","Asia/Kamchatka|Pacific/Wake","Asia/Kamchatka|Pacific/Wallis","Asia/Kathmandu|Asia/Katmandu","Asia/Kolkata|Asia/Calcutta","Asia/Kuala_Lumpur|Asia/Brunei","Asia/Kuala_Lumpur|Asia/Irkutsk","Asia/Kuala_Lumpur|Asia/Kuching","Asia/Kuala_Lumpur|Asia/Singapore","Asia/Kuala_Lumpur|Etc/GMT-8","Asia/Kuala_Lumpur|Singapore","Asia/Makassar|Asia/Ujung_Pandang","Asia/Rangoon|Asia/Yangon","Asia/Rangoon|Indian/Cocos","Asia/Seoul|ROK","Asia/Shanghai|Asia/Chongqing","Asia/Shanghai|Asia/Chungking","Asia/Shanghai|Asia/Harbin","Asia/Shanghai|Asia/Macao","Asia/Shanghai|Asia/Macau","Asia/Shanghai|Asia/Taipei","Asia/Shanghai|PRC","Asia/Shanghai|ROC","Asia/Tashkent|Antarctica/Mawson","Asia/Tashkent|Asia/Aqtau","Asia/Tashkent|Asia/Aqtobe","Asia/Tashkent|Asia/Ashgabat","Asia/Tashkent|Asia/Ashkhabad","Asia/Tashkent|Asia/Atyrau","Asia/Tashkent|Asia/Dushanbe","Asia/Tashkent|Asia/Oral","Asia/Tashkent|Asia/Samarkand","Asia/Tashkent|Asia/Yekaterinburg","Asia/Tashkent|Etc/GMT-5","Asia/Tashkent|Indian/Kerguelen","Asia/Tashkent|Indian/Maldives","Asia/Tehran|Iran","Asia/Tokyo|Japan","Asia/Ulaanbaatar|Asia/Choibalsan","Asia/Ulaanbaatar|Asia/Ulan_Bator","Asia/Vladivostok|Antarctica/DumontDUrville","Asia/Vladivostok|Asia/Ust-Nera","Asia/Vladivostok|Etc/GMT-10","Asia/Vladivostok|Pacific/Chuuk","Asia/Vladivostok|Pacific/Port_Moresby","Asia/Vladivostok|Pacific/Truk","Asia/Vladivostok|Pacific/Yap","Asia/Yakutsk|Asia/Dili","Asia/Yakutsk|Asia/Khandyga","Asia/Yakutsk|Etc/GMT-9","Asia/Yakutsk|Pacific/Palau","Atlantic/Azores|America/Scoresbysund","Atlantic/Cape_Verde|Etc/GMT+1","Australia/Adelaide|Australia/Broken_Hill","Australia/Adelaide|Australia/South","Australia/Adelaide|Australia/Yancowinna","Australia/Brisbane|Australia/Lindeman","Australia/Brisbane|Australia/Queensland","Australia/Darwin|Australia/North","Australia/Lord_Howe|Australia/LHI","Australia/Perth|Australia/West","Australia/Sydney|Australia/ACT","Australia/Sydney|Australia/Canberra","Australia/Sydney|Australia/Currie","Australia/Sydney|Australia/Hobart","Australia/Sydney|Australia/Melbourne","Australia/Sydney|Australia/NSW","Australia/Sydney|Australia/Tasmania","Australia/Sydney|Australia/Victoria","Etc/UTC|Etc/UCT","Etc/UTC|Etc/Universal","Etc/UTC|Etc/Zulu","Etc/UTC|UCT","Etc/UTC|UTC","Etc/UTC|Universal","Etc/UTC|Zulu","Europe/Athens|Asia/Nicosia","Europe/Athens|EET","Europe/Athens|Europe/Bucharest","Europe/Athens|Europe/Helsinki","Europe/Athens|Europe/Kiev","Europe/Athens|Europe/Mariehamn","Europe/Athens|Europe/Nicosia","Europe/Athens|Europe/Riga","Europe/Athens|Europe/Sofia","Europe/Athens|Europe/Tallinn","Europe/Athens|Europe/Uzhgorod","Europe/Athens|Europe/Vilnius","Europe/Athens|Europe/Zaporozhye","Europe/Chisinau|Europe/Tiraspol","Europe/Dublin|Eire","Europe/Istanbul|Asia/Istanbul","Europe/Istanbul|Turkey","Europe/Lisbon|Atlantic/Canary","Europe/Lisbon|Atlantic/Faeroe","Europe/Lisbon|Atlantic/Faroe","Europe/Lisbon|Atlantic/Madeira","Europe/Lisbon|Portugal","Europe/Lisbon|WET","Europe/London|Europe/Belfast","Europe/London|Europe/Guernsey","Europe/London|Europe/Isle_of_Man","Europe/London|Europe/Jersey","Europe/London|GB","Europe/London|GB-Eire","Europe/Moscow|Europe/Simferopol","Europe/Moscow|W-SU","Europe/Paris|Africa/Ceuta","Europe/Paris|Arctic/Longyearbyen","Europe/Paris|Atlantic/Jan_Mayen","Europe/Paris|CET","Europe/Paris|Europe/Amsterdam","Europe/Paris|Europe/Andorra","Europe/Paris|Europe/Belgrade","Europe/Paris|Europe/Berlin","Europe/Paris|Europe/Bratislava","Europe/Paris|Europe/Brussels","Europe/Paris|Europe/Budapest","Europe/Paris|Europe/Busingen","Europe/Paris|Europe/Copenhagen","Europe/Paris|Europe/Gibraltar","Europe/Paris|Europe/Ljubljana","Europe/Paris|Europe/Luxembourg","Europe/Paris|Europe/Madrid","Europe/Paris|Europe/Malta","Europe/Paris|Europe/Monaco","Europe/Paris|Europe/Oslo","Europe/Paris|Europe/Podgorica","Europe/Paris|Europe/Prague","Europe/Paris|Europe/Rome","Europe/Paris|Europe/San_Marino","Europe/Paris|Europe/Sarajevo","Europe/Paris|Europe/Skopje","Europe/Paris|Europe/Stockholm","Europe/Paris|Europe/Tirane","Europe/Paris|Europe/Vaduz","Europe/Paris|Europe/Vatican","Europe/Paris|Europe/Vienna","Europe/Paris|Europe/Warsaw","Europe/Paris|Europe/Zagreb","Europe/Paris|Europe/Zurich","Europe/Paris|Poland","Europe/Ulyanovsk|Europe/Astrakhan","Pacific/Auckland|Antarctica/McMurdo","Pacific/Auckland|Antarctica/South_Pole","Pacific/Auckland|NZ","Pacific/Bougainville|Antarctica/Macquarie","Pacific/Bougainville|Asia/Srednekolymsk","Pacific/Bougainville|Etc/GMT-11","Pacific/Bougainville|Pacific/Efate","Pacific/Bougainville|Pacific/Guadalcanal","Pacific/Bougainville|Pacific/Kosrae","Pacific/Bougainville|Pacific/Noumea","Pacific/Bougainville|Pacific/Pohnpei","Pacific/Bougainville|Pacific/Ponape","Pacific/Chatham|NZ-CHAT","Pacific/Easter|Chile/EasterIsland","Pacific/Fakaofo|Etc/GMT-13","Pacific/Fakaofo|Pacific/Enderbury","Pacific/Galapagos|Etc/GMT+6","Pacific/Gambier|Etc/GMT+9","Pacific/Guam|Pacific/Saipan","Pacific/Honolulu|HST","Pacific/Honolulu|Pacific/Johnston","Pacific/Honolulu|US/Hawaii","Pacific/Kiritimati|Etc/GMT-14","Pacific/Niue|Etc/GMT+11","Pacific/Pago_Pago|Pacific/Midway","Pacific/Pago_Pago|Pacific/Samoa","Pacific/Pago_Pago|US/Samoa","Pacific/Pitcairn|Etc/GMT+8","Pacific/Tahiti|Etc/GMT+10","Pacific/Tahiti|Pacific/Rarotonga"],countries:["AD|Europe/Andorra","AE|Asia/Dubai","AF|Asia/Kabul","AG|America/Port_of_Spain America/Antigua","AI|America/Port_of_Spain America/Anguilla","AL|Europe/Tirane","AM|Asia/Yerevan","AO|Africa/Lagos Africa/Luanda","AQ|Antarctica/Casey Antarctica/Davis Antarctica/DumontDUrville Antarctica/Mawson Antarctica/Palmer Antarctica/Rothera Antarctica/Syowa Antarctica/Troll Antarctica/Vostok Pacific/Auckland Antarctica/McMurdo","AR|America/Argentina/Buenos_Aires America/Argentina/Cordoba America/Argentina/Salta America/Argentina/Jujuy America/Argentina/Tucuman America/Argentina/Catamarca America/Argentina/La_Rioja America/Argentina/San_Juan America/Argentina/Mendoza America/Argentina/San_Luis America/Argentina/Rio_Gallegos America/Argentina/Ushuaia","AS|Pacific/Pago_Pago","AT|Europe/Vienna","AU|Australia/Lord_Howe Antarctica/Macquarie Australia/Hobart Australia/Currie Australia/Melbourne Australia/Sydney Australia/Broken_Hill Australia/Brisbane Australia/Lindeman Australia/Adelaide Australia/Darwin Australia/Perth Australia/Eucla","AW|America/Curacao America/Aruba","AX|Europe/Helsinki Europe/Mariehamn","AZ|Asia/Baku","BA|Europe/Belgrade Europe/Sarajevo","BB|America/Barbados","BD|Asia/Dhaka","BE|Europe/Brussels","BF|Africa/Abidjan Africa/Ouagadougou","BG|Europe/Sofia","BH|Asia/Qatar Asia/Bahrain","BI|Africa/Maputo Africa/Bujumbura","BJ|Africa/Lagos Africa/Porto-Novo","BL|America/Port_of_Spain America/St_Barthelemy","BM|Atlantic/Bermuda","BN|Asia/Brunei","BO|America/La_Paz","BQ|America/Curacao America/Kralendijk","BR|America/Noronha America/Belem America/Fortaleza America/Recife America/Araguaina America/Maceio America/Bahia America/Sao_Paulo America/Campo_Grande America/Cuiaba America/Santarem America/Porto_Velho America/Boa_Vista America/Manaus America/Eirunepe America/Rio_Branco","BS|America/Nassau","BT|Asia/Thimphu","BW|Africa/Maputo Africa/Gaborone","BY|Europe/Minsk","BZ|America/Belize","CA|America/St_Johns America/Halifax America/Glace_Bay America/Moncton America/Goose_Bay America/Blanc-Sablon America/Toronto America/Nipigon America/Thunder_Bay America/Iqaluit America/Pangnirtung America/Atikokan America/Winnipeg America/Rainy_River America/Resolute America/Rankin_Inlet America/Regina America/Swift_Current America/Edmonton America/Cambridge_Bay America/Yellowknife America/Inuvik America/Creston America/Dawson_Creek America/Fort_Nelson America/Vancouver America/Whitehorse America/Dawson","CC|Indian/Cocos","CD|Africa/Maputo Africa/Lagos Africa/Kinshasa Africa/Lubumbashi","CF|Africa/Lagos Africa/Bangui","CG|Africa/Lagos Africa/Brazzaville","CH|Europe/Zurich","CI|Africa/Abidjan","CK|Pacific/Rarotonga","CL|America/Santiago America/Punta_Arenas Pacific/Easter","CM|Africa/Lagos Africa/Douala","CN|Asia/Shanghai Asia/Urumqi","CO|America/Bogota","CR|America/Costa_Rica","CU|America/Havana","CV|Atlantic/Cape_Verde","CW|America/Curacao","CX|Indian/Christmas","CY|Asia/Nicosia Asia/Famagusta","CZ|Europe/Prague","DE|Europe/Zurich Europe/Berlin Europe/Busingen","DJ|Africa/Nairobi Africa/Djibouti","DK|Europe/Copenhagen","DM|America/Port_of_Spain America/Dominica","DO|America/Santo_Domingo","DZ|Africa/Algiers","EC|America/Guayaquil Pacific/Galapagos","EE|Europe/Tallinn","EG|Africa/Cairo","EH|Africa/El_Aaiun","ER|Africa/Nairobi Africa/Asmara","ES|Europe/Madrid Africa/Ceuta Atlantic/Canary","ET|Africa/Nairobi Africa/Addis_Ababa","FI|Europe/Helsinki","FJ|Pacific/Fiji","FK|Atlantic/Stanley","FM|Pacific/Chuuk Pacific/Pohnpei Pacific/Kosrae","FO|Atlantic/Faroe","FR|Europe/Paris","GA|Africa/Lagos Africa/Libreville","GB|Europe/London","GD|America/Port_of_Spain America/Grenada","GE|Asia/Tbilisi","GF|America/Cayenne","GG|Europe/London Europe/Guernsey","GH|Africa/Accra","GI|Europe/Gibraltar","GL|America/Godthab America/Danmarkshavn America/Scoresbysund America/Thule","GM|Africa/Abidjan Africa/Banjul","GN|Africa/Abidjan Africa/Conakry","GP|America/Port_of_Spain America/Guadeloupe","GQ|Africa/Lagos Africa/Malabo","GR|Europe/Athens","GS|Atlantic/South_Georgia","GT|America/Guatemala","GU|Pacific/Guam","GW|Africa/Bissau","GY|America/Guyana","HK|Asia/Hong_Kong","HN|America/Tegucigalpa","HR|Europe/Belgrade Europe/Zagreb","HT|America/Port-au-Prince","HU|Europe/Budapest","ID|Asia/Jakarta Asia/Pontianak Asia/Makassar Asia/Jayapura","IE|Europe/Dublin","IL|Asia/Jerusalem","IM|Europe/London Europe/Isle_of_Man","IN|Asia/Kolkata","IO|Indian/Chagos","IQ|Asia/Baghdad","IR|Asia/Tehran","IS|Atlantic/Reykjavik","IT|Europe/Rome","JE|Europe/London Europe/Jersey","JM|America/Jamaica","JO|Asia/Amman","JP|Asia/Tokyo","KE|Africa/Nairobi","KG|Asia/Bishkek","KH|Asia/Bangkok Asia/Phnom_Penh","KI|Pacific/Tarawa Pacific/Enderbury Pacific/Kiritimati","KM|Africa/Nairobi Indian/Comoro","KN|America/Port_of_Spain America/St_Kitts","KP|Asia/Pyongyang","KR|Asia/Seoul","KW|Asia/Riyadh Asia/Kuwait","KY|America/Panama America/Cayman","KZ|Asia/Almaty Asia/Qyzylorda Asia/Qostanay Asia/Aqtobe Asia/Aqtau Asia/Atyrau Asia/Oral","LA|Asia/Bangkok Asia/Vientiane","LB|Asia/Beirut","LC|America/Port_of_Spain America/St_Lucia","LI|Europe/Zurich Europe/Vaduz","LK|Asia/Colombo","LR|Africa/Monrovia","LS|Africa/Johannesburg Africa/Maseru","LT|Europe/Vilnius","LU|Europe/Luxembourg","LV|Europe/Riga","LY|Africa/Tripoli","MA|Africa/Casablanca","MC|Europe/Monaco","MD|Europe/Chisinau","ME|Europe/Belgrade Europe/Podgorica","MF|America/Port_of_Spain America/Marigot","MG|Africa/Nairobi Indian/Antananarivo","MH|Pacific/Majuro Pacific/Kwajalein","MK|Europe/Belgrade Europe/Skopje","ML|Africa/Abidjan Africa/Bamako","MM|Asia/Yangon","MN|Asia/Ulaanbaatar Asia/Hovd Asia/Choibalsan","MO|Asia/Macau","MP|Pacific/Guam Pacific/Saipan","MQ|America/Martinique","MR|Africa/Abidjan Africa/Nouakchott","MS|America/Port_of_Spain America/Montserrat","MT|Europe/Malta","MU|Indian/Mauritius","MV|Indian/Maldives","MW|Africa/Maputo Africa/Blantyre","MX|America/Mexico_City America/Cancun America/Merida America/Monterrey America/Matamoros America/Mazatlan America/Chihuahua America/Ojinaga America/Hermosillo America/Tijuana America/Bahia_Banderas","MY|Asia/Kuala_Lumpur Asia/Kuching","MZ|Africa/Maputo","NA|Africa/Windhoek","NC|Pacific/Noumea","NE|Africa/Lagos Africa/Niamey","NF|Pacific/Norfolk","NG|Africa/Lagos","NI|America/Managua","NL|Europe/Amsterdam","NO|Europe/Oslo","NP|Asia/Kathmandu","NR|Pacific/Nauru","NU|Pacific/Niue","NZ|Pacific/Auckland Pacific/Chatham","OM|Asia/Dubai Asia/Muscat","PA|America/Panama","PE|America/Lima","PF|Pacific/Tahiti Pacific/Marquesas Pacific/Gambier","PG|Pacific/Port_Moresby Pacific/Bougainville","PH|Asia/Manila","PK|Asia/Karachi","PL|Europe/Warsaw","PM|America/Miquelon","PN|Pacific/Pitcairn","PR|America/Puerto_Rico","PS|Asia/Gaza Asia/Hebron","PT|Europe/Lisbon Atlantic/Madeira Atlantic/Azores","PW|Pacific/Palau","PY|America/Asuncion","QA|Asia/Qatar","RE|Indian/Reunion","RO|Europe/Bucharest","RS|Europe/Belgrade","RU|Europe/Kaliningrad Europe/Moscow Europe/Simferopol Europe/Kirov Europe/Astrakhan Europe/Volgograd Europe/Saratov Europe/Ulyanovsk Europe/Samara Asia/Yekaterinburg Asia/Omsk Asia/Novosibirsk Asia/Barnaul Asia/Tomsk Asia/Novokuznetsk Asia/Krasnoyarsk Asia/Irkutsk Asia/Chita Asia/Yakutsk Asia/Khandyga Asia/Vladivostok Asia/Ust-Nera Asia/Magadan Asia/Sakhalin Asia/Srednekolymsk Asia/Kamchatka Asia/Anadyr","RW|Africa/Maputo Africa/Kigali","SA|Asia/Riyadh","SB|Pacific/Guadalcanal","SC|Indian/Mahe","SD|Africa/Khartoum","SE|Europe/Stockholm","SG|Asia/Singapore","SH|Africa/Abidjan Atlantic/St_Helena","SI|Europe/Belgrade Europe/Ljubljana","SJ|Europe/Oslo Arctic/Longyearbyen","SK|Europe/Prague Europe/Bratislava","SL|Africa/Abidjan Africa/Freetown","SM|Europe/Rome Europe/San_Marino","SN|Africa/Abidjan Africa/Dakar","SO|Africa/Nairobi Africa/Mogadishu","SR|America/Paramaribo","SS|Africa/Juba","ST|Africa/Sao_Tome","SV|America/El_Salvador","SX|America/Curacao America/Lower_Princes","SY|Asia/Damascus","SZ|Africa/Johannesburg Africa/Mbabane","TC|America/Grand_Turk","TD|Africa/Ndjamena","TF|Indian/Reunion Indian/Kerguelen","TG|Africa/Abidjan Africa/Lome","TH|Asia/Bangkok","TJ|Asia/Dushanbe","TK|Pacific/Fakaofo","TL|Asia/Dili","TM|Asia/Ashgabat","TN|Africa/Tunis","TO|Pacific/Tongatapu","TR|Europe/Istanbul","TT|America/Port_of_Spain","TV|Pacific/Funafuti","TW|Asia/Taipei","TZ|Africa/Nairobi Africa/Dar_es_Salaam","UA|Europe/Simferopol Europe/Kiev Europe/Uzhgorod Europe/Zaporozhye","UG|Africa/Nairobi Africa/Kampala","UM|Pacific/Pago_Pago Pacific/Wake Pacific/Honolulu Pacific/Midway","US|America/New_York America/Detroit America/Kentucky/Louisville America/Kentucky/Monticello America/Indiana/Indianapolis America/Indiana/Vincennes America/Indiana/Winamac America/Indiana/Marengo America/Indiana/Petersburg America/Indiana/Vevay America/Chicago America/Indiana/Tell_City America/Indiana/Knox America/Menominee America/North_Dakota/Center America/North_Dakota/New_Salem America/North_Dakota/Beulah America/Denver America/Boise America/Phoenix America/Los_Angeles America/Anchorage America/Juneau America/Sitka America/Metlakatla America/Yakutat America/Nome America/Adak Pacific/Honolulu","UY|America/Montevideo","UZ|Asia/Samarkand Asia/Tashkent","VA|Europe/Rome Europe/Vatican","VC|America/Port_of_Spain America/St_Vincent","VE|America/Caracas","VG|America/Port_of_Spain America/Tortola","VI|America/Port_of_Spain America/St_Thomas","VN|Asia/Bangkok Asia/Ho_Chi_Minh","VU|Pacific/Efate","WF|Pacific/Wallis","WS|Pacific/Apia","YE|Asia/Riyadh Asia/Aden","YT|Africa/Nairobi Indian/Mayotte","ZA|Africa/Johannesburg","ZM|Africa/Maputo Africa/Lusaka","ZW|Africa/Maputo Africa/Harare"]}),c});
/* eslint-disable */
/* eslint-disable eqeqeq */
/* eslint-disable no-unused-vars */
/* eslint-disable new-cap */
var objectAssign = (function() {
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function ToObject(val) {
        if (val == null) {
            throw new TypeError('Object.assign cannot be called with null or undefined');
        }

        return Object(val);
    }

    function ownEnumerableKeys(obj) {
        var keys = Object.getOwnPropertyNames(obj);

        if (Object.getOwnPropertySymbols) {
            keys = keys.concat(Object.getOwnPropertySymbols(obj));
        }

        return keys.filter(function(key) {
            return propIsEnumerable.call(obj, key);
        });
    }

    return Object.assign || function(target, source) {
            var from;
            var keys;
            var to = ToObject(target);

            for (var s = 1; s < arguments.length; s++) {
                from = arguments[ s ];
                keys = ownEnumerableKeys(Object(from));

                for (var i = 0; i < keys.length; i++) {
                    to[ keys[ i ] ] = from[ keys[ i ] ];
                }
            }

            return to;
        };
})();
/* eslint-enable eqeqeq */
/* eslint-enable no-unused-vars */
/* eslint-enable new-cap */

/* global objectAssign */
/* global EventEmitter */
var MPageUI = (function() {
    /**
     * An enumeration indicating the policy for mixing in a specification as it
     * is used in MPageUI.createClass.
     * @type {{ONCE: string, MULTI: string}}
     */
    var SPEC_POLICY = {
        ONCE: "ONCE",       //The key can only be mixed into the component once
        MULTI: "MULTI"      //The key can be merged multiple times
    };
    /**
     * An enumeration of recognized MPageUI.UIComponent functions that indicates
     * how each should be handled when mixing in the specification via
     * MPageUI.createClass.
     * @type {{functionName: SPEC_POLICY}} A key/value pair indicating the
     * policy for each function when mixing in the specification.
     */
    var MPageUIInterface = {
        attachEvents: SPEC_POLICY.ONCE,
        render: SPEC_POLICY.ONCE,
        init: SPEC_POLICY.MULTI,
        onReceiveProps: SPEC_POLICY.MULTI
    };
    /**
     * A utility function which takes two functions and returns a merged
     * function which calls fnOne then fnTwo with the same parameters.
     * @param {function} fnOne - The first function in the chain.
     * @param {function} fnTwo - The second function in the chain.
     * @returns {function} The merged function which calls fnOne then fnTwo in
     * that order.
     */
    var chainFunctions = function(fnOne, fnTwo) {
        return function chained() {
            fnOne.apply(this, arguments);
            fnTwo.apply(this, arguments);
        };
    };
    /**
     * This function takes a Constructor function and a specification which
     * will be mixed into the prototype of the Constructor. If a name collision
     * occurs and it is a function, the functions will be merged into one
     * function.
     * @param {Object} Constructor - The Constructor object, this is the
     * Constructor of the class being created.
     * @param {{}} spec - A JSON object specification whose properties are
     * mixed into the Constructor.
     * @returns {undefined} Returns nothing.
     */
    var mixSpec = function(Constructor, spec) {
        if (!spec) {
            return;
        }
        var proto = Constructor.prototype;
        if (spec.hasOwnProperty("mixins")) {
            spec.mixins.forEach(function(mixin) {
                mixSpec(Constructor, mixin);
            });
        }
        for (var name in spec) {
            if (!spec.hasOwnProperty(name) || name === "mixins") {
                continue;
            }
            var property = spec[ name ];
            var alreadyDefined = proto.hasOwnProperty(name);
            if (alreadyDefined) {
                var specPolicy = MPageUIInterface[ name ];
                if (specPolicy === SPEC_POLICY.MULTI) {
                    proto[ name ] = chainFunctions(proto[ name ], property);
                }
                else if (specPolicy === SPEC_POLICY.ONCE) {
                    logger.logWarning("Error creating MPageUI class, you can't define this fn");
                }
            }
            else {
                proto[ name ] = property;
            }
        }
    };

    var idGen = 0;
    var uiComponentPrefix = "mpageui_";
    return {
        
        /**
         * Retrieves the window object.
         * @returns {Window} The browser window object.
         */
        getWindow: function() {
            return window;
        },
        /**
         * Consider using MPageUI.createClass({}) instead.
         *
         * A small helper function that will make the provided Subclass function
         * a subclass of the provided ParentClass by setting the Subclass'
         * prototype.
         * @param {function} Subclass - The function (class) that is to become
         * a subclass of the ParentClass.
         * @param {function} ParentClass - The function (class) that is to
         * become the parent class of the Subclass.
         * @returns {undefined} Returns nothing.
         */
        extend: function(Subclass, ParentClass) {
            //Make the Subclass extend the ParentClass
            var parentClass = new ParentClass();
            Subclass.prototype = parentClass;
            Subclass.prototype.constructor = ParentClass;
        },
        /**
         * Registers a UIComponent to the MPageUI framework by giving it a
         * unique identifier.
         * @param {MPageUI.UIComponent} component - The UIComponent object to
         * be registered into the MPageUI framework.
         * @private
         * @returns {undefined} Returns undefined.
         */
        registerComponent: function(component) {
            var gid = ++idGen + "";
            component.setId(uiComponentPrefix + gid);
        },
        /**
         * Creates a new MPageUI class
         * @param {object} spec - The object specification for creating an
         * MPageUI class.
         * @returns {Function} A constructor with the specification mixed into
         * the prototype.
         */
        createClass: function(spec) {
            var Constructor = function(props) {
                this.m_props = props || {};
                this.base();
                this.init();
            };
            //By default, inherit from the base UIComponent object
            Constructor.prototype = new MPageUI.UIComponent();
            Constructor.prototype.constructor = MPageUI.UIComponent;

            //If this component is flagged as an emitter, add that to its
            //prototype
            if (spec.hasOwnProperty("emitter") && spec.emitter) {
                objectAssign(Constructor.prototype, EventEmitter.prototype);
            }

            mixSpec(Constructor, spec);

            return Constructor;
        }
    };
})();

MPageUI.UIComponent = (function() {
    /**
     * The base UIComponent class. All 'widgets' that are part of the MPageUI
     * framework must inherit from this base class.
     * @returns {MPageUI.UIComponent} Returns self to allow chaining.
     * @constructor
     */
    var UIComponent = function() {
        this.m_props = {};
        this.m_id = "";
        this.m_parent = null;
        this.m_$rootElement = null;
        return this;
    };
    UIComponent.prototype = {
        /**
         * Returns the props on the UIComponent.
         * @returns {{}} The props on the UIComponent.
         */
        getProps: function() {
            return this.m_props;
        },
        /**
         * This function takes properties, merges them with the existing
         * properties, then triggers the onReceiveProps function for the
         * UIComponent.
         * @param {{}} props - An object/JSON of properties for the
         * UIComponent. Properties should be just that, properties. It is
         * HIGHLY RECOMMENDED that you do NOT store other UIComponents as
         * properties unless you have a very good reason and understand that
         * by setting a property on a UIComponent, the UIComponent will hold
         * onto a reference of your property unless explicitly removed.
         * @returns {MPageUI.UIComponent} Returns self to allow chaining.
         */
        setProps: function(props) {
            this.m_props = objectAssign(this.m_props, props);
            this.onReceiveProps(props);
            return this;
        },
        /**
         * The clearProps function will clear the props on the UIComponent.
         * Clearing means that the props will be reset back to an empty JSON
         * object.
         * @returns {MPageUI.UIComponent} Returns self to allow chaining.
         */
        clearProps: function() {
            this.m_props = {};
            return this;
        },
        /* eslint-disable no-unused-vars */
        /**
         * This function is meant to be overridden in an MPageUI.UIComponent
         * class to handle the UIComponent receiving new properties. This
         * function is called AFTER the properties have already been stored
         * in this.m_props. The object received by this function are only the
         * new props that were set. A common use-case for this function is
         * to refresh the UIComponent based on the new properties.
         * @param {{}} nextProps - The next set of properties that were merged
         * into this.props.
         * @returns {MPageUI.UIComponent} Returns self to allow chaining.
         */
        onReceiveProps: function(nextProps) {
            return this;
        },
        /* eslint-enable no-unused-vars */
        /**
         * This function shall house any post-render event attachments.
         * The UIComponent must exist on the DOM before this function is called.
         * It is expected that subclasses of the UIComponent provide an
         * implementation of this function.
         * @returns {MPageUI.UIComponent} Returns self to allow chaining.
         */
        attachEvents: function() {
            return this;
        },
        /**
         * Serves as a base constructor for any UIComponent. This function must
         * be called within the constructor of any subclasses of the UIComponent.
         * This ensures the UIComponent is properly registered with the MPageUI
         * framework. Failure to register will result in unexpected behavior.
         * @returns {MPageUI.UIComponent} Returns self to allow chaining.
         */
        base: function() {
            MPageUI.registerComponent(this);
            return this;
        },
        /**
         * This function clears any cached elements stored in the UIComponent.
         * This ensures that the next time an element is requested, it will be
         * queried from the DOM anew. Developers who choose to cache more than
         * the root element in their UIComponent may wish to override this
         * function so that calling it will clear their set of cached elements.
         * @returns {MPageUI.UIComponent} Returns self to allow chaining.
         */
        clearElementCache: function() {
            this.m_$rootElement = null;
            return this;
        },
        /**
         * This function shall house any post-constructor initialization
         * processing. This function is especially useful for developers who
         * choose to create their UIComponent's via MPageUI.createClass as it
         * gives them an entry point into the constructor of the class.
         * @returns {MPageUI.UIComponent} Returns self to allow chaining.
         */
        init: function() {
            return this;
        },
        /**
         * Retrieves the ID of the UIComponent.
         * @returns {string} The ID of the UIComponent.
         */
        getId: function() {
            return this.m_id;
        },
        /**
         * Sets the ID of the UIComponent. This ID must be unique across all
         * UIComponent objects as it should be applied to the root DOM element
         * of the UIComponent.
         * @param {string} id - The ID of the UIComponent.
         * @returns {MPageUI.UIComponent} Returns self to allow chaining.
         */
        setId: function(id) {
            if (typeof id !== "string") {
                throw new Error("UIComponent.prototype.setId expects a string.");
            }
            this.m_id = id;
            return this;
        },
        /**
         * Retrieves the root element of the UIComponent. If this element has
         * not been cached previously, it will be queried from the DOM using the
         * ID that was set prior to rendering the UIComponent.
         * @returns {jQuery} The root jQuery DOM element of the UIComponent.
         */
        getRootElement: function() {
            if (!this.m_$rootElement || !this.m_$rootElement.length) {
                this.m_$rootElement = $("#" + this.m_id);
            }
            return this.m_$rootElement;
        },
        /**
         * The render function should be overridden by all MPageUI.UIComponent
         * classes to render the UIComponent as an html string.
         * @returns {string} The UIComponent rendered as a rendered element.
         */
        render: function() {
            return "";
        },
        /* eslint-disable no-unused-vars */
        /**
         * The base resize function should be overridden by MPageUI.UIComponent
         * classes that wish to implement resizing logic.
         * @param {{width: number, height: number}} dimensions - The dimensions
         * available to the MPageUI.UIComponent.
         * @returns {boolean} Returns false until overridden.
         */
        resize: function(dimensions) {
            return false;
        }
        /* eslint-enable no-unused-vars */
    };
    return UIComponent;
})();

/**
 * Retrieves the Fusion object.
 * @returns {MpageFusion} MpageFusion to make sure the NPMify changes for fusion are passive.
 */
if(window.MPageFusion)
{
    MPageUI.Fusion = MPageFusion;
}
        

/* globals MPageUI, objectAssign, EventEmitter */
MPageUI.MediaQuery = (function() {
    var queries = [
        { name: "XS", size: 580 },
        { name: "SM", size: 760 },
        { name: "MD", size: 1024 },
        { name: "LG", size: 1240 },
        { name: "XL", size: 1540 },
        { name: "XXL", size: 2068 }
    ].map(function(queryObject) {
        return {
            name: queryObject.name,
            size: queryObject.size,
            query: "screen and (min-width: " + queryObject.size + "px)"
        };
    });
    /**
     * Retrieves the query attribute of the provided query object, otherwise
     * it returns null.
     * @param {{
     *      name: string,
     *      size: number,
     *      query: string
     * }} queryObject - The query object from which the query attribute is retrieved.
     * @returns {string | null} The query attribute or null.
     */
    var mediaQuery = function(queryObject) {
        return queryObject ? queryObject.query : null;
    };
    /**
     * Determines if a provided query string matches the media size via
     * the window.matchMedia function.
     * @param {string} query - A media query string.
     * @returns {boolean} True if the media query string is a match, otherwise
     * false.
     */
    var matchesQuery = function(query) {
        return query ? MPageUI.getWindow().matchMedia(query).matches : false;
    };
    /**
     * Gets the current media query that matches the size of the window.
     * @param {Array<object>} queryList - The list of queries being tested.
     * @returns {object | null} The matching query or null.
     */
    var getCurrent = function(queryList) {
        for(var i = queryList.length; i--;) {
            if(matchesQuery(mediaQuery(queryList[i]))) {
                return queryList[i];
            }
        }
        return null;
    };
    /**
     * Iterates through the list of query objects to find the one that matches
     * the specified name.
     * @param {string} name - The name of the query to find in the array.
     * @param {Array<object>} queryList - The list of queries which are searched
     * for a match on the name.
     * @returns {object | null} The matching query or null.
     */
    var findQueryByName = function(name, queryList) {
        var match = null;
        queryList.some(function(queryObject) {
            if (queryObject.name === name) {
                match = queryObject;
                return true;
            }
            return false;
        });
        return match;
    };
    /**
     * Attempts to fire the change event, but only does so if the previous
     * and current media query objects do not match.
     * @param {Event} event - The JavaScript event that triggered the change.
     * @param {object} previous - The previous media query that matched.
     * @param {object} current - The current query that matches.
     * @returns {boolean} True if current is not equal to previous and there are
     * listeners for the "change" event, otherwise false.
     */
    var attemptChangeEvent = function(event, previous, current) {
        return (previous !== current) ?
            MPageUI.MediaQuery.emit("change", event, previous, current) :
            false;
    };
    var current = getCurrent(queries);
    var previous = current;
    MPageUI.getWindow().addEventListener("resize", function(event) {
        previous = current;
        current = getCurrent(queries);
        attemptChangeEvent(event, previous, current);
    });
    return objectAssign({
        /**
         * Determines if the screen is at least matching the query with the
         * specified name.
         * @param {string} name - The name of the query which will be tested
         * for a match.
         * @returns {boolean} True if the specified query name matches the
         * current screen dimensions, otherwise false.
         */
        atLeast: function(name) {
            return matchesQuery(
                mediaQuery(
                    findQueryByName(name, queries)
                )
            );
        },
        /**
         * Returns the query that is currently matching the screen dimensions.
         * @returns {object | null} The query that is currently matching on the
         * screen.
         */
        current: function() {
            return current;
        },
        /**
         * Returns the query object that matches the provided name.
         * @param {string} name - The name of the query being retrieved.
         * @returns {object | null} The query object that matched the specified
         * name, otherwise null.
         */
        get: function(name) {
            return findQueryByName(name, queries);
        },
        /**
         * Returns the list of queries that are currently supported by MPageUI.
         * @returns {Array<object>} An array of query objects.
         */
        queries: function() {
            return queries;
        }
    }, EventEmitter.prototype);
})();

/* global MPageUI */

MPageUI.DemoBanner = (function() {

    /**
     * The DemoBanner class.
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     * @constructor
     */
    var DemoBanner = function() {
        //Super constructor
        this.base();

        this.m_name = "";
        this.m_age = 0;
        this.m_gender = "";
        this.m_dateOfBirth = null;
        this.m_isDeceased = false;
        this.m_dateOfDeath = null;
        this.m_location = "";
        this.m_identificationFields = null;
        this.m_contactInfoFields = null;

        return this;
    };
    MPageUI.extend(DemoBanner, MPageUI.UIComponent);

    /**
     * Retrieves the name for the demoBanner.
     * @returns {string} the name for the demoBanner.
     */
    DemoBanner.prototype.getName = function() {
        return this.m_name;
    };

    /**
     * Sets the name for the demoBanner.
     * @param {string} name - The name for the demoBanner.
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     */
    DemoBanner.prototype.setName = function(name) {
        this.m_name = name;
        return this;
    };

    /**
     * Retrieves the age for the demoBanner.
     * @returns {string} the age for the demoBanner.
     */
    DemoBanner.prototype.getAge = function() {
        return this.m_age;
    };

    /**
     * Sets the age for the demoBanner.
     * @param {string} age - The age for the demoBanner.
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     */
    DemoBanner.prototype.setAge = function(age) {
        this.m_age = age;
        return this;
    };

    /**
     * Retrieves the date of birth for the demoBanner.
     * @returns {string} the date of birth for the demoBanner.
     */
    DemoBanner.prototype.getDOB = function() {
        return this.m_dateOfBirth;
    };

    /**
     * Sets the date of birth for the demoBanner.
     * @param {string} dob - The date of birth for the demoBanner.
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     */
    DemoBanner.prototype.setDOB = function(dob) {
        this.m_dateOfBirth = dob;
        return this;
    };

    /**
     * Retrieves the gender for the demoBanner.
     * @returns {string} the gender for the demoBanner.
     */
    DemoBanner.prototype.getGender = function() {
        return this.m_gender;
    };

    /**
     * Sets the gender for the demoBanner.
     * @param {string} sex - The gender for the demoBanner.
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     */
    DemoBanner.prototype.setGender = function(sex) {
        this.m_gender = sex;
        return this;
    };

    /**
     * Retrieves the deceased status for the demoBanner.
     * @returns {boolean} the deceased status for the demoBanner.
     */
    DemoBanner.prototype.getDeceasedIndicator = function() {
        return this.m_isDeceased;
    };

    /**
     * Sets the deceased status for the demoBanner.
     * @param {boolean} deceasedInd - The deceased status for the demoBanner.
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     */
    DemoBanner.prototype.setDeceasedIndicator = function(deceasedInd) {
        this.m_isDeceased = deceasedInd;
        return this;
    };

    /**
     * Retrieves the date of death for the demoBanner.
     * @returns {string} the date of death.
     */
    DemoBanner.prototype.getDateOfDeath = function() {
        return this.m_dateOfDeath;
    };

    /**
     * Sets the date of death for the demoBanner.
     * @param {string} dateOfDeath - The date of death.
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     */
    DemoBanner.prototype.setDateOfDeath = function(dateOfDeath) {
        this.m_dateOfDeath = dateOfDeath;
        return this;
    };

    /**
     * Retrieves the location for the demoBanner.
     * @returns {string} the location.
     */
    DemoBanner.prototype.getLocation = function() {
        return this.m_location;
    };

    /**
     * Sets the location for the demoBanner.
     * @param {string} location  - The location for the demoBanner.
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     */
    DemoBanner.prototype.setLocation = function(location) {
        this.m_location = location;
        return this;
    };

    /**
     * This function is used to add additional patient identifier fields.  Each new field will contain both a label
     * and one or more value associated with those values to display with that label.
     * Example. DemoBanner.addIdentifierField("MRNs", ["9B81A02E4193AE", "5B84868E41A"]);
     * @param {string} label The label to display next to the value(s)
     * @param {string|Array} values Either a single string value or an array of string values to display next to the label
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     **/
    DemoBanner.prototype.addIdentifierField = function(label, values) {
        if (!this.m_identificationFields) {
            this.m_identificationFields = [];
        }
        values = typeof values === "string" ? [ values ] : values;
        this.m_identificationFields.push({ label: label, value: values });
        return this;
    };

    /**
     * This function is used to add additional patient identifier fields.  Each new field will contain both a label
     * and one or more value associated with those values to display with that label.
     * @param {string} label The label to display next to the value(s)
     * @param {string|Array} values Either a single string value or an array of string values to display next to the label
     * @returns {MPageUI.DemoBanner} Returns self to allow chaining.
     **/
    DemoBanner.prototype.addContactInformationField = function(label, values) {
        if (!this.m_contactInfoFields) {
            this.m_contactInfoFields = [];
        }
        this.m_contactInfoFields.push({ label: label, value: values });
        return this;
    };

    /**
     * Builds the html for the demoBanner by including all the fields
     * @returns {string} The DemoBanner rendered as an html string.
     */
    DemoBanner.prototype.render = function() {
        var demoBannerHTML = "";
        //Render the Name, DOB, Sex and Location row
        demoBannerHTML += "<section id='" + this.m_id + "' class='demographics-banner demographics-banner--preventOverlap'>";
        demoBannerHTML += "<header>";
        demoBannerHTML += "<div class='demographics-row'>";
        demoBannerHTML += "<h1>" + this.getName() + "</h1>";
        if (this.getLocation()) {
            demoBannerHTML += "<h1 title='" + this.getLocation() + "' class='demographics-location'>" + this.getLocation() + "</h1>";
        }
        demoBannerHTML += "</div>";
        demoBannerHTML += "<div class='demographics-row'>";
        demoBannerHTML += "<span class='demographics-single'>";
        if (this.getDOB()) {
            demoBannerHTML += i18n.DOB + ": " + "<b>" + (this.getDOB() || "") + "</b>";
        }
        if (this.getGender()) {
            demoBannerHTML += i18n.SEX + ": " + "<b>" + this.getGender() + "</b>";
        }
        //Render the identification row
        var idFields = this.m_identificationFields;
        var idFieldCnt = 0;
        if (idFields) {
            idFieldCnt = idFields.length;
            for (var x = 0; x < idFieldCnt; x++) {
                demoBannerHTML += idFields[ x ].label + ": " + "<b>" + idFields[ x ].value.join(",") + "</b>";
            }
        }
        demoBannerHTML += "</span></div></header></section>";
        return demoBannerHTML;
    };

    return DemoBanner;
})();




/* global MPageUI */

MPageUI.Grouper = (function() {
    /**
     * The Grouper class.
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     * @constructor
     */
    var Grouper = function() {
        //Super constructor
        this.base();
        this.m_headerHTML = "";
        this.m_bodyHTML = "";
        this.m_isCollapsed = false;
        this.m_addIconCssClass = "";
    };

    MPageUI.extend(Grouper, MPageUI.UIComponent);

    /**
     * Renders the grouper by generating and appending the HTML on the DOM.
     * @returns {String} Returns the html representing the content of the grouper
     */
    Grouper.prototype.render = function() {
        var html = "";
        var collapseCss = this.m_isCollapsed ? "collapsed" : "expanded";
        var hideCss = this.m_isCollapsed ? "mpage-ui-grouper-hide" : "";

        html += "<form class='mpage-ui-grouper' id='" + this.m_id + "'>"
            + "<fieldset class='mpage-ui-grouper-content " + hideCss + "'>"
            + "<legend class='mpage-ui-grouper-header'>"
            + "<div class='collapse " + collapseCss + "'></div>"
            + "<div class='sec-hdr'>" + this.m_headerHTML + "</div>"
            + "<div class='mpage-ui-add-icon " + this.m_addIconCssClass + "'></div>"
            + "</legend>"
            + "<div class='mpage-ui-grouper-body'>"
            + this.m_bodyHTML
            + "</div>"
            + "</fieldset>"
            + "</form>";

        return html;
    };

    /**
     * Attach event to DOM elements once the HTML has been rendered.
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.attachEvents = function() {
        var self = this;

        //Expand/Collapse sections
        $("#" + this.m_id).find(".mpage-ui-grouper-content .collapse").on("click", function() {
            self.onClick(this);
        });

        return this;
    };

    /**
     * Sets the header/title of the Grouper. This is the text listed at the top of the grouper.
     * @param {string} header - The header of Grouper
     * @throws {Error} An error indicating that the header parameter is an invalid type.
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.setHeader = function(header) {
        if (typeof header !== "string") {
            throw new Error("MPageUI.Grouper.prototype.setHeader expects a string.");
        }
        this.m_headerHTML = header;

        return this;
    };

    /**
     * Sets the content of the Grouper. This is the text listed in the body of the grouper.
     * @param {string} body - The content of Grouper
     * @throws {Error} An error indicating that the header parameter is an invalid type.
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.setBody = function(body) {
        if (typeof body !== "string") {
            throw new Error("MPageUI.Grouper.prototype.setBody expects a string.");
        }
        this.m_bodyHTML = body;

        return this;
    };


    /**
     * Sets whether or not the grouper should be collapsed on load.
     * @param {Boolean} isCollapsed - A boolean indicating whether or not the grouper is collapsed.
     * @throws {Error} An error indicating that the isCollapsed parameter is an invalid type.
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.setIsCollapsed = function(isCollapsed) {
        if (typeof isCollapsed !== "boolean") {
            throw new Error("MPageUI.Grouper.prototype.setIsCollapsed expects a boolean.");
        }
        this.m_isCollapsed = isCollapsed;

        return this;
    };

    /**
     * Sets a CSS class which would have URL to different icons that should be applied to the right of the header.
     * @param {String} cssClass - A string representing the CSS class to be applied to the header
     * @throws {Error} An error indicating that the cssClass parameter is an invalid type.
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.setAddIconCssClass = function(cssClass) {
        if (typeof cssClass !== "string") {
            throw new Error("MPageUI.Grouper.prototype.setShowAddIcon expects a string.");
        }
        this.m_addIconCssClass = cssClass;

        return this;
    };

    /**
     * Expands the grouper
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.expand = function() {
        var $compId = $("#" + this.m_id);

        $compId.find(".mpage-ui-grouper-content .collapse").addClass("expanded").removeClass("collapsed");
        $compId.find(".mpage-ui-grouper-content").removeClass("mpage-ui-grouper-hide");
        this.setIsCollapsed(false);

        return this;
    };

    /**
     * Collapses the grouper
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.collapse = function() {
        var $compId = $("#" + this.m_id);

        $compId.find(".mpage-ui-grouper-content .collapse").addClass("collapsed").removeClass("expanded");
        $compId.find(".mpage-ui-grouper-content").addClass("mpage-ui-grouper-hide");
        this.setIsCollapsed(true);

        return this;
    };

    /**
     * Updates the body with the current private variables
     * @param {string} body - The content of Grouper
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.updateBody = function(body) {
        var $compId = $("#" + this.m_id);

        this.setBody(body);
        $compId.find(".mpage-ui-grouper-body").html(this.m_bodyHTML);
        return this;
    };

    /**
     * Updates the header with the current private variables
     * @param {string} header - The header of Grouper
     * @returns {MPageUI.Grouper} Returns self to allow chaining.
     */
    Grouper.prototype.updateHeader = function(header) {
        var $compId = $("#" + this.m_id);

        this.setHeader(header);
        $compId.find(".sec-hdr").html(this.m_headerHTML);
        return this;
    };

    /**
     * Defined click events for the expand/collapse functions
     * @param {string} elem - The The window element clicked on
     * @returns {Undefined} Returns nothing.
     */
    Grouper.prototype.onClick = function(elem) {
        if ($(elem).hasClass("collapsed")) {
            this.expand();
        }
        else {
            this.collapse();
        }
    };

    return Grouper;
})();

/* global MPageUI */

MPageUI.PlaceholderContent = (function() {
    /**
     * The PlaceholderContent class.
     * This ui component will render a placeholder styled with a dashed border.
     * The contents will have primary text and only one actionable control.
     *
     * @returns {MPageUI.PlaceholderContent} Returns self to allow chaining.
     * @constructor
     */
    var PlaceholderContent = function() {
        // Super constructor
        this.base();
        this.m_primaryText = "";
        this.m_actionableControl = null;
        this.m_rendered = false;
        return this;
    };
    MPageUI.extend(PlaceholderContent, MPageUI.UIComponent);
    /**
     * Sets the primary text in the placeholder.
     * @param {string} text - A string to be displayed in placeholder.
     * @throws {Error} An error indicating that the text parameter is an invalid type.
     * @returns {MPageUI.PlaceholderContent} Returns self to allow chaining.
     */
    PlaceholderContent.prototype.setPrimaryText = function(text) {
        if (typeof text !== "string") {
            throw new Error("PlaceholderContent.prototype.setPrimaryText expects a string");
        }
        this.m_primaryText = text;
        return this;
    };
    /**
     * Sets the control that will provide actionability. Currently limiting it to just the base Button object.
     * @param {MPageUI.Button} control - An instance of the MPageUI.Button component created by the consumer.
     * @throws {Error} An error indicating that the control provided is not an instance of MPageUI.Button
     * @returns {MPageUI.SplitButton} Returns self to allow chaining.
     */
    PlaceholderContent.prototype.setActionableControl = function(control) {
        if (!control || !MPageUI.Button.prototype.isPrototypeOf(control)) {
            throw new Error("PlaceholderContent.prototype.setActionableControl expects an instance of MPageUI.Button.");
        }
        this.m_actionableControl = control;
        return this;
    };
    /**
     * Retrieves the instance of the control that will have some actionablity.
     * @returns {MPageUI.Button} The contextual view button.
     */
    PlaceholderContent.prototype.getActionableControl = function() {
        return this.m_actionableControl;
    };
    /**
     * Sets the flag whether to indicate PlaceholderContent has rendered.
     * @param {boolean} rendered - Boolean to indicate whether the PlaceholderContent has rendered.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.PlaceholderContent} Returns self to allow chaining.
     */
    PlaceholderContent.prototype.setRendered = function(rendered) {
        if (typeof rendered !== "boolean") {
            throw new Error("PlaceholderContent.prototype.setRendered expects a boolean");
        }
        this.m_rendered = rendered;
        return this;
    };

    /**
     * Gets the flag that indicates whether the PlaceholderContent is rendered.
     * @returns {Boolean} Flag whether to indicate PlaceholderContent has rendered.
     */
    PlaceholderContent.prototype.hasRendered = function() {
        return this.m_rendered;
    };
    /**
     * Overrides the MPageUI.UIComponent.prototype.render function to return the PlaceholderContent
     * Renders a simple placeholder styled with a dashed border, with a primary text and an actionable control.
     * @returns {String} The HTML markup of ghosted view
     */
    PlaceholderContent.prototype.render = function() {
        var placeholderContentHTML = "";
        placeholderContentHTML += "<div id='" + this.m_id + "' class='placeholder-content-container'>";
        placeholderContentHTML += "<span class='primary-text'>" + this.m_primaryText + "</span>";
        placeholderContentHTML += this.m_actionableControl ? "<span class ='actionable-control'>" + this.m_actionableControl.render() + "</span>" : "";
        placeholderContentHTML += "</div>";
        return placeholderContentHTML;
    };
    return PlaceholderContent;
})();


/* global MPageUI */
/**
 * Enumeration for AlertBanner options.
 * @readonly
 */
MPageUI.ALERT_OPTIONS = {
    TYPE: {
        INFO: "info-msg",
        SUCCESS: "success-msg",
        WARNING: "warning-msg",
        ERROR: "error-msg",
        SEVERE: "severe-msg",
        ADVISORY: "advisory-msg"
    }
};

MPageUI.AlertBanner = (function() {
    /**
     * The MPageUI.AlertBanner class.
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     * @constructor
     */
    var AlertBanner = function() {
        this.base();
        this.m_dismissible = false;
        this.m_primaryText = "";
        this.m_secondaryText = "";
        this.m_content = null;
        this.m_time = null;
        this.m_bannerType = "";
        this.m_closeFunction = null;
        return this;
    };
    MPageUI.extend(AlertBanner, MPageUI.UIComponent);
    /* eslint-disable no-unused-vars */
    /**
     * Sets whether the AlertBanner is dismissible or not.
     * @param {boolean} dismissible - A boolean indicating if the AlertBanner is dismissible or not. True if it is dismissible,
     * otherwise false.
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.setDismissible = function(dismissible) {
        //Check dismissible
        if (typeof dismissible !== "boolean") {
            throw new Error("AlertBanner.prototype.setDismissible expects a boolean.");
        }
        //Set dismissible
        this.m_dismissible = dismissible;
        return this;
    };
    /* eslint-enable no-unused-vars */
    /**
     * Sets the primary text to be displayed in the alert.
     * @param {string} primaryText - The primary text to be displayed in the alert banner.
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.setPrimaryText = function(primaryText) {
        //Check text
        if (typeof primaryText !== "string") {
            throw new Error("AlertBanner.prototype.setPrimaryText expects a string.");
        }
        //Set primary text
        this.m_primaryText = primaryText;
        return this;
    };
    /**
     * Sets the secondary text to be displayed in the alert.
     * @param {string} secondaryText - The secondary text to be displayed in the alert banner.
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.setSecondaryText = function(secondaryText) {
        //Check text
        if (typeof secondaryText !== "string") {
            throw new Error("AlertBanner.prototype.setSecondaryText expects a string.");
        }
        //Set secondary text
        this.m_secondaryText = secondaryText;
        return this;
    };

    /**
     * Sets the custom content to be displayed in the alert.
     * @param {MPageUI.UIComponent} content - The custom content to be displayed in the alert banner.
     * Parameter input ideally should be an MPageUI UIComponent control. For example, we can include the PEDBannerControl as the content for the AlertBanner shell.
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.setContents = function(content) {
        if (!content) {
            throw new Error("AlertBanner.prototype.setContents expects a valid banner content");
        }
        this.m_content = content;
        return this;
    };

    /* eslint-disable no-unused-vars */
    /**
     * Hides the alert banner
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining..
     */
    AlertBanner.prototype.hide = function() {
        //hide the alert banner
        this.getRootElement().hide();
        return this;
    };

    /**
     * Displays the alert banner
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.show = function() {
        //shows the alert banner and returns self
        this.getRootElement().show();
        return this;
    };
    /**
     * Returns the function to be executed when close button is clicked
     *
     * @returns {AlertBanner.m_closeFunction} the function to close the alert banner
     */
    AlertBanner.prototype.getCloseFunction = function() {
        return this.m_closeFunction;
    };

    /**
     * Sets the close function
     *
     * @param {closeFunction} closeFunction The function which is executed when we click on the close button
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.setCloseFunction = function(closeFunction) {
        if (typeof closeFunction !== "function") {
            throw new Error("AlertBanner.prototype.setCloseFunction expects a function.");
        }
        this.m_closeFunction = closeFunction;
        return this;
    };
    /**
     * Sets the amount of time (in seconds) the AlertBanner will remain before disappearing.
     * @param {number} timeInSeconds - The amount of time (in seconds) the AlertBanner will remain before disappearing.
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.setTime = function(timeInSeconds) {
        //Check time
        //Set time
        return this;
    };
    /* eslint-enable no-unused-vars */
    /**
     * Sets the alert type. This must be a choice from the MPageUI.ALERT_OPTIONS.type enumeration.
     * @param {string} type - The type of alert banner to be created.
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.setType = function(type) {
        if (typeof type !== "string") {
            throw new Error("AlertBanner.prototype.setType expects a string.");
        }
        this.m_bannerType = type;
        return this;
    };
    /**
     * Renders the Alert as an html string.
     * @returns {string} The AlertBanner rendered as an html string.
     */
    AlertBanner.prototype.render = function() {
        var bannerHTML;
        if (this.m_bannerType === "") {
            throw new Error("AlertBanner.prototype.render expects a valid banner type from MPageUI.ALERT_OPTIONS.TYPE");
        }
        //Construct banner rendering HTML
        bannerHTML = "<div id='" + this.m_id + "' class='alert-msg'>";
        bannerHTML += "<div class = '" + this.m_bannerType + "'>";
        if (this.m_dismissible) {
            bannerHTML += "<div class='alert-info-dismissible'>";
        }
        else {
            bannerHTML += "<div class='alert-info'>";
        }

        // If the content is being passed then the primary and secondary info is removed
        if (this.m_content) {
            this.m_primaryText = "";
            this.m_secondaryText = "";
            if (typeof this.m_content.render !== "function") {
                throw new Error("AlertBanner.prototype.render expects a MPageUI->render to be passed if setContent is used.");
            }

            bannerHTML += "<span class='alert-icon'>&nbsp;</span>" + this.m_content.render() + "</div>";
        }
        else {
            bannerHTML += "<span class='alert-icon'>&nbsp;</span>" + this.m_primaryText;
            bannerHTML += "<span class='alert-msg-secondary-text'>&nbsp;" + this.m_secondaryText + "</span></div>";
        }

        if (this.m_dismissible) {
            bannerHTML += "<span id='alertClose" + this.m_id + "' class='alert-close-option'>&nbsp;</span>";
        }
        return bannerHTML + "</div></div>";
    };
    /**
     * Attaches the necessary events to the close button. This function must be called after the alert banner
     * markup exists on the DOM.
     * @returns {MPageUI.AlertBanner} Returns self to allow chaining.
     */
    AlertBanner.prototype.attachEvents = function() {
        var self = this;
        self.getRootElement().on("click", "#alertClose" + self.m_id, function() {
            self.getCloseFunction()();
        });

        //If the AlertBanner.setContents -> m_content is present then we need to attach the events, if any
        if (this.m_content && typeof this.m_content.attachEvents === "function") {
            this.m_content.attachEvents();
        }
        return self;
    };
    return AlertBanner;
})();


/* global MPageUI */

MPageUI.ICONS = {
    ICON_MOVE_LEFT: "icon-move-left",
    ICON_MOVE_RIGHT: "icon-move-right"
};

/* global MPageUI, MenuSeparator */

/**
 * Enumeration for MPageUI Menu configuration
 * @readonly
 */
MPageUI.MENU_OPTIONS = {
    TYPE: {
        SELECT: 0,
        SEPARATOR: 1
    }
};

MPageUI.Menu = (function() {
    /**
     * The Base Menu class.
     * @returns {MPageUI.Menu} Returns self to allow chaining.
     * @constructor
     */
    var Menu = function() {
        this.base();
        return this;
    };
    MPageUI.extend(Menu, MPageUI.UIComponent);

    /**
     * The base open function. This shall open the menu. Subclasses of the Menu must provide the implementation.
     * @returns {MPageUI.Menu} Returns self to allow chaining.
     */
    Menu.prototype.open = function() {
        return this;
    };

    /**
     * The base close function. This shall close the menu. Subclasses of the Menu must provide the implementation.
     * @returns {MPageUI.Menu} Returns self to allow chaining.
     */
    Menu.prototype.close = function() {
        return this;
    };

    /**
     * The base isOpen function. This shall determine if the menu is currently open. Subclasses of the Menu must
     * provide the implementation.
     * @returns {boolean} True if the menu is open, otherwise false.
     */
    Menu.prototype.isOpen = function() {
        return false;
    };

    /**
     * The base menu render function. This shall render the menu as an html string. Subclasses of the Menu must
     * provide the implementation. Note that some menus may not render html, as they may be dynamically added to the
     * DOM and managed by another component.
     * @returns {string} The Menu rendered as an html string.
     */
    Menu.prototype.render = function() {
        return "";
    };

    /* eslint-disable no-unused-vars */
    /**
     * Adds an option to the menu. This shall add an option to the Menu whether it be a selectable option or
     * a radio option. Subclasses of the Menu must provide the implementation. The option must be a JSON object of the
     * form
     * {
	 * 		label: 		"Label",
	 * 		type:		MPageUI.MENU_OPTIONS.TYPE.x,
	 * 		value: 		0.0 (or some other data)
	 * 		onSelect:	function() { ... }
	 * }
     * @param {Object} option - The option to be added to the menu.
     * @returns {MPageUI.Menu} Returns self to allow chaining.
     */
    Menu.prototype.addOption = function(option) {
        return this;
    };
    /* eslint-enable no-unused-vars */

    /**
     * Adds a set of options to the menu. This loops over the array of provided options and calls addOption on each.
     * @param {Array<Object>} options - The array of options to be added to the menu.
     * @returns {MPageUI.Menu} Returns self to allow chaining.
     */
    Menu.prototype.addOptions = function(options) {
        if (!Array.prototype.isPrototypeOf(options)) {
            throw new Error("MPageUI.Dropdown.prototype.addOptions expects an array of options");
        }
        var optionCount = options.length;
        for (var i = 0; i < optionCount; i++) {
            this.addOption(options[ i ]);
        }
        return this;
    };

    /**
     * Removes all options from the menu.
     * @returns {MPageUI.Menu} Returns self to allow chaining.
     */
    Menu.prototype.removeAllOptions = function() {
        return this;
    };

    /**
     * This function will validate a provided option. If the option is not valid, an exception will be thrown to
     * inform the consumer.
     * @param {Object} option - The option to be verified.
     * @throws {Error} An error indicating that the provided option was not valid.
     * @returns {undefined} Returns nothing.
     */
    Menu.prototype.validateOption = function(option) {
        if (typeof option !== "object") {
            throw new Error("MPageUI.Dropdown.prototype.addOption expects an object");
        }
        var optionType = option.type || MPageUI.MENU_OPTIONS.TYPE.SELECT;
        var menuOptionsTypeEnum = MPageUI.MENU_OPTIONS.TYPE;
        switch (optionType) {
            case menuOptionsTypeEnum.SELECT:
                if (!option.label) {
                    throw new Error("MPageUI.Dropdown.prototype.addOption: 'select' options must provide a label.");
                }
                if (typeof option.label !== "string") {
                    throw new Error("MPageUI.Dropdown.prototype.addOption: the label must be a string.");
                }
                if (!option.onSelect) {
                    throw new Error("MPageUI.Dropdown.prototype.addOption: 'select' options must provide an onSelect callback.");
                }
                if (typeof option.onSelect !== "function") {
                    throw new Error("MPageUI.Dropdown.prototype.addOption: the onSelect must be a function.");
                }
                break;
            case menuOptionsTypeEnum.SEPARATOR:
                break;
            default:
                throw new Error("MPageUI.Dropdown.prototype.addOption: the option must provide a 'type', use MPageUI.MENU_OPTIONS.TYPE");
        }
    };
    return Menu;
})();

MPageUI.StandardMPageMenu = (function() {
    /**
     * The StandardMPageMenu class. This is a subclass of MPageUI.Menu. It provides the implementation by wrapping
     * the existing standard menu API to ensure ease of compatibility if/when MPageUI converts to the Terra convention
     * for menus.
     * @param {string} anchorId - The id of the element that is to be the anchor for the standard menu.
     * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
     * @constructor
     */
    var StandardMPageMenu = function(anchorId) {
        this.base();
        this.m_anchorId = anchorId;
        this.m_menuItemCounter = 0;
        this.m_standardMenu = null;
        this.init();
        return this;
    };
    MPageUI.extend(StandardMPageMenu, MPageUI.Menu);

    /**
     * Overrides the base init function. This initializes an instance of the existing standard menu API.
     * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
     */
    StandardMPageMenu.prototype.init = function() {
        var self = this;
        this.m_standardMenu = new Menu(this.m_id + "_standardMenu");
        this.m_standardMenu.setTypeClass("dropdown-standard-menu");
        this.m_standardMenu.setAnchorElementId(this.m_anchorId);
        this.m_standardMenu.setAnchorConnectionCorner([ "bottom", "right" ]);
        this.m_standardMenu.setContentConnectionCorner([ "top", "right" ]);
        this.m_standardMenu.setIsRootMenu(true);
        //Hijack the setIsActive function so we can intelligently prevent memory leaks
        this.m_standardMenu.setIsActive = function(activeInd) {
            //Call the base setIsActive function
            Menu.prototype.setIsActive.call(self.m_standardMenu, activeInd);
            //If the menu is being closed, remove the menu from the global lookup
            if (!activeInd) {
                //Remove the standard menu
                MP_MenuManager.deleteMenuObject(self.m_standardMenu.getId());
            }
        };
        return this;
    };

    /**
     * Overrides the base addOption function. This transforms the option data object into a subsequent MenuItem from
     * the existing standard MPages menu API.
     * @param {Object} option - The option object being added to the menu.
     * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
     */
    StandardMPageMenu.prototype.addOption = function(option) {
        this.validateOption(option);
        var menuOptionsTypeEnum = MPageUI.MENU_OPTIONS.TYPE;
        var optionType = option.type || menuOptionsTypeEnum.SELECT;
        var menuItem = null;
        switch (optionType) {
            case menuOptionsTypeEnum.SELECT:
                menuItem = new MenuSelection(this.m_id + "_menuSelection_" + this.m_menuItemCounter++);
                menuItem.setLabel(option.label);
                menuItem.setClickFunction(this.getSelectionFunction(option));
                break;
            case menuOptionsTypeEnum.SEPARATOR:
                menuItem = new MenuSeparator(this.m_id + "_menuSeparator_" + this.m_menuItemCounter++);
                break;
            default:
                throw new Error("MPageUI.Dropdown.prototype.addOption: the option must provide a 'type'");
        }
        this.m_standardMenu.addMenuItem(menuItem);
        /*
         * This was removed to prevent a potential memory leak when standard
         * menus were created and options were added, it would register the
         * menu to the MP_MenuManager global lookup via updateMenuObject. If
         * the StandardMPageMenu was later destroyed, that menu object could
         * still be hanging in the lookup of MP_MenuManager.
         *
         * It is safe to refrain from calling MP_MenuManager.updateMenuObject
         * because it will be called in the open function.
         */
        //MP_MenuManager.updateMenuObject(this.m_standardMenu);
        return this;
    };

    /**
     * Overrides the base Menu.prototype.removeAllOptions function.
     * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
     */
    StandardMPageMenu.prototype.removeAllOptions = function() {
        var options = this.m_standardMenu.getMenuItemArray();
        var optionCount = options.length;
        for (var i = 0; i < optionCount; i++) {
            if (!this.m_standardMenu.removeMenuItem(options[ i ])) {
                logger.logWarning("MPageUI.StandardMPageMenu.prototype.removeAllOptions: error removing menu item");
            }
        }
        this.m_menuItemCounter = 0;
        MP_MenuManager.updateMenuObject(this.m_standardMenu);
        return this;
    };

    /**
     * This generates a selection function that is triggered when one of the items in the menu is selected. It will
     * call the onSelect callback function for the specified option, ensuring to pass the option as the context of the
     * function call.
     * @param {Object} option - The option for which the selection function is being generated.
     * @returns {function} The selection function. This closes on the option to ensure the correct callback function
     * is triggered.
     */
    StandardMPageMenu.prototype.getSelectionFunction = function(option) {
        return function() {
            option.onSelect.call(option);
        };
    };

    /**
     * Overrides the base isOpen function to determine if the standard menu is open.
     * @returns {boolean} True if the menu is currently open (active), otherwise false.
     */
    StandardMPageMenu.prototype.isOpen = function() {
        return this.m_standardMenu.isActive();
    };

    /**
     * Overrides the base open function to open the standard menu.
     * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
     */
    StandardMPageMenu.prototype.open = function() {
        //Since the Menu is removed on close (see init function), make sure it is available to
        //the MP_MenuManager.
        MP_MenuManager.updateMenuObject(this.m_standardMenu);
        MP_MenuManager.showMenu(this.m_standardMenu.getId());
        return this;
    };

    /**
     * Overrides the base close function to close the standard menu.
     * @returns {MPageUI.StandardMPageMenu} Returns self to allow chaining.
     */
    StandardMPageMenu.prototype.close = function() {
        MP_MenuManager.closeMenuStack(false);
        return this;
    };

    /**
     * Overrides the base render function to render nothing. The StandardMPageMenu is a special case in that it is
     * not truly rendered to the DOM, but it is desirable to treat it as a standard UIComponent.
     * @returns {string} An empty string since the StandardMPageMenu is not rendered as a composite piece of another
     * UIComponent.
     */
    StandardMPageMenu.prototype.render = function() {
        return "";
    };

    return StandardMPageMenu;
})();

/* global MPageUI */

MPageUI.Dropdown = (function() {
    /**
     * Base Dropdown interface. Exposes necessary functions for a drop-down control.
     * @returns {MPageUI.Dropdown} Returns self to allow chaining.
     * @constructor
     */
    var Dropdown = function() {
        this.m_menu = null;
        return this;
    };
    MPageUI.extend(Dropdown, MPageUI.UIComponent);

    /**
     * Adds an option to the dropdown.
     * @param {Object} option - The option to be added to the dropdown. This must be of the following form.
     * {
	 * 		label: 'Label',
	 * 		type:	MPageUI.MENU_OPTIONS.TYPE.x,
	 * 		onSelect: function() { ... }
	 * }
     * @returns {MPageUI.Dropdown} Returns self to allow chaining.
     */
    Dropdown.prototype.addOption = function(option) {
        this.m_menu.addOption(option);
        return this;
    };

    /**
     * Adds a set of options to the dropdown.
     * @param {Array<Object>} options - The list of options to be added to the dropdown.
     * @returns {MPageUI.Dropdown} Returns self to allow chaining.
     */
    Dropdown.prototype.addOptions = function(options) {
        this.m_menu.addOptions(options);
        return this;
    };

    /**
     * Removes all options for the dropdown.
     * @returns {MPageUI.Dropdown} Returns self to allow chaining.
     */
    Dropdown.prototype.removeAllOptions = function() {
        this.m_menu.removeAllOptions();
        return this;
    };

    /**
     * Determines if the dropdown is currently open.
     * @private
     * @returns {boolean} True if the dropdown is currently open, otherwise false.
     */
    Dropdown.prototype.isOpen = function() {
        return this.m_menu.isOpen();
    };

    /**
     * Opens the dropdown menu.
     * @returns {MPageUI.Dropdown} Returns self to allow chaining.
     */
    Dropdown.prototype.open = function() {
        this.m_menu.open();
        return this;
    };

    /**
     * Closes the dropdown menu.
     * @returns {MPageUI.Dropdown} Returns self to allow chaining.
     */
    Dropdown.prototype.close = function() {
        this.m_menu.close();
        return this;
    };

    /**
     * Toggles the open state of the dropdown menu.
     * @returns {MPageUI.Dropdown} Returns self to allow chaining.
     */
    Dropdown.prototype.toggle = function() {
        if (this.isOpen()) {
            this.close();
        }
        else {
            this.open();
        }
        return this;
    };

    return Dropdown;
})();

/* global MPageUI */

MPageUI.BUTTON_OPTIONS = {
    SHAPE: {
        NORMAL: "",
        PILL: "btn-pill"
    },
    STYLE: {
        NORMAL: "",
        PRIMARY: "btn-primary",
        SECONDARY: "btn-secondary",
        INVERSE: "btn-inverse",
        POSITIVE: "btn-positive",
        NEGATIVE: "btn-negative",
        LINK: "btn-link"
    },
    SIZE: {
        NORMAL: "",
        SMALL: "btn-small",
        LARGE: "btn-large",
        THINLINE: "btn-thinline"
    },
    TOGGLE: {
        NORMAL: "",
        DROPDOWN: "dropdown"
    },
    ICON_POSITION: {
        LEFT: 0,
        RIGHT: 1
    }
};

MPageUI.Button = (function() {
    /**
     * The Button class.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     * @constructor
     */
    var Button = function() {
        //Super constructor
        this.base();

        this.m_disabled = false;
        this.m_label = "";
        this.m_onClickCallback = null;

        this.m_shape = MPageUI.BUTTON_OPTIONS.SHAPE.NORMAL;
        this.m_size = MPageUI.BUTTON_OPTIONS.SIZE.NORMAL;
        this.m_style = MPageUI.BUTTON_OPTIONS.STYLE.NORMAL;
        this.m_dataToggle = MPageUI.BUTTON_OPTIONS.TOGGLE.NORMAL;

        this.m_icon = "";
        this.m_iconPosition = MPageUI.BUTTON_OPTIONS.ICON_POSITION.LEFT;
        return this;
    };
    MPageUI.extend(Button, MPageUI.UIComponent);

    /**
     * Retrieves the disabled indicator for the button.
     * @returns {boolean} True if the button is disabled, otherwise false.
     */
    Button.prototype.isDisabled = function() {
        return this.m_disabled;
    };

    /**
     * Sets the disabled indicator for the button.
     * @param {boolean} disabled - The disabled state of the button.
     * @throws {Error} An error indicating that the disabled parameter is an invalid type.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setDisabled = function(disabled) {
        if (typeof disabled !== "boolean") {
            throw new Error("Button.prototype.setDisabled expects a boolean.");
        }
        this.m_disabled = disabled;
        var $rootElement = this.getRootElement();
        $rootElement.prop("disabled", disabled);
        return this;
    };

    /**
     * Sets the label of the Button.
     * @param {string} label - The label of the Button.
     * @throws {Error} An error indicating that the label parameter is an invalid type.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setLabel = function(label) {
        if (typeof label !== "string") {
            throw new Error("Button.prototype.setLabel expects a string.");
        }
        this.m_label = label;
        var $rootElement = this.getRootElement();
        $rootElement.html(this.renderButtonContents());
        return this;
    };
    /**
     * Sets the shape of the Button.
     * @param {string} shape - The shape of the button.
     * @throws {Error} An error indicating that the shape parameter is an invalid type.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setShape = function(shape) {
        if (typeof shape !== "string") {
            throw new Error("Button.prototype.setShape expects a string.");
        }
        var $rootElement = this.getRootElement();
        if (shape !== this.m_shape) {
            $rootElement.removeClass(this.m_shape);
            $rootElement.addClass(shape);
        }
        this.m_shape = shape;
        return this;
    };
    /**
     * Sets the size of the Button.
     * @param {string} size - The size of the Button.
     * @throws {Error} An error indicating that the size is an invalid type.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setSize = function(size) {
        if (typeof size !== "string") {
            throw new Error("Button.prototype.setSize expects a string.");
        }
        var $rootElement = this.getRootElement();
        if (size !== this.m_size) {
            $rootElement.removeClass(this.m_size);
            $rootElement.addClass(size);
        }
        this.m_size = size;
        return this;
    };
    /**
     * Sets the style of the Button.
     * @param {string} style - The style of the Button.
     * @throws {Error} An error indicating that the style is an invalid type.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setStyle = function(style) {
        if (typeof style !== "string") {
            throw new Error("Button.prototype.setStyle expects a string.");
        }
        var $rootElement = this.getRootElement();
        if (style !== this.m_style) {
            $rootElement.removeClass(this.m_style);
            $rootElement.addClass(style);
        }
        this.m_style = style;
        return this;
    };
    /**
     * Sets the data toggle attribute for the button.
     * @param {string} dataToggle - The data-toggle attribute for the button. This will be rendered into the markup
     * as <button data-toggle='dataToggle'>Sample</button>.
     * @throws {Error} An error indicating that the dataToggle is an invalid type.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setDataToggle = function(dataToggle) {
        if (typeof dataToggle !== "string") {
            throw new Error("Button.prototype.setDataToggle");
        }
        var $rootElement = this.getRootElement();
        if (dataToggle !== this.m_dataToggle) {
            $rootElement.attr("data-toggle", dataToggle);
        }
        this.m_dataToggle = dataToggle;
        return this;
    };
    /**
     * Sets the icon class for the button. Use the MPageUI.ICONS enumeration for supported icons.
     * @param {string} icon - The icon CSS class for the button.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setIcon = function(icon) {
        if (typeof icon !== "string") {
            throw new Error("Button.prototype.setIcon expects a string.");
        }
        this.m_icon = icon;
        this.getRootElement().html(this.renderButtonContents());
        return this;
    };
    /**
     * Sets the position of the icon within the button. Use MPageUI.BUTTON_OPTIONS.ICON_POSITION.
     * @param {number} iconPosition - The icon position.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setIconPosition = function(iconPosition) {
        if (typeof iconPosition !== "number") {
            throw new Error("Button.prototype.setIconPosition expects a number.");
        }
        this.m_iconPosition = iconPosition;
        this.getRootElement().html(this.renderButtonContents());
        return this;
    };
    /**
     * Sets the callback function that is triggered when the button is clicked.
     * @param {function} callback - The function
     * @throws {Error} An error indicating that the callback is an invalid type.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.setOnClickCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("Button.prototype.setOnClickCallback expects a function.");
        }
        this.m_onClickCallback = callback;
        return this;
    };
    /**
     * Handles the click function for the button.
     * @returns {undefined} Returns nothing.
     */
    Button.prototype.onClick = function() {
        if (this.m_onClickCallback) {
            this.m_onClickCallback();
        }
    };
    /**
     * Renders the button contents (what goes inside the <button></button> tags) as an html string
     * @private
     * @returns {string} The button contents rendered as an html string.
     */
    Button.prototype.renderButtonContents = function() {
        var icon = this.renderIcon();
        var contents = this.m_label;
        if (!icon) {
            return contents;
        }
        if (!contents) {
            return icon;
        }
        //An icon and a label are present
        if (this.m_iconPosition === MPageUI.BUTTON_OPTIONS.ICON_POSITION.LEFT) {
            contents = icon + "&nbsp;" + contents;
        }
        else {
            contents = contents + "&nbsp;" + icon;
        }
        return contents;
    };
    /**
     * Renders the button icon as an html string. If no icon is set on the button, it will return an empty string.
     * @private
     * @returns {string} The button icon as an html string. Empty if no icon is set.
     */
    Button.prototype.renderIcon = function() {
        if (!this.m_icon) {
            return "";
        }
        return "<span class='" + this.m_icon + "'>&nbsp;</span>";
    };
    /**
     * Renders the Button as an HTML string.
     * @returns {string} The Button rendered as an HTML string.
     */
    Button.prototype.render = function() {
        var disabled = this.m_disabled ? "disabled='true'" : "";
        var classes = "btn";
        var dataToggle = this.m_dataToggle ? ("data-toggle='" + this.m_dataToggle + "'") : "";
        var contents = this.renderButtonContents();
        classes += this.m_size ? " " + this.m_size : "";
        classes += this.m_shape ? " " + this.m_shape : "";
        classes += this.m_style ? " " + this.m_style : "";
        return "<button type='button' id='" + this.m_id + "' class='" + classes + "' " + disabled + " " + dataToggle + ">" + contents + "</button>";
    };

    /**
     * Attaches the necessary events to the button. This function must be called after the button
     * markup exists on the DOM.
     * @returns {MPageUI.Button} Returns self to allow chaining.
     */
    Button.prototype.attachEvents = function() {
        var self = this;
        this.getRootElement().on("click.mpageui", function() {
            self.onClick();
        });
        return this;
    };
    return Button;
})();

MPageUI.DropdownButton = (function() {
    /**
     * The DropdownButton class. This creates a standard dropdown styled button.
     * @returns {MPageUI.DropdownButton} Returns self to allow chaining.
     * @constructor
     */
    var DropdownButton = function() {
        //Super constructor
        this.base();
        this.m_dataToggle = MPageUI.BUTTON_OPTIONS.TOGGLE.DROPDOWN;
        return this;
    };
    MPageUI.extend(DropdownButton, MPageUI.Button);

    /* eslint-disable no-unused-vars */
    /**
     * Override the MPageUI.Button.prototype.setLabel function to do nothing, since we want to ensure the label is
     * not altered.
     * @param {string} label - The label for the button. This parameter is ignored.
     * @returns {MPageUI.DropdownButton} Returns self to allow chaining.
     */
    DropdownButton.prototype.setLabel = function(label) {
        return this;
    };
    /* eslint-enable no-unused-vars */

    /* eslint-disable no-unused-vars */
    /**
     * Overrides the MPageUI.Button.prototpye.setDataToggle function to do nothing to ensure the dropdown button
     * always has the data-toggle='dropdown' attribute.
     * @param {string} dataToggle - The data-toggle attribute value.
     * @returns {MPageUI.DropdownButton} Returns self to allow chaining.
     */
    DropdownButton.prototype.setDataToggle = function(dataToggle) {
        return this;
    };
    /* eslint-enable no-unused-vars */

    /**
     * Overrides the MPageUI.Button.prototype.render function to render the DropdownButton as an html string.
     * @returns {string} The DropdownButton rendered as an html string.
     */
    DropdownButton.prototype.render = function() {
        var disabled = this.m_disabled ? " disabled='true'" : "";
        var classes = "btn dropdown-toggle";
        var dataToggle = "data-toggle='" + this.m_dataToggle + "'";
        classes += (this.m_style ? " " + this.m_style : "");
        return "<button type='button' id='" + this.m_id + "' class='" + classes + "' " + dataToggle + disabled + "><span class='caret'></span></button>";
    };

    return DropdownButton;
})();

MPageUI.SplitButton = (function() {
    /**
     * The SplitButton class.
     * @returns {MPageUI.SplitButton} Returns self to allow chaining.
     * @constructor
     */
    var SplitButton = function() {
        this.base();
        //this.m_menu -> inherited from MPageUI.Dropdown
        this.m_labelButton = null;
        this.m_dropdownButton = null;
        this.init();
        return this;
    };
    MPageUI.extend(SplitButton, MPageUI.Dropdown);

    /**
     * Retrieves the label button.
     * @returns {MPageUI.Button} The label button.
     */
    SplitButton.prototype.getLabelButton = function() {
        return this.m_labelButton;
    };

    /**
     * Retrieves the dropdown button.
     * @returns {MPageUI.DropdownButton} The dropdown button.
     */
    SplitButton.prototype.getDropdownButton = function() {
        return this.m_dropdownButton;
    };

    /**
     * Sets the click callback function that is triggered when the label button is clicked.
     * @param {function} labelButtonClickCallback - The click callback function that is triggered when the label button
     * is clicked.
     * @throws {Error} An error indicating that the labelButtonClickCallback is an invalid type.
     * @returns {MPageUI.SplitButton} Returns self to allow chaining.
     */
    SplitButton.prototype.setLabelButtonClickCallback = function(labelButtonClickCallback) {
        if (typeof labelButtonClickCallback !== "function") {
            throw new Error("MPageUI.SplitButton.prototype.setLabelButtonClickCallback expects a function.");
        }
        this.m_labelButton.setOnClickCallback(labelButtonClickCallback);
        return this;
    };

    /**
     * Sets the label of the SplitButton.
     * @param {string} label - The label of the SplitButton.
     * @returns {MPageUI.SplitButton} Returns self to allow chaining.
     */
    SplitButton.prototype.setLabel = function(label) {
        this.m_labelButton.setLabel(label);
        return this;
    };

    /**
     * Sets the style for both the label button and the dropdown button.
     * @param {string} style - The style to be applied to the label and dropdown button.
     * @returns {MPageUI.SplitButton} Returns self to allow chaining.
     */
    SplitButton.prototype.setStyle = function(style) {
        this.m_labelButton.setStyle(style);
        this.m_dropdownButton.setStyle(style);
        return this;
    };

    /**
     * Overrides the MPageUI.Dropdown.prototype.init function. This will initialize all children of the SplitButton.
     * It first calls the super init function which initializes the menu object. This creates two buttons; a label
     * button and a dropdown button.
     * @returns {MPageUI.SplitButton} Returns self to allow chaining.
     */
    SplitButton.prototype.init = function() {
        var self = this;
        //Initialize the label and dropdown button
        this.m_labelButton = new MPageUI.Button();
        this.m_dropdownButton = new MPageUI.DropdownButton();
        this.m_dropdownButton.setOnClickCallback(function() {
            self.toggle();
        });
        this.m_menu = new MPageUI.StandardMPageMenu(this.m_dropdownButton.getId());
        return this;
    };

    /**
     * Overrides the MPageUI.UIComponent.prototype.render function to return the SplitButton rendered as an html
     * string.
     * @returns {string} The SplitButton rendered as an html string.
     */
    SplitButton.prototype.render = function() {
        var html = "<div id='" + this.m_id + "' class='btn-group'>";
        html += this.m_labelButton.render();
        html += this.m_dropdownButton.render();
        html += this.m_menu.render();
        return html + "</div>";
    };

    /**
     * Attaches the necessary events to the SplitButton. This function must be called after the SplitButton
     * exists on the DOM.
     * @returns {undefined} Returns nothing.
     */
    SplitButton.prototype.attachEvents = function() {
        this.m_labelButton.attachEvents();
        this.m_dropdownButton.attachEvents();
    };

    return SplitButton;
})();

MPageUI.ToggleButton = (function() {
    /**
     * The ToggleButton class.
     * @constructor
     */
    var ToggleButton = function() {
        this.m_selected = false;
        this.m_onSelectCallback = null;
        this.m_onDeselectCallback = null;
        this.base();
    };
    MPageUI.extend(ToggleButton, MPageUI.Button);

    /**
     * Determines if the toggle button is selected.
     * @returns {boolean} A boolean indicating if the toggle button is selected or not.
     */
    ToggleButton.prototype.isSelected = function() {
        return this.m_selected;
    };

    /**
     * Selects the toggle button. This will do nothing if the toggle is already selected. Otherwise, the UI
     * will be updated to reflect the selected state. If the consumer has provided an onSelect callback, that will be
     * triggered.
     * @returns {undefined} undefined
     */
    ToggleButton.prototype.select = function() {
        //Simply return if the toggle is already selected
        if (this.m_selected) {
            return;
        }
        this.setSelected(true);
        if (this.m_onSelectCallback) {
            this.m_onSelectCallback();
        }
    };

    /**
     * Deselects the toggle button. This will do nothing if the toggle is already deselected. Otherwise, the UI
     * will be updated to reflect the deselected state. If the consumer has provided an onDeselect callback, that will be
     * triggered.
     * @returns {undefined} undefined
     */
    ToggleButton.prototype.deselect = function() {
        //Simple return if the toggle is already deselected
        if (!this.m_selected) {
            return;
        }
        this.setSelected(false);
        if (this.m_onDeselectCallback) {
            this.m_onDeselectCallback();
        }
    };

    /**
     * Overrides the base onClick function to provide toggle functionality. If the onClickCallback is set for the
     * toggle button it will override the default behavior. Otherwise, it will toggle the state of the button
     * between selected and deselected.
     * @returns {undefined} undefined
     */
    ToggleButton.prototype.onClick = function() {
        if (this.m_onClickCallback) {
            this.m_onClickCallback();
            return;
        }
        if (this.m_selected) {
            this.deselect();
        }
        else {
            this.select();
        }
    };

    /**
     * Sets the callback function that is triggered when the toggle button is selected.
     * @param {function} onSelectCallback - The callback function that is triggered when the toggle button is selected.
     * @returns {MPageUI.ToggleButton} Returns self to allow chaining.
     */
    ToggleButton.prototype.setOnSelectCallback = function(onSelectCallback) {
        if (typeof onSelectCallback !== "function") {
            throw new Error("MPageUI.ToggleButton.prototype.setOnSelectCallback expects a function");
        }
        this.m_onSelectCallback = onSelectCallback;
        return this;
    };

    /**
     * Sets the callback function that is triggered when the toggle button is deselected.
     * @param {function} onDeselectCallback - The callback function that is triggered when the toggle button is deselected.
     * @returns {MPageUI.ToggleButton} Returns self to allow chaining.
     */
    ToggleButton.prototype.setOnDeselectCallback = function(onDeselectCallback) {
        if (typeof onDeselectCallback !== "function") {
            throw new Error("MPageUI.ToggleButton.prototype.setOnDeselectCallback expects a function");
        }
        this.m_onDeselectCallback = onDeselectCallback;
        return this;
    };

    /**
     * Sets the UI state of the toggle button to the provided selected state.
     * @param {boolean} selected - The selected state of the toggle button. True is selected, false is deselected.
     * @returns {MPageUI.ToggleButton} Returns self to allow chaining.
     */
    ToggleButton.prototype.setSelected = function(selected) {
        if (typeof selected !== "boolean") {
            throw new Error("MPageUI.ToggleButton.prototype.setActive expects a boolean");
        }
        var $rootElement = this.getRootElement();
        if (selected) {
            $rootElement.addClass("active");
        }
        else {
            $rootElement.removeClass("active");
        }
        this.m_selected = selected;
        return this;
    };

    /**
     * Overrides the base render function. This renders the ToggleButton as an html string.
     * @returns {string} The ToggleButton rendered as an html string.
     */
    ToggleButton.prototype.render = function() {
        var disabled = this.m_disabled ? "disabled='true'" : "";
        var classes = "btn";
        var dataToggle = this.m_dataToggle ? ("data-toggle='" + this.m_dataToggle + "'") : "";
        classes += (this.m_size ? " " + this.m_size : "");
        classes += (this.m_shape ? " " + this.m_shape : "");
        classes += (this.m_style ? " " + this.m_style : "");
        classes += (this.m_selected ? " active" : "");
        return "<button type='button' id='" + this.m_id + "' class='" + classes + "' " + disabled + " " + dataToggle + ">" + this.m_label + "</button>";
    };

    return ToggleButton;
})();

/* global MPageUI */

MPageUI.Pager = (function() {
    /**
     * The Pager UIComponent. This class is used for paging mechanisms.
     * @returns {MPageUI.Pager} Returns self to allow chaining.
     * @constructor
     */
    var Pager = function() {
        //Super constructor
        this.base();
        this.m_currentPageLabel = "";
        this.m_previousLabel = "";
        this.m_nextLabel = "";
        this.m_currentPage = 0;
        this.m_numberPages = 0;
        this.m_wrap = false;
        this.m_onPageChangeCallback = null;

        //Element cache
        this.m_$currentPageElement = null;
        this.m_$nextElement = null;
        this.m_$previousElement = null;
        return this;
    };
    MPageUI.extend(Pager, MPageUI.UIComponent);

    /**
     * Retrieves the current page element.
     * @returns {jQuery} The current page element.
     */
    Pager.prototype.getCurrentPageElement = function() {
        if (!this.m_$currentPageElement || !this.m_$currentPageElement.length) {
            this.m_$currentPageElement = this.getRootElement().find(".current-page");
        }
        return this.m_$currentPageElement;
    };

    /**
     * Retrieves the next clickable target.
     * @returns {jQuery} The next clickable target element.
     */
    Pager.prototype.getNextElement = function() {
        if (!this.m_$nextElement || !this.m_$nextElement.length) {
            this.m_$nextElement = this.getRootElement().find(".next-page");
        }
        return this.m_$nextElement;
    };

    /**
     * Retrieves the previous clickable target.
     * @returns {jQuery} The previous clickable target element.
     */
    Pager.prototype.getPreviousElement = function() {
        if (!this.m_$previousElement || !this.m_$previousElement.length) {
            this.m_$previousElement = this.getRootElement().find(".prev-page");
        }
        return this.m_$previousElement;
    };

    /**
     * Sets the current page label. This pattern is used to update the page display, for instance 0 of 10 or 0 / 10.
     * The pattern replaces the string ${currentPage} with the current page number. The pattern replaces ${numberPages}
     * with the total number of pages. For example, if you wanted your page control to display '0 out of 10', you
     * would set the pattern to '${currentPage} out of ${numberPages}'.
     * @param {string} currentPageLabel - The current page label. The two recognized keywords are ${currentPage} and
     * ${numberPages} which are replaced by the current page and total number of pages respectively.
     * @returns {MPageUI.Pager} Returns self to allow chaining.
     */
    Pager.prototype.setCurrentPageLabelPattern = function(currentPageLabel) {
        if (typeof currentPageLabel !== "string") {
            throw new Error("Pager.prototype.setCurrentPageLabel expects a string");
        }
        this.m_currentPageLabel = currentPageLabel;
        this.getCurrentPageElement().html(this.getCurrentPageLabel());
        return this;
    };

    /**
     * Gets the current page label.
     * @returns {string} The current page label as a string.
     */
    Pager.prototype.getCurrentPageLabel = function() {
        return this.m_currentPageLabel.replace("${currentPage}", this.m_currentPage + 1).replace("${numberPages}", this.m_numberPages);
    };

    /**
     * Sets the label to be displayed in the clickable previous target.
     * @param {string} previousLabel - The label to be displayed in the previous target.
     * @returns {MPageUI.Pager} Returns self to allow chaining.
     */
    Pager.prototype.setPreviousLabel = function(previousLabel) {
        if (typeof previousLabel !== "string") {
            throw new Error("Pager.prototype.setPreviousLabel expects a string.");
        }
        this.m_previousLabel = previousLabel;
        return this;
    };

    /**
     * Sets the label to be displayed in the clickable next target.
     * @param {string} nextLabel - The label to be displayed in the next target.
     * @returns {MPageUI.Pager} Returns self to allow chaining.
     */
    Pager.prototype.setNextLabel = function(nextLabel) {
        if (typeof nextLabel !== "string") {
            throw new Error("Pager.prototype.setNextLabel expects a string.");
        }
        this.m_nextLabel = nextLabel;
        return this;
    };

    /**
     * Updates the disabled state of the previous/next clickable targets.
     * @returns {undefined} Returns undefined.
     */
    Pager.prototype.updateNextPreviousDisabled = function() {
        if (this.m_numberPages === Number.POSITIVE_INFINITY) {
            //Disable the previous target if you are at the first page.
            this.getPreviousElement().prop("disabled", (this.m_currentPage === 0)).attr("disabled", (this.m_currentPage === 0));
        }
        else {
            if (this.m_wrap) {
                return;
            }
            //Disable the previous target if you are at first page
            this.getPreviousElement().prop("disabled", (this.m_currentPage === 0)).attr("disabled", (this.m_currentPage === 0));

            //Disable the next target if you are at the last page.
            this.getNextElement().prop("disabled", (this.m_currentPage + 1 === this.m_numberPages)).attr("disabled", (this.m_currentPage + 1 === this.m_numberPages));
        }
    };

    /**
     * Sets the number of pages to infinity and sets the current page to 1.
     * @param {boolean} pagesUnknown - The indicator for specifying if the pages are unknown
     * @returns {MPageUI.Pager} Return self to allow chaining.
     */
    Pager.prototype.setPagesUnknown = function(pagesUnknown) {
        if (typeof pagesUnknown !== "boolean") {
            throw new Error("Pager.prototype.setPagesUnknown expects a boolean.");
        }
        if (pagesUnknown) {
            this.m_numberPages = Number.POSITIVE_INFINITY;
        }
        return this;
    };

    /**
     * Updates the Current Page label when the next/prev button is clicked.
     * @returns {undefined} Returns undefined.
     */
    Pager.prototype.updateCurrentPageLabel = function() {
        this.getCurrentPageElement().html(this.getCurrentPageLabel());
    };

    /**
     * Sets whether the pager should wrap the page index. If set to true, the page index will continually cycle from
     * zero to the specified number of pages in the positive or negative direction (depending on
     * @param {boolean} wrap - A boolean indicating that the pager should wrap or not.
     * @returns {MPageUI.Pager} Returns self to allow chaining.
     */
    Pager.prototype.setWrap = function(wrap) {
        this.m_wrap = wrap;
        return this;
    };

    /**
     * Sets the maximum number of pages for the pager.
     * @param {number} numberPages - An integer indicating how many pages the pager has.
     * @returns {MPageUI.Pager} Returns self to allow chaining.
     */
    Pager.prototype.setNumberPages = function(numberPages) {
        if (typeof numberPages !== "number") {
            throw new Error("Pager.prototype.setNumberPages expects a number.");
        }
        if (numberPages < 0 || numberPages % 1 !== 0) {
            throw new Error("Pager.prototype.setNumberPages expects a number greater than or equal to 0.");
        }
        this.m_numberPages = numberPages;
        return this;
    };

    /**
     * Sets the current page for the pager.
     * @param {number} currentPage - An integer indicating the current page.
     * @returns {MPageUI.Pager} Returns self to allow chaining.
     */
    Pager.prototype.setCurrentPage = function(currentPage) {
        if (typeof currentPage !== "number") {
            throw new Error("Pager.prototype.setCurrentPage expects a number.");
        }
        if (currentPage < 0 || currentPage % 1 !== 0) {
            throw new Error("Pager.prototype.setCurrentPage expects a number greater than or equal to 0.");
        }
        this.m_currentPage = currentPage;
        if (!this.m_wrap) {
            this.updateNextPreviousDisabled();
        }
        this.updateCurrentPageLabel();
        return this;
    };

    /**
     * Handles the event when the user clicks the first page target. This will automatically set the page index to 0,
     * or the first page. Once the page index has been updated, the page change callback will be called with the current
     * page index.
     * @returns {undefined} Returns undefined.
     */
    Pager.prototype.onClickFirst = function() {
        this.setCurrentPage(0);
        if (this.m_onPageChangeCallback) {
            this.m_onPageChangeCallback({
                "currentPage": this.m_currentPage,
                "numberPages": this.m_numberPages
            });
        }
    };

    /**
     * Handles the event when the user clicks the previous target. If the control is configured to wrap, the page index
     * will continually cycle from zero to the specified number of pages. Otherwise, the page index will be clamped
     * to zero. Once the page index has been updated, the page change callback will be called with the current page
     * index.
     * @returns {undefined} Returns undefined.
     */
    Pager.prototype.onClickPrevious = function() {
        if (this.m_numberPages === Number.POSITIVE_INFINITY && this.m_currentPage >= 0) {
            this.m_currentPage--;
            this.setCurrentPage(this.m_currentPage);
        }
        else {
            /* eslint-disable */
            if (this.m_wrap) {
                this.setCurrentPage(((this.m_currentPage - 1) + this.m_numberPages) % this.m_numberPages);
            }
            else {
                this.setCurrentPage(Math.max(0, this.m_currentPage - 1));
            }
            /* eslint-enable */
        }
        if (this.m_onPageChangeCallback) {
            this.m_onPageChangeCallback({
                "currentPage": this.m_currentPage,
                "numberPages": this.m_numberPages
            });
        }
    };

    /**
     * Handles the event when the user clicks the next target. If the control is configured to wrap, the page index
     * will continually cycle from zero to the specified number of pages. Otherwise, the page index will be clamped
     * to zero. Once the page index has been updated, the page change callback will be called with the current page
     * index.
     * @returns {undefined} Returns undefined.
     */
    Pager.prototype.onClickNext = function() {
        if (this.m_numberPages === Number.POSITIVE_INFINITY) {
            this.m_currentPage++;
            this.setCurrentPage(this.m_currentPage);
        }
        else {
            /* eslint-disable */
            if (this.m_wrap) {
                this.setCurrentPage((this.m_currentPage + 1) % this.m_numberPages);
            }
            else {
                this.setCurrentPage(Math.min(this.m_numberPages, this.m_currentPage + 1));
            }
            /* eslint-enable */
        }
        if (this.m_onPageChangeCallback) {
            this.m_onPageChangeCallback({
                "currentPage": this.m_currentPage,
                "numberPages": this.m_numberPages
            });
        }
    };

    /**
     * Handles the event when the user clicks the first page target. This will automatically set the page index to 0,
     * or the first page. Once the page index has been updated, the page change callback will be called with the current
     * page index.
     * @returns {undefined} Returns undefined.
     */
    Pager.prototype.onClickLast = function() {
        this.setCurrentPage(this.m_numberPages);
        if (this.m_onPageChangeCallback) {
            this.m_onPageChangeCallback({
                "currentPage": this.m_currentPage,
                "numberPages": this.m_numberPages
            });
        }
    };

    /**
     * Sets the callback to be triggered when the page index changes.
     * @param {function} callback - The callback function to be triggered when the page index changes. It is expected
     * that this callback function provide a parameter for the current page index. For example...
     * pager.setOnPageChangeCallback(function(pageIndex){ ... });
     * @returns {MPageUI.Pager} Returns self to allow chaining.
     */
    Pager.prototype.setOnPageChangeCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("Pager.prototype.setOnPageChangeCallback expects a function.");
        }
        this.m_onPageChangeCallback = callback;
        return this;
    };

    /**
     * Overrides the base render function.
     * @returns {string} Returns jquery pager object.
     */
    Pager.prototype.render = function() {
        var previousDisabled = (!this.m_wrap ? " disabled='true'" : "");
        var pager = "<nav id='" + this.m_id + "' class='paginator'>";
        //Next
        pager += "<span class='next-pages'><a class='next-page' href='#' rel='next'>" + this.m_nextLabel + "</a></span>";
        //Previous
        pager += "<span class='prior-pages'><a class='prev-page' href='#' rel='prev'" + previousDisabled + ">" + this.m_previousLabel + "</a></span>";
        //Middle area (separator)
        pager += "<span class='current-page'>" + this.getCurrentPageLabel() + "</span></nav>";
        return pager;
    };

    /**
     * Attaches the necessary events to an instance of the Pager. This function must be called after the Pager has
     * been rendered to the DOM.
     * @returns {undefined} Returns nothing.
     */
    Pager.prototype.attachEvents = function() {
        var self = this;
        var $rootElement = this.getRootElement();
        $rootElement.on("click.mpageui", ".first-page", function() {
            self.onClickFirst();
        });
        $rootElement.on("click.mpageui", ".prev-page", function() {
            self.onClickPrevious();
        });
        $rootElement.on("click.mpageui", ".next-page", function() {
            self.onClickNext();
        });
        $rootElement.on("click.mpageui", ".last-page", function() {
            self.onClickLast();
        });
    };
    return Pager;
})();

/* global MPageUI */

MPageUI.POPUP_OPTIONS = {
    POSITION: {
        RIGHT: "right",
        LEFT: "left",
        TOP: "top",
        TOP_RIGHT: "top-right",
        TOP_LEFT: "top-left",
        BOTTOM: "bottom",
        BOTTOM_RIGHT: "bottom-right",
        BOTTOM_LEFT: "bottom-left"
    },
    WIDTH: {
        SMALL: 200,
        MEDIUM: 400,
        LARGE: 600
    }
};

MPageUI.Popup = (function() {
    /**
     * The Popup class.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     * @constructor
     */
    var Popup = function() {
        //Super constructor
        this.base();
        this.m_headerHTML = "";
        this.m_bodyHTML = "";
        this.m_footerHTML = "";
        this.m_anchorId = "";
        this.m_position = MPageUI.POPUP_OPTIONS.POSITION.BOTTOM;
        this.m_width = MPageUI.POPUP_OPTIONS.WIDTH.SMALL;
        this.m_maxBodyHeight = "400px";
        this.m_popupExistsFlag = false;
        this.m_popupShowingFlag = false;
        this.m_hideOnScroll = false;
        this.m_scrollableParent = "";
        return this;
    };

    MPageUI.extend(Popup, MPageUI.UIComponent);

    /**
     * A parent div containing the tooltip. Once scrolled, the tooltip will disapear.
     * @throws {Error} An error indicating that the argument is an invalid type.
     * @param {string} scrollableParent - a class or ID representing the parent scrollable element
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.setScrollableParent = function(scrollableParent) {
        if (typeof scrollableParent !== "string") {
            throw new Error("MPageUI.Popup.prototype.setScrollableParent expects a string.");
        }

        this.m_scrollableParent = scrollableParent;

        return this;
    };

    /**
     * Returns whether the popup exists or not
     * @throws {Error} An error indicating that the argument is an invalid type.
     * @param {Boolean} isHidden - true or false based on if the popup exists or not
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.hideOnScroll = function(isHidden) {
        if (typeof isHidden !== "boolean") {
            throw new Error("MPageUI.Popup.prototype.hideOnScroll expects a boolean.");
        }

        if (!this.m_scrollableParent) {
            throw new Error("MPageUI.Popup.prototype.hideOnScroll expects setScrollableParent to be set.");
        }

        this.m_hideOnScroll = isHidden;

        return this;
    };
    /**
     * Returns whether the popup exists or not
     * @returns {boolean} true or false based on if the popup exists or not
     */
    Popup.prototype.exists = function() {
        return this.m_popupExistsFlag;
    };
    /**
     * Returns whether the popup is open or not
     * @returns {boolean} true or false based on if the popup is open or not
     */
    Popup.prototype.isOpen = function() {
        return this.m_popupShowingFlag;
    };
    /**
     * Calls the create and show functions. This function was only created to
     * allow the sampler to call .render. It should not be used by
     * external callers
     * @private
     * @returns {undefined} Returns nothing.
     */
    Popup.prototype.render = function() {
        this.show();
    };
    /**
     * Creates the popup using the tooltipster plugin
     * @throws {Error} An error indicating that the anchor id should already be set
     * @private
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.create = function() {
        if (!this.m_anchorId) {
            throw new Error("MPageUI.Popup.prototype.create expects the anchor id to be set.");
        }

        var self = this;
        var anchorSelector = "#" + this.m_anchorId;
        var popupHTML = "";

        if (this.m_headerHTML) {
            popupHTML += "<div class='mpage-ui-popup-header'>" + this.m_headerHTML + "</div>";
        }

        popupHTML += "<div class='mpage-ui-popup-body' id='" + this.m_id + "' style='max-height:" + this.m_maxBodyHeight + "'>" + this.m_bodyHTML + "</div>";

        if (this.m_footerHTML) {
            popupHTML += "<div>" + this.m_footerHTML + "</div>";
        }

        $(anchorSelector).tooltipster({
            content: $(popupHTML),
            interactive: true,
            maxWidth: self.m_width,
            minWidth: self.m_width,
            position: self.m_position,
            restoration: "none",
            theme: "mpage-ui-popup",
            trigger: "custom",
            speed: 0
        });

        this.m_popupExistsFlag = true;

        return this;
    };
    /**
     * Destroys the popup using and clears some member level variables
     * @throws {Error} An error indicating that the anchor id should already be set
     * @deprecated
     * @private
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.destroy = function() {
        if (!this.m_anchorId) {
            throw new Error("MPageUI.Popup.prototype.destroy expects the anchor id to be set.");
        }
        //If the popup does not exist, then there is nothing to destroy
        if (!this.m_popupExistsFlag) {
            return this;
        }
        //destroy the popup
        var anchorSelector = "#" + this.m_anchorId;
        $(anchorSelector).tooltipster("destroy");
        //clear the member level variables
        this.m_popupExistsFlag = false;
        this.m_popupShowingFlag = false;
        this.m_headerHTML = "";
        this.m_bodyHTML = "";
        this.m_footerHTML = "";
        return null;
    };
    /**
     * Shows the popup
     * @throws {Error} An error indicating that the anchor id should already be set
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.show = function() {
        if (!this.m_anchorId) {
            throw new Error("MPageUI.Popup.prototype.show expects the anchor id to be set.");
        }

        //If the popup is already showing, no need to show again, just return self to allow chaining
        if (this.m_popupShowingFlag) {
            return this;
        }

        //If the popup does not already exist, call create
        if (!this.m_popupExistsFlag) {
            this.create();
        }

        var anchorSelector = "#" + this.m_anchorId;
        $(anchorSelector).tooltipster("show");
        this.m_popupShowingFlag = true;

        return this;
    };
    /**
     * Hides the popup
     * @throws {Error} An error indicating that the anchor id should already be set
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.hide = function() {
        if (!this.m_anchorId) {
            throw new Error("MPageUI.Popup.prototype.hide expects the anchor id to be set.");
        }

        //if the popup is showing, hide it
        if (this.m_popupShowingFlag) {
            var anchorSelector = "#" + this.m_anchorId;
            $(anchorSelector).tooltipster("hide");
            this.m_popupShowingFlag = false;
        }
        return this;
    };
    /**
     * Toggles the popup to show and hide as needed
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.toggle = function() {
        if (this.m_popupShowingFlag) {
            this.hide();
        }
        else {
            this.show();
        }
        return this;
    };
    /**
     * Sets the anchor id of the popup. This is the id of the element the popup should anchor to.
     * @param {string} anchorId - The anchor id of popup
     * @throws {Error} An error indicating that the anchor id parameter is an invalid type.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.setAnchorId = function(anchorId) {
        if (typeof anchorId !== "string") {
            throw new Error("MPageUI.Popup.prototype.setAnchorId expects a string.");
        }
        this.m_anchorId = anchorId;
        return this;
    };
    /**
     * Sets the header of the popup
     * @param {string} headerText - The header text to display in the popup
     * @throws {Error} An error indicating that the header text parameter is an invalid type.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.setHeader = function(headerText) {
        if (typeof headerText !== "string") {
            throw new Error("MPageUI.Popup.prototype.setHeader expects a string.");
        }
        this.m_headerHTML = headerText;

        if (this.m_popupExistsFlag) {
            this.changePopupContent();
        }

        return this;
    };
    /**
     * Sets the body content of the popup
     * @param {string} bodyHTML - The body html string to display in the popup
     * @throws {Error} An error indicating that the body html parameter is an invalid type.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.setBodyContent = function(bodyHTML) {
        if (typeof bodyHTML !== "string") {
            throw new Error("MPageUI.Popup.prototype.setBodyContent expects a string.");
        }

        this.m_bodyHTML = bodyHTML;

        if (this.m_popupExistsFlag) {
            this.changePopupContent();
        }

        return this;
    };
    /**
     * Sets the footer of the popup
     * @param {string} footerHTML - The footer html string to display in the popup
     * @throws {Error} An error indicating that the footer html parameter is an invalid type.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.setFooter = function(footerHTML) {
        if (typeof footerHTML !== "string") {
            throw new Error("MPageUI.Popup.prototype.setFooter expects a string.");
        }
        this.m_footerHTML = footerHTML;

        if (this.m_popupExistsFlag) {
            this.changePopupContent();
        }

        return this;
    };
    /**
     * Sets the position of the popup
     * @param {string} position - The position string of the popup
     * @throws {Error} An error indicating that the position parameter is an invalid type.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.setPosition = function(position) {
        if (typeof position !== "string") {
            throw new Error("MPageUI.Popup.prototype.setPosition expects a string.");
        }
        this.m_position = position;
        return this;
    };
    /**
     * Sets the width of the popup
     * @param {number} width - The width of the popup
     * @throws {Error} An error indicating that the width parameter is an invalid type.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.setWidth = function(width) {
        if (typeof width !== "number") {
            throw new Error("MPageUI.Popup.prototype.setWidth expects a number.");
        }
        this.m_width = width;
        return this;
    };
    /**
     * Sets the max body height of the popup (not the whole popup height). Should be passed
     * as "400px" or "20%".
     * @param {string} bodyMaxHeight - The maximum body height string of the popup
     * @throws {Error} An error indicating that the position parameter is an invalid type.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.setMaxBodyHeight = function(bodyMaxHeight) {
        if (typeof bodyMaxHeight !== "string") {
            throw new Error("MPageUI.Popup.prototype.setMaxBodyHeight expects a string.");
        }
        this.m_maxBodyHeight = bodyMaxHeight;
        return this;
    };
    /**
     * Updates any of the three areas of the popup content. This function is called by
     * other functions when a content area is set and the popup already exists
     * @throws {Error} An error indicating that the anchor id should already be set
     * @private
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.changePopupContent = function() {
        if (!this.m_anchorId) {
            throw new Error("MPageUI.Popup.prototype.changePopupContent expects the anchor id to be set.");
        }

        var popupHTML = "";
        var anchorSelector = "#" + this.m_anchorId;

        if (this.m_headerHTML) {
            popupHTML += "<div class='mpage-ui-popup-header'>" + this.m_headerHTML + "</div>";
        }

        popupHTML += "<div class='mpage-ui-popup-body' style='max-height:" + this.m_maxBodyHeight + "'>" + this.m_bodyHTML + "</div>";

        if (this.m_footerHTML) {
            popupHTML += "<div>" + this.m_footerHTML + "</div>";
        }

        $(anchorSelector).tooltipster("content", $(popupHTML));
        return this;
    };
    /**
     * Attach event to DOM elements once the HTML has been rendered.
     * @returns {MPageUI.Popup} Returns self to allow chaining.
     */
    Popup.prototype.attachEvents = function() {
        var self = this;

        /**
         * @TODO - This fixes the issue #463 on https://github.com/iamceege/tooltipster/issues
         *         Where the tooltip does not move when the parent div is scrolled. Update code
         *         once issue is fixed by owner on Terra lands on another library for tooltips.
         */
        if (this.m_hideOnScroll && this.m_anchorId) {
            $(this.m_scrollableParent).on("scroll", function() {
                if (self.isOpen()) {
                    //Hide the popup upon scrolling the parent div
                    self.hide();
                }
            });
        }
        return this;
    };
    return Popup;
})();

/* global MPageUI */

MPageUI.SEGMENTED_CONTROL_OPTIONS = {
    SELECT_MODE: {
        SINGLE: 0,
        MULTI: 1
    }
};

MPageUI.SegmentedControl = (function() {
    /**
     * The SegmentedControl class.
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     * @constructor
     */
    var SegmentedControl = function() {
        this.m_selectedSegments = null;
        this.m_segments = null;
        this.m_selectMode = MPageUI.SEGMENTED_CONTROL_OPTIONS.SELECT_MODE.SINGLE;
        this.base();
        return this;
    };
    MPageUI.extend(SegmentedControl, MPageUI.UIComponent);

    /**
     * Retrieves the list of all selected segments.
     * @private
     * @returns {Array<Object>} The array of selected segments.
     */
    SegmentedControl.prototype.getSelectedSegments = function() {
        if (!this.m_selectedSegments) {
            this.m_selectedSegments = [];
        }
        return this.m_selectedSegments;
    };

    /**
     * Retrieves the list of all segments.
     * @private
     * @returns {Array<Object>} The array of segments.
     */
    SegmentedControl.prototype.getSegments = function() {
        if (!this.m_segments) {
            this.m_segments = [];
        }
        return this.m_segments;
    };

    /**
     * Sets the selection mode for the SegmentedControl. This will determine the behavior when the user interacts with
     * the control.
     * @param {number} selectMode - The selection mode for the SegmentedControl. This must be chosen from the
     * MPageUI.SEGMENTED_CONTROL_OPTIONS.SELECT_MODE enumeration.
     * @throws {Error} An error indicating that the provided option was not valid.
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.setSelectMode = function(selectMode) {
        if (typeof selectMode !== "number") {
            throw new Error("MPageUI.SegmentedControl.prototype.setSelectMode expects an integer");
        }
        this.m_selectMode = selectMode;
        return this;
    };

    /**
     * Activates a single segment object. This will add the segment to the list of selected segments and add an
     * active class to the root element of the segment.
     * @private
     * @param {Object} segmentObject - The segment object to be activated.
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.selectSegment = function(segmentObject) {
        //Update the UI
        var $segmentRootElement = segmentObject.uiComponent.getRootElement();
        $segmentRootElement.addClass("active");
        //Store the selected segment
        this.getSelectedSegments().push(segmentObject);
        //If the onSelect function has been provided for the segment
        if (segmentObject.segment.onSelect) {
            segmentObject.segment.onSelect.call(segmentObject.segment);
        }
        return this;
    };

    /**
     * Deactivates a single segment object. This will remove the segment from the list of selected segments and remove
     * the active class from the root element of the segment.
     * @private
     * @param {Object} segmentObject - The segment object to be deactivated.
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.deselectSegment = function(segmentObject) {
        //Update the UI
        var $segmentRootElement = segmentObject.uiComponent.getRootElement();
        $segmentRootElement.removeClass("active");
        var selectedSegments = this.getSelectedSegments();
        var selectedSegmentCount = selectedSegments.length;
        //Loop through the list of selected segments and remove the specified segment from the list
        for (var i = 0; i < selectedSegmentCount; i++) {
            if (selectedSegments[ i ] === segmentObject) {
                selectedSegments.splice(i, 1);
                //If the onDeselect function has been provided for the segment
                if (segmentObject.segment.onDeselect) {
                    segmentObject.segment.onDeselect.call(segmentObject.segment);
                }
                break;
            }
        }
        return this;
    };
    /**
     * This function will validate a provided segment. If the segment is not valid, an exception will be thrown to
     * inform the consumer.
     * @param {Object} segment - The segment to be verified.
     * @private
     * @throws {Error} An error indicating that the provided segment was not valid.
     * @returns {undefined} Returns nothing.
     */
    SegmentedControl.prototype.validateSegment = function(segment) {
        if (typeof segment !== "object") {
            throw new Error("MPageUI.SegmentedControl.prototype.validateSegment expects an object");
        }
        //validate label
        if (!segment.label) {
            throw new Error("MPageUI.SegmentedControl.prototype.addSegment: label is required for this segment.");
        }
        //validate id
        if (segment.id && typeof segment.id !== "string") {
            throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the label must be a string.");
        }
        //validate disabled
        if (segment.selected && typeof segment.selected !== "boolean") {
            throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the selected attribute must be a boolean.");
        }
        //validate disabled
        if (segment.disabled && typeof segment.disabled !== "boolean") {
            throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the disabled attribute must be a boolean.");
        }
        //validate onSelect callback
        if (!segment.onSelect) {
            throw new Error("MPageUI.SegmentedControl.prototype.addSegment: onSelect callback is required for this segment.");
        }
        if (typeof segment.onSelect !== "function") {
            throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the onSelect callback must be a function.");
        }
        //validate onDeselect callback
        if (segment.onDeselect && typeof segment.onDeselect !== "function") {
            throw new Error("MPageUI.SegmentedControl.prototype.addSegment: the onDeselect callback must be a function.");
        }
    };
    /**
     * This function will disable the segment with a given index position
     * @param  {number} index The index of the segment to be activated
     * @throws {Error} An error is thrown if an invalid index is provided.
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.disableSegmentAtIndex = function(index) {
        var segments = this.getSegments();
        var segment = null;
        if (index < 0 || index >= segments.length) {
            throw new Error("SegmentedControl.prototype.selectSegmentAtIndex expects an integer between 0 and the number of segments.");
        }
        segment = segments[ index ];
        //check if segment is selected deselect it
        if (this.isSegmentAtIndexSelected(index)) {
            this.deselectSegment(segment);
        }
        //set the segment as disabled
        segment.uiComponent.setDisabled(true);

        return this;
    };
    /**
     * This private function will take a segment id as a parameter and return the segment with that id
     * if there is no segment with the given id the function will return null
     * @param  {String} id - The id of the segment.
     * @throws {Error} An error is thrown if an invalid id is provided.
     * @private
     * @returns {MPageUI.SegmentedControl}    Returns the segment with the given id.
     */
    SegmentedControl.prototype.getSegmentById = function(id) {
        //validate id to be a string
        if (typeof id !== "string") {
            throw new Error("SegmentedControl.prototype.deselectSegmentById expects id to be a string.");
        }
        var segments = this.getSegments();
        var segmentCount = segments.length;
        var segment = null;
        for (var i = 0; i < segmentCount; i++) {
            segment = segments[ i ];
            if (segment.segment.id === id) {
                return segment;
            }
        }
        return null;
    };
    /**
     * This function will take a segment id as a parameter and deselect it
     * @param  {String} id - The id of the segment
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.deselectSegmentById = function(id) {
        //get the segment with the id
        var segment = this.getSegmentById(id);
        var selectedSegments = null;
        if (segment) {
            //get all selected segments
            selectedSegments = this.getSelectedSegments();
            var selectedSegmentsCount = selectedSegments.length;
            //check if the segment is selected and deselect it
            for (var i = 0; i < selectedSegmentsCount; i++) {
                if (selectedSegments[ i ] === segment) {
                    this.deselectSegment(segment);
                }
                break;
            }
        }
        return this;
    };
    /**
     * This function will take a segment id as a parameter and change the state of the segment
     * with the given id to disabled
     * @param  {String} id - Segment id
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.disableSegmentById = function(id) {
        var segment = this.getSegmentById(id);
        //deselect the segment
        this.deselectSegmentById(id);
        //set the segment as disabled
        segment.uiComponent.setDisabled(true);
        return this;
    };
    /**
     * This is a consumer-facing function that allows a segment to be activated via its index. The index is 0-based.
     * @param {number} index - The index of the segment to be activated.
     * @throws {Error} An error is thrown if an invalid index is provided.
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.selectSegmentAtIndex = function(index) {
        var segments = this.getSegments();
        var segment = null;
        if (index < 0 || index >= segments.length) {
            throw new Error("SegmentedControl.prototype.selectSegmentAtIndex expects an integer between 0 and the number of segments.");
        }
        segment = segments[ index ];
        //Use the handle selection function
        this.handleSelection(segment);
        return this;
    };

    /**
     * This is a consumer-facing function that allows a segment to be activated via its index. The index is 0-based.
     * @param {number} index - The index of the segment to be activated.
     * @throws {Error} An error is thrown if an invalid index is provided.
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.deselectSegmentAtIndex = function(index) {
        var segments = this.getSegments();
        var segment = null;
        var selectedIndex = null;
        if (index < 0 || index >= segments.length) {
            throw new Error("MPageUI.SegmentedControl.prototype.deselectSegmentAtIndex expects a number between 0 and the number of segments.");
        }
        segment = segments[ index ];
        selectedIndex = this.getSelectedSegmentIndex(segment);
        //If the segment is already inactive
        if (selectedIndex < 0) {
            return this;
        }
        this.deselectSegment(segment);
        return this;
    };

    /**
     * Returns a boolean indicating if the segment at the provided index is selected or not.
     * @param {number} index - The index of the segment that is being checked.
     * @throws {Error} An error is thrown if an invalid index is provided.
     * @returns {boolean} True if the segment is selected otherwise false.
     */
    SegmentedControl.prototype.isSegmentAtIndexSelected = function(index) {
        var segments = this.getSegments();
        if (index < 0 || index >= segments.length) {
            throw new Error("MPageUI.SegmentedControl.prototype.isSegmentAtIndexSelected expects a number between 0 and the number of segments.");
        }
        return this.getSelectedSegmentIndex(segments[ index ]) > -1;
    };

    /**
     * Retrieves the index where the segment is within the array of selected segments. If the segment is not selected
     * (not present in the array of selected segments), -1 will be returned.
     * @param {Object} segment - The segment object for which we are retrieving the position in the array of selected
     * segments.
     * @private
     * @returns {number} The index of the segment in the array of selected segments. Returns -1 if the segment was not
     * found.
     */
    SegmentedControl.prototype.getSelectedSegmentIndex = function(segment) {
        var segments = this.getSelectedSegments();
        var segmentCount = segments.length;
        for (var i = 0; i < segmentCount; i++) {
            if (segments[ i ] === segment) {
                return i;
            }
        }
        //Segment is not within the array of selected segments
        return -1;
    };

    /**
     * Handles the selection of a segment object.
     * @param {Object} segment - The segment object for which selection is being handled.
     * @private
     * @returns {undefined} Returns nothing.
     */
    SegmentedControl.prototype.handleSelection = function(segment) {
        var selectionModeEnum = MPageUI.SEGMENTED_CONTROL_OPTIONS.SELECT_MODE;
        //Checks if the segment is selected
        var selectedIndex = this.getSelectedSegmentIndex(segment);
        switch (this.m_selectMode) {
            //Multi selection mode
            case selectionModeEnum.MULTI:
                if (selectedIndex > -1) {
                    this.deselectSegment(segment);
                }
                else {
                    this.selectSegment(segment);
                }
                break;
            case selectionModeEnum.SINGLE:
            default:
                //Only do work if the segment is not selected
                if (selectedIndex < 0) {
                    this.deselectAllSegments();
                    this.selectSegment(segment);
                }
                break;
        }
    };

    /**
     * Deactivates all segments. It first iterates over all selected segments, calling their onDeselect callback if
     * provided.
     * @returns {undefined} Returns nothing.
     */
    SegmentedControl.prototype.deselectAllSegments = function() {
        var $rootElement = this.getRootElement();
        $rootElement.find(".active").removeClass("active");
        var selectedSegments = this.getSelectedSegments();
        var selectedSegmentCount = selectedSegments.length;
        var selectedSegment = null;
        for (var i = 0; i < selectedSegmentCount; i++) {
            selectedSegment = selectedSegments[ i ];
            if (selectedSegment.segment.onDeselect) {
                selectedSegment.segment.onDeselect.call(selectedSegment.segment);
            }
        }
        this.m_selectedSegments = [];
    };

    /**
     * Adds a segment to the SegmentedControl. The segment
     * @param {Object} segment - The segment to be added to the SegmentedControl. This must be of the following form.
     * {
	 * 		id: 'segmentId'
	 * 		label: 'Label',
	 * 		selected: 'true/false' [optional - false if not set]
	 * 		disabled: true/false, [optional - false if not set]
	 * 		onSelect:	function() { ... },
	 * 		onDeselect: function() { ... }
	 * }
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.addSegment = function(segment) {
        this.validateSegment(segment);
        var segmentObject = null;
        var segments = this.getSegments();
        var button = new MPageUI.ToggleButton();
        var self = this;
        button.setLabel(segment.label);
        button.setSelected(segment.selected || false);
        button.setDisabled(segment.disabled || false);
        button.setOnClickCallback(function() {
            self.handleSelection(segmentObject);
        });
        //Create a wrapping segment object which stores
        segmentObject = {
            "segment": segment,
            "uiComponent": button
        };
        segments.push(segmentObject);
        if (segment.selected) {
            this.getSelectedSegments().push(segmentObject);
        }
        return this;
    };

    /**
     * Renders the SegmentedControl as an html string.
     * @returns {string} The SegmentedControl rendered as an html string.
     */
    SegmentedControl.prototype.render = function() {
        var segments = this.getSegments();
        var segmentCount = segments.length;
        var html = "<div id='" + this.m_id + "' class='btn-group'>";
        for (var i = 0; i < segmentCount; i++) {
            html += segments[ i ].uiComponent.render();
        }
        return html + "</div>";
    };

    /**
     * Attaches the events to the segments.
     * @returns {MPageUI.SegmentedControl} Returns self to allow chaining.
     */
    SegmentedControl.prototype.attachEvents = function() {
        var segments = this.getSegments();
        var segmentCount = segments.length;
        for (var i = 0; i < segmentCount; i++) {
            segments[ i ].uiComponent.attachEvents();
        }
        return this;
    };

    /**
     * Runs through each segment and clears the element cache for each component.
     * @returns {undefined} Returns nothing.
     */
    SegmentedControl.prototype.clearElementCache = function() {
        var segments = this.getSegments();
        var segmentCount = segments.length;
        for (var i = 0; i < segmentCount; i++) {
            segments[ i ].uiComponent.clearElementCache();
        }
    };

    return SegmentedControl;
})();

/* global MPageUI */

MPageUI.PEDBannerControl = (function() {
    /**
     * The MPageUI.PEDBannerControl class.
     * @returns {MPageUI.PEDBannerControl} Returns self to allow chaining.
     * @constructor
     */
    var PEDBannerControl = function() {
        this.base();
        this.m_buttonClickCallback = null;
        this.m_bannerButton = new MPageUI.Button();
        this.m_options = {
            buttonLabel: "",
            bannerText: "",
            buttonStyle: MPageUI.BUTTON_OPTIONS.STYLE.SECONDARY
        };
        return this;
    };

    MPageUI.extend(PEDBannerControl, MPageUI.UIComponent);

    /**
     * Renders banner button with the inputs provided - Parameters checked: Button, Button label, button callback
     * @throws {Error} Error thrown when banner button is not present || button label is not present || button callback is not present
     * @returns {string} Contains the markup of the button
     */
    PEDBannerControl.prototype.renderBannerButton = function() {
        if (!this.m_bannerButton) {
            throw new Error("MPageUI.PEDBannerControl.prototype.renderBannerButton is not able to create an instance of MPageUI Button");
        }
        if (!this.m_options.buttonLabel) {
            throw new Error("MPageUI.PEDBannerControl.prototype.renderBannerButton expects a button label");
        }
        if (!this.m_buttonClickCallback) {
            throw new Error("MPageUI.PEDBannerControl.prototype.renderBannerButton expects a button callback");
        }
        this.m_bannerButton.setLabel(this.m_options.buttonLabel);
        this.m_bannerButton.setStyle(this.m_options.buttonStyle);
        this.m_bannerButton.setOnClickCallback(this.m_buttonClickCallback);

        return this.m_bannerButton.render();
    };
    /* eslint-enable no-unused-vars */
    /**
     * Sets the callback for the button in the banner
     * @param {Function} callback function to call when the button is clicked
     * @throws {Error} Error thrown when button callback is not of a type function
     * @returns {MPageUI.PEDBannerControl} Returns self to allow chaining.
     */
    PEDBannerControl.prototype.setPEDBannerButtonCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("MPageUI.PEDBannerControl.prototype.setPEDBannerButtonCallback expects a function");
        }
        this.m_buttonClickCallback = callback;
        return this;
    };

    /* eslint-enable no-unused-vars */
    /**
     * Sets the banner text
     * @param {string} bannerText Text describing the banner content
     * @throws {Error} Error thrown when banner text is not of a type string
     * @returns {MPageUI.PEDBannerControl} Returns self to allow chaining.
     */
    PEDBannerControl.prototype.setPEDBannerText = function(bannerText) {
        if (typeof bannerText !== "string") {
            throw new Error("MPageUI.PEDBannerControl.prototype.setPEDBannerText expects a string");
        }
        this.m_options.bannerText = bannerText;
        return this;
    };

    /* eslint-enable no-unused-vars */
    /**
     * Sets the button label
     * @param {string} buttonLabel Label of the button placed inside the banner
     * @throws {Error} Error thrown when banner button label is not of a type string
     * @returns {MPageUI.PEDBannerControl} Returns self to allow chaining.
     */
    PEDBannerControl.prototype.setPEDButtonLabel = function(buttonLabel) {
        if (typeof buttonLabel !== "string") {
            throw new Error("MPageUI.PEDBannerControl.prototype.setPEDButtonLabel expects a string");
        }
        this.m_options.buttonLabel = buttonLabel;
        return this;
    };

    /**
     * Renders the banner with the text and the button which forms the content within the Alert Banner shell
     * @throws {Error} Error thrown when banner text is not present
     * @returns {string} Markup containing the banner html
     */
    PEDBannerControl.prototype.render = function() {
        var bannerHtml = "";

        if (!this.m_options.bannerText) {
            throw new Error("MPageUI.PEDBannerControl.prototype.render expects setPEDBannerText");
        }

        bannerHtml += "<span class='ped-banner-text'>" + this.m_options.bannerText + "</span><span class='ped-banner-button' id='bannerBtn_" + this.m_id + "'>" + this.renderBannerButton() + "</span>";
        return bannerHtml;
    };

    /**
     * Attaches the necessary events to the button. This function must be called after the button
     * markup exists on the DOM.
     */
    PEDBannerControl.prototype.attachEvents = function() {
        this.m_bannerButton.attachEvents();
    };

    /**
     * Clears the element cache for each sub-component elements.
     */
    PEDBannerControl.prototype.clearElementCache = function() {
        this.m_bannerButton.clearElementCache();
    };

    return PEDBannerControl;
})();

/* global MPageUI */

MPageUI.TabControl = (function() {

    /**
     * The TabControl class.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     * @constructor
     */
    var TabControl = function() {
        //calls super class
        this.base();
        //total width of the tab controller
        this.m_totalWidth = null;
        //to store the list of tabs in the tab controller
        this.m_tabs = null;
        //flag to have the close tab option for the tabs
        this.m_canCloseTabs = false;
        //A flag to store the state of whether the scroll control should be shown given the current width of the control.
        this.m_displayScroller = false;
        // flag to have the drag and drop option for the tabs
        this.m_canSortTabs = false;
        // flag to have count option for tabs
        this.m_enableLabelCount = false;
        //callback function for the click/activate tab events
        this.m_onSelectCallback = null;
        //callback function for the deactivate tab events
        this.m_onDeselectCallback = null;
        //callback function for closing the tab
        this.m_onCloseCallback = null;
        //callback function for drag and drop option
        this.m_onSortCallback = null;
        //to have the default tab id
        this.m_defaultTab = null;
        //to store the list of activated tabs
        this.m_alreadyActivatedTabs = null;
        //to store the number of tabs shown
        this.m_numberOfTabsShown = null;
        //to store the index of the first tab shown
        this.m_firstTabIndex = 0;
        //to store which tab is currently active
        this.m_currentActiveTab = null;
        //to store the space for scroll elements(left and right arrow)
        this.m_scrollerWidth = 70;
        //to store the parent width of the tab controller
        this.m_parentWidth = null;
        //A flag to store whether the tabControl has been finalized or not.
        this.m_tabControlFinalized = false;

        return this;
    };
    MPageUI.extend(TabControl, MPageUI.UIComponent);

    /**
     * Flag indicating if a count needs to be shown on the tab
     * @param {boolean} enableLabelCount - The flag to set the display state for tab label to have count.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setEnableLabelCount = function(enableLabelCount) {
        if (typeof enableLabelCount !== "boolean") {
            throw new Error("TabControl.prototype.setEnableLabelCount expects a boolean.");
        }
        this.m_enableLabelCount = enableLabelCount;
        return this;
    };

    /**
     * hide the count label for a tab.
     * @param  {JSON} tab - tab for which count label is to be hidden
     * @returns {MPageUI.TabControl}     Returns self to allow chaining
     */
    TabControl.prototype.hideCountOnTab = function(tab) {
        this.validateTab(tab);
        $("#countTab" + tab.id).empty();
        this.resize(true);
        return this;
    };

    /**
     * Update count label for a tab. The tab control must be rendered for this function
     * @param {JSON} tab - tab for which count is to be updated
     * @param {number} count - count on the tab to be updated
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.updateCountOnTab = function(tab, count) {
        this.validateTab(tab);
        if (typeof count !== "number") {
            throw new Error("MPageUI.TabControl.prototype.updateCountOnTab expects a number");
        }
        var countElement = $("#countTab" + tab.id);
        countElement.empty();
        countElement.append("(" + count + ")");
        this.resize(true);
        return this;
    };

    /**
     * Update indicator on a tab. The tab control must be rendered for this function
     * @param {JSON} tab - tab for which indicator is to be updated
     * @param {String} indicatorHTML - indicator markup to be updated
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.updateIndicatorOnTab = function(tab, indicatorHTML) {
        this.validateTab(tab);
        if (typeof indicatorHTML !== "string") {
            throw new Error("MPageUI.TabControl.prototype.updateIndicatorOnTab expects a string");
        }
        if (!tab.hasIndicator) {
            throw new Error("MPageUI.TabControl.prototype.updateIndicatorOnTab: tab is not configured to have indicators on label");
        }
        var indicatorElement = $("#indicatorTab" + tab.id);
        if (indicatorElement.length === 0) {
            //get the label element object to inject indicator markup
            var labelElement = $("#labelTab" + tab.id);
            // Prepend indicator container and markup
            labelElement.prepend("<span id = 'indicatorTab" + tab.id + "' class='indicator-label'>" + indicatorHTML + "</span>");
        }
        else {
            indicatorElement.empty();
            indicatorElement.append(indicatorHTML);
        }
        this.resize(true);
        return this;
    };

    /**
     * Gets the indicator for the ability to allow tab label to have count.
     * @returns {boolean} Returns indicator for enabling label count
     */
    TabControl.prototype.getEnableLabelCount = function() {
        return this.m_enableLabelCount;
    };


    /**
     * Sets the indicator for the ability to close tabs.
     * @param {boolean} canCloseTabs - The flag to set the display state for close tab.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setCanCloseTabs = function(canCloseTabs) {
        if (typeof canCloseTabs !== "boolean") {
            throw new Error("TabControl.prototype.setCanCloseTabs expects a boolean.");
        }
        this.m_canCloseTabs = canCloseTabs;
        return this;
    };

    /**
     * Sets the indicator for the ability to have sorting option for tabs.
     * @param {boolean} canSortTabs - The flag to set the display state for having sorting option.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setCanSortTabs = function(canSortTabs) {
        if (typeof canSortTabs !== "boolean") {
            throw new Error("TabControl.prototype.setCanSortTabs expects a boolean.");
        }
        this.m_canSortTabs = canSortTabs;
        return this;
    };

    /**
     * Sets the tab as default to make it active.
     * @param {string} tabId - tab id for the tab to make it active by default.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setDefaultTab = function(tabId) {
        if (typeof tabId !== "string") {
            throw new Error("TabControl.prototype.setDefaultTab expects a string.");
        }
        this.m_defaultTab = tabId;
        return this;
    };

    /**
     * Sets the call back function for on tab click/activation.
     * @param {function} callback - The callback function for the tab click/activation.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setOnSelectCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("TabControl.prototype.setOnSelectCallback expects a function.");
        }
        this.m_onSelectCallback = callback;
        return this;
    };

    /**
     * Sets the call back function for on tab deactivate.
     * @param {function} callback - The callback function for the tab deactivate.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setOnDeselectCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("TabControl.prototype.setOnDeselectCallback expects a function.");
        }
        this.m_onDeselectCallback = callback;
        return this;
    };

    /**
     * Sets the call back function for sorting of the tabs.
     * @param {function} callback - The callback function for sorting of the tab.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setOnSortCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("TabControl.prototype.setOnSortCallback expects a function.");
        }
        this.m_onSortCallback = callback;
        return this;
    };

    /**
     * Sets the call back function for tab close option.
     * @param {function} callback - The call back function for tab close option.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setOnCloseCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("TabControl.prototype.setOnCloseCallback expects a function.");
        }
        this.m_onCloseCallback = callback;
        return this;
    };

    /**
     * This function will validate a provided tab. If the tab is not valid, an exception will be thrown to
     * inform the consumer.
     * @param {Object} tab - The tab to be verified.
     * @throws {Error} An error indicating that the provided tab was not valid.
     * @returns {undefined} Returns nothing.
     */
    TabControl.prototype.validateTab = function(tab) {
        if (typeof tab !== "object") {
            throw new Error("MPageUI.TabControl.prototype.validateTab expects an object");
        }
        //validate id
        if (typeof tab.id !== "string") {
            throw new Error("MPageUI.TabControl.prototype.validateTab: the id must be a string.");
        }
        //validate label
        if (typeof tab.label !== "string") {
            throw new Error("MPageUI.TabControl.prototype.validateTab: the label must be a string.");
        }
        //validate title
        if (typeof tab.title !== "string") {
            throw new Error("MPageUI.TabControl.prototype.validateTab: the title must be a string.");
        }
        //validate onSelect function only if it is set
        if (tab.onSelect && typeof tab.onSelect !== "function") {
            throw new Error("MPageUI.TabControl.prototype.validateTab: the onSelect callback must be a function.");
        }
        //validate onDeselect function only if it is set
        if (tab.onDeselect && typeof tab.onDeselect !== "function") {
            throw new Error("MPageUI.TabControl.prototype.validateTab: the onDeselect callback must be a function.");
        }
        //validate onClose function only if it is set
        if (tab.onClose && typeof tab.onClose !== "function") {
            throw new Error("MPageUI.TabControl.prototype.validateTab: the onClose callback must be a function.");
        }
        //validate canClose option only if it is set
        if (tab.canClose && typeof tab.canClose !== "boolean") {
            throw new Error("MPageUI.TabControl.prototype.validateTab: the canClose callback must be a boolean.");
        }
        //validate hasIndicator option only if it is set
        if (tab.hasIndicator && typeof tab.hasIndicator !== "boolean") {
            throw new Error("MPageUI.TabControl.prototype.validateTab: hasIndicator must be boolean.");
        }
    };

    /**
     * Function to get the list of tabs from the tab controller.
     * @returns {Array} m_tabs - The array of tabs.
     */
    TabControl.prototype.getTabs = function() {
        return this.m_tabs || [];
    };

    /**
     * Function to set the list of tabs to the tab controller, This will determine the list of tabs that will be part of tab controller.
     * @param {Array} tabs - The array of tabs.This must be of the following form.
     * {
	 * 		id: 'tabId'
	 * 		label: 'Label',
	 * 		title: 'title'
	 * 		onSelect: function() { ... },
	 * 		onDeselect: function() { ... },
	 * 		onClose: function() { ... },
	 * 		canClose: boolean
	 * }
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.setTabs = function(tabs) {
        if (!Array.prototype.isPrototypeOf(tabs)) {
            throw new Error("TabControl.prototype.setTabs expects a array.");
        }
        //validate the tabs, it throws an error in case of validation fails
        for (var i = 0; i < tabs.length; i++) {
            this.validateTab(tabs[ i ]);
        }
        this.m_tabs = tabs;
        return this;
    };

    /**
     * Add a tab to the tab control. this will add tab to to the tab existing tab control if tab controller available or
     * it will create tab controller and add the tab onto it
     * and it resizes the tab controller if addTab function is called after finalizing tab control.
     * @param {Object} tab - the tab object.This must be of the following form.
     * {
	 * 		id: 'tabId'
	 * 		label: 'Label',
	 * 		title: 'title'
	 * 		onSelect: function() { ... },
	 * 		onDeselect: function() { ... },
	 * 		onClose: function() { ... },
	 * 		canClose: boolean,
	 * 		hasIndicator: boolean
	 * }
     * @param {boolean} activateNewTab - to decide whether to activate the tab
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.addTab = function(tab, activateNewTab) {
        //validate the tab object
        this.validateTab(tab);
        var rootElement = this.getRootElement();
        //initialize the tabs array if not exists.
        this.m_tabs = this.m_tabs || [];
        //check if tab controller is already available, if not push the tab to tabs array and return
        //then the consumers should have to call the render after adding the tab to get the tab controller
        if (!rootElement.length) {
            //check if the tab is already exists.
            if (!this.tabExists(tab.id)) {
                this.m_tabs.push(tab);
            }
            return;
        }
        var lastIndex = this.m_tabs.length - 1;
        var lastTabId = null;
        //check if the tab is already exists.
        if (!this.tabExists(tab.id)) {
            this.m_tabs.push(tab);
            //render the tab
            var tabElement = $(this.createTab(tab));
            if (this.m_tabs[ lastIndex ]) {
                lastTabId = this.m_tabs[ lastIndex ].id;
                var lastTab = this.getRootElement().find("#" + lastTabId + "tab");
                //add the new tab in the end of last tab if available
                lastTab.after(tabElement);
            }
            else {
                //add the new tab to the end of tab controller
                rootElement.append(tabElement);
            }
            if (this.m_tabControlFinalized) {
                //resize the tab controller
                this.resize(true);
            }
            //check if the tab added is need to be activated
            if (activateNewTab) {
                //activate the new tab
                this.activateTab(tabElement);
            }
        }
    };

    /**
     * Insert a tab to the tab control. this function should be called after the tab controller is available
     * and if a tab needs to be added as part of the tab controller, it resize the tab controller after adding the tab
     * @param {Object} newTab - the tab object.This must be of the following form.
     * {
	 * 		id: 'tabId'
	 * 		label: 'Label',
	 * 		title: 'title'
	 * 		onSelect: function() { ... },
	 * 		onDeselect: function() { ... },
	 * 		onClose: function() { ... },
	 * 		canClose: boolean
	 * }
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.insertTab = function(newTab) {
        //throw error if tab controller is not available
        if (!this.getRootElement().length) {
            throw new Error("TabControl.prototype.insertTab: tab controller not available");
        }
        //validate the new tab
        this.validateTab(newTab);
        if (!this.tabExists(newTab.id)) {
            var tab = null;
            var currentIndex = 0;
            for (var i = 0; i < this.m_tabs.length; i++) {
                tab = this.m_tabs[ i ];
                if (tab.id === this.m_currentActiveTab) {
                    currentIndex = i;
                    break;
                }
            }
            //add the new tab next to current tab
            this.m_tabs.splice(currentIndex + 1, 0, newTab);
            //render the tab
            var tabElement = $(this.createTab(newTab));
            var currentTab = this.getRootElement().find("#" + this.m_currentActiveTab + "tab");
            //add the new tab next to current tab
            currentTab.after(tabElement);
            this.resize(true);
            //activate the new tab
            this.activateTab(tabElement);
        }
    };

    /**
     * Function to return true if the tab is already exists in the tab controller.
     * @private
     * @param {string} tabId - the tabId to check.
     * @returns {boolean} true - if tab exists, false- if not.
     */
    TabControl.prototype.tabExists = function(tabId) {
        var existingTabs = this.m_tabs;
        for (var i = 0; i < existingTabs.length; i++) {
            if (existingTabs[ i ].id === tabId) {
                return true;
            }
        }
        return false;
    };

    /**
     * Remove a tab from the tab control. It removes the tab and resize the tab controller
     * @param {string} tabId - the tab id to remove.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.removeTab = function(tabId) {
        //throw error if tab controller is not available
        if (!this.getRootElement().length) {
            throw new Error("TabControl.prototype.removeTab: tab controller not available");
        }
        if (typeof tabId !== "string") {
            throw new Error("TabControl.prototype.removeTab expects a string.");
        }
        var tab = null;
        var hiddenTab = null;
        var count = 0;
        var tabToActivate = null;
        var isRemoveTabActive = false;
        var activatedPrevoiusTab = false;
        var removeTab = this.getRootElement().find("#" + tabId + "tab");

        // check if the removing tab is active
        if (removeTab.hasClass("tab-active")) {
            isRemoveTabActive = true;
        }
        // remove the closing tab from controller
        removeTab.remove();
        for (var i = 0; i < this.m_tabs.length; i++) {
            tab = this.m_tabs[ i ];
            //remove the closing tab from existing array
            if (tab.id === tabId) {
                this.m_tabs.splice(i, 1);
            }
        }

        //take the first hidden tab from the right and make it visible
        var nextTabIndex = this.m_firstTabIndex + this.m_numberOfTabsShown - 1;
        hiddenTab = this.m_tabs[ nextTabIndex ];
        if (hiddenTab) {
            this.getRootElement().find("#" + hiddenTab.id + "tab").removeClass("hide-tab");
        }
        else {
            //if there is not hidden tab in the right, get it form left
            hiddenTab = this.m_tabs[ this.m_firstTabIndex - 1 ];
            if (hiddenTab) {
                this.getRootElement().find("#" + hiddenTab.id + "tab").removeClass("hide-tab");
                this.m_firstTabIndex--;
            }
        }
        // resize the tab controller
        this.resize(true);
        //check if remove tab is active, then decide for making other tab active
        if (isRemoveTabActive) {
            //decide what tab to activate after closing the tab
            count = this.m_alreadyActivatedTabs.length;
            for (var j = count - 1; j >= 0; j--) {
                tabToActivate = this.getRootElement().find("#" + this.m_alreadyActivatedTabs[ j ]);
                if (tabToActivate.length) {
                    this.activateTab(tabToActivate);
                    activatedPrevoiusTab = true;
                    break;
                }
            }
            //if there is no previous active tab found activate the first tab
            if (!activatedPrevoiusTab) {
                //check if tabs array has a tab
                if (this.m_tabs.length) {
                    var firstTab = this.getRootElement().find("#" + this.m_tabs[ 0 ].id + "tab");
                    this.activateTab(firstTab);
                }
            }
        }
    };

    /**
     * Function to select the existing tab, it activate the tab and deactivate the previous activated tab by the tabId passed.
     * and it scrolls the tab control to make the tab visible in the tab control
     * @param {string} tabId - The tab id that needs to be activated.
     * @returns {undefined} does not return anything
     */
    TabControl.prototype.selectTab = function(tabId) {
        //make the tab active
        this.activateTab($("#" + tabId + "tab"));
    };

    /**
     * Function to activate the tab and deactivate the existing activated tab.
     * @private
     * @param {jQuery} tab - The tab element to activate.
     * @returns {undefined} does not return anything
     */
    TabControl.prototype.activateTab = function(tab) {
        var previouslyActiveTab = this.getRootElement().find(".tab-active");
        //initialize the activated tab array if not exists.
        this.m_alreadyActivatedTabs = this.m_alreadyActivatedTabs || [];
        //store previously activated tab
        if (previouslyActiveTab.length) {
            var previousTab = previouslyActiveTab[ 0 ].id;
            this.m_alreadyActivatedTabs.push(previousTab);
            //deactivate the previous active tab
            this.setTabAsActive(previouslyActiveTab, false);
        }
        //activate the current tab
        this.setTabAsActive(tab, true);
    };

    /**
     * Function to render the tab controller with the available tabs.
     * @returns {string} tabControllerHTML - HTML mark up for tab controller.
     */
    TabControl.prototype.render = function() {
        return this.createTabControl();
    };

    /**
     * Function to create the tab controller with the available tabs.
     * @private
     * @returns {string} tabControllerHTML - HTML mark up for tab controller.
     */
    TabControl.prototype.createTabControl = function() {
        var tabControllerHTML = "";
        var tabs = this.m_tabs || [];
        var tabCount = tabs.length;
        var tab = null;
        var tabControllerCSS = "tabs";
        //add to the tab controller CSS if the secondary CSS has been provided
        if (this.m_secondaryCSS) {
            tabControllerCSS += " " + this.m_secondaryCSS;
        }
        // create Tab controller.
        tabControllerHTML = "<ul id='" + this.m_id + "' class='" + tabControllerCSS + "'>";
        for (var i = 0; i < tabCount; i++) {
            tab = tabs[ i ];
            // set the first tab active if no default tab is provided
            if (!this.m_defaultTab && i === 0) {
                this.setDefaultTab(tab.id);
            }
            tabControllerHTML += this.createTab(tab);
        }
        tabControllerHTML += "</ul>";
        return tabControllerHTML;
    };

    /**
     * Function to create the tab with tab name, tile and close option if applicable.
     * @private
     * @param {object} tab - The tab to be rendered.
     * @returns {string} tabHTML - HTML mark up for tab.
     */
    TabControl.prototype.createTab = function(tab) {
        var tabHTML = "<li id = '" + tab.id + "tab' title='" + tab.title + "' class = 'tab-container' style= 'width: " + this.m_minWidth + "px'>";
        tabHTML += "<span id = 'labelTab" + tab.id + "' class='tab-label'>";
        if (tab.hasIndicator) {
            tabHTML += "<span id = 'indicatorTab" + tab.id + "' class='indicator-label'>" + tab.indicatorHTML + "</span>";
        }
        tabHTML += "<span id = 'labelTextTab" + tab.id + "' class='tab-label-text'>" + tab.label + "</span>";
        if (this.getEnableLabelCount()) {
            tabHTML += "<span id = 'countTab" + tab.id + "' class='tab-count-label'>(" + tab.count + ")</span>";
        }
        tabHTML += "";
        var canClose = typeof tab.canClose === "boolean" ? tab.canClose : this.m_canCloseTabs;
        if (canClose) {
            tabHTML += "<span id = 'closeTab" + tab.id + "' class='close-tab'>&nbsp;</span>";
        }
        tabHTML += "</span></li>";
        return tabHTML;
    };

    /**
     * Function to resize the tab controller, it sets the width for the each tabs from the total width.
     * @param {boolan} resizeFromTabUpdate - resize call from the tab update(add/remove/insert).
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.resize = function(resizeFromTabUpdate) {
        //check if it already contains the tab controller
        var tabContoller = this.getRootElement();
        if (!tabContoller.length) {
            throw new Error("TabControl.prototype.resize tab controller not exists");
        }
        var tabCount = this.m_tabs.length;
        var tab = null;
        var tabElement = null;
        var tabWidth = null;
        var totalWidth = null;
        var labelElement = null;
        var closeTabWidth = null;
        var labelTextElement = null;

        //reset the index if it is not resize from tab update
        if (!resizeFromTabUpdate) {
            this.m_firstTabIndex = 0;
        }
        //reset the number of tabs shown
        this.m_numberOfTabsShown = 0;
        //calculate the tab width
        tabWidth = this.calculatedTabWidth(resizeFromTabUpdate);
        totalWidth = this.m_totalWidth;
        for (var i = 0; i < tabCount; i++) {
            tab = this.m_tabs[ i ];
            tabElement = this.getRootElement().find("#" + tab.id + "tab");
            if (tabElement.length) {
                tabElement.outerWidth(tabWidth, true);
                //get the close tab width to set the tab name width
                closeTabWidth = this.getOtherChildrenWidth(tab);
                //once width is decided for the tab set the label width to have the name with ellipses
                labelElement = tabElement.find("#labelTab" + tab.id);
                labelTextElement = tabElement.find("#labelTextTab" + tab.id);
                var totalPaddingWidth = tabElement.innerWidth() - tabElement.width();
                var totalMarginWidth = tabElement.outerWidth() - tabElement.innerWidth();
                //reducing the close tabs width
                labelElement.outerWidth(tabWidth - totalPaddingWidth - totalMarginWidth, true);
                var labelWidth = labelElement.outerWidth();
                labelTextElement.css("maxWidth", labelWidth - closeTabWidth + "px");
                // make the tab active
                if (totalWidth < this.m_minWidth) {
                    tabElement.addClass("hide-tab");
                }
                if (!tabElement.hasClass("hide-tab")) {
                    totalWidth = totalWidth - tabWidth;
                    this.m_numberOfTabsShown++;
                }
                else if (!resizeFromTabUpdate && totalWidth >= this.m_minWidth) {
                    //if total width is more than min_width show the hidden tabs in case of window resize
                    this.m_numberOfTabsShown++;
                    tabElement.removeClass("hide-tab");
                    totalWidth = totalWidth - tabWidth;
                }
            }
        }
        //in case of the the first/last element is hidden due to the scroll elements space
        //this is an edge case it happens only when removing the tab when tabs array has last two hidden elements left.
        //check if total width is greater than min_width, show last hidden tab
        if (resizeFromTabUpdate && totalWidth >= this.m_minWidth) {
            var hiddenTab = this.getRootElement().find(".hide-tab")[ 0 ];
            if (hiddenTab) {
                $(hiddenTab).removeClass("hide-tab");
                this.m_numberOfTabsShown++;
            }
        }
        //apply scroll Elements if needed
        this.applyScrollElements(resizeFromTabUpdate);
    };

    /**
     * Function calculate the total width from the parent of tab controller.
     * @private
     * @returns {number} totalWidth.
     */
    TabControl.prototype.getTotalWidth = function() {
        return this.getRootElement().parent().width();
    };

    /**
     * Function to calculate the tab width from the the total width based on the number of tabs.
     * @private
     * @param {boolan} resizeFromTabUpdate - resize call from the tab update(add/remove/insert)
     * @returns {number} calculated tab width.
     */
    TabControl.prototype.calculatedTabWidth = function(resizeFromTabUpdate) {
        //use the existing parent width for resize from tab update
        //otherwise get the width from its parent
        if (resizeFromTabUpdate) {
            this.m_totalWidth = this.m_parentWidth;
        }
        else {
            this.m_totalWidth = this.getTotalWidth();
            this.m_parentWidth = this.m_totalWidth;
        }
        var availableWidth = this.m_totalWidth / this.m_tabs.length;
        if (availableWidth >= this.m_maxWidth) {
            //The calculated tab width is larger than the max_width we define,
            //so there is enough space for all tabs, but we will limit their size to maxWidth
            this.m_displayScroller = false;
            return this.m_maxWidth;
        }
        else if (availableWidth >= this.m_minWidth) {
            //The calculated width is greater than the min_width
            //so we have enough space for all of the tabs to fit without scroll elements
            this.m_displayScroller = false;
            return availableWidth;
        }
        else {
            //The calculated width is lesser than our min_width
            //so we don't have enough space for all of the tabs, so adding a scroll elements and setting the tabs to min_width
            this.m_displayScroller = true;
            //accounting for scroll elements width by reducing it form the total width
            this.m_totalWidth -= this.m_scrollerWidth;
            //calculate the tabs width to use the total width for the tabs shown
            return this.calculateTabWidth();
        }
    };

    /**
     * Function to get the width of the children other than label(tab name).
     * @private
     * @param {Object} tab- width calculation for particular tab
     * @returns {number} close option width.
     */
    TabControl.prototype.getOtherChildrenWidth = function(tab) {
        // it gets the close options width and adds the padding/borders the tab has
        var totalChildrenWidth = 0;
        var defaultIndicatorWidth = 16;
        var defaultCountWidth = 17;

        var canClose = typeof tab.canClose === "boolean" ? tab.canClose : this.m_canCloseTabs;
        if (canClose) {
            totalChildrenWidth += this.getRootElement().find(".close-tab").outerWidth(true) + 4;
        }
        if (tab.hasIndicator) {
            var indicatorWidth = this.getRootElement().find("#indicatorTab" + tab.id).outerWidth(true);
            if (!indicatorWidth) {
                indicatorWidth += defaultIndicatorWidth;
            }
            totalChildrenWidth += indicatorWidth;
        }
        if (this.getEnableLabelCount()) {
            var countWidth = this.getRootElement().find("#countTab" + tab.id).outerWidth(true);
            if (!countWidth) {
                countWidth += defaultCountWidth;
            }
            totalChildrenWidth += countWidth;
        }
        // add padding width
        return totalChildrenWidth;
    };

    /**
     * Function to calculate tab width based on total number of tabs can be shown.
     * @private
     * @returns {number} calculated tab width.
     */
    TabControl.prototype.calculateTabWidth = function() {
        //take the total number of tabs that can be shown based on total width
        //using Math.floor to get the lowest whole number to get the tabs that can be shown
        var numberOfTabs = Math.floor(this.m_totalWidth / this.m_minWidth);
        //use the total width to calculate the width for the tabs
        return this.m_totalWidth / numberOfTabs;
    };

    /**
     * Function to apply the scroll elements  to the tab controller.
     * @private
     * @param {boolan} resizeFromTabUpdate - resize call from the tab update(add/remove/insert)
     * @returns {undefined} does not return anything
     */
    TabControl.prototype.applyScrollElements = function(resizeFromTabUpdate) {
        var leftArrow = this.getRootElement().find("#" + this.m_id + "leftArrow");
        var rightArrow = this.getRootElement().find("#" + this.m_id + "rightArrow");
        //check if the scroll elements is needed
        if (this.m_displayScroller) {
            //create the scroll elements if it does not exist
            if (!leftArrow.length) {
                leftArrow = $("<li></li>").addClass("inactive-left-arrow").attr("id", this.m_id + "leftArrow");
                this.getRootElement().prepend(leftArrow);
            }
            else if (!resizeFromTabUpdate) {
                //in a case of resize if the left arrow is activated, then in the resize again
                //it may not need to be active
                leftArrow.removeClass("active-left-arrow");
                leftArrow.addClass("inactive-left-arrow");
            }
            if (!rightArrow.length) {
                rightArrow = $("<li></li>").addClass("active-right-arrow").attr("id", this.m_id + "rightArrow");
                this.getRootElement().append(rightArrow);
            }
            else if (this.haveNextTabs()) {
                //in a case of resize if the right arrow is deactivated, then in the resize again
                //it may need to be active
                rightArrow.removeClass("inactive-right-arrow");
                rightArrow.addClass("active-right-arrow");
            }
            else {
                rightArrow.removeClass("active-right-arrow");
                rightArrow.addClass("inactive-right-arrow");
            }

        }
        else {
            //remove scroll elements if it is not needed
            leftArrow.remove();
            rightArrow.remove();
        }
    };

    /**
     * Function to scroll a tab controller to the first index provided
     * and displays the number of tabs shown
     * @private
     * @param {number} firstIndex - the starting index of the tab
     * @returns {undefined} does not return anything
     */
    TabControl.prototype.scrollTabs = function(firstIndex) {
        //calculate the last index to be displayed
        var lastIndex = firstIndex + this.m_numberOfTabsShown;
        var tabs = this.m_tabs;
        var tab = null;
        var leftArrow = null;
        var rightArrow = null;
        for (var i = 0; i < tabs.length; i++) {
            tab = tabs[ i ];
            // check if index is in between first and last index
            if (i >= firstIndex && i < lastIndex) {
                this.getRootElement().find("#" + tab.id + "tab").removeClass("hide-tab");
            }
            else {
                this.getRootElement().find("#" + tab.id + "tab").addClass("hide-tab");
            }
        }
        //activate or deactivate the left arrow if tabs are pushed
        leftArrow = this.getRootElement().find("#" + this.m_id + "leftArrow");
        //activate the left arrow if it reaches first index
        if (firstIndex > 0) {
            leftArrow.addClass("active-left-arrow");
            leftArrow.removeClass("inactive-left-arrow");
        }
        else {
            leftArrow.addClass("inactive-left-arrow");
            leftArrow.removeClass("active-left-arrow");
        }
        //activate or deactivate the right arrow when elements are pushed
        rightArrow = this.getRootElement().find("#" + this.m_id + "rightArrow");
        //deactivate the right arrow when it reaches the last tab
        if (lastIndex === this.m_tabs.length) {
            rightArrow.addClass("inactive-right-arrow");
            rightArrow.removeClass("active-right-arrow");
        }
        else {
            rightArrow.addClass("active-right-arrow");
            rightArrow.removeClass("inactive-right-arrow");
        }
    };

    /**
     * Function to perform on next click(right arrow) operation.
     * @private
     * it shows the first hidden tab in the right and hides the first displayed tab
     * @returns {undefined} does not return anything
     */
    TabControl.prototype.scrollRight = function() {
        var tab = null;
        var tabs = this.m_tabs;
        var firstIndex = this.m_firstTabIndex;
        var nextTabIndex = firstIndex + this.m_numberOfTabsShown;
        var leftArrow = null;
        var rightArrow = null;
        for (var i = 0; i < tabs.length; i++) {
            tab = tabs[ i ];
            // check if index is first element
            if (i === firstIndex) {
                this.getRootElement().find("#" + tab.id + "tab").addClass("hide-tab");
                //increment the index
                this.m_firstTabIndex++;
                //activate the left scroll arrow
                leftArrow = this.getRootElement().find("#" + this.m_id + "leftArrow");
                leftArrow.removeClass("inactive-left-arrow");
                leftArrow.addClass("active-left-arrow");
            }
            else if (i === nextTabIndex) {
                //show the first hidden tab
                this.getRootElement().find("#" + tab.id + "tab").removeClass("hide-tab");
            }
        }
        //if the next tab is last element is the last in the list, deactivate the right arrow
        if (nextTabIndex === this.m_tabs.length - 1) {
            rightArrow = this.getRootElement().find("#" + this.m_id + "rightArrow");
            rightArrow.addClass("inactive-right-arrow");
            rightArrow.removeClass("active-right-arrow");
        }

    };

    /**
     * Function to perform on previous click(left arrow) operation.
     * it shows the first hidden tab in the left and hides the last displayed tab
     * @private
     * @returns {undefined} does not return anything
     */
    TabControl.prototype.scrollLeft = function() {
        var tab = null;
        var tabs = this.m_tabs;
        //gets the first previous index to show the hidden tab in the left
        var prevoiusIndex = this.m_firstTabIndex - 1;
        //gets the last index to hide the last tab
        var lastTabIndex = this.m_firstTabIndex + this.m_numberOfTabsShown - 1;
        var leftArrow = null;
        var rightArrow = null;
        for (var i = 0; i < tabs.length; i++) {
            tab = tabs[ i ];
            //check if index last tab index, then hide the tab
            if (i === lastTabIndex) {
                this.getRootElement().find("#" + tab.id + "tab").addClass("hide-tab");
                rightArrow = this.getRootElement().find("#" + this.m_id + "rightArrow");
                rightArrow.removeClass("inactive-right-arrow");
                rightArrow.addClass("active-right-arrow");
            }
            else if (i === prevoiusIndex) {
                //hide the first hidden tab and decrement the first index
                this.getRootElement().find("#" + tab.id + "tab").removeClass("hide-tab");
                this.m_firstTabIndex--;
            }
        }
        //check if index is zero, deactivate the left arrow since there is no hidden tab in the left.
        if (prevoiusIndex === 0) {
            leftArrow = this.getRootElement().find("#" + this.m_id + "leftArrow");
            leftArrow.addClass("inactive-left-arrow");
            leftArrow.removeClass("active-left-arrow");
        }
    };

    /**
     *Function to return true if next tabs exists, currently hidden
     * @private
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.haveNextTabs = function() {
        //calculate the last index from tabs array
        var lastIndex = this.m_tabs.length - 1;
        //get the last element and check if it is hidden
        var lastTab = this.getRootElement().find("#" + this.m_tabs[ lastIndex ].id + "tab");
        return lastTab.hasClass("hide-tab");
    };

    /**
     * Function to update the tabs title, it should be called with valid tab object with the changed title
     * @param {Object} tab - the tab object.This must be of the following form.
     * {
	 * 		id: 'tabId'
	 * 		label: 'Label',
	 * 		title: 'title'
	 * 		onSelect: function() { ... },
	 * 		onDeselect: function() { ... },
	 * 		onClose: function() { ... },
	 * 		canClose: boolean
	 * }
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.updateTitle = function(tab) {
        //throw error if tab controller is not available
        if (!this.getRootElement().length) {
            throw new Error("TabControl.prototype.updateTitle: tab controller not available");
        }
        //throw error if tab does not exists
        if (!this.tabExists(tab.id)) {
            throw new Error("TabControl.prototype.updateTitle: tab does not exists");
        }
        //validate the tab object
        this.validateTab(tab);
        //get the tab object from root element
        var tabElement = this.getRootElement().find("#" + tab.id + "tab");
        //change the title
        $(tabElement).attr("title", tab.title);
    };

    /**
     * Function to have sorting option for the tabs.
     * @private
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.applyTabSorting = function() {
        var self = this;
        this.getRootElement().sortable({
            axis: "x",
            appendTo: "#" + this.m_id,
            containment: "parent",
            items: ".tab-container:not(.hide-tab)",
            delay: 100,
            distance: 5,
            forceHelperSize: true,
            forcePlaceholderSize: true,
            scroll: false,
            tolerance: "pointer",
            start: function(event, ui) {
                //set the height and width for the scroll elements on sorting
                ui.placeholder.height(28);
                ui.placeholder.width(ui.item[ 0 ].scrollWidth - 2);
            },
            stop: function(event, ui) {
                //removing the text tab from the id,
                //tab id is suffixed with the text 'tab', it needs to be removed.Example:tab1tab will be tab1
                var sortedTabId = ui.item[ 0 ].id.slice(0, -3);
                //re arrange the tabs array after sorting
                self.reArrangeTabs(sortedTabId);
                //pass the sorted array to callback
                if (self.m_onSortCallback) {
                    self.m_onSortCallback(self.m_tabs);
                }
            },
            placeholder: "tab-placeholder"
        });
        this.getRootElement().disableSelection();
    };

    /**
     * Function to re arrange the tabs array in case of sorting changes the index
     * @private
     * @param {string} sortedTabId - the tab id for the element which is being sorted
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.reArrangeTabs = function(sortedTabId) {
        var tab = null;
        var tabElement = null;
        var tabElementId = null;
        //Grab all of the tabs
        var sortedTabs = this.getRootElement().find(".tab-container");
        //remove the sorted tab from the existing array
        for (var i = 0; i < this.m_tabs.length; i++) {
            tab = this.m_tabs[ i ];
            if (tab.id === sortedTabId) {
                this.m_tabs.splice(i, 1);
                break;
            }
        }
        //find the sorted tab array in the sorted array
        for (var j = 0; j < sortedTabs.length; j++) {
            tabElement = sortedTabs[ j ];
            //removing the text tab from the id
            tabElementId = tabElement.id.slice(0, -3);
            if (tabElementId === sortedTabId) {
                //insert the tab into the tabs array in the index that matches the sorted tab id in the sortedTabs array
                this.m_tabs.splice(j, 0, tab);
                break;
            }
        }
    };

    /**
     * Activate or deactivate a tabs visuals.As well execute the callback functions on tab activate and deactivate
     * @private
     * @param {jQuery} tabElement - The tab element which needs to be activated or deactivated
     * @param {boolean} activateInd A boolean flag to indicate if the tab element should have active css class or not
     * @returns {undefined} This function does not return a value
     */
    TabControl.prototype.setTabAsActive = function(tabElement, activateInd) {
        //get the tab object
        var tabId = tabElement[ 0 ].id.slice(0, -3);
        var tab = this.getTabById(tabId);
        //check if it is to activate tab
        if (activateInd) {
            tabElement.addClass("tab-active");
            this.m_currentActiveTab = tabId;
            //scroll the tabs to make activated visible in case if it is hidden
            this.makeTabVisible(tabId);
            //check if the current tab has a onSelectCallback function
            if (tab && tab.onSelect) {
                tab.onSelect(tab);
            }
            else if (this.m_onSelectCallback) {
                //if there is no callback set in the tab level then call the callback function form the tab control
                this.m_onSelectCallback(tab);
            }
        }
        else {
            tabElement.removeClass("tab-active");
            //check if the current tab has a onDeselectCallback function
            if (tab && tab.onDeselect) {
                tab.onDeselect(tab);
            }
            else if (this.m_onDeselectCallback) {
                //if there is no callback set in the tab level then call the callback function form the tab control
                this.m_onDeselectCallback(tab);
            }
        }
    };

    /**
     * make the tab visible if it is hidden in the tabControl
     * @private
     * @param {string} tabId - tab id
     * @returns {undefined} does not return anything.
     */
    TabControl.prototype.makeTabVisible = function(tabId) {
        var currentIndex = 0;
        var tab = null;
        var lastIndex = this.m_firstTabIndex + this.m_numberOfTabsShown - 1;
        var totalTabs = this.m_tabs.length;
        for (var i = 0; i < this.m_tabs.length; i++) {
            tab = this.m_tabs[ i ];
            if (tab.id === tabId) {
                currentIndex = i;
                break;
            }
        }
        //check if the selecting tab is hidden
        if (this.m_firstTabIndex > 0 && currentIndex < this.m_firstTabIndex) {
            //scroll to the tabs to show the selected tab
            this.scrollTabs(currentIndex);
            this.m_firstTabIndex = currentIndex;
        }
        else if (lastIndex < totalTabs - 1 && currentIndex > lastIndex) {
            this.m_firstTabIndex = currentIndex - this.m_numberOfTabsShown + 1;
            this.scrollTabs(this.m_firstTabIndex);
        }
    };

    /**
     * Function to get the tab from the tabId passed
     * @private
     * @param {string} tabId - tab id
     * @returns {object} tab - tab object.
     */
    TabControl.prototype.getTabById = function(tabId) {
        var existingTabs = this.m_tabs;
        var tab = null;
        for (var i = 0; i < existingTabs.length; i++) {
            tab = existingTabs[ i ];
            if (tab.id === tabId) {
                return tab;
            }
        }
        return null;
    };

    /**
     * Attaches the necessary events to the Tab controller. This function must be called after the tab controller
     * mark up exists on the DOM.
     * @private
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.attachEvents = function() {
        var self = this;
        var rootElement = this.getRootElement();
        //event for right arrow(scroll element) click
        rootElement.on("click.mpageui", ".active-right-arrow", function() {
            self.scrollRight($(this));
        });
        //event for left arrow(scroll element) click
        rootElement.on("click.mpageui", ".active-left-arrow", function() {
            self.scrollLeft($(this));
        });
        // adding click event for the tabs
        rootElement.on("click.mpageui", ".tab-container", function(event) {
            // return if the element clicked is close option
            if ($(event.target).hasClass("close-tab")) {
                return;
            }
            self.activateTab($(this));
        });

        // adding click event for close tab
        rootElement.on("click.mpageui", ".close-tab", function() {
            var closingTab = this.id;
            //removing prefixed text(closetab) to identify the tab id
            var tabId = closingTab.slice(8);
            var tab = self.getTabById(tabId);
            //remove tab
            self.removeTab(tabId);
            //check to see the tab has its own call back function
            if (tab && tab.onClose) {
                tab.onClose(tab);
            }
            else if (self.m_onCloseCallback) {
                //if tabs as no call back, then execute the tab control call back
                self.m_onCloseCallback(tab);
            }
        });

        return this;
    };

    /**
     * Finalizes the Tab controller. This function must be called after the tab controller
     * mark up exists on the DOM.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    TabControl.prototype.finalize = function() {
        this.attachEvents();
        // make the sorting option available if it is opted for
        if (this.m_canSortTabs) {
            this.applyTabSorting();
        }
        // Call resize to resize the tab controller.
        this.resize();
        //make the default tab active
        var defaultTab = this.getRootElement().find("#" + this.m_defaultTab + "tab");
        if (defaultTab.length) {
            this.activateTab(defaultTab);
        }
        else if (this.m_tabs.length > 0) {
            //make the first tab active
            var firstElement = this.getRootElement().find("#" + this.m_tabs[ 0 ].id + "tab");
            this.activateTab(firstElement);
        }
        this.m_tabControlFinalized = true;
        return this;
    };

    return TabControl;
})();

MPageUI.PrimaryTabControl = (function() {
    /**
     * The PrimaryTabControl class.
     * @returns {MPageUI.PrimaryTabControl} Returns self to allow chaining.
     * @constructor
     */
    var PrimaryTabControl = function() {
        this.base();
        //the minimum size of the tab
        this.m_minWidth = 140;
        //the maximum size of the tab
        this.m_maxWidth = 250;
        return this;
    };

    MPageUI.extend(PrimaryTabControl, MPageUI.TabControl);

    return PrimaryTabControl;
})();

MPageUI.SecondaryTabControl = (function() {
    /**
     * The SecondaryTabControl class.
     * @returns {MPageUI.SecondaryTabControl} Returns self to allow chaining.
     * @constructor
     */
    var SecondaryTabControl = function() {
        this.base();
        //the minimum size of the tab
        this.m_minWidth = 120;
        //the maximum size of the tab
        this.m_maxWidth = 200;
        //to store the CSS class name to set the specific styles for the tab control
        this.m_secondaryCSS = "secondary-tab";
        return this;
    };
    MPageUI.extend(SecondaryTabControl, MPageUI.TabControl);

    return SecondaryTabControl;
})();

MPageUI.AddTabControl = (function() {
    /**
     * The AddTabControl class.
     * @returns {MPageUI.AddTabControl} Returns self to allow chaining.
     * @constructor
     */
    var AddTabControl = function() {
        //flag to have the add tab functionality
        this.m_displayAddTab = true;
        //callback function for clicking the add tab option
        this.m_onAddTabCallback = null;
        return this;
    };

    MPageUI.extend(AddTabControl, MPageUI.PrimaryTabControl);

    /**
     * Function to set the call back for add tab option.
     * @param {function} callback - The callback function for the add tab.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {MPageUI.TabControl} Returns self to allow chaining.
     */
    AddTabControl.prototype.setOnAddTabCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("AddTabControl.prototype.setOnAddTabCallback expects a function.");
        }
        this.m_onAddTabCallback = callback;
        return this;
    };

    /**
     * Override the MPageUI.PrimaryTabControl.render function to create tab control with the add tab option
     * @returns {string} tabControlHTML - HTML mark up for add tab control.
     */
    AddTabControl.prototype.render = function() {
        var tabControlHTML = this.createTabControl();
        tabControlHTML += this.createAddTab();
        return tabControlHTML;
    };

    /**
     * Function to create add tab option of it is opted for.
     * @private
     * @returns {string} addTabHTML - HTML mark up for add tab.
     */
    AddTabControl.prototype.createAddTab = function() {
        var addTabHTML = "";
        // Check to see if add tab (+) needs to be displayed.
        if (this.m_displayAddTab) {
            addTabHTML = "<div id ='" + this.m_id + "_addTab' class= 'add-tab-wrapper'> <span class= 'add-tab'></span> </div>";
        }
        return addTabHTML;
    };

    /**
     * Attaches the necessary events to the Tab controller. This function must be called after the tab controller
     * mark up exists on the DOM.
     * @private
     * @returns {MPageUI.AddTabControl} Returns self to allow chaining.
     */
    AddTabControl.prototype.attachAddTabEvent = function() {
        var self = this;
        //event for add tab click
        $("#" + this.m_id + "_addTab").on("click.mpageui", function() {
            self.m_onAddTabCallback();
        });
        return this;
    };

    /**
     * Override the MPageUI.PrimaryTabControl.finalize function to Finalizes the AddTab controller. This function must be called after the tab controller
     * mark up exists on the DOM.
     * @returns {MPageUI.AddTabControl} Returns self to allow chaining.
     */
    AddTabControl.prototype.finalize = function() {
        //attaches the events from parent(PrimaryTabControl)
        this.attachEvents();
        this.attachAddTabEvent();
        // make the sorting option if it is opted for
        if (this.m_canSortTabs) {
            this.applyTabSorting();
        }
        // Call resize to resize the tab controller.
        this.resize();
        //make the default tab active
        var defaultTab = this.getRootElement().find("#" + this.m_defaultTab + "tab");
        if (defaultTab.length) {
            this.activateTab(defaultTab);
        }
        else if (this.m_tabs.length > 0) {
            //make the first tab active
            var firstElement = this.getRootElement().find("#" + this.m_tabs[ 0 ].id + "tab");
            this.activateTab(firstElement);
        }
        this.m_tabControlFinalized = true;
        return this;
    };

    /**
     * Override the MPageUI.PrimaryTabControl.calculateTotalWidth Function to calculate the total width from the parent of tab controller.
     * @private
     * @returns {number} totalWidth.
     */
    AddTabControl.prototype.getTotalWidth = function() {
        var parentWidth = this.getRootElement().parent().width();
        // reduce width for the add tab
        if (this.m_displayAddTab) {
            var addTabWidth = $("#" + this.m_id + "_addTab").outerWidth(true);
            parentWidth -= addTabWidth;
        }
        return parentWidth;
    };

    return AddTabControl;
})();

MPageUI.ViewpointTabControl = (function() {
    /**
     * The ViewpointTabControl class.
     * @returns {MPageUI.ViewpointTabControl} Returns self to allow chaining.
     * @constructor
     */
    var ViewpointTabControl = function() {
        this.base();
        return this;
    };
    MPageUI.extend(ViewpointTabControl, MPageUI.AddTabControl);

    /**
     * overrides the parent removeTab function. It removes the tab and resize the tab controller
     * @param {string} tabId - the tab id to remove.
     * @param {boolean} doNotActivatePreviousTab - to decide whether to activate the previous tab or not.
     * @throws {Error} An error indicating that the parameter is an invalid type.
     * @returns {undefined} does not return anything.
     */
    ViewpointTabControl.prototype.removeTab = function(tabId, doNotActivatePreviousTab) {
        //throw error if tab controller is not available
        if (!this.getRootElement().length) {
            throw new Error("TabControl.prototype.removeTab: tab controller not available");
        }
        if (typeof tabId !== "string") {
            throw new Error("TabControl.prototype.removeTab expects a string.");
        }
        var tab = null;
        var hiddenTab = null;
        var count = 0;
        var tabToActivate = null;
        var isRemoveTabActive = false;
        var activatedPrevoiusTab = false;
        var removeTab = this.getRootElement().find("#" + tabId + "tab");

        // check if the removing tab is active
        if (removeTab.hasClass("tab-active")) {
            isRemoveTabActive = true;
        }
        // remove the closing tab from controller
        removeTab.remove();
        for (var i = 0; i < this.m_tabs.length; i++) {
            tab = this.m_tabs[ i ];
            //remove the closing tab from existing array
            if (tab.id === tabId) {
                this.m_tabs.splice(i, 1);
            }
        }

        //take the first hidden tab from the right and make it visible
        var nextTabIndex = this.m_firstTabIndex + this.m_numberOfTabsShown - 1;
        hiddenTab = this.m_tabs[ nextTabIndex ];
        if (hiddenTab) {
            this.getRootElement().find("#" + hiddenTab.id + "tab").removeClass("hide-tab");
        }
        else {
            //if there is not hidden tab in the right, get it form left
            hiddenTab = this.m_tabs[ this.m_firstTabIndex - 1 ];
            if (hiddenTab) {
                this.getRootElement().find("#" + hiddenTab.id + "tab").removeClass("hide-tab");
                this.m_firstTabIndex--;
            }
        }
        // resize the tab controller
        this.resize(true);
        //check if remove tab is active, then decide for making other tab active
        if (isRemoveTabActive && !doNotActivatePreviousTab) {
            //decide what tab to activate after closing the tab
            count = this.m_alreadyActivatedTabs.length;
            for (var j = count - 1; j >= 0; j--) {
                tabToActivate = this.getRootElement().find("#" + this.m_alreadyActivatedTabs[ j ]);
                if (tabToActivate.length) {
                    this.activateTab(tabToActivate);
                    activatedPrevoiusTab = true;
                    break;
                }
            }
            //if there is no previous active tab found activate the first tab
            if (!activatedPrevoiusTab) {
                //check if tabs array has a tab
                if (this.m_tabs.length) {
                    var firstTab = this.getRootElement().find("#" + this.m_tabs[ 0 ].id + "tab");
                    this.activateTab(firstTab);
                }
            }
        }
    };

    return ViewpointTabControl;
})();

/* eslint-disable no-underscore-dangle */
/* global MPageUI */
/* global MPageTooltip */

MPageUI.TABLE_OPTIONS = {
    HIGHLIGHT: {
        NONE: "",
        ROW: "table-hover",
        CELL: "table-hover-cell"
    },
    SORT: {
        ASCENDING: -1,
        DESCENDING: 1,
        NONE: 0
    },
    SELECT: {
        NONE: 0,
        SINGLE_ROW: 1,
        MULTI_ROW: 2
    }
};
MPageUI.Table = (function() {
    /**
     * The Table class.
     * The Table is to be used for html table functionality and extensions upon the table. The API provides a standard
     * markup system and predefined styles to ensure consistency.
     * @constructor
     */
    var Table = function() {
        this.base();
        this.m_columns = null;
        this.m_data = null;
        this.m_groupingData = null;
        this.m_recordHash = null;
        this.m_selection = null;
        this.m_maxHeight = 200;
        this.m_options = {
            columns: {
                separators: true
            },
            highlight: MPageUI.TABLE_OPTIONS.HIGHLIGHT.NONE,
            namespace: "",
            rows: {
                striped: true
            },
            show: {
                header: true
            },
            select: MPageUI.TABLE_OPTIONS.SELECT.NONE
        };
        this.m_tableHover = null;
        //Callbacks
        this.m_rowClickCallback = null;
        this.m_cellClickCallback = null;
        this.m_columnHeaderClickCallback = null;
        this.m_groupClickCallback = null;
        this.m_hoverCallBack = null;

        //Selection range
        this.m_lastClickedRecord = null;
    };
    MPageUI.extend(Table, MPageUI.UIComponent);

    /**
     * Returns the list of column configurations for the table.
     * @returns {Array<object>} The list of column configurations for the table.
     */
    Table.prototype.getColumns = function() {
        if (!this.m_columns) {
            this.m_columns = [];
        }
        return this.m_columns;
    };

    /**
     * Sets the column data.
     * @param {Array<object>} columns - The column data.
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setColumns = function(columns) {
        this.m_columns = columns;
        return this;
    };

    /**
     * Checks if a given column field is sortable
     * @throws {Error} Throws an error if the parameter is not a string.
     * @param  {string}  columnId - The id of the column being tested.
     * @returns {boolean} true/false if the column specified is sortable
     * @private
     */
    Table.prototype.isColumnSortable = function(columnId) {
        if (typeof columnId !== "string") {
            throw new Error("MPageUI.Table.prototype.isColumnSortable expects columnId to be a string");
        }
        var columns = this.getColumns();
        var columnCount = columns.length;
        for (var i = 0; i < columnCount; i++) {
            var column = columns[ i ];
            //Find the column with the requested id
            if (column.id === columnId && column.sortOptions) {
                return true;
            }
        }
        return false;
    };
    /**
     * Toggles the sort direction for a given column
     * if the current sort direction is DESCENDING the function will set it to be ASCENDING.
     * if the current sort direction is ASCENDING the function will set it to be DESCENDING.
     * @returns {undefined} Returns nothing
     * @private
     */
    Table.prototype.toggleSortDirection = function() {
        this.m_currentSortDirection *= -1;
    };

    /**
     * Gets the sort class based on the sort direction
     * ASCENDING will return "sort-asc"
     * DESCENDING will return "sort-desc"
     * @param  {Number} sortDirection 1 - DESCENDING
     *                                0 - NONE
     *                                -1 - ASCENDING
     * @returns {String}               sort class
     */
    Table.prototype.getSortClass = function(sortDirection) {
        switch (sortDirection) {
            case MPageUI.TABLE_OPTIONS.SORT.ASCENDING:
                return "sort-asc";
            case MPageUI.TABLE_OPTIONS.SORT.DESCENDING:
                return "sort-desc";
            default:
                return "";
        }
    };

    /**
     * Sets the data that the table is to render. The table can render a list of records or a list of groups. Groups
     * must be a container of records or groups (nested) and provide a label.
     * @param {Object} data - The data to be rendered by the table. This must be of the form
     * {
	 * 		groups: [
	 * 			label: "Group Label",
	 * 			records: [ ... ],
	 * 			groups: [ ... ]
	 * 		],
	 * }
     * or
     * {
	 * 		records: [
	 * 			{ ... },
	 * 			{ ... }
	 * 		],
	 * }
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setData = function(data) {
        this.validateData(data);
        this.m_data = data;
        this.resetSelection();
        //If grouping is already applied, process that now
        this.processGroups();
        this.processData();
        this.refresh();
        return this;
    };

    /**
     * Processes the data provided to the table. This will hash the records, giving them a unique id that can link
     * the markup back to the respective record.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.processData = function() {
        var data = this.m_data;
        var self = this;
        var groupCounter = 0;
        var recordCounter = 0;
        var recordHash = null;
        this.clearRecordHash();
        recordHash = this.getRecordHash();
        /**
         * Recursively processes through the table data that was provided.
         * @param {object} node - The current node being processed.
         * @param {number} depth - The current depth in the recursion.
         * @returns {undefined} Returns nothing
         */
        function recursiveProcess(node, depth) {
            var records = node.records;
            var groups = node.groups;
            var recordCount = 0;
            var recordHashKey = null;
            var groupHashKey = null;
            var groupCount = 0;
            var record = null;
            var group = null;
            var i = 0;
            if (records && records.length) {
                recordCount = records.length;
                for (i = 0; i < recordCount; i++) {
                    recordHashKey = "record_" + (recordCounter++);
                    record = records[ i ];
                    record._MPageUI = {
                        recordHash: recordHashKey,
                        selected: false,
                        rowReference: (self.m_id + "_" + recordHashKey)
                    };
                    recordHash[ record._MPageUI.recordHash ] = record;
                }
            }
            if (groups && groups.length) {
                groupCount = groups.length;
                for (i = 0; i < groupCount; i++) {
                    group = groups[ i ];
                    //If the expanded attribute is not present, default to true
                    if (typeof group.expanded === "undefined") {
                        group.expanded = true;
                    }
                    groupHashKey = ((typeof group.id !== "undefined") ? (group.id + "") : ("group_" + (groupCounter++)));
                    group._MPageUI = {
                        depth: depth,
                        groupHash: groupHashKey,
                        groupReference: (self.m_id + "_" + groupHashKey)
                    };
                    recordHash[ group._MPageUI.groupHash ] = group;
                    recursiveProcess(group, depth + 1);
                }
            }
        }

        recursiveProcess(data, 0);
    };

    /**
     * A quick form of grouping that takes a set of group parameters and organizes the table records into groups based
     * on qualifying fields. The groupData must be of the form.
     * [
     *        { field: "field1", display: "field1", expanded: true|false },
     *        { field: "field2", display: "field2", expanded: true|false },
     *        ...
     *        { field: "fieldN", display: "fieldN", expanded: true|false }
     * ]
     * Where field is the field on which the group is created and
     * display is the field in the record which populates the header of the group and
     * expanded is the default expanded state of groups created on that field.
     * @param {Array<object>} groupData - The group data which will organize the table records into groups.
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.setGrouping = function(groupData) {
        this.m_groupingData = groupData;
        if (!this.m_data) {
            return;
        }
        //Reset necessary selection tracking
        this.resetSelection();
        this.processGroups();
        this.processData();
        this.refresh();
    };

    /**
     * Resets the variables that are used to track table selection data.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.resetSelection = function() {
        this.m_selection = null;
        this.m_lastClickedRecord = null;
    };

    /**
     * Processes the table data into groups based on the grouping parameters specified when calling the setGrouping
     * function. Once the existing data has been processed into groups, the internal data will be overwritten.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.processGroups = function() {
        if (!this.m_data) {
            return;
        }
        var groupData = this.m_groupingData;
        if (!groupData) {
            return;
        }
        var records = this.getAllRecords();
        var recordCount = records.length;
        var data = {};
        var groupHash = {};

        /**
         * Recursively traverse down the group chain and build the group data structure with each record
         * in its corresponding group.
         * @param {object} record - The record being placed into the structure.
         * @param {number} depth - How deep in the group tree the recursion is.
         * @param {object} parent - The parent data object keeping track of assigned groups.
         * @param {object} currentGroup - The current group in the group data tree.
         * @returns {undefined} Returns nothing.
         */
        function recursiveGroup(record, depth, parent, currentGroup) {
            //If the bottom has been reached (we must now process records)
            if (depth >= groupData.length) {
                if (!currentGroup.records) {
                    currentGroup.records = [];
                }
                currentGroup.records.push(record);
                return;
            }
            var groupField = groupData[ depth ].field;
            var groupDisplayField = groupData[ depth ].display;
            var grouping = record[ groupField ];
            var groupExpanded = (typeof groupData[ depth ].expanded !== "undefined") ? groupData[ depth ].expanded : true;
            //We have not encountered a group for the hash of the record
            if (!parent[ grouping ]) {
                if (!currentGroup.groups) {
                    currentGroup.groups = [];
                }
                //Add the new group to the hierachy of groups
                currentGroup.groups.push({
                    label: record[ groupDisplayField ],
                    expanded: groupExpanded
                });
                parent[ grouping ] = {};
                parent[ grouping ]._groupRef = currentGroup.groups.length - 1;
            }
            recursiveGroup(record, depth + 1, parent[ grouping ], currentGroup.groups[ parent[ grouping ]._groupRef ]);
        }

        //Iterate over each record and find its place in the group hierarchy
        for (var i = 0; i < recordCount; i++) {
            recursiveGroup(records[ i ], 0, groupHash, data);
        }
        //Overwrite existing data with newly grouped data
        this.m_data = data;
    };

    /**
     * Retrieves the record hash object.
     * @private
     * @returns {Object<string, object>} The mapping of record id strings to record objects.
     */
    Table.prototype.getRecordHash = function() {
        if (!this.m_recordHash) {
            this.m_recordHash = {};
        }
        return this.m_recordHash;
    };

    /**
     * Performs validation on the data provided to the table.
     * @param {object} data - The data provided to the table.
     * @throws {Error} Throws an error if the following conditions are not met
     * 1). The data is not an object
     * 2). The data does not provide groups or records
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.validateData = function(data) {
        if (typeof data !== "object") {
            throw new Error("MPageUI.Table.prototype.validateData expects an object");
        }
        if (!data.groups && !data.records) {
            throw new Error("MPageUI.Table.prototype.validateData expects the data to have groups or records");
        }
    };

    /**
     * Gets the group by a group id
     * @param {String} groupId the id of a group
     * @returns {null | object} Returns the group by id or null if no group was found
     */
    Table.prototype.getGroupById = function(groupId) {
        if (typeof groupId !== "string") {
            throw new Error("MPageUI.Table.prototype.getGroupById expects a string");
        }
        /**
         * Recursively traverses the table data and finds all groups.
         * @param {object} node - The current node being processed recursively.
         * @returns {null | object} Returns null or the group that was found.
         */
        function recursiveGroupFind(node) {
            var groups = node.groups;
            var groupCount = 0;
            var i = 0;
            if (groups && groups.length) {
                groupCount = groups.length;
                for (i = 0; i < groupCount; i++) {
                    if (groups[ i ].id === groupId) {
                        return groups[ i ];
                    }
                    var foundGroup = recursiveGroupFind(groups[ i ]);
                    if (foundGroup) {
                        return foundGroup;
                    }
                }
            }
            return null;
        }

        return recursiveGroupFind(this.m_data);
    };
    /**
     * Retrieves a flattened array of all records that reside in the table. Recards are leaf nodes.
     * @returns {Array<object>} The flattened array of all records residing in the table.
     */
    Table.prototype.getAllRecords = function() {
        var allRecords = [];
        if (!this.m_data) {
            return allRecords;
        }
        /**
         * Recursively traverses the table data and finds all records (leaf nodes).
         * @param {object} node - The current node being processed recursively.
         * @returns {undefined} Returns nothing.
         */
        function recursiveRecordFind(node) {
            var groups = node.groups;
            var records = node.records;
            var groupCount = 0;
            var recordCount = 0;
            var i = 0;
            if (records && records.length) {
                recordCount = records.length;
                for (i = 0; i < recordCount; i++) {
                    allRecords.push(records[ i ]);
                }
            }
            if (groups && groups.length) {
                groupCount = groups.length;
                for (i = 0; i < groupCount; i++) {
                    recursiveRecordFind(groups[ i ]);
                }
            }
        }

        recursiveRecordFind(this.m_data);
        return allRecords;
    };

    /**
     * Clears the record hash.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.clearRecordHash = function() {
        this.m_recordHash = null;
    };

    /**
     * Utility function to sort the table with specified options.
     * {
	 * 		column: { id: "columnId", direction: MPageUI.TABLE_OPTIONS.SORT.ASCENDING | MPageUI.TABLE_OPTIONS.SORT.DESCENDING }
	 * }
     * If sorting by column and the column is already being sorted and no
     * direction is specified, the table will toggle the sort direction. If
     * a direction is specified, the table will honor the direction. If the
     * column is not currently sorted, the table will honor the direction if specified,
     * otherwise, it will use the default sort direction as specified in the
     * column's primary sort options.
     * @param {Object} sortOptions - The sort options object. Currently only
     * supports sorting by column.
     *
     *    column:{
	 *        id: "...", [required]
	 *        direction: MPagesUI.TABLE_OPTIONS.SORT.[ASCENDING|DESCENDING] [optional]
	 *    }
     *
     * @returns {Undefined} Returns nothing.
     */
    Table.prototype.sortBy = function(sortOptions) {
        if (typeof sortOptions !== "object") {
            throw new Error("MPageUI.Table.prototype.sortBy the parameter is not an object");
        }
        if (sortOptions.column) {
            var columnId = sortOptions.column.id;
            var direction = sortOptions.column.direction || null;
            //Validate that the column is sortable meaning that sortOptions are available
            if (!this.isColumnSortable(columnId)) {
                return;
            }
            //If already sorted by this column
            if (this.m_currentlySortedColumnId === columnId) {
                if (direction !== null) {
                    this.m_currentSortDirection = direction;
                }
                else {
                    this.toggleSortDirection();
                }
            }
            else {
                //Currently not sorted by this column
                //If available use the direction from the sort options, otherwise use the primarysort direction defined on the column
                if (direction !== null) {
                    this.m_currentSortDirection = direction;
                }
                else {
                    var columnSortOptions = this.getColumnSortOptions(columnId);
                    this.m_currentSortDirection = columnSortOptions.primary.direction;
                }
            }
            this.m_currentlySortedColumnId = columnId;
        }
        this.refresh();
    };
    /**
     * Sets the configurable options for the table. All customization options are specified via this function. The
     * options must be of the form
     * {
	 * 		columns: {
	 *			separators: true | false
	 * 		},
	 *		highlight: MPageUI.TABLE_OPTIONS.HIGHLIGHT.[ROW|CELL],
	 *		namespace: "",
	 *		rows: {
	 *			striped: true | false
	 *		},
	 *		show: {
	 *			header: true | false
	 *		},
	 *		sort: {
	 *			sortable: true | false,
	 *			sortDirection: MPageUI.TABLE_OPTIONS.[ASCENDING|DESCENDING|NONE]
	 *		},
	 * }
     * @throws {Error} If the parameter is not an object
     * @param {object} options - The customization configuration object (see above).
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setOptions = function(options) {
        if (typeof options !== "object") {
            throw new Error("MPageUI.Table.prototype.setOptions the parameter is not an object");
        }
        var currentOptions = this.m_options;
        //Column options
        if (options.columns) {
            var columnOptions = currentOptions.columns;
            columnOptions.separators = (typeof options.columns.separators !== "undefined") ?
                options.columns.separators : columnOptions.separators;
        }
        //Highlight option
        if (options.highlight) {
            currentOptions.highlight = (typeof options.highlight !== "string") ? currentOptions.highlight : options.highlight;
        }
        //Row Options
        if (options.rows) {
            var rowOptions = currentOptions.rows;
            //Striped
            rowOptions.striped = (typeof options.rows.striped !== "undefined") ?
                options.rows.striped : rowOptions.striped;
        }
        //Show Options
        if (options.show) {
            var showOptions = currentOptions.show;
            //Header
            showOptions.header = (typeof options.show.header !== "undefined") ?
                options.show.header : showOptions.header;
        }
        //Select options
        if (typeof options.select !== "undefined") {
            currentOptions.select = (typeof options.select !== "number") ? currentOptions.select : options.select;
        }
        //Namespace option
        if (options.namespace) {
            currentOptions.namespace = (typeof options.namespace !== "string") ? currentOptions.namespace : options.namespace;
        }
        return this;
    };

    /**
     * Retrieves the full list of column ids associated to the table.
     * @private
     * @returns {Array<string>} The full list of column ids that have been bound to the table.
     */
    Table.prototype.getAllColumnIds = function() {
        var columns = this.m_columns;
        var columnCount = columns.length;
        var allColumnIds = [];
        for (var i = 0; i < columnCount; i++) {
            allColumnIds.push(columns[ i ].id);
        }
        return allColumnIds;
    };

    /**
     * Retrieve the list of column ids except for the specified id.
     * @param {string} columnId - The columnId to be excluded from the full list of column ids.
     * @private
     * @returns {Array<string>} The list of column ids except for the field provided.
     */
    Table.prototype.getAllColumnIdsExcept = function(columnId) {
        var columns = this.m_columns;
        var columnCount = columns.length;
        var allColumnIds = [];
        for (var i = 0; i < columnCount; i++) {
            if (columns[ i ].id !== columnId) {
                allColumnIds.push(columns[ i ].id);
            }
        }
        return allColumnIds;
    };

    /**
     * Returns the list of selected objects. This is not to be confused with the consumer facing getSelectionData
     * function.
     * @private
     * @returns {Array<object>} The list of selection data.
     */
    Table.prototype.getSelection = function() {
        if (!this.m_selection) {
            this.m_selection = [];
        }
        return this.m_selection;
    };

    /**
     * Retrieves the selection data in such a way that consumers can digest it. The data is returned in the form of
     * [
     *        {
	 * 			record: object,
	 * 			fields: [field1, field2, ..., field(n)] | null
	 *		}
     * ]
     * The data is an array of objects which specify which records have a selection and which fields in the record
     * are selected. If the fields attribute is null, it is assumed that the entire record (row) is selected.
     * @returns {Array} The list of selected records and fields (if any) that are currently selected in the table.
     */
    Table.prototype.getSelectionData = function() {
        var selections = this.getSelection();
        var selectionCount = selections.length;
        var selectionData = [];
        for (var i = 0; i < selectionCount; i++) {
            selectionData.push({
                record: selections[ i ],
                columns: (selections[ i ]._MPageUI.cellSelection || null)
            });
        }
        return selectionData;
    };

    /**
     * Retrieves a record object from an element.
     * @param {jQuery} $element - The jQuery element from which the associated record will be retrieved.
     * @private
     * @returns {null|Object} The retrieved record or null.
     */
    Table.prototype.getRecordFromElement = function($element) {
        var recordHashKey = $element.attr("data-record");
        var record = null;
        if (!recordHashKey) {
            return null;
        }
        record = this.getRecordHash()[ recordHashKey ];
        if (!record) {
            return null;
        }
        return record;
    };

    /**
     * Sets the hover callback function to handle the event when a table row/cell is hovered over.
     * @param {Function} hoverContentCallback - The callback function to produce the content for the hover event
     * @param {String} highlightOption - The highlight option for the hover ROW|CELL|NONE
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setHover = function(hoverContentCallback, highlightOption) {
        if (typeof hoverContentCallback !== "function") {
            throw new Error("MPageUI.Table.prototype.setHover expects a function");
        }
        //Override the highlight option
        if (highlightOption) {
            this.m_options.highlight = highlightOption;
        }

        this.m_hoverCallBack = hoverContentCallback;
        return this;
    };
    /**
     * Sets the callback function to handle the event when a table column header is clicked.
     * @param {function} callback - The callback function to handle the column header click.
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setOnColumnHeaderClickCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("MPageUI.Table.prototype.setOnColumnHeaderClick expects a function");
        }
        this.m_columnHeaderClickCallback = callback;
        return this;
    };

    /**
     * Sets the callback function to handle the event when a table cell is clicked.
     * @param {function} callback - The callback function to handle the cell click event.
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setOnCellClickCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("MPageUI.Table.prototype.setOnCellClickCallback expects a function");
        }
        this.m_cellClickCallback = callback;
        return this;
    };

    /**
     * Sets the callback function to handle the event when a table rows is clicked.
     * @param {function} callback - The callback function to handle the row click event.
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setOnRowClickCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("MPageUI.Table.prototype.setOnRowClickCallback expects a function");
        }
        this.m_rowClickCallback = callback;
        return this;
    };

    /**
     * Sets the callback function to handle the event when a table group (section) is clicked.
     * @param {function} callback - The callback function to handle the group (section) click event.
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setOnGroupClickCallback = function(callback) {
        if (typeof callback !== "function") {
            throw new Error("MPageUI.Table.prototype.setOnGroupClickCallback expects a function");
        }
        this.m_groupClickCallback = callback;
        return this;
    };

    /**
     * Handles the group section click event for the table.
     * @param {Event} event - The jQuery event that occurred.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.onGroupClick = function(event) {
        var $targetElement = $(event.currentTarget);
        if (!$targetElement || !$targetElement.length) {
            logger.logWarning("MPageUI.Table.prototype.onGroupClick: a target element was not found.");
            return;
        }
        var groupHash = $targetElement.attr("data-group");
        if (!groupHash) {
            logger.logWarning("MPageUI.Table.prototype.onGroupClick: a group hash has not been associated to the group section, verify the group objects.");
            return;
        }
        var group = this.getRecordHash()[ groupHash ];
        if (!group) {
            logger.logWarning("MPageUI.Table.prototype.onGroupClick: a group was not found with the hash");
            return;
        }
        //If the group is collapsible toggle the group, undefined will default collapsible to true
        if (typeof group.collapsible === "undefined" || group.collapsible) {
            this.toggleGroup(group);
        }
        //Call the consumer provided callback
        if (this.m_groupClickCallback) {
            this.m_groupClickCallback({
                groups: [ group ],
                event: event
            });
        }
    };

    /**
     * Retrieves the sort options for the column with the specified id.
     * @param {string} columnId - The id of the column for which we are retrieving sort options.
     * @returns {Object|null} The sort options for the specified column or null
     * if the column was not found.
     * @private
     */
    Table.prototype.getColumnSortOptions = function(columnId) {
        var columns = this.getColumns();
        //Iterate through the columns and check if the requested column contains sort options if so return the sort options
        for (var i = 0; i < columns.length; i++) {
            var column = columns[ i ];
            if (column.id === columnId && column.sortOptions) {
                return column.sortOptions;
            }
        }
        //No sortOptions found for the selected column
        return null;
    };
    /**
     * Handles the column header click event for the table.
     * @param {Event} event - The jQuery event that occurred.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.onColumnHeaderClick = function(event) {
        var $targetElement = $(event.currentTarget);
        if (!$targetElement || !$targetElement.length) {
            logger.logWarning("MPageUI.Table.prototype.onColumnHeaderClick: a target element was not found.");
            return;
        }
        var columnId = $targetElement.attr("data-column");
        if (!columnId) {
            logger.logWarning("MPageUI.Table.prototype.onColumnHeaderClick: a field has not been associated to the column, verify the column objects.");
            return;
        }
        var columnSortOptions = this.getColumnSortOptions(columnId);
        var canUserSort = true;
        if (columnSortOptions && typeof columnSortOptions.userSort !== "undefined") {
            canUserSort = columnSortOptions.userSort;
        }
        if (canUserSort) {
            this.sortBy({
                "column": { id: columnId }
            });
        }
        if (this.m_columnHeaderClickCallback) {
            this.m_columnHeaderClickCallback({
                records: this.getAllRecords(),
                columns: [ columnId ],
                event: event
            });
        }
    };

    /**
     * Hover event to be triggered upon hovering over a table cell and display the content set via setHover()
     * this function will display the content in a hover utilizing the MPageTooltip
     * @param {Event} event jQuery event the occured
     * @returns {undefined} Returns nothing.
     * @private
     */
    Table.prototype.onHover = function(event) {
        //Do nothing if no hover callback is available
        if (!this.m_hoverCallBack) {
            return;
        }
        //Get the table row element in order to get the row record data
        var $targetElement = $(event.currentTarget.parentElement);
        var record = null;
        var columnId = null;
        var data = {};
        //No target element available
        if (!$targetElement || !$targetElement.length) {
            logger.logWarning("MPageUI.Table.prototype.onHover: a target element was not found.");
            return;
        }
        //Get the record data from the table row element
        record = this.getRecordFromElement($targetElement);
        //No record available
        if (!record) {
            logger.logWarning("MPageUI.Table.prototype.onHover: could not find a record for the row");
            return;
        }
        //Get the table cell element
        $targetElement = $(event.currentTarget);
        //The column name of the cell that is being hovered over
        columnId = $targetElement.attr("data-column");
        //Create the data object that will be used with the hover content callback
        data = {
            records: [ record ],
            columns: [ columnId ],
            event: event
        };
        //Get hover content with the callback
        var content = this.m_hoverCallBack(data);
        //Initialize the hover if not available
        if (content) {
          if (!this.m_tableHover) {
              this.m_tableHover = new MPageTooltip().setShowDelay(0);
          }
          //Set the hover
          this.m_tableHover.setX(event.pageX).setY(event.pageY).setAnchor($targetElement).setContent(content);
          //Display the hover
          this.m_tableHover.show();
        }
    };
    /**
     * Handles the row click event for the table.
     * @param {Event} event - The jQuery event that occurred.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.onRowClick = function(event) {
        var $targetElement = $(event.currentTarget);
        var record = null;
        if (!$targetElement || !$targetElement.length) {
            logger.logWarning("MPageUI.Table.prototype.onRowClick: a target element was not found.");
            return;
        }
        record = this.getRecordFromElement($targetElement);
        if (!record) {
            return;
        }
        this.handleSelection(record, event);
        if (this.m_rowClickCallback) {
            this.m_rowClickCallback({
                records: [ record ],
                event: event
            });
        }
    };

    /**
     * In the list of all records, returns the index of the specified record.
     * @param {object} record - The record for which the index will be found.
     * @returns {number} The index of the record, if found, otherwise it will
     * return -1.
     */
    Table.prototype.getRecordIndex = function(record) {
        var records = this.getAllRecords();
        for (var i = 0; i < records.length; i++) {
            if (records[ i ] === record) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Handles the table select functionality when the user shift-clicks a
     * record in the table.
     * @param {object} record - The record being selected.
     * @param {object} lastClickedRecord - The record that was last selected
     * (this becomes the anchor for the shift-select).
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.handleShiftSelect = function(record, lastClickedRecord) {
        //Record index values
        var currentIndex = this.getRecordIndex(record);
        var indexOfLastSelectedRecord = this.getRecordIndex(lastClickedRecord);
        //Range information
        var startRange = indexOfLastSelectedRecord;
        var endRange = indexOfLastSelectedRecord;
        //No record has been previously selected
        if (!lastClickedRecord) {
            startRange = 0;
            endRange = currentIndex;
        }
        else {
            if (currentIndex < indexOfLastSelectedRecord) {
                startRange = currentIndex;
            }
            else {
                endRange = currentIndex;
            }
        }
        //Perform the actual selection
        this.select({
            records: this.getAllRecords().slice(startRange, endRange + 1),
            options: { clearPrevious: true }
        });
    };

    /**
     * Handles the table select functionality when the user ctrl-clicks a record
     * in the table.
     * @param {object} record - The record being selected.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.handleControlSelect = function(record) {
        var selectOptions = {
            records: [ record ],
            options: {
                toggle: true
            }
        };
        this.select(selectOptions);
        this.m_lastClickedRecord = record;
    };

    /**
     * Handles the table single select functionality (when the user simply clicks
     * on a record in the table).
     * @param {object} record - The record being selected.
     * @param {Array<object>} currentSelection - The current table selection.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.handleSingleSelect = function(record, currentSelection) {
        var selectOptions = {
            records: [ record ],
            options: {}
        };
        if (currentSelection.length === 1 && currentSelection[ 0 ] === record) {
            selectOptions.options.toggle = true;
        }
        else {
            selectOptions.options.clearPrevious = true;
        }
        this.select(selectOptions);
        this.m_lastClickedRecord = record;
    };

    /**
     * Handles the selection logic for the table.
     * @param {object} record - The record object that was selected (as derived
     * from the row that was clicked).
     * @param {MouseEvent} event - The mouse event that triggered the selection.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.handleSelection = function(record, event) {
        var selectMode = this.m_options.select;
        var selectModeEnum = MPageUI.TABLE_OPTIONS.SELECT;
        var currentSelection = this.getSelection();
        var shiftHeld = event.shiftKey;
        var ctrlHeld = event.ctrlKey;
        var lastClickedRecord = this.m_lastClickedRecord;
        switch (selectMode) {
            case selectModeEnum.SINGLE_ROW:
                this.handleSingleSelect(record, currentSelection);
                break;
            case selectModeEnum.MULTI_ROW:
                if (shiftHeld) {
                    this.handleShiftSelect(record, lastClickedRecord);
                }
                else if (ctrlHeld) {
                    this.handleControlSelect(record);
                }
                else {
                    this.handleSingleSelect(record, currentSelection);
                }
                break;
            default:
                break;
        }
    };

    /**
     * Handles the cell click event. If the consumer has provided the cell click callback, that function is triggered.
     * @param {Event} event - The jQuery event that occurred.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.onCellClick = function(event) {
        var $targetElement = $(event.currentTarget);

        var record = null;
        var columnId = null;
        if (!$targetElement || !$targetElement.length) {
            logger.logWarning("MPageUI.Table.prototype.onCellClick: a target element was not found.");
            return;
        }
        record = this.getRecordFromElement($targetElement);
        columnId = $targetElement.attr("data-column");
        if (!record) {
            return;
        }
        if (!columnId) {
            return;
        }
        if (this.m_cellClickCallback) {
            this.m_cellClickCallback({
                records: [ record ],
                columns: [ columnId ],
                event: event
            });
        }
    };

    /**
     * Handles the group section click event.
     * @param {object} group - The group being toggled.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.toggleGroup = function(group) {
        var $tableBody = this.getRootElement().find("tbody");
        group.expanded = !group.expanded;
        //Optimization. Without detaching, a recursive hide will cause N reflows. Detaching will only trigger 2 reflows.
        $tableBody.detach();
        var $groupElement = $tableBody.find("#" + group._MPageUI.groupReference);

        /**
         * Recursively hides elements in the table.
         * @param {object} node - The current node being processed.
         * @returns {undefined} Returns nothing.
         */
        function recursiveHide(node) {
            var groups = node.groups;
            var records = node.records;
            var groupCount = 0;
            var recordCount = 0;
            var record = null;
            var childGroup = null;
            var i = 0;
            if (records) {
                recordCount = records.length;
                for (i = 0; i < recordCount; i++) {
                    record = records[ i ];
                    $tableBody.find("#" + record._MPageUI.rowReference).hide();
                }
                //If this node has no records, attempt to hide the no records found row (it should be the next immediate sibling)
                if (!recordCount) {
                    $tableBody.find("#" + node._MPageUI.groupReference).next("[data-type='no-records']").hide();
                }
            }
            if (groups && groups.length) {
                groupCount = groups.length;
                for (i = 0; i < groupCount; i++) {
                    childGroup = groups[ i ];
                    $tableBody.find("#" + childGroup._MPageUI.groupReference).hide();
                    //Optimization. Only recursively hide subsequent groups if it is currently expanded.
                    if (childGroup.expanded) {
                        recursiveHide(childGroup);
                    }
                }
            }
        }

        /**
         * Recursively shows elements in the table. If a node has not yet been rendered, it will render the node.
         * @param {object} node - The current node being processed.
         * @returns {undefined} Returns nothing.
         */
        function recursiveShow(node) {
            var groups = node.groups;
            var records = node.records;
            var groupCount = 0;
            var recordCount = 0;
            var record = null;
            var childGroup = null;
            var nodeIsExpanded = node.expanded;
            var i = 0;
            if (records && nodeIsExpanded) {
                recordCount = records.length;
                for (i = 0; i < recordCount; i++) {
                    record = records[ i ];
                    $tableBody.find("#" + record._MPageUI.rowReference).css("display", "");
                }
                //If this node has no records, attempt to show the no records found row (it should be the next immediate sibling)
                if (!recordCount) {
                    $tableBody.find("#" + node._MPageUI.groupReference).next("[data-type='no-records']").css("display", "");
                }
            }
            if (groups && groups.length && nodeIsExpanded) {
                groupCount = groups.length;
                for (i = 0; i < groupCount; i++) {
                    childGroup = groups[ i ];
                    $tableBody.find("#" + childGroup._MPageUI.groupReference).css("display", "");
                    recursiveShow(childGroup);
                }
            }
        }

        if (!group.expanded) {
            $tableBody.find("#" + group._MPageUI.groupReference).addClass("collapsed");
            recursiveHide(group);
        }
        else {
            $tableBody.find("#" + group._MPageUI.groupReference).removeClass("collapsed");
            //If this node was pruned, render its children...
            if (group._MPageUI.pruned) {
                group._MPageUI.pruned = null;
                $groupElement.after(this.renderData(group, group._MPageUI.depth + 1));
            }
            else {
                recursiveShow(group);
            }
        }
        //Re-attach the table body to the table once we have finished manipulating the DOM.
        this.getRootElement().find(".table-body>table:first-child").append($tableBody);
        this.resize();
    };

    /**
     * Finds the specified record in the list of records that currently have some form of selection (record or column).
     * @param {object} record - The record being checked.
     * @private
     * @returns {number} The index in the array of selected records, otherwise -1 is returned.
     */
    Table.prototype.getSelectionIndex = function(record) {
        var selection = this.getSelection();
        var selectionCount = selection.length;
        for (var i = 0; i < selectionCount; i++) {
            if (selection[ i ] === record) {
                return i;
            }
        }
        return -1;
    };

    /**
     * For the specified column, searches through the list of selected column (if any) and determines if the column
     * is currently selected for the record. If the column is selected in the record, the index in the array is returned.
     * Otherwise, -1 is returned to indicate the column is not selected on the record.
     * @param {object} record - The record in which the search will be performed.
     * @param {string} column - The name of the column being tested.
     * @private
     * @returns {number} The index in the array of selected columns, otherwise -1 is returned.
     */
    Table.prototype.getSelectedCellIndex = function(record, column) {
        var mpageUIData = record._MPageUI;
        var selectedCells = mpageUIData.cellSelection;
        if (!selectedCells) {
            return -1;
        }
        var selectedCellCount = selectedCells.length;
        for (var i = 0; i < selectedCellCount; i++) {
            if (selectedCells[ i ] === column) {
                return i;
            }
        }
        return -1;
    };

    /**
     * An advanced selection function. This will perform selection on the table. The selection options must be of the form
     * {
	 * 		records: [ ... ] (a list of records to select)
	 *		columns: [ ... ] (a list of field identifiers)
	 *		options: {
	 *			toggle: true | false (boolean indicating if selection should toggle),
	 *			clearPrevious: true | false (boolean indicating if previous selection should be cleared)
	 *		}
	 * }
     * WARNING: Using field (cell) selection can be non-performant. The table must keep track of which fields are
     * selected and apply styling to each cell individually.
     * @param {object} selectOptions - The select parameters (see above).
     * @public
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.select = function(selectOptions) {
        var records = selectOptions.records;
        if (!records) {
            records = this.getAllRecords();
        }
        var recordCount = records.length;
        var record = null;
        var columns = selectOptions.columns;
        var toggle = selectOptions.options && selectOptions.options.toggle || false;
        var clearPrevious = selectOptions.options && selectOptions.options.clearPrevious || false;
        var fieldCount = columns ? columns.length : 0;
        if (clearPrevious) {
            this.deselectAll();
        }
        //If selection should qualify on records
        for (var i = 0; i < recordCount; i++) {
            record = records[ i ];
            if (!columns) {
                if (toggle) {
                    this.toggleRecordSelection(record);
                }
                else {
                    this.selectRecord(record);
                }
            }
            else {
                for (var j = 0; j < fieldCount; j++) {
                    if (toggle) {
                        this.toggleCellSelection(record, columns[ j ]);
                    }
                    else {
                        this.selectCell(record, columns[ j ]);
                    }
                }
            }
        }
    };

    /**
     * Toggles the selection state of the cell.
     * @param {object} record - The record in which the cell being toggled resides.
     * @param {string} column - The column within the record that is being toggled.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.toggleCellSelection = function(record, column) {
        var selectedCellIndex = this.getSelectedCellIndex(record, column);
        if (selectedCellIndex > -1 || record._MPageUI.selected) {
            this.deselectCell(record, column);
        }
        else {
            this.selectCell(record, column);
        }
    };

    /**
     * Selects the cell.
     * @param {object} record - The record in which the cell being selected resides.
     * @param {string} column - The column within the record that is being selected.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.selectCell = function(record, column) {
        var mpageUIData = record._MPageUI;
        var selectedCellIndex = this.getSelectedCellIndex(record, column);
        if (mpageUIData.selected || selectedCellIndex > -1) {
            return;
        }
        if (!mpageUIData.cellSelection) {
            mpageUIData.cellSelection = [];
        }
        mpageUIData.cellSelection.push(column);
        var selectedIndex = this.getSelectionIndex(record);
        if (selectedIndex < 0) {
            this.getSelection().push(record);
        }
        if (mpageUIData.cellSelection.length === this.m_columns.length) {
            mpageUIData.cellSelection = null;
            $("#" + record._MPageUI.rowReference).addClass("selected").find(".selected").removeClass("selected");
            mpageUIData.selected = true;
        }
        else {
            $("#" + record._MPageUI.rowReference + " td[data-column='" + column + "']").addClass("selected");
        }
    };

    /**
     * Deselects the specified cell (a cell is denoted by a record and field identifier).
     * @param {object} record - The record the desired cell lies within.
     * @param {string} column - The field in the record object which is considered the cell
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.deselectCell = function(record, column) {
        var mpageUIData = record._MPageUI;
        var wasSelected = mpageUIData.selected;
        var selectedCellIndex = this.getSelectedCellIndex(record, column);
        var isCellSelected = (selectedCellIndex > -1) || wasSelected;
        var cellSelection = null;
        if (!isCellSelected) {
            return;
        }
        cellSelection = mpageUIData.cellSelection;
        if (wasSelected) {
            mpageUIData.cellSelection = cellSelection = this.getAllColumnIdsExcept(column);
            $("#" + record._MPageUI.rowReference).removeClass("selected");
            record._MPageUI.selected = false;
            for (var i = 0; i < cellSelection.length; i++) {
                $("#" + record._MPageUI.rowReference + " td[data-column='" + cellSelection[ i ] + "']").addClass("selected");
            }
        }
        if (selectedCellIndex > -1) {
            cellSelection.splice(selectedCellIndex, 1);
        }
        //If there are no more cells selected, remove the record from selection
        if (!cellSelection.length) {
            mpageUIData.cellSelection = null;
            this.getSelection().splice(this.getSelectionIndex(record), 1);
        }
        $("#" + record._MPageUI.rowReference + " td[data-column='" + column + "']").removeClass("selected");
    };

    /**
     * Deselects everything in the table.
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.deselectAll = function() {
        var selectedRecords = this.getSelection();
        var selectedRecordCount = selectedRecords.length;
        var selectedRecord = null;
        var mpageUIData = null;
        for (var i = 0; i < selectedRecordCount; i++) {
            selectedRecord = selectedRecords[ i ];
            mpageUIData = selectedRecord._MPageUI;
            mpageUIData.selected = false;
            mpageUIData.cellSelection = null;
        }
        this.getRootElement().find(".selected").removeClass("selected");
        this.m_selection = null;
    };

    /**
     * Toggles the selection of the specified record. If it is selected, it will be deselected and vice-versa.
     * @param {object} record - The JSON record for which selected status will be toggled.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.toggleRecordSelection = function(record) {
        var mpageUIData = record._MPageUI;
        //Some cells are selected, so we need to toggle them
        if (mpageUIData.cellSelection) {
            this.select({
                records: [ record ],
                columns: this.getAllColumnIds(),
                options: {
                    toggle: true
                }
            });
            return;
        }
        if (mpageUIData.selected) {
            this.deselectRecord(record);
        }
        else {
            this.selectRecord(record);
        }
    };

    /**
     * Selects the specified record.
     * @param {object} record - The record to be selected
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.selectRecord = function(record) {
        var mpageUIData = record._MPageUI;
        var selectionIndex = this.getSelectionIndex(record);
        //If the record is already currently selected, return
        if (mpageUIData.selected) {
            return;
        }
        var $recordElement = $("#" + record._MPageUI.rowReference);
        //If the record had cells selected, we can remove that and save some memory
        if (mpageUIData.cellSelection && mpageUIData.cellSelection.length) {
            $recordElement.find(".selected").removeClass("selected");
            mpageUIData.cellSelection = null;
        }
        $recordElement.addClass("selected");
        record._MPageUI.selected = true;
        //If the record selection has not been stored off
        if (selectionIndex < 0) {
            this.getSelection().push(record);
        }
    };

    /**
     * Deselects the specified record.
     * @param {object} record - The record to be
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.deselectRecord = function(record) {
        var mpageUIData = record._MPageUI;
        var selectionIndex = this.getSelectionIndex(record);
        if (selectionIndex < 0) {
            return;
        }
        var $recordElement = $("#" + record._MPageUI.rowReference);
        //If the record had cells selected, we must deselect the cells as they are part of the record
        if (mpageUIData.cellSelection && mpageUIData.cellSelection.length) {
            mpageUIData.cellSelection = null;
            $recordElement.find(".selected").removeClass("selected");
        }
        $recordElement.removeClass("selected");
        mpageUIData.selected = false;
        this.getSelection().splice(selectionIndex, 1);
    };

    /**
     * Renders the colgroup markup which allows consumers to style their
     * columns appropriately.
     * @returns {string} The colgroup and col tags rendered as an HTML string.
     */
    Table.prototype.renderColumns = function() {
        var html = "<colgroup>";
        html += this.getColumns().map(function(column) {
            return "<col data-column='" + column.id + "' class='" + (column.css || "") + "'>";
        }).join("");
        return html + "</colgroup>";
    };

    /**
     * Renders the table as an html string.
     * @returns {string} The table rendered as an html string.
     */
    Table.prototype.render = function() {
        /*
         * With a split head table, the following must happen
         * 1). A wrapper div is created to encompass the entire DOM structure of the table
         * 2). The table head and body are split into two separate tables
         * 3). The header is rendered into the top table
         * 4). The body is rendered into the lower table
         * 5). The root of the split table becomes the wrapping element
         */
        var classes = this.getClasses();
        var html = "<div id='" + this.m_id + "' class='" + classes + "'>";
        html += "<div class='table-head'><table>";
        html += this.renderColumns();
        html += this.renderHeader();
        html += "</table></div>";
        html += "<div class='table-body'><table>";
        html += this.renderColumns();
        html += this.renderBody();
        html += "</table></div></div>";
        return html;
    };

    /**
     * Retrieves the CSS classes that will be applied to the table at the top
     * DOM level. This is driven off of the options provided to the table.
     * @private
     * @returns {string} The set of CSS classes to be applied to the table.
     */
    Table.prototype.getClasses = function() {
        var classes = "table-base";
        classes += (this.m_options.namespace) ? " " + this.m_options.namespace : "";
        classes += (this.m_options.rows.striped ? " table-striped" : "");
        classes += (this.m_options.columns.separators ? " table-with-separators" : "");
        classes += (this.m_options.highlight ? " " + this.m_options.highlight : "");
        return classes;
    };

    /**
     * Renders the header of the table as an html string.
     * @private
     * @returns {string} The header of the table rendered as an html string.
     */
    Table.prototype.renderHeader = function() {
        if (!this.m_options.show.header) {
            return "";
        }
        var header = "<thead><tr>";
        var sortClass = "";
        var columns = this.m_columns;
        var columnCount = columns ? columns.length : 0;
        var cellStyles = "";
        var canUserSort = true;
        var column = 0;
        for (var i = 0; i < columnCount; i++) {
            canUserSort = true;
            column = columns[ i ];
            sortClass = "";
            cellStyles = "";
            if (column.width) {
                cellStyles = "width='" + column.width + "'";
            }
            //set the sort class if the column is sortable
            if (this.isColumnSortable(column.id)) {
                //check if the user is allowed to sort this column
                canUserSort = (typeof column.sortOptions.userSort !== "undefined") ? column.sortOptions.userSort : true;
                if (canUserSort) {
                    //add the sortable class to show the hover on the column header
                    sortClass += " sortable ";
                    //current sorted column will display the sort direction indicator
                    if (this.m_currentlySortedColumnId === column.id) {
                        sortClass += this.getSortClass(this.m_currentSortDirection);
                    }
                }
            }
            header += "<th class='" + sortClass + "' data-column='" + columns[ i ].id + "' scope='col'" + cellStyles + ">" + (columns[ i ].label || "&nbsp;") + "</th>";
        }
        return header + "</tr></thead>";
    };

    /**
     * Helper function to compare two values.
     * @param {object} a - the first value to compare
     * @param {object} b - the second value to compare
     * @returns {number} a comparison value 1, -1, or 0, where 0 means equality
     * @private
     */
    Table.prototype.compare = function(a, b) {
        try {
            //Perform special logic for setting up sort values for comparison
            if (typeof a === "number" || typeof b === "number") {
                a = a || 0;
                b = b || 0;
            }
            else if (typeof a === "string" || typeof b === "string") {
                a = (a || "").toUpperCase();
                b = (b || "").toUpperCase();
            }
            if (a > b) {
                return -1;
            }
            else if (a < b) {
                return 1;
            }
            else {
                return 0;
            }
        }
        catch (exe) {
            logger.logError("Called MPageUI.Table.prototype.compare(a,b) with an invalid value for a or b");
            return 0;
        }
    };

    /**
     * Gets the sort function to be used to sort the records of a given column.
     * @returns {Function} The sort function.
     * @private
     */
    Table.prototype.getSortFunction = function() {
        var self = this;
        var currentColumn = this.m_currentlySortedColumnId;
        var columnSortOptions = this.getColumnSortOptions(currentColumn);
        var primaryField = columnSortOptions.primary.field;
        var currentSortDirection = this.m_currentSortDirection;
        return function(rowA, rowB) {
            var rowAVal = rowA[ primaryField ];
            var rowBVal = rowB[ primaryField ];
            var comparison = self.compare(rowAVal, rowBVal);
            //If the comparison on the primary sort fields isn't 0 (not equal), return this value
            if (comparison !== 0) {
                return currentSortDirection * comparison;
            }
            //check if secondary fields are available within the sort options for the current column
            if (columnSortOptions && columnSortOptions.secondary) {
                var secondarySortFields = columnSortOptions.secondary;
                var secondarySortFieldsCount = secondarySortFields.length;
                for (var i = 0; i < secondarySortFieldsCount; i++) {
                    rowAVal = rowA[ secondarySortFields[ i ].field ];
                    rowBVal = rowB[ secondarySortFields[ i ].field ];
                    comparison = self.compare(rowAVal, rowBVal);
                    if (comparison !== 0) {
                        return secondarySortFields[ i ].direction * comparison;
                    }
                }
            }
            //If we've made it this far, all fields are equal, so return 0
            return 0;
        };
    };

    /**
     * Renders a no results message in the case that no records are present.
     * @param {string} noRecordsMessage - The message to be displayed indicating
     * that no records are present.
     * @param {number} depth - The depth in the data tree at which the no
     * records message is being rendered.
     * @returns {string} The no records table row markup rendered as a string.
     * @private
     */
    Table.prototype.renderNoRecords = function(noRecordsMessage, depth) {
        return "<tr data-type='no-records' class='table-row no-records group-level-" + depth + "'>" +
            "<td class='table-cell' colspan='" + this.m_columns.length + "'>" + noRecordsMessage + "</td></tr>";
    };

    /**
     * Renders the data that has been bound to the table.
     * @param {object} data - The data bound to the table.
     * @param {number} startDepth - The depth at which rendering started.
     * @private
     * @returns {string} The table body content rendered to an html string.
     */
    Table.prototype.renderData = function(data, startDepth) {
        var self = this;
        var html = "";

        /**
         * Recursively traverses through the table data and renders a flat html table.
         * @param {object} node - The current node being rendered.
         * @param {number} depth - The current recursion depth.
         * @returns {undefined} Returns nothing.
         * @private
         */
        function recursiveRender(node, depth) {
            var records = node.records;
            var sortFunction = null;
            var columnSortData = self.getColumnSortOptions(self.m_currentlySortedColumnId);
            var groups = node.groups;
            var group = null;
            var expanded = true;
            if (records) {
                //check if the table is sortable
                if (columnSortData && records.length) {
                    sortFunction = self.getSortFunction();
                    records.sort(sortFunction);
                }
                if (records.length) {
                    html += self.renderRecords(records, depth, node);
                }
                else {
                    //Render the default "No Results Found" row
                    if (typeof node.no_records === "undefined") {
                        html += self.renderNoRecords(i18n.discernabu.NO_RESULTS_FOUND, depth);
                    }
                    else if (node.no_records) { //no_records is a string render the row
                        html += self.renderNoRecords(node.no_records, depth);
                    }
                }
            }
            if (groups && groups.length) {
                for (var i = 0; i < groups.length; i++) {
                    group = groups[ i ];
                    if (typeof group.expanded !== "undefined") {
                        expanded = group.expanded;
                    }
                    //get the group records count
                    if (group.showCount) {
                        group.recordCount = self.getRecordsCount(group, 0);
                    }
                    //Render the group markup
                    html += self.renderGroup(group, depth);
                    //Don't bother rendering children if the group is collapsed (save some DOM memory and processing)
                    if (expanded) {
                        recursiveRender(group, depth + 1);
                    }
                    else {
                        group._MPageUI.pruned = true;
                    }
                }
            }
        }

        recursiveRender(data, startDepth);
        return html;
    };

    /**
     * Gets the record count for a group if showCount is set to true
     * @param {object} data - The data bound to the table.
     * @private
     * @returns {number} The table body content rendered to an html string.
     */
    Table.prototype.getRecordsCount = function(data) {
        var recordsCount = 0;

        /**
         * Recursively traverses through the table groups and counts the records
         * @param {object} node - The current node being rendered.
         * @param {number} depth - The current recursion depth.
         * @returns {undefined} Returns nothing.
         */
        function recursiveRecordCount(node) {
            var records = node.records;
            var groups = node.groups;
            var group = null;
            if (records && records.length) {
                recordsCount += records.length;
            }
            if (groups && groups.length) {
                for (var i = 0; i < groups.length; i++) {
                    group = groups[ i ];
                    recursiveRecordCount(group);
                }
            }
        }

        recursiveRecordCount(data);
        return recordsCount;
    };

    /**
     * Renders a group to an html string.
     * @param {object} group - The group object to be rendered.
     * @param {number} depth - The depth at which the group is being rendered.
     * @private
     * @returns {string} The group rendered as an html string.
     */
    Table.prototype.renderGroup = function(group, depth) {
        var groupClasses = "table-section " + "group-level-" + depth;
        if (group.css) {
            groupClasses += (" " + group.css);
        }
        var showCount = group.showCount || false;
        var expanded = true;
        var collapsible = true;
        if (typeof group.collapsible !== "undefined") {
            collapsible = group.collapsible;
        }
        if (typeof group.expanded !== "undefined") {
            expanded = group.expanded;
        }
        if (!expanded) {
            groupClasses += " collapsed";
        }
        if (collapsible) {
            groupClasses += " collapsible";
        }
        //Group count display
        var groupCountHtml = (showCount) ? "<span data-group-count='" + group.recordCount + "' class='table-section-count'>&nbsp;(" + group.recordCount + ")</span>" : "";
        var html = "";
        html += "<tr id='" + group._MPageUI.groupReference + "' data-group='" + group._MPageUI.groupHash + "' class='" + groupClasses + "'>";
        html += "<th data-group='" + group._MPageUI.groupHash + "' colspan='" + this.m_columns.length + "'><span class='table-section-icon'></span>" + group.label + groupCountHtml + "</th>";
        return html + "</tr>";
    };

    /**
     * Renders a list of table records as an html string.
     * @param {Array<object>} records - The list of records to be rendered as an html string.
     * @param {number} depth - The depth at which the records are being rendered (typically 0).
     * @param {object} parentNode - The data node that is the parent to the record. This will
     * either be the root data or a group.
     * @private
     * @returns {string} The list of records rendered as an html string.
     */
    Table.prototype.renderRecords = function(records, depth, parentNode) {
        var html = "";
        var recordCount = records.length;
        var record = null;
        var column = null;
        var columns = this.m_columns;
        var columnCount = columns.length;
        var columnId = null;
        var contentFunction = null;
        var mpageUIData = null;
        var rowClasses = "";
        var cellClasses = "";
        var cellSelection = null;
        var cellStyle = "";
        var parentGroup = "";
        //Iterate over each result
        for (var i = 0; i < recordCount; i++) {
            rowClasses = "table-row";
            record = records[ i ];
            //Retrieve the stored MPageUI data
            mpageUIData = record._MPageUI;
            if (mpageUIData.selected) {
                rowClasses += " selected";
            }
            if (depth > 0) {
                parentGroup = "data-group='" + parentNode._MPageUI.groupHash + "'";
                rowClasses += " group-level-" + depth;
            }
            if (this.m_options.rows.striped) {
                rowClasses += ((i % 2 === 0) ? "" : " stripe");
            }
            html += "<tr id='" + this.m_id + "_" + record._MPageUI.recordHash + "'" + parentGroup + " data-record='" + record._MPageUI.recordHash + "' class='" + rowClasses + "'>";
            //Iterate over each column, rendering the field of the result
            for (var j = 0; j < columnCount; j++) {
                cellStyle = "";
                cellClasses = "table-cell";
                column = columns[ j ];
                //Determine which field the column is to render
                columnId = column.id;
                if (mpageUIData.cellSelection && mpageUIData.cellSelection.length) {
                    cellSelection = mpageUIData.cellSelection;
                    for (var k = 0; k < cellSelection.length; k++) {
                        if (columnId === cellSelection[ k ]) {
                            cellClasses += " selected";
                        }
                    }
                }
                if (column.width) {
                    cellStyle += "width='" + column.width + "'";
                }
                //Render the cell
                html += column.row_heading ?
                    "<th scope='row'>" :
                "<td data-record='" + record._MPageUI.recordHash + "' data-column='" + column.id + "' class='" + cellClasses + "'" + cellStyle + ">";

                //Determine if the column provides a processor function
                contentFunction = column.contents;
                if (contentFunction) {
                    html += contentFunction(record);
                }
                html += column.row_heading ? "</th>" : "</td>";
            }
            html += "</tr>";
        }
        return html;
    };

    /**
     * Renders the body of the table as an html string.
     * @private
     * @returns {string} The body of the table rendered as an html string.
     */
    Table.prototype.renderBody = function() {
        var body = "";
        var data = this.m_data;
        body += "<tbody>" + this.renderData(data, 0) + "</tbody>";
        return body;
    };

    /**
     * Refreshes the table by replacing the inner contents.
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.refresh = function() {
        var $rootElement = this.getRootElement();
        //Do not attempt to refresh if the table has not been rendered
        if (!$rootElement || !$rootElement.length) {
            return;
        }
        $rootElement.find(".table-head>table:first-child")[ 0 ].innerHTML = (this.renderColumns() + this.renderHeader());
        $rootElement.find(".table-body>table:first-child")[ 0 ].innerHTML = (this.renderColumns() + this.renderBody());
        this.resize();
    };

    /**
     * Resizes the table it checks if scrolling is applied, and if so it shifts
     * the header over to compensate for the scrollbar in the table body.
     * @returns {undefined} Returns nothing
     */
    Table.prototype.resize = function() {
        if (!this.m_options.show.header) {
            return;
        }
        var $rootElement = this.getRootElement();
        //Not rendered to the DOM
        if ((!$rootElement || !$rootElement.length)) {
            return;
        }
        //apply max height to the table body
        this.applyMaxHeight();
        //shift the table header if scrolling is applied
        this.shiftTableHeader();
    };

    /**
     * Applies max height to the table body based
     * on the max height that was set for the table.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.applyMaxHeight = function() {
        var $rootElement = this.getRootElement();
        var maxHeight = this.getMaxHeight();
        //find the table header height
        var $tableHeader = $rootElement.find(".table-head");
        var tableHeaderHeight = $tableHeader[ 0 ].offsetHeight;
        //Calculate the new body max-height
        var newBodyMaxHeight = maxHeight - tableHeaderHeight;
        //set the new table body max-height
        var $tableBody = $rootElement.find(".table-body");
        $tableBody.css({ "max-height": newBodyMaxHeight + "px" });
    };

    /**
     * Shifts table header when scrolling is applied.
     * @private
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.shiftTableHeader = function() {
        var $rootElement = this.getRootElement();
        var $tableBody = $rootElement.find(".table-body");
        var $table = $tableBody.find("table:first");

        var offsetHeight = $tableBody[ 0 ].offsetHeight;
        var tableHeight = $table[ 0 ].offsetHeight;
        /*
         * We do not use the scrollHeight calculation because IE has what
         * appears to be a known rounding error.
         * http://stackoverflow.com/questions/22174841/scrollheight-is-incorrect-in-ie
         *
         * Instead, determine if the height of the table within the wrapping
         * table body is greater than the table body. This is sufficient to
         * assume that the table is scrolling.
         */
        if (tableHeight > offsetHeight) {
            $rootElement.find(".table-head").addClass("shifted");
        }
        else {
            $rootElement.find(".table-head").removeClass("shifted");
        }
    };

    /**
     * Gets the max height for the table.
     * @returns {number} The max height of the table.
     */
    Table.prototype.getMaxHeight = function() {
        return this.m_maxHeight;
    };

    /**
     * Sets the max height for the table
     * @throws {Error} If height is not a number
     * @param {number} height to be set as max height for the component table
     * @returns {MPageUI.Table} Returns self to allow chaining.
     */
    Table.prototype.setMaxHeight = function(height) {
        if (typeof height !== "number") {
            throw new Error("MPageUI.Table.prototype.setMaxHeight expects a number");
        }
        this.m_maxHeight = height;
        //Resize after the max height is set
        this.resize();
        return this;
    };

    /**
     * Attaches the necessary events to the table. This must be called after the Table instance has been rendered
     * to the DOM.
     * @returns {undefined} Returns nothing.
     */
    Table.prototype.attachEvents = function() {
        var $rootElement = this.getRootElement();
        var self = this;
        //Table column header click
        $rootElement.on("click.mpageui", "thead th", function(event) {
            self.onColumnHeaderClick(event);
        });
        //Table row click
        $rootElement.on("click.mpageui", "tbody tr.table-row", function(event) {
            self.onRowClick(event);
        });
        //Table cell click
        $rootElement.on("click.mpageui", "tbody tr td.table-cell", function(event) {
            self.onCellClick(event);
        });
        //Table group section click
        $rootElement.on("click.mpageui", "tbody tr.table-section", function(event) {
            self.onGroupClick(event);
        });
        //Hover - mouse enter
        $rootElement.on("mouseenter.mpageui", "tbody tr td.table-cell", function(event) {
            self.onHover(event);
        });
    };

    return Table;
})();

/* eslint-enable no-underscore-dangle */

/* globals MPageUI, CERN_Validate, objectAssign, EventEmitter */
/**
 * Enumeration for TextControl options.
 * Subclasses of TextControl can add a type to the enum and should set a field type in their constructor
 * @readonly
 */
MPageUI.TEXT_CONTROL_OPTIONS = {
    TYPE: {
        TEXT: "field-text",
        TEXT_AREA: "field-textarea"
    }
};

MPageUI.TextControl = (function() {
    /**
     * The TextControl class.
     * @returns {TextControl} Returns self to allow chaining.
     * @constructor
     */
    var TextControl = function() {
        // Super constructor
        this.base();
        this.m_headerLabel = "";
        this.m_width = null;
        this.m_currentValue = "";
        this.m_requiredInd = false;
        this.m_fieldType = MPageUI.TEXT_CONTROL_OPTIONS.TYPE.TEXT;
        this.m_placeholder = "";

        // Callback functions
        this.m_onChangeCallback = null;
        this.m_onKeyUpCallback = null;
        this.m_onFocusCallback = null;

        // Element cache
        this.m_$inputElement = null;
        return this;
    };
    // Extend the base UIComponent class
    MPageUI.extend(TextControl, MPageUI.UIComponent);

    /**
     * Returns the id of the input element for the TextControl.
     * @private
     * @returns {string} The id of the input element of the TextControl.
     */
    TextControl.prototype.getInputId = function() {
        return this.m_id + "Input";
    };

    /**
     * Returns the id of the label element for the TextControl.
     * @private
     * @returns {string} The id of the label element of the TextControl.
     */
    TextControl.prototype.getLabelId = function() {
        return this.m_id + "Label";
    };

    /**
     * Sets the placeholder text for the TextControl. This is the text that
     * will be displayed in the input element when no user-entered input is
     * present.
     * @param {string} placeholder - The placeholder text for the input.
     * @returns {MPageUI.TextControl} Returns self.
     */
    TextControl.prototype.setPlaceholder = function(placeholder) {
        this.m_placeholder = placeholder;
        this.getInputElement().attr("placeholder", placeholder);
        return this;
    };

    /**
     * Sets the header label for the text box.
     * @param {string} headerText - The label to display above the text control
     * @throws {Error} An error is thrown if the headerText is not a string.
     * @returns {MPageUI.TextControl} Returns self to allow chaining.
     */
    TextControl.prototype.setHeaderLabel = function(headerText) {
        if (!CERN_Validate.string.isString(headerText)) {
            throw new Error("MPageUI.TextControl.prototype.setHeaderLabel expects a string.");
        }
        this.m_headerLabel = headerText;
        return this;
    };

    /**
     * Sets the width of the text control in pixels. The width to be set needs to be a positive number.
     * @param {number} width - The width of the text control in pixels.
     * @returns {MPageUI.TextControl} Returns self to allow chaining.
     */
    TextControl.prototype.setWidth = function(width) {
        if (!CERN_Validate.number.isPositive(width)) {
            throw new Error("TextControl.prototype.setWidth expects a number > 0");
        }
        this.m_width = width;
        return this;
    };

    /**
     * Returns the current value of the text control.
     * @returns {string} The current value of the text control.
     */
    TextControl.prototype.getCurrentValue = function() {
        return this.m_currentValue;
    };

    /**
     * Sets a value in the text control. This method needs to be called before the text control is rendered.
     * Only string parameter is allowed.
     * @param {string} value - The value to be set in the text control.
     * @returns {TextControl} Returns self to allow chaining.
     */
    TextControl.prototype.setCurrentValue = function(value) {
        if (!CERN_Validate.string.isString(value)) {
            throw new Error("TextControl.prototype.setCurrentValue expects a string.");
        }
        this.m_currentValue = value;
        // If the element has been rendered, update the value.
        this.getInputElement().val(value);
        return this;
    };

    /**
     * Returns whether the text control is required.
     * @returns {boolean} Whether the text control is required.
     */
    TextControl.prototype.isRequired = function() {
        return this.m_requiredInd;
    };

    /**
     * Sets whether the text control is required.
     * @param {boolean} required - Whether the text control is required.
     * @returns {TextControl} Returns self to allow chaining.
     */
    TextControl.prototype.setRequired = function(required) {
        if (typeof required !== "boolean") {
            throw new Error("TextControl.prototype.setRequired expects a boolean.");
        }
        this.m_requiredInd = required;
        this.getInputElement().prop("required", required);
        return this;
    };

    /**
     * Sets the callback function to be called when the content within the text control changes.
     * The callback function must specify a content parameter as such:
     * ex: control.setOnChangeCallback(function(content){ ... });
     * @param {Function} onChangeCallback - The callback function to be called when the content within the text control changes.
     * @returns {TextControl} Returns self to allow chaining.
     */
    TextControl.prototype.setOnChangeCallback = function(onChangeCallback) {
        if (typeof onChangeCallback !== "function") {
            throw new Error("TextControl.prototype.setOnChangeCallback expects a function");
        }
        this.m_onChangeCallback = onChangeCallback;
        return this;
    };

    /**
     * Sets the callback function to be called when the keyup event is triggered
     * on the input element of the TextControl.
     * @param {function(e)} onKeyUpCallback - The callback function to be
     * triggered when the keyup event is triggered on the input element.
     * @returns {MPageUI.TextControl} Returns self.
     */
    TextControl.prototype.setOnKeyUpCallback = function(onKeyUpCallback) {
        this.m_onKeyUpCallback = onKeyUpCallback;
        return this;
    };

    /**
     * Overrides the base render function to render a place holder for text control.
     * @returns {string} The TextControl object rendered as an html string.
     */
    TextControl.prototype.render = function() {
        var classes = [ "field", this.m_fieldType, this.isRequired() ? "field-required" : "" ];
        classes = classes.join(" ");
        var html = "<p id='" + this.m_id + "' class='" + classes + "'>";
        // Renders the label for the input
        html += this.renderLabel();
        // Can be overridden by subclasses of the text control
        html += this.renderInput();
        html += "</p>";
        return html;
    };

    /**
     * Overrides the base render function to render a header label for the
     * text control as an html string. If no header text is set then this
     * function will return an empty html string.
     *  @returns {string} The TextControl object rendered as an html string.
     */
    TextControl.prototype.renderLabel = function() {
        var html = "";

        // HTML for label style
        if (this.m_headerLabel.length) {
            // HTML for label
            html += (
                "<label id='" + this.getLabelId() + "' for='" + this.getInputId() + "'>" +
                this.m_headerLabel +
                "</label>"
            );
        }
        return html;
    };

    /**
     * The base TextControl object does not implement this function, but some sub-classes of the TextControl class
     * can override this method to render a specific type of input element
     * @returns {string} The input rendered as a string.
     */
    TextControl.prototype.renderInput = function() {
        var required = this.isRequired() ? "required" : "";
        var placeholder = "placeholder='" + this.m_placeholder + "'";
        var ariaRequired = this.isRequired() ? "aria-required='true'" : "";
        var attributes = [ placeholder, required, ariaRequired ].join(" ");
        return "<input type='text' id='" + this.getInputId() + "' class='field-input' " + attributes + ">";
    };

    /**
     * Overrides the base attachEvents function to attach any JavaScript events
     * to the component once it has been rendered to the DOM.
     * @returns {undefined} Returns nothing.
     */
    TextControl.prototype.attachEvents = function() {
        var self = this;
        var $input = this.getInputElement();
        $input.on("input.mpageui", function() {
            self.onUpdate(this.value);
            self.emit("input", this.value);
        });
        $input.on("keyup.mpageui", function(e) {
            if (self.m_onKeyUpCallback) {
                self.m_onKeyUpCallback(e);
            }
            self.emit("keyup", e);
        });
        $input.on("focus.mpageui", function(e) {
            if (self.m_onFocusCallback) {
                self.m_onFocusCallback(e);
            }
            self.emit("focus", e);
        });
    };

    /**
     * Handles the input update. This function is called on the keyup event of the text control.
     * @param {string} currentValue - The current value in the text control
     * @returns {undefined} Returns nothing.
     */
    TextControl.prototype.onUpdate = function(currentValue) {
        this.setCurrentValue(currentValue);
        // Notify that the content has changed.
        if (this.m_onChangeCallback) {
            this.m_onChangeCallback(currentValue);
        }
    };

    /**
     * Returns the input element. If the element is null, it will be queried from the DOM.
     * @returns {jQuery} The input element.
     */
    TextControl.prototype.getInputElement = function() {
        if (!this.m_$inputElement || !this.m_$inputElement.length) {
            this.m_$inputElement = $("#" + this.getInputId());
        }
        return this.m_$inputElement;
    };

    /**
     * Determines if the control is empty.
     * @returns {boolean} A boolean indicating if the control is empty.
     */
    TextControl.prototype.isEmpty = function() {
        return CERN_Validate.string.isBlank(this.m_currentValue);
    };

    objectAssign(TextControl.prototype, EventEmitter.prototype);

    return TextControl;
})();

MPageUI.TextArea = (function() {
    /**
     * The TextArea class. This creates a standard text area.
     * @returns {MPageUI.TextArea} Returns self to allow chaining.
     * @constructor
     */
    var TextArea = function() {
        // Super constructor
        this.base();
        this.m_height = null;
        this.m_rows = 1;
        this.m_fieldType = MPageUI.TEXT_CONTROL_OPTIONS.TYPE.TEXT_AREA;
        return this;
    };
    MPageUI.extend(TextArea, MPageUI.TextControl);

    /**
     * Sets the height of the <textarea> in pixels. This value can be null if no value
     * has been explicitly provided. In this case, the <textarea> element will
     * be styled natively via the "rows" attribute which defaults to 1.
     * @param {number} height - The height of the <textarea> element in pixels.
     * @returns {TextArea} Returns self to allow chaining.
     */
    TextArea.prototype.setHeightInPixels = function(height) {
        if (!CERN_Validate.number.isPositive(height)) {
            throw new Error("TextArea.prototype.setHeightInPixels expects a number > 0.");
        }
        this.m_height = height;
        return this;
    };

    /**
     * Sets the number of rows for the <textarea>. This refers to the native
     * "rows" attribute on the <textarea> element. The row number to be set
     * has to be greater than or equal to 1. For example: <textarea rows="1"></textarea>
     * @param {number} rows - The number of native rows for the <textarea> element.
     * @returns {TextArea} returns self to allows chaining.
     */
    TextArea.prototype.setHeightInRows = function(rows) {
        if (!CERN_Validate.number.isGreaterThanOrEqualTo(1)) {
            throw new Error("TextArea.prototype.setHeightInRows expects an integer >= 1");
        }
        this.m_rows = rows;
        return this;
    };

    /**
     * First calls the base render function to render the header label and then
     * returns the header and TextArea as an html string.
     * @returns {string} The TextArea object rendered as an html string.
     */
    TextArea.prototype.renderInput = function() {
        var style = "style='";
        style += this.m_width ? ("width:" + this.m_width + "px;") : "";
        style += this.m_height ? ("height:" + this.m_height + "px;") : "";
        style += "'";

        var attributes = [
            "rows='" + this.m_rows + "'",
            style,
            this.m_placeholder ? "placeholder='" + this.m_placeholder + "'" : "",
            this.isRequired() ? "required" : "",
            this.isRequired() ? "aria-required='true'" : ""
        ].join(" ");

        // HTML for <textarea>
        return (
            "<textarea id='" + this.getInputId() + "' class='field-input' " + attributes + ">" +
            this.m_currentValue +
            "</textarea>"
        );
    };
    return TextArea;
})();

/* global MPageUI */
/* global objectAssign */
MPageUI.Search = (function() {
    var ESCAPE_KEY = 27;
    /**
     * Highlights a portion of a string based on the provided regex by wrapping
     * the text in <b> (bold) tags.
     * @param {RegExp} regex - The current search regular expression.
     * @param {string} text - The text in which matches on the regular
     * expression will be highlighted.
     * @returns {string} The string with the matches on the regular expression
     * highlighted via bold tags.
     */
    var highlight = function(regex, text) {
        return text.replace(regex, function(str) {
            return "<b>" + str + "</b>";
        });
    };
    /**
     * Creates the label for the menu by passing a single search result to the
     * template function along with the highlight function. This allows
     * consumers to choose how to display their search results as well as
     * highlight pieces of the result.
     * @param {object} result - A single search result.
     * @param {RegExp} regex - The current search regular expression.
     * @param {function(object, function)} template - The template function
     * which will generate the display for the menu selection.
     * @returns {string} An html string generated by the template function.
     */
    var makeMenuDisplay = function(result, regex, template) {
        return template(result, highlight.bind(this, regex));
    };
    /**
     * Creates a new MenuSelection object (see com.cerner.discernabu.utils
     * mpage-menu artifact). It generates the label via makeMenuDisplay
     * and binds the click function to the provided onSelectHandler.
     * @param {object} result - A single search result.
     * @param {RegExp} regex - The current search regular expression.
     * @param {function(object)} onSelectHandler - The function to be called
     * when the MenuSelection is selected from the menu.
     * @param {function(object, function)} template - The template function
     * which will generate the display for the menu selection.
     * @returns {MenuSelection} The MenuSelection object created from the
     * search result.
     */
    var makeSearchMenuItem = function(result, regex, onSelectHandler, template) {
        var m = new MenuSelection();
        m.setLabel(makeMenuDisplay(result, regex, template));
        m.setClickFunction(function() {
            onSelectHandler(result);
        });
        return m;
    };
    /**
     * Helper function to determine if the options object has the specified
     * optionsName (key in the options object).
     * @param {{
	 * 		ignoreCase: boolean,
	 * 		label: string,
	 *		placeholder: string,
	 *		required: boolean,
	 *		throttle: number
	 * }} options - The options object for the MPageUI.Search class.
     * @param {string} optionName - The key in the options object for which
     * this function checks existence.
     * @returns {boolean} True if the key exists in the options object.
     */
    var hasOption = function(options, optionName) {
        return typeof options[ optionName ] !== "undefined";
    };
    /**
     * Takes an options object and makes necessary calls to update the
     * encapsulated TextControl with the specified options.
     * @param {MPageUI.TextControl} textControl - The instance of
     * MPageUI.TextControl that is encapsulated in the MPageUI.Search class.
     * @param {{
	 * 		label: string,
	 *		placeholder: string,
	 *		required: boolean
	 * }} options - The options object for the MPageUI.Search class that are
     * relevant to the MPageUI.TextControl class.
     * @returns {undefined} Returns self.
     */
    var updateTextControl = function(textControl, options) {
        if (hasOption(options, "label")) {
            textControl.setHeaderLabel(options.label);
        }
        if (hasOption(options, "placeholder")) {
            textControl.setPlaceholder(options.placeholder);
        }
        if (hasOption(options, "required")) {
            textControl.setRequired(options.required);
        }
    };
    /**
     * Creates an instance of MPageUI.TextControl that is to be encapsulated
     * in the MPageUI.Search class. It creates an instance, wires up necessary
     * events, and updates the instance with the specified options.
     * @param {{
	 * 		filter: boolean,
	 * 		ignoreCase: boolean,
	 * 		label: string,
	 *		placeholder: string,
	 *		required: boolean,
	 *		throttle: number
	 * }} options - The options for the encapsulated MPageUI.TextControl class.
     * Note that only a subset of the options are used.
     * @param {function} onInputHandler - A function to handle the input event
     * on the encapsulated MPageUI.TextControl class.
     * @param {function} onKeyUpHandler - A function to handle the keyup event
     * on the encapsulated MPageUI.TextControl class.
     * @param {function} onFocusHandler - A function to handle the focus event
     * on the encapsulated MPageUI.TextControl class.
     * @returns {MPageUI.TextControl} The created instance of an
     * MPageUI.TextControl class.
     */
    var makeTextControl = function(options, onInputHandler, onKeyUpHandler, onFocusHandler) {
        var t = new MPageUI.TextControl()
            .on("input", onInputHandler)
            .on("keyup", onKeyUpHandler)
            .on("focus", onFocusHandler);
        updateTextControl(t, options);
        return t;
    };
    /**
     * Takes in a standard Menu object (see: com.cerner.discernabu.utils mpage-menu)
     * and checks to see if there are menu items in the menu. If so, the menu
     * object is updated and shown. Otherwise, nothing happens.
     * @param {Menu} menu - An instance of Menu from the standard mpage-menu
     * artifact.
     * @returns {undefined} Returns nothing.
     */
    var openMenu = function(menu) {
        if (!menu.getMenuItemArray() || !menu.getMenuItemArray().length) {
            return;
        }
        MP_MenuManager.updateMenuObject(menu);
        MP_MenuManager.showMenu(menu.getId());
    };
    /**
     * For each provided result, a menu item is created via makeSearchMenuItem
     * and is added to the provided menu object.
     * @param {Menu} menu - An instance of Menu from the standard mpage-menu
     * artifact.
     * @param {Array<object>} results - An array of results returned by the
     * provider (a function that generates search results).
     * @param {RegExp} regex - A regular expression created from the current
     * search text.
     * @param {function(object)} onSelectHandler - The function for handling
     * when a menu item is selected.
     * @param {function(object, function)} template - The template for rendering
     * menu items.
     * @returns {undefined} Returns nothing.
     */
    var addMenuOptions = function(menu, results, regex, onSelectHandler, template) {
        results.forEach(function(result) {
            menu.addMenuItem(makeSearchMenuItem(result, regex, onSelectHandler, template));
        });
    };
    /**
     * Filters a set of results based on the provided filter. First, if a filter
     * is specified, the results are filtered by calling the consumer-provided
     * filter function. The consumer is provided the result being tested and
     * a helper function to test their result to see if it needs to be filtered.
     * It is not the responsibility of the Search API to know what field in the
     * result is the filter-point. Secondly, if no filter is provided, the full
     * set of results is returned (no filtering).
     * @param {function(object, function)} filter - The consumer-provided filter
     * function which takes a single result and the test function to determine
     * if the result passes the filter.
     * @param {RegExp} regex - The current search regular expression.
     * @param {Array<object>} results - The array of results returns for the
     * Search.
     * @returns {Array<object>} The array of filtered results.
     */
    var filterValues = function(filter, regex, results) {
        return filter ? results.filter(function(value) {
            return filter(value, function(text) {
                return regex.test(text);
            });
        }) : results;
    };
    /**
     * Simply closes the menu stack.
     * @returns {undefined} Returns nothing.
     */
    var closeMenu = function() {
        MP_MenuManager.closeMenuStack(false);
    };
    /**
     * Removes all menu items from the provided menu.
     * @param {Menu} menu - The instance of the standard Menu
     * (see: com.cerner.discernabu.utils mpage-menu) which is displaying the
     * current search results.
     * @returns {undefined} Returns nothing.
     */
    var clearMenuItems = function(menu) {
        var items = menu.getMenuItemArray();
        if (!items || !items.length) {
            return;
        }
        while (items.length) {
            menu.removeMenuItem(items[ items.length - 1 ]);
        }
    };
    /**
     * Creates an instance of the standard Menu
     * (see: com.cerner.discernabu.utils mpage-menu). This menu will display
     * search results. The Menu is anchored to the root element of the
     * MPageUI.Search class.
     * @param {string} menuId - The id of the Menu being created.
     * @param {string} anchorId - The id of the anchor to the Menu.
     * @returns {Menu} An instance of the Menu class.
     */
    var makeMenu = function(menuId, anchorId) {
        var menu = new Menu(menuId);
        menu.setTypeClass("dropdown-standard-menu");
        menu.setAnchorElementId(anchorId);
        menu.setAnchorConnectionCorner([ "bottom", "left" ]);
        menu.setContentConnectionCorner([ "top", "left" ]);
        menu.setContentParentId(anchorId);
        menu.setIsRootMenu(true);
        menu.setAutoFlipVertical(false);
        menu.setIsPersistent(true);
        //Hijack the setIsActive function so we can intelligently prevent memory leaks
        menu.setIsActive = function(activeInd) {
            //Call the base setIsActive function
            Menu.prototype.setIsActive.call(menu, activeInd);
            //If the menu is being closed, remove the menu from the global lookup
            if (!activeInd) {
                //Remove the standard menu
                MP_MenuManager.deleteMenuObject(menu.getId());
            }
        };
        return menu;
    };
    /**
     * Checks if an event was pressing the escape key.
     * @param {Event} event - The JavaScript event that occurred.
     * @returns {boolean} True if the event was pressing the escape key,
     * otherwise false.
     */
    var wasEscapeKey = function(event) {
        return event && event.keyCode === ESCAPE_KEY;
    };
    /**
     * Creates a regular expression based on a string value passed in. If
     * the ignoreCase flag is true, the ignore-case option is specified when
     * creating an instance of RegExp.
     * @param {string} value - The string (current search text) for which the
     * regular expression will be created.
     * @param {boolean} ignoreCase - A flag indicating whether the RegExp should
     * ignore case or not.
     * @returns {RegExp} A regular expression created from the provided string
     * value.
     */
    var createRegex = function(value, ignoreCase) {
        return new RegExp(value, ignoreCase ? "i" : "");
    };
    /**
     * Updates the provided menu with a new set of search results. The order of
     * updates is as follows.
     * 1). Close the menu (to prevent rapid reflowing)
     * 2). Clear all current menu items from the menu (we must show new results)
     * 3). If no results are present, return.
     * 4). Otherwise, add the new menu options to the menu based on the search
     *        results.
     * 5). Open the menu.
     * @param {Menu} menu - The Menu instance encapsulated in the MPageUI.Search
     * class.
     * @param {Array<object>} results - The array of search results as provided
     * by the consumer.
     * @param {function(object)} onSelectHandler - The function to be called
     * when a selection is made in the menu.
     * @param {RegExp} regex - The regular expression based on the current
     * search.
     * @param {function(object, function)} template - The template function as
     * provided by the consumer which will render the label of the menu
     * selection items.
     * @returns {undefined} Returns nothing.
     */
    var updateMenuWithResults = function(menu, results, onSelectHandler, regex, template) {
        closeMenu();
        clearMenuItems(menu);
        if (!results || !results.length) {
            return;
        }
        addMenuOptions(menu, results, regex, onSelectHandler, template);
        openMenu(menu);
    };
    /**
     * Handles the response for search results by the consumer. It first
     * removes the search-control-loading class from the root element of the
     * Search class then updates the menu with new menu selections based on the
     * new search results.
     * @param {MPageUI.Search} searchControl - The instance of MPageUI.Search
     * class that is being updated.
     * @param {Menu} menu - The instance of Menu that is encapsulated in the
     * MPageUI.Search class. This is the menu that will be updated with new
     * search results.
     * @param {RegExp} searchRegex - The regular expression based on the
     * current search.
     * @param {Array<object>} results - The new list of search results.
     * @param {function(object, function)} filter - The filter function provided
     * by the consumer which will filter search results.
     * @param {function(object)} onSelectHandler - The function to be called
     * when a selection is made in the Menu.
     * @param {function(object, function)} template - The consumer-provided
     * function which will render a search result's label in the Menu.
     * @returns {undefined} Returns nothing.
     */
    var handleSearchResponse = function(searchControl, menu, searchRegex, results,
                                        filter, onSelectHandler, template) {
        searchControl.getRootElement().removeClass("search-control-loading");
        if (!searchControl.getValue()) {
            return;
        }
        updateMenuWithResults(
            menu,
            filterValues(filter, searchRegex, results),
            onSelectHandler,
            searchRegex,
            template
        );
    };
    /**
     * Handles the response for search results in the case that there was an
     * error (the promise was rejected). In this scenario, the results menu
     * is closed, the loading state styling is removed, and an error-state
     * styling is applied to the search control.
     * @param {MPageUI.Search} searchControl - The instance of the Search being
     * updated.
     * @returns {undefined} Returns nothing.
     */
    var handleErrorResponse = function(searchControl) {
        closeMenu();
        searchControl.getRootElement()
            .removeClass("search-control-loading")
            .addClass("search-control-error");
    };
    /**
     * Updates the search results when the input of the MPageUI.Search class
     * changes. This will first add the search-control-loading class to the root
     * element of the MPageUI.Search class then will make the call to the
     * consumer-provided provider function. The provider function should
     * retrieve a set of search results and return a Promise for the results.
     * When the promise is resolved, the MPageUI.Search class will handle the
     * new set of search results.
     * @param {MPageUI.Search} searchControl - The instance of MPageUI.Search
     * that is being updated.
     * @param {function(string)} provider - The function that is expected to
     * return a promise of a set of search results.
     * @param {function(object, function)} filter - The consumer-provided filter
     * function.
     * @param {{
	 * 		ignoreCase: boolean
	 * }} options - The set of options for the MPageUI.Search instance. The only
     * value used when updated search results is the ignoreCase flag which will
     * alter the regular expression created via createRegex.
     * @param {Menu} menu - The instance of the Menu class that is encapsulated
     * in the MPageUI.Search class instance.
     * @param {function} onSelectHandler - The function that will be triggered
     * when a selection is made from the Menu.
     * @param {function(object, function)} template - The consumer-provided
     * function which will render a search result's label in the Menu.
     * @returns {undefined} Returns nothing.
     */
    var updateSearch = function(searchControl, provider, filter, options, menu,
                                onSelectHandler, template) {
        //Add a loading class
        searchControl.getRootElement()
            .removeClass("search-control-error")
            .addClass("search-control-loading");
        /*
         * The provider function returns a promise of a set of results.
         */
        provider(searchControl.getValue()).then(function(results) {
            handleSearchResponse(
                searchControl, menu,
                createRegex(searchControl.getValue(), options.ignoreCase),
                results, filter, onSelectHandler, template
            );
        }, function() {
            handleErrorResponse(
                searchControl
            );
        });
    };
    return MPageUI.createClass({
        emitter: true,
        /**
         * Called upon initialization of an instance of MPageUI.Search. It
         * serves as the constructor to the MPageUI.Search. The necessary
         * member variables are initialized.
         * @private
         * @returns {undefined} Returns nothing.
         */
        init: function() {
            this.m_filter = null;
            this.m_menu = makeMenu(this.m_id + "Menu", this.m_id);
            this.m_options = {
                ignoreCase: true,
                label: "",
                placeholder: "",
                required: false,
                throttle: 50
            };
            this.m_provider = null;
            this.m_template = null;
            //Encapsulate an instance of the TextControl
            this.m_textControl = makeTextControl(
                this.m_options,
                this.handleInput.bind(this),
                this.handleKeyUp.bind(this),
                this.handleFocus.bind(this)
            );
            this.m_timeout = null;
        },
        /**
         * Handles the focus event on the encapsulated TextControl class.
         * If no value is currently in the search, simply return. Otherwise,
         * a full update is made to the search results.
         * @private
         * @returns {undefined} Returns nothing.
         */
        handleFocus: function() {
            if (!this.getValue()) {
                return;
            }
            updateSearch(
                this, this.m_provider, this.m_filter, this.m_options, this.m_menu,
                this.handleSelect.bind(this), this.m_template
            );
        },
        /**
         * Handles the keyup event on the encapsulated TextControl class. If
         * the event was pressing the escape key, the menu is closed.
         * @param {Event} e - The JavaScript keyup event.
         * @private
         * @returns {undefined} Returns nothing.
         */
        handleKeyUp: function(e) {
            if (wasEscapeKey(e)) {
                closeMenu();
            }
        },
        /**
         * Handles the input event on the encapsulated TextControl class. If
         * no value is currently in the search, the menu is closed and the
         * function returns. This function throttles the input to ensure that
         * requests are not fired rapidly; the throttle value is configurable.
         * @param {string} currentValue - The current string value in the
         * TextControl.
         * @private
         * @returns {undefined} Returns nothing.
         */
        handleInput: function(currentValue) {
            clearTimeout(this.m_timeout);
            this.m_timeout = setTimeout(function() {
                if (!currentValue) {
                    closeMenu();
                    return;
                }
                updateSearch(
                    this, this.m_provider, this.m_filter, this.m_options, this.m_menu,
                    this.handleSelect.bind(this), this.m_template
                );
            }.bind(this), this.m_options.throttle);
        },
        /**
         * This function handles the event in which a selection is made from
         * the Menu of search results. It emits the "select" event, providing
         * the selected result.
         * @param {object} selection - The selection that was made.
         * @private
         * @returns {undefined} Returns nothing.
         */
        handleSelect: function(selection) {
            this.emit("select", selection);
        },
        /**
         * Sets the options on the MPageUI.Search class. It merges the new
         * options with existing options. Since the options can affect the
         * encapsulated TextControl, a call is made to update the TextControl
         * with the new options.
         * @param {{
		 * 		ignoreCase: boolean,
		 * 		label: string,
		 *		placeholder: string,
		 *		required: boolean,
		 *		throttle: number
		 * }} options - The set of options for the MPageUI.Search class.
         * @returns {MPageUI.Search} Returns self.
         */
        setOptions: function(options) {
            this.m_options = objectAssign(this.m_options, options);
            updateTextControl(this.m_textControl, options);
            return this;
        },
        /**
         * Sets the value of the encapsulated TextControl.
         * @param {string} value - The string value to be set in the search
         * input.
         * @returns {MPageUI.Search} Returns self.
         */
        setValue: function(value) {
            this.m_textControl.setCurrentValue(value);
            return this;
        },
        /**
         * Retrieves the current value from the encapsulated TextControl.
         * @returns {string} The current value in the TextControl.
         */
        getValue: function() {
            return this.m_textControl.getCurrentValue();
        },
        /**
         * Sets the filter function for the MPageUI.Search class. This function
         * should provide a "result" and "test" parameter where "result" is a
         * single search result being tested for filtering and "test" is a
         * helper function that can determine if a value passes filtering.
         * For example.
         * ...
         * s.setFilter(function(result, test){
		 *		test(result.EVENT_CD_DISP);
		 * });
         * ...
         * @param {function(object, function)} filter - The consumer-provided
         * filter function which tests that a result (as retrieved from the
         * provider) passes filtering. The first parameter is a single result
         * as retrieved by the provider. The second function parameter is a
         * helper "test" function which takes in a string value and determines
         * if it matches the regular expression in the search.
         * @returns {MPageUI.Search} Returns self.
         */
        setFilter: function(filter) {
            this.m_filter = filter;
            return this;
        },
        /**
         * Sets the highlight function for the MPageUI.Search class. This
         * function should provide a "result" and "highlight" parameter where
         * "result" is a single search result being rendered and "highlight" is
         * a helper function that will wrap text that matches the search regex
         * in standard tags (<b>) to achieve a highlight effect. For example
         * ...
         * s.setTemplate(function(result, highlight){
		 *		return "<div>" + highlight(result.EVENT_CD_DISP) + "</div>";
		 * });
         * ...
         * @param {function(object, function)} template - The consumer-provided
         * template function which renders a result into a label that will be
         * displayed in a MenuSelection. The first parameter is a single result
         * as retrieved by the provider. The second function parameter is a
         * helper "highlight" function which takes in a string value and
         * highlights portions of the string that match the current search
         * regular expression.
         * @returns {MPageUI.Search} Returns self.
         */
        setTemplate: function(template) {
            this.m_template = template;
            return this;
        },
        /**
         * Sets the provider function for the MPageUI.Search class. This
         * function should return a Promise for a set of search results. The
         * provider function should provide a "search" parameter which will
         * be populated with the current search text. For example.
         * ...
         * s.setProvider(function(search){
		 *		return new Promise(function(resolve, reject){
		 *			//Script request using the search value
		 *			resolve(searchResults);
		 *		});
		 * });
         * @param {function(string)} provider - The consumer-provided provider
         * function which uses the current search text to retrieve a set of
         * search results. The "search" parameter is simply the current string
         * value in the search.
         * @returns {MPageUI.Search} Returns self.
         */
        setProvider: function(provider) {
            this.m_provider = provider;
            return this;
        },
        /**
         * Renders the MPageUI.Search class as an html string.
         * @returns {string} The MPageUI.Search class rendered as an html
         * string.
         */
        render: function() {
            return (
                "<div id='" + this.m_id + "' class='search-control'>" +
                this.m_textControl.render() +
                "</div>"
            );
        },
        /**
         * Attaches events on the encapsulated TextControll class.
         * @returns {undefined} Returns nothing.
         */
        attachEvents: function() {
            this.m_textControl.attachEvents();
        }
    });
})();

/* global MPageUI */
/* global objectAssign */
MPageUI.PANEL_OPTIONS = {
    BEHAVIOR: {
        OVERLAY: "overlay",
        SQUISH: "squish"
    },
    SIDE: {
        START: "start",
        END: "end"
    },
    WIDTH: {
        SMALL: "panel-small",
        MEDIUM: "panel-medium",
        LARGE: "panel-large"
    }
};

/**
 * The MPageUI.PanelLayout class. A panel layout is a component that wraps
 * a content and panel component. The content component is any content that
 * is considered the main view. The panel component is a view that is typically
 * related to a selection from the content component but shown within a panel.
 * @class MPageUI.PanelLayout
 */
MPageUI.PanelLayout = MPageUI.createClass({
    /**
     * Emits
     * panelToggleExpand - When the panel expanded state is toggled
     * panelClose - When the panel is closed
     * panelOpen - When the panel is opened
     */
    emitter: true,
    /**
     * Called upon initialization of an instance of PanelLayout. It serves
     * as the constructor to the PanelLayout.
     * @private
     * @returns {undefined} Returns nothing.
     */
    init: function() {
        this.m_dimensions = {
            height: 0
        };
        this.m_expanded = false;
        this.m_open = false;
        this.m_options = {
            behavior: MPageUI.PANEL_OPTIONS.BEHAVIOR.OVERLAY,
            side: MPageUI.PANEL_OPTIONS.SIDE.END,
            width: MPageUI.PANEL_OPTIONS.WIDTH.MEDIUM
        };
        this.m_panel = null;
        this.m_content = null;
    },
    /**
     * This function will merge the specified options with the current panel
     * options. If the layout has already been rendered, then the necessary
     * styles will be overridden to reflect immediately in the DOM.
     * @param {{}} options - The options to be set on the layout.
     * @public
     * @returns {undefined} Returns nothing.
     */
    setOptions: function(options) {
        var $root = this.getRootElement();
        if (options.width) {
            $root.removeClass(this.m_options.width);
        }
        objectAssign(this.m_options, options);
        $root.attr("data-slide-panel-behavior", this.m_options.behavior);
        $root.attr("data-slide-panel-side", this.m_options.side);
        $root.addClass(options.width);
        return this;
    },
    /**
     * Handles resizing the panel layout. This function should be called
     * by a higher level component that is aware of how much space to allocate
     * to the panel layout.
     * @param { { width: number, height: number } } dimensions - The dimensions
     * provided to the PanelLayout indicating how much space is available to the
     * panel layout. These dimensions could come from anywhere but are typically
     * calculated based on the MPage view.
     * @public
     * @returns {undefined} Returns nothing.
     */
    resize: function(dimensions) {
        if (!dimensions) {
            dimensions = this.m_dimensions;
        }
        this.m_dimensions = dimensions;
        /*
         * The layout will automatically resize the content component.
         */
        this.m_content.resize(dimensions);
        /*
         * Attempting to resize the panel layout while closed will cause
         * undesired behavior. It can also have performance implications.
         */
        if (!this.m_open) {
            return;
        }
        var offsetHeight = function(element) {
            return (element && element.length) ? element[ 0 ].offsetHeight : 0;
        };
        var height = 0;
        if (this.m_expanded) {
            /*
             * When expanded, the height of the panel is the minimum of...
             * 1). The available height as provided by dimensions
             * 2). The absolute height of the panel content
             * 			This is to make the panel tall enough to eliminate scrolling
             */
            height = Math.min(dimensions.height, this.m_panel.absoluteHeight());
            this.getRootElement().css({ "min-height": height + "px" });
            this.m_panel.resize({
                maxHeight: dimensions.height,
                height: height
            });
        }
        else if (this.m_open) {
            /*
             * When the panel is open, the height of the panel is (1/2) the available
             * height, by default.
             */
            var contentHeight = offsetHeight(this.m_content.getRootElement());
            var panelAbsoluteHeight = this.m_panel.absoluteHeight();
            var panelMin = Math.min(dimensions.height / 2, panelAbsoluteHeight);
            height = Math.max(panelMin, contentHeight);
            this.getRootElement().css({ "min-height": height + "px" });
            this.m_panel.resize({
                maxHeight: dimensions.height,
                height: height
            });
        }
    },
    /**
     * Handles the expand event for the panel. It will trigger a resize.
     * @private
     * @returns {undefined} Returns nothing.
     */
    handlePanelExpand: function() {
        this.m_expanded = !this.m_expanded;
        this.resize(this.m_dimensions);
        this.emit("panelToggleExpand", this.m_expanded);
    },
    /**
     * Handles the close event for the panel by making a call to closePanel.
     * This is triggered when the layout receives the event when the close
     * is triggered on the panel object.
     * @private
     * @returns {undefined} Returns nothing.
     */
    handlePanelClose: function() {
        this.closePanel();
    },
    /**
     * Opens the panel then triggers a resize with the last known dimensions.
     * @public
     * @returns {undefined} Returns nothing.
     */
    openPanel: function() {
        this.m_open = true;
        this.getRootElement().addClass("slide-panel-open");
        this.resize(this.m_dimensions);
        this.emit("panelOpen");
    },
    /**
     * Closes the panel.
     * @public
     * @returns {undefined} Returns nothing.
     */
    closePanel: function() {
        this.m_open = false;
        this.getRootElement().removeClass("slide-panel-open").css({
            "min-height": "0px"
        });
        this.emit("panelClose");
    },
    /**
     * Check to see if the panel is currently open.
     * @public
     * @returns {boolean} True if the panel is open, otherwise false.
     */
    isPanelOpen: function() {
        return this.m_open;
    },
    /**
     * Returns the component to be used as the content for the panel layout.
     * @returns {MPageUI.UIComponent|null} The MPageUI.UIComponent being used as the
     * content of the panel layout.
     */
    getContent: function() {
        return this.m_content;
    },
    /**
     * Sets the component to be rendered into the content of the panel layout.
     * This content is typically what drives the panel (such as a table).
     * @param {MPageUI.UIComponent} contentComponent - Any component which is
     * to be rendered into the content portion of the layout.
     * @returns {MPageUI.PanelLayout} Returns self.
     */
    setContent: function(contentComponent) {
        this.m_content = contentComponent;
        return this;
    },
    /**
     * Returns the component to be used as the panel for the panel layout.
     * @returns {MPageUI.UIComponent|null} The MPageUI.UIComponent being used as the
     * panel of the panel layout.
     */
    getPanel: function() {
        return this.m_panel;
    },
    /**
     * Sets the component to be rendered into the panel of the panel layout.
     * This function also wires up an event between the PanelInterface and
     * the PanelLayout so the PanelLayout is notified when the panel is expanded.
     * This is necessary because the PanelLayout is responsible for applying
     * a minimum height to the layout.
     * @param {MPageUI.PanelInterface} panelComponent - A component that
     * implements the PanelInterface.
     * @returns {MPageUI.PanelLayout} Returns self.
     */
    setPanel: function(panelComponent) {
        this.m_panel = panelComponent;
        this.m_panel.on("panelToggleExpand", this.handlePanelExpand.bind(this));
        this.m_panel.on("panelClose", this.handlePanelClose.bind(this));
        return this;
    },
    /**
     * Renders the PanelLayout as an html string. The render function expects
     * that a content and panel component have been provided to the layout. The
     * content component is rendered into the 'slide-panel-detail' element and
     * the panel component is rendered into the 'slide-panel-master' element.
     * The 'slide-panel-master' is the element that serves as the panel.
     * @returns {string} The PanelLayout rendered as an html string.
     */
    render: function() {
        var classes = "panel-layout " + this.m_options.width;
        var html = "<div id='" + this.m_id + "' data-slide-panel-behavior='" + this.m_options.behavior + "' data-slide-panel-side='" + this.m_options.side + "' class='" + classes + "'>";
        html += "<div class='slide-panel-detail'>" + this.m_content.render() + "</div>";
        html += "<div class='slide-panel-master'>" + this.m_panel.render() + "</div>";
        return html + "</div>";
    },
    /**
     * Attaches the events to both the content and panel component. This function
     * is expected to be called after render.
     * @returns {undefined} Returns nothing.
     */
    attachEvents: function() {
        this.m_content.attachEvents();
        this.m_panel.attachEvents();
    }
});

/**
 * The PanelLayoutInterface is intended as a mixin for developers that are
 * creating a panel layout. This interface provides a level of indirection
 * between the implementation of the PanelLayout and the content that developers
 * wish to inject into the panel layout.
 * @interface PanelLayoutInterface
 */
MPageUI.PanelLayoutInterface = {
    /**
     * The init function to be mixed into an MPageUI.UIComponent. This will
     * merge with any init function defined on the UIComponent. This init
     * function will be called first.
     *
     * This init function initializes an instance of the PanelLayout and
     * interfaces the necessary events to ensure they are propagated out from
     * the UIComponent that has mixed in this interface.
     * @returns {undefined} Returns nothing.
     */
    init: function() {
        this.m_layout = new MPageUI.PanelLayout();
        this.m_layout.on("panelClose", function() {
            this.emit("panelClose");
        }.bind(this));
        this.m_layout.on("panelOpen", function() {
            this.emit("panelOpen");
        }.bind(this));
        this.m_layout.on("panelToggleExpand", function(expanded) {
            this.emit("panelToggleExpand", expanded);
        }.bind(this));
    },
    /**
     * Calls set options on the encapsulated layout.
     * @param {{}} options - The options to be set on the encapsulated layout.
     * @returns {undefined} Returns nothing.
     */
    setOptions: function(options) {
        this.m_layout.setOptions(options);
    },
    /**
     * Calls openPanel on the encapsulated layout.
     * @returns {undefined} Returns nothing.
     */
    openPanel: function() {
        this.m_layout.openPanel();
    },
    /**
     * Calls closePanel on the encapsulated layout.
     * @returns {undefined} Returns nothing.
     */
    closePanel: function() {
        this.m_layout.closePanel();
    },
    /**
     * Gets the MPageUI.UIComponent that was set as the content component for
     * the encapsulated layout.
     * @returns {MPageUI.UIComponent|null} The content component.
     */
    getContent: function() {
        return this.m_layout.getContent();
    },
    /**
     * Sets the MPageUI.UIComponent that is to be used as the content component
     * for the encapsulated layout.
     * @param {MPageUI.UIComponent} content - The MPageUI.UIComponent to be
     * used as the content component for the encapsulated layout.
     * @returns {MPageUI.UIComponent} Returns self.
     */
    setContent: function(content) {
        this.m_layout.setContent(content);
        return this;
    },
    /**
     * Gets the MPageUI.UIComponent that was set as the panel component for
     * the encapsulated layout.
     * @returns {MPageUI.UIComponent|null} The panel component.
     */
    getPanel: function() {
        return this.m_layout.getPanel();
    },
    /**
     * Sets the MPageUI.UIComponent that is to be used as the panel component
     * for the encapsulated layout.
     * @param {MPageUI.UIComponent} panel - The MPageUI.UIComponent to be
     * used as the panel component for the encapsulated layout.
     * @returns {MPageUI.UIComponent} Returns self.
     */
    setPanel: function(panel) {
        this.m_layout.setPanel(panel);
        return this;
    },
    /**
     * Calls render on the encapsulated layout.
     * @returns {string} The layout rendered as an html string.
     */
    render: function() {
        return this.m_layout.render();
    },
    /**
     * Calls resize on the encapsulated layout.
     * @param {{height: number}} dimensions - The dimensions to be used for
     * resizing.
     * @returns {undefined} Returns nothing.
     */
    resize: function(dimensions) {
        this.m_layout.resize(dimensions);
    },
    /**
     * Calls attachEvents on the encapsulated layout.
     * @returns {undefined} Returns nothing.
     */
    attachEvents: function() {
        this.m_layout.attachEvents();
    }
};

/**
 * The MPageUI.ComponentPanel class. A ComponentPanel is a standard component
 * for showing MPageUI component content in a panel. The ComponentPanel is
 * composed of standard sections (order matters).
 * 1). Actions
 * 2). Title
 * 3). Alerts
 * 4). Body
 * Each of the standard sections is expected to be an instance of an MPageUI
 * component.
 * @class MPageUI.ComponentPanel
 */
MPageUI.ComponentPanel = (function() {
    /**
     * Helper function to get the offset height of a jQuery element, if the
     * element is defined, otherwise it returns 0.
     * @param {jQuery} element - The jQuery element for which the offset height
     * will be returned.
     * @returns {number} The offset height of the element.
     */
    var offsetHeight = function(element) {
        return (element && element.length) ? element[ 0 ].offsetHeight : 0;
    };
    /**
     * Helper function to get the scroll height of a jQuery element, if the
     * element is defined, otherwise it returns 0.
     * @param {jQuery} element - The jQuery element for which the scroll height
     * will be returned.
     * @returns {number} The scroll height of the element.
     */
    var scrollHeight = function(element) {
        return (element && element.length) ? element[ 0 ].scrollHeight : 0;
    };
    /**
     * Attempts to call attachEvents on the component.
     * @param {MPageUI.UIComponent} component - The component for which to call
     * attachEvents.
     * @returns {undefined} Returns nothing.
     */
    var tryAttach = function(component) {
        if (component) {
            component.attachEvents();
        }
    };
    return MPageUI.createClass({
        /**
         * Emits
         * panelToggleExpand - When the expander is toggled.
         * panelClose - When the close icon is clicked on the panel
         */
        emitter: true,
        /**
         * Called upon initialization of an instance of ComponentPanel. It
         * serves as the constructor to the ComponentPanel. The necessary
         * member variables are initialized.
         * @private
         * @returns {undefined} Returns nothing.
         */
        init: function() {
            this.m_dimensions = {
                height: 0
            };
            this.m_expanded = false;

            //Panel sub-components
            this.m_actionsComponent = null;
            this.m_titleComponent = null;
            this.m_alertsComponent = null;
            this.m_bodyComponent = null;
        },
        /**
         * This function handles when the panel expander is clicked. It will
         * toggle the expanded state, update the UI of the panel, then fire
         * the 'expand' event.
         * @emits 'expand' - An expand event is emitted with the value of the
         * expanded state.
         * @returns {undefined} Returns nothing.
         */
        handlePanelExpand: function() {
            this.m_expanded = !this.m_expanded;
            if (this.m_expanded) {
                this.getRootElement().addClass("panel-expanded");
            }
            else {
                this.getRootElement().removeClass("panel-expanded");
            }
            this.emit("panelToggleExpand", this.m_expanded);
        },
        /**
         * This function handles when the panel close is clicked. It simply
         * fires the 'panelClose' event. The reason is that the panel alone
         * is not responsible for closing itself. Some parent (or containing)
         * class is responsible for closing the panel.
         * @emits 'panelClose' - An event indicating that the panel is to
         * be closed.
         * @returns {undefined} Returns nothing.
         */
        handlePanelClose: function() {
            this.emit("panelClose");
        },
        /**
         * Retrieves the actions component for the panel.
         * @returns {MPageUI.UIComponent|null} The component used as the actions
         * section of the panel. Can be null.
         */
        getActionsComponent: function() {
            return this.m_actionsComponent;
        },
        /**
         * Sets the component to be used in the actions section of the panel.
         * @param {MPageUI.UIComponent} actionsComponent - The component to
         * be used as the actions section of the panel.
         * @returns {MPageUI.ComponentPanel} Returns self.
         */
        setActionsComponent: function(actionsComponent) {
            this.m_actionsComponent = actionsComponent;
            return this;
        },
        /**
         * Retrieves the title component for the panel.
         * @returns {MPageUI.UIComponent|null} The component used as the title
         * section of the panel. Can be null.
         */
        getTitleComponent: function() {
            return this.m_titleComponent;
        },
        /**
         * Sets the component to be used in the title section of the panel.
         * @param {MPageUI.UIComponent} titleComponent - The component to be
         * used as the title section of the panel.
         * @returns {MPageUI.ComponentPanel} Returns self.
         */
        setTitleComponent: function(titleComponent) {
            this.m_titleComponent = titleComponent;
            return this;
        },
        /**
         * Retrieves the alerts component for the panel.
         * @returns {MPageUI.UIComponent|null} The component used as the alerts
         * section of the panel. Can be null.
         */
        getAlertsComponent: function() {
            return this.m_alertsComponent;
        },
        /**
         * Sets the component to be used in the alerts section of the panel.
         * @param {MPageUI.UIComponent} alertsComponent - The component to be
         * used as the alerts section of the panel.
         * @returns {MPageUI.ComponentPanel} Returns self.
         */
        setAlertsComponent: function(alertsComponent) {
            this.m_alertsComponent = alertsComponent;
            return this;
        },
        /**
         * Retrieves the body component for the panel.
         * @returns {MPageUI.UIComponent|null} The component used as the body
         * section of the panel. Can be null.
         */
        getBodyComponent: function() {
            return this.m_bodyComponent;
        },
        /**
         * Sets the component to be used in the body section of the panel.
         * @param {MPageUI.UIComponent} bodyComponent - The component to be
         * used as the body section of the panel.
         * @returns {MPageUI.ComponentPanel} Returns self.
         */
        setBodyComponent: function(bodyComponent) {
            this.m_bodyComponent = bodyComponent;
            return this;
        },
        /**
         * Calculates the absolute height of the panel; this is the height of
         * all sections of the panel as well as the scroll height of the body
         * of the panel. This estimates how tall the panel would be if it were
         * stretched such that no scrolling occurred. It is considered an
         * estimation because the nature of stretching content to remove a scroll
         * bar can in turn affect the height of the content within the scrollable
         * area.
         *
         * This calculation sums the height of the following elements.
         * 1). Offset height of the actions section
         * 2). Offset height of the title section
         * 3). Offset height of the alerts section
         * 4). Scroll height of the body section
         * 5). Offset height of the panel expander
         *
         * @returns {number} The estimated absolute height of the panel.
         */
        absoluteHeight: function() {
            var $root = this.getRootElement();
            return (
                offsetHeight($root.find(".component-panel-actions-section")) +
                offsetHeight($root.find(".component-panel-title-section")) +
                offsetHeight($root.find(".component-panel-alerts-section")) +
                scrollHeight($root.find(".component-panel-body-section")) +
                offsetHeight($root.find(".panel-expander"))
            );
        },
        /**
         * Handles resizing the component panel. This function should be called
         * by a higher level component that is aware of how much space to allocate
         * to the component panel.
         *
         * If no dimensions are provided, the ComponentPanel will use the last
         * known dimensions that it was provided.
         *
         * @param { { width: number, height: number, maxHeight: number} } dimensions - The dimensions
         * provided to the ComponentPanel indicating how much space is available to the
         * component panel.
         * @returns {undefined} Returns nothing.
         */
        resize: function(dimensions) {
            //If no dimensions are provided, use the last known dimensions
            if (!dimensions) {
                dimensions = this.m_dimensions;
            }
            this.m_dimensions = dimensions;
            var $root = this.getRootElement();
            var $expander = $root.find(".panel-expander");
            var actionsHeight = offsetHeight($root.find(".component-panel-actions-section"));
            var titleHeight = offsetHeight($root.find(".component-panel-title-section"));
            var alertsHeight = offsetHeight($root.find(".component-panel-alerts-section"));
            var bodyHeight = dimensions.height - (actionsHeight + titleHeight + alertsHeight - 1);
            var bodyScrollHeight = scrollHeight($root.find(".component-panel-body-section"));
            //var bodyScrollHeight = $root.find('.component-panel-body-section').prop('scrollHeight');
            var expanderHeight = 0;
            /*
             * The panel will show the expander under the following conditions
             * 1). If the body of the panel would scroll AND the panel has not yet reached its maximum height.
             * 2). The panel is currently expanded.
             *
             * The panel will hide the expander under the following conditions
             * 1). The panel is NOT expanded AND the body of the panel will not be scrolling.
             */
            if (((bodyHeight < bodyScrollHeight) && (dimensions.height < dimensions.maxHeight)) || (this.m_expanded)) {
                $expander.show();
                expanderHeight = offsetHeight($expander);
            }
            else if (!this.m_expanded) {
                $expander.hide();
            }
            //Apply a max height to the body of the panel to enable scrolling
            $root.find(".component-panel-body-section").css({ "max-height": Math.max(0, (bodyHeight - expanderHeight)) + "px" });
        },
        /**
         * Renders the ComponentPanel as an html string. It wraps the standard
         * sections of the panel, followed by the panel expander.
         * @returns {string} The ComponentPanel rendered as an html string.
         */
        render: function() {
            var renderActions = function() {
                return this.m_actionsComponent ? "<div class='component-panel-actions-section'>" + this.m_actionsComponent.render() + "</div>" : "";
            }.bind(this);
            var renderTitle = function() {
                return this.m_titleComponent ? "<div class='component-panel-title-section'>" + this.m_titleComponent.render() + "</div>" : "";
            }.bind(this);
            var renderAlerts = function() {
                return this.m_alertsComponent ? "<div class='component-panel-alerts-section'>" + this.m_alertsComponent.render() + "</div>" : "";
            }.bind(this);
            var renderBody = function() {
                return this.m_bodyComponent ? "<div class='component-panel-body-section'>" + this.m_bodyComponent.render() + "</div>" : "";
            }.bind(this);
            var html = "<div id='" + this.m_id + "' class='component-panel'>";
            html += "<div class='panel-close'></div>";
            html += renderActions();
            html += renderTitle();
            html += renderAlerts();
            html += renderBody();
            html += "<div class='panel-expander'><span></span></div>";
            return html + "</div>";
        },
        /**
         * Attaches the events to each of the sections of the panel (if provided).
         * It also attaches a click event to the expander which ultimately
         * calls handlePanelExpand.
         * @returns {undefined} Returns nothing.
         */
        attachEvents: function() {
            tryAttach(this.m_actionsComponent);
            tryAttach(this.m_titleComponent);
            tryAttach(this.m_alertsComponent);
            tryAttach(this.m_bodyComponent);
            this.getRootElement().find(".panel-expander").on("click.mpageui", function() {
                this.handlePanelExpand();
            }.bind(this));
            this.getRootElement().find(".panel-close").on("click.mpageui", function() {
                this.handlePanelClose();
            }.bind(this));
        }
    });
})();

/**
 * The PanelInterface is intended as a mixin for developers that are creating
 * a panel. This interface provides a level of indirection between the
 * implementation of the ComponentPanel and the content that developers wish
 * to inject into the panel.
 * @interface PanelInterface
 */
MPageUI.PanelInterface = {
    /**
     * The init function to be mixed into an MPageUI.UIComponent. This will
     * merge with any init function defined on the UIComponent. This init
     * function will be called first.
     *
     * This init function initializes an instance of the ComponentPanel and
     * interfaces events from the ComponentPanel so they can be propogated out
     * of the UIComponent that has mixed in this interface.
     * @returns {undefined} Returns nothing.
     */
    init: function() {
        this.m_panel = new MPageUI.ComponentPanel();
        /*
         * The interface wraps an instance of ComponentPanel which fires the
         * 'expand' and 'panelClose' events. We want to ensure this is propagated out such that
         * listeners can subscribe to the events on the PanelInterface
         * rather that directly through the ComponentPanel object.
         */
        this.m_panel.on("panelToggleExpand", function(expanded) {
            this.emit("panelToggleExpand", expanded);
        }.bind(this));
        this.m_panel.on("panelClose", function() {
            this.emit("panelClose");
        }.bind(this));
    },
    /**
     * Sets the actions component for the panel.
     * @param {MPageUI.UIComponent} actionsComponent - The MPageUI.UIComponent
     * to be used in the actions section of the panel.
     * @returns {MPageUI.UIComponent} Returns the UIComponent that has mixed
     * in this interface.
     */
    setActions: function(actionsComponent) {
        this.m_panel.setActionsComponent(actionsComponent);
        return this;
    },
    /**
     * Sets the title component for the panel.
     * @param {MPageUI.UIComponent} titleComponent - The MPageUI.UIComponent
     * to be used in the title section of the panel.
     * @returns {MPageUI.UIComponent} Returns the UIComponent that has mixed
     * in this interface.
     */
    setTitle: function(titleComponent) {
        this.m_panel.setTitleComponent(titleComponent);
        return this;
    },
    /**
     * Sets the alerts component for the panel.
     * @param {MPageUI.UIComponent} alertsComponent - The MPageUI.UIComponent
     * to be used in the alerts section of the panel.
     * @returns {MPageUI.UIComponent} Returns the UIComponent that has mixed
     * in this interface.
     */
    setAlerts: function(alertsComponent) {
        this.m_panel.setAlertsComponent(alertsComponent);
        return this;
    },
    /**
     * Sets the body component for the panel.
     * @param {MPageUI.UIComponent} bodyComponent - The MPageUI.UIComponent
     * to be used in the body section of the panel.
     * @returns {MPageUI.UIComponent} Returns the UIComponent that has mixed
     * in this interface.
     */
    setBody: function(bodyComponent) {
        this.m_panel.setBodyComponent(bodyComponent);
        return this;
    },
    /**
     * Returns the MPageUI.UIComponent being used as the actions section in the
     * panel. You should not call this unless you absolutely need to.
     * @returns {MPageUI.UIComponent} The MPageUI.UIComponent being used as the
     * actions section in the panel.
     */
    getActions: function() {
        return this.m_panel.getActionsComponent();
    },
    /**
     * Returns the MPageUI.UIComponent being used as the title section in the
     * panel. You should not call this unless you absolutely need to.
     * @returns {MPageUI.UIComponent} The MPageUI.UIComponent being used as the
     * title section in the panel.
     */
    getTitle: function() {
        return this.m_panel.getTitleComponent();
    },
    /**
     * Returns the MPageUI.UIComponent being used as the alerts section in the
     * panel. You should not call this unless you absolutely need to.
     * @returns {MPageUI.UIComponent} The MPageUI.UIComponent being used as the
     * alerts section in the panel.
     */
    getAlerts: function() {
        return this.m_panel.getAlertsComponent();
    },
    /**
     * Returns the MPageUI.UIComponent being used as the body section in the
     * panel. You should not call this unless you absolutely need to.
     * @returns {MPageUI.UIComponent} The MPageUI.UIComponent being used as the
     * body section in the panel.
     */
    getBody: function() {
        return this.m_panel.getBodyComponent();
    },
    /**
     * Retrieves the absolute height of the encapsulated panel.
     * @returns {number} The absolute height of the encapsulated panel.
     */
    absoluteHeight: function() {
        return this.m_panel.absoluteHeight();
    },
    /**
     * Makes the call to resize on the encapsulated panel.
     * @param { { width: number, height: number  } } dimensions - The dimensions
     * provided to the PanelInterface indicating how much space is available to the
     * panel.
     * @returns {undefined} Returns nothing.
     */
    resize: function(dimensions) {
        this.m_panel.resize(dimensions);
    },
    /**
     * Makes the call to render on the encapsulated panel.
     * @returns {string} The encapsulated panel rendered as an html string.
     */
    render: function() {
        return this.m_panel.render();
    },
    /**
     * Makes the call to attachEvents on the encapsulated panel.
     * @returns {undefined} Returns nothing.
     */
    attachEvents: function() {
        this.m_panel.attachEvents();
    }
};

/**
 * The ComponentPanelActions class. The ComponentPanelActions is a standard
 * MPageUI class for rendering the actions in a ComponentPanel.
 * @class MPageUI.ComponentPanelActions
 */
MPageUI.ComponentPanelActions = (function() {
    var MAX_FACEUP_ACTIONS = 3;
    /**
     * This function takes a list of actions and maps them to a list of option
     * objects that are compatible with the MPageUI.SplitButton.prototype.addOptions
     * function.
     * @param {Array<{
	 * 		label: string,
	 * 		action: function
	 * }>} actions - The list of actions being mapped to options for the
     * SplitButton API.
     * @returns {Array<{
	 * 		label: string,
	 * 		onSelect: function,
	 *		type: number
	 * }>} An array of options to be added to the SplitButton dropdown.
     */
    var makeSplitOptions = function(actions) {
        return actions.map(function(action) {
            return {
                label: action.label,
                onSelect: action.action,
                type: MPageUI.MENU_OPTIONS.TYPE.SELECT
            };
        });
    };
    /**
     * Takes the array of actions and creates the list of face-up buttons. If
     * the number of actions exceeds the maximum face-up, only create (max-1)
     * buttons; the last face-up action will be a SplitButton.
     * @param {Array<{
	 * 		label: string,
	 * 		action: function
	 * }>} actions - The array of actions.
     * @returns {Array<MPageUI.Button>} The face-up array of MPageUI.Button
     * objects.
     */
    var makeDefaultButtons = function(actions) {
        var defaultButtons = [];
        var buttonCount = actions.length;
        /*
         * If the number of actions exceeds the maximum face-up, then only
         * create (max-1) Button objects because the remaining actions will be
         * placed in a SplitButton and its options.
         */
        if (actions.length > MAX_FACEUP_ACTIONS) {
            buttonCount = MAX_FACEUP_ACTIONS - 1;
        }
        for (var i = 0; i < buttonCount; i++) {
            defaultButtons.push(
                new MPageUI.Button()
                    .setLabel(actions[ i ].label)
                    .setOnClickCallback(actions[ i ].action)
                    .setStyle(MPageUI.BUTTON_OPTIONS.STYLE.SECONDARY)
            );
        }
        return defaultButtons;
    };
    /**
     * Takes the array of actions and conditionally creates an
     * MPageUI.SplitButton. This only occurs if the number of actions exceeds
     * the maximum face-up. If the number of actions is less than the max,
     * null is returned.
     * @param {Array<{
	 * 		label: string,
	 * 		action: function
	 * }>} actions - The array of actions.
     * @returns {MPageUI.SplitButton|null} Returns a SplitButton if the number
     * of actions exceeds the max, otherwise null.
     */
    var makeSplitButton = function(actions) {
        if (actions.length <= MAX_FACEUP_ACTIONS) {
            return null;
        }
        var split = new MPageUI.SplitButton();
        split.setStyle(MPageUI.BUTTON_OPTIONS.STYLE.SECONDARY);
        split.setLabelButtonClickCallback(actions[ MAX_FACEUP_ACTIONS - 1 ].action);
        split.setLabel(actions[ MAX_FACEUP_ACTIONS - 1 ].label);
        split.addOptions(makeSplitOptions(actions.slice(MAX_FACEUP_ACTIONS, actions.length)));
        return split;
    };
    /**
     * Small helper function to add a button to an array and return the array.
     * @param {Array<MPageUI.Button>} array - The starting array of buttons.
     * @param {MPageUI.Button|MPageUI.SplitButton} button - The button to be
     * added to the array.
     * @returns {Array<MPageUI.Button>} The array with the new button added.
     */
    var addButton = function(array, button) {
        if (button) {
            array.push(button);
        }
        return array;
    };
    /**
     * Takes an array of actions and creates an array of MPageUI.Button objects
     * to be used as actions.
     * @param {Array<{
	 * 		label: string,
	 * 		action: function
	 * }>} actions - The array of actions to be transformed to MPageUI.Button
     * objecs.
     * @returns {Array<MPageUI.Button|MPageUI.SplitButton>} The array of
     * MPageUI.Button objects.
     */
    var makeButtons = function(actions) {
        return addButton(makeDefaultButtons(actions), makeSplitButton(actions));
    };
    /**
     * Takes an array of MPageUI.Button objects and renders them all together
     * as an html string.
     * @param {Array<MPageUI.Button|MPageUI.SplitButton>} buttons - The array
     * of buttons to be rendered.
     * @returns {string} The array of buttons rendered together as an html
     * string.
     */
    var renderButtons = function(buttons) {
        return buttons.map(function(button) {
            return button.render();
        }).join("");
    };
    return MPageUI.createClass({
        /**
         * Called upon initialization of an instance of ComponentPanelActions.
         * It serves as the constructor to the ComponentPanelActions. The array
         * of buttons are initialized to an empty array.
         * @private
         * @returns {undefined} Returns nothing.
         */
        init: function() {
            this.m_buttons = [];
        },
        /**
         * Sets the actions for the ComponentPanelActions. The actions are
         * first transformed to instances of MPageUI.Button, the content is then
         * updated with the new actions. Finally, attachEvents is called.
         * @param {Array<{
		 * 		label: string,
		 * 		action: function
		 * }>} actions - The array of actions.
         * @returns {undefined} Returns nothing.
         */
        setActions: function(actions) {
            this.m_buttons = makeButtons(actions || []);
            this.getRootElement().html(renderButtons(this.m_buttons));
            this.attachEvents();
        },
        /**
         * Renders the ComponentPanelActions as an html string.
         * @returns {string} The ComponentPanelActions rendered as an html
         * string.
         */
        render: function() {
            return (
                "<div id='" + this.m_id + "' class='component-panel-actions'>" +
                renderButtons(this.m_buttons) +
                "</div>"
            );
        },
        /**
         * Calls attachEvents on each button in the ComponentPanelActions.
         * @returns {undefined} Returns nothing.
         */
        attachEvents: function() {
            this.m_buttons.forEach(function(button) {
                button.attachEvents();
            });
        }
    });
})();

/**
 * The PanelActionsInterface is intended as a mixin for developers that are
 * creating their own panel actions. This interface provides a level of
 * indirection between the implementation of the ComponentPanelActions and the
 * actions that developers wish to include in their panel.
 * @interface PanelActionsInterface
 */
MPageUI.PanelActionsInterface = (function() {
    return {
        /**
         * The init function to be mixed into an MPageUI.UIComponent. This will
         * merge with any init function defined on the UIComponent. This init
         * function will be called first.
         *
         * This init function initializes an instance of the
         * MPageUI.ComponentPanelActions class.
         * @private
         * @returns {undefined} Returns nothing.
         */
        init: function() {
            this.m_componentPanelActions = new MPageUI.ComponentPanelActions();
        },
        /**
         * Sets the array of actions on the encapsulated ComponentPanelActions.
         * @param {Array<{
		 * 		label: string,
		 * 		action: function
		 * }>} actions - The array of actions.
         * @returns {MPageUI.UIComponent} Returns the UIComponent that has mixed
         * in this interface.
         */
        setActions: function(actions) {
            this.m_componentPanelActions.setActions(actions);
            return this;
        },
        /**
         * Calls render on the encapsulated ComponentPanelActions.
         * @returns {string} The ComponentPanelActions rendered as an html
         * string.
         */
        render: function() {
            return this.m_componentPanelActions.render();
        },
        /**
         * Calls attachEvents on the encapsulated ComponentPanelActions.
         * @returns {undefined} Returns nothing.
         */
        attachEvents: function() {
            this.m_componentPanelActions.attachEvents();
        }
    };
})();

/**
 * The ComponentPanelTitle class. The ComponentPanelTitle is a standard MPageUI
 * class for rendering the title of a component panel.
 * @class MPageUI.ComponentPanelTitle
 */
MPageUI.ComponentPanelTitle = (function() {
    /**
     * Maps an array of subtitles into an html string.
     * @param {Array<{
	 * 		primary: string,
	 * 		secondary: string
	 * }>} subTitles - The array of subtitles.
     * @returns {string} An html string of all subtitles rendered together.
     */
    var renderSubTitles = function(subTitles) {
        return (subTitles || []).map(function(subTitle) {
            return (
                "<div class='component-panel-title-row'>" +
                "<div>" + (subTitle.primary || "") + "</div>" +
                "<div>" + (subTitle.secondary || "") + "</div>" +
                "</div>"
            );
        }).join("");
    };
    return MPageUI.createClass({
        /**
         * Called upon initialization of an instance of ComponentPanelTitle. It
         * serves as the constructor to the ComponentPanelTitle. The title string
         * and additional subtitles are initialized.
         * @private
         * @returns {undefined} Returns nothing.
         */
        init: function() {
            this.m_title = "";
            this.m_subTitles = [];
        },
        /**
         * Sets the main title. The header tag is found from the root element of
         * the ComponentPanelLayout and is updated with the new title if it has
         * been rendered and exists on the DOM.
         * @param {string} title - The main title of the ComponentPanelTitle.
         * @returns {MPageUI.ComponentPanelTitle} Returns self.
         */
        setTitle: function(title) {
            this.m_title = title;
            this.getRootElement().find("h3:first").html((title || ""));
            return this;
        },
        /**
         * Sets the subtitles. The sub titles are additional title information
         * found below the main title. The primary string will be rendered in
         * alignment with the main title while the secondary string will be
         * rendered aligned to the opposite side of the primary title.
         * @param {Array<{
		 * 		primary: string,
		 * 		secondary: string
		 * }>} subTitles - An array of subtitles that are to be displayed below
         * the main title.
         * @returns {MPageUI.ComponentPanelTitle} Returns self.
         */
        setSubTitles: function(subTitles) {
            this.m_subTitles = subTitles;
            this.getRootElement().find("div:first").html(renderSubTitles(subTitles));
            return this;
        },
        /**
         * Renders the ComponentPanelTitle to an html string.
         * @returns {string} The ComponentPanelTitle rendered as an html string.
         */
        render: function() {
            return (
                "<div id='" + this.m_id + "' class='component-panel-title'>" +
                "<h3>" + (this.m_title || "") + "</h3>" +
                "<div>" +
                renderSubTitles(this.m_subTitles) +
                "</div>" +
                "</div>"
            );
        }
    });
})();

/**
 * The PanelTitleInterface is intended as a mixin for developers that are creating
 * a panel title. This interface provides a level of indirection between the
 * implementation of the ComponentPanelTitle and the content that developers wish
 * to inject into the panel.
 * @interface PanelTitleInterface
 */
MPageUI.PanelTitleInterface = {
    /**
     * The init function to be mixed into an MPageUI.UIComponent. This will
     * merge with any init function defined on the UIComponent. This init
     * function will be called first.
     *
     * This init function initializes an instance of the ComponentPanelTitle.
     * @private
     * @returns {undefined} Returns nothing.
     */
    init: function() {
        this.title = new MPageUI.ComponentPanelTitle();
    },
    /**
     * This function will update the encapsulated instance of
     * ComponentPanelTitle with new title data. Developers that create
     * their own panel title classes should consume this method for updating
     * the title rather than accessing the ComponentPanelTitle directly.
     *
     * The supported data is as follows...
     * {
	 * 		title: string,
	 * 		subTitles: Array<{ primary: string, secondary: string }>
	 * }
     *
     * @param {{title: string, subTitles: Array}} titleData - The title data
     * that will be used to update the encapsulated instance of
     * ComponentPanelTitle.
     * @returns {undefined} Returns nothing.
     */
    setTitle: function(titleData) {
        this.title.setTitle(titleData.title);
        this.title.setSubTitles(titleData.subTitles);
    },
    /**
     * Makes the call to render on the encapsulated ComponentPanelTitle.
     * @returns {string} The encapsulated panel title rendered as an html
     * string.
     */
    render: function() {
        return this.title.render();
    }
};

/**
 * The ComponentPanelAlerts class. The ComponentPanelAlerts is a standard
 * MPageUI class for rendering the alerts of a component panel.
 * @class MPageUI.ComponentPanelAlerts
 */
MPageUI.ComponentPanelAlerts = (function() {
    /**
     * Takes a JSON representation of an alert and creates an
     * MPageUI.AlertBanner.
     * @param {
	 * 		{
	 * 			primaryText: string,
	 * 			secondaryText: string,
	 * 			type: string
	 * 		}
	 * 	} alert - The JSON representation of the alert which will be transformed
     * into an instance of MPageUI.AlertBanner.
     * @returns {MPageUI.AlertBanner} An instance of MPageUI.AlertBanner created
     * from the alert JSON provided.
     */
    var makeBanner = function(alert) {
        var a = new MPageUI.AlertBanner();
        a.setPrimaryText(alert.primaryText || "");
        a.setSecondaryText(alert.secondaryText || "");
        a.setType(alert.type || MPageUI.ALERT_OPTIONS.TYPE.INFO);
        return a;
    };
    /**
     * Takes an array of JSON alerts and maps them into instances of
     * MPageUI.AlertBanner via makeBanner then calls render on each banner.
     * This creates an html string that is multiple alerts.
     * @param {[
	 * 		{
	 * 			primaryText: string,
	 * 			secondaryText: string,
	 * 			type: string
	 * 		}
	 * 	]} alerts - An array of JSON alerts which will be transformed into
     *    instances of MPageUI.AlertBanner and rendered.
     * @returns {string} The full html string of all rendered alerts.
     */
    var renderAlerts = function(alerts) {
        return (alerts || []).map(function(alert) {
            return makeBanner(alert).render();
        }).join("");
    };
    return MPageUI.createClass({
        /**
         * Called upon initialization of an instance of ComponentPanelAlerts. It
         * serves as the constructor to the ComponentPanelAlerts. The array of
         * alerts are initialized to an empty array.
         * @private
         * @returns {undefined} Returns nothing.
         */
        init: function() {
            this.m_alerts = [];
        },
        /**
         * Sets the alerts to be rendered.
         * @param {Array<
		 * 		{
		 * 			primaryText: string,
		 *			secondaryText: string,
		 * 			type: string
		 * 		}
		 * >} alerts - An array of JSON alerts which will be rendered.
         * @returns {undefined} Returns nothing.
         */
        setAlerts: function(alerts) {
            this.m_alerts = alerts;
            this.getRootElement().html(renderAlerts(this.m_alerts));
            return this;
        },
        /**
         * Renders the alerts as an html string.
         * @returns {string} The alerts rendered as an html string.
         */
        render: function() {
            return (
                "<div id='" + this.m_id + "' class='component-panel-alerts'>" +
                renderAlerts(this.m_alerts) +
                "</div>"
            );
        }
    });
})();

/**
 * The PanelAlertsInterface is intended as a mixin for developers that are
 * creating panel alerts. This interface provides a level of indirection between
 * the implementation ComponentPanelAlerts class and the class being created
 * by developers.
 * @interface PanelAlertsInterface
 */
MPageUI.PanelAlertsInterface = (function() {
    return {
        /**
         * The init function to be mixed into an MPageUI.UIComponent. This will
         * merge with any init function defined on the UIComponent. This init
         * function will be called first.
         *
         * This init function initializes an array of alerts.
         * @private
         * @returns {undefined} Returns nothing.
         */
        init: function() {
            this.m_componentPanelAlerts = new MPageUI.ComponentPanelAlerts();
        },
        /**
         * Sets the alerts to be rendered.
         * @param {Array<
		 * 		{
		 * 			primaryText: string,
		 *			secondaryText: string,
		 * 			type: string
		 * 		}
		 * >} alerts - An array of JSON alerts which will be rendered.
         * @returns {undefined} Returns nothing.
         */
        setAlerts: function(alerts) {
            this.m_componentPanelAlerts.setAlerts(alerts);
            return this;
        },
        /**
         * Renders the alerts as an html string.
         * @returns {string} The alerts rendered as an html string.
         */
        render: function() {
            return this.m_componentPanelAlerts.render();
        }
    };
})();
/*

Tooltipster 3.3.0 | 2014-11-08
A rockin' custom tooltip jQuery plugin

Developed by Caleb Jacob under the MIT license http://opensource.org/licenses/MIT

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

/* Tooltipster v3.3.0 */;(function(e,t,n){function s(t,n){this.bodyOverflowX;this.callbacks={hide:[],show:[]};this.checkInterval=null;this.Content;this.$el=e(t);this.$elProxy;this.elProxyPosition;this.enabled=true;this.options=e.extend({},i,n);this.mouseIsOverProxy=false;this.namespace="tooltipster-"+Math.round(Math.random()*1e5);this.Status="hidden";this.timerHide=null;this.timerShow=null;this.$tooltip;this.options.iconTheme=this.options.iconTheme.replace(".","");this.options.theme=this.options.theme.replace(".","");this._init()}function o(t,n){var r=true;e.each(t,function(e,i){if(typeof n[e]==="undefined"||t[e]!==n[e]){r=false;return false}});return r}function f(){return!a&&u}function l(){var e=n.body||n.documentElement,t=e.style,r="transition";if(typeof t[r]=="string"){return true}v=["Moz","Webkit","Khtml","O","ms"],r=r.charAt(0).toUpperCase()+r.substr(1);for(var i=0;i<v.length;i++){if(typeof t[v[i]+r]=="string"){return true}}return false}var r="tooltipster",i={animation:"fade",arrow:true,arrowColor:"",autoClose:true,content:null,contentAsHTML:false,contentCloning:true,debug:true,delay:200,minWidth:0,maxWidth:null,functionInit:function(e,t){},functionBefore:function(e,t){t()},functionReady:function(e,t){},functionAfter:function(e){},hideOnClick:false,icon:"(?)",iconCloning:true,iconDesktop:false,iconTouch:false,iconTheme:"tooltipster-icon",interactive:false,interactiveTolerance:350,multiple:false,offsetX:0,offsetY:0,onlyOne:false,position:"top",positionTracker:false,positionTrackerCallback:function(e){if(this.option("trigger")=="hover"&&this.option("autoClose")){this.hide()}},restoration:"current",speed:350,timer:0,theme:"tooltipster-default",touchDevices:true,trigger:"hover",updateAnimation:true};s.prototype={_init:function(){var t=this;if(n.querySelector){var r=null;if(t.$el.data("tooltipster-initialTitle")===undefined){r=t.$el.attr("title");if(r===undefined)r=null;t.$el.data("tooltipster-initialTitle",r)}if(t.options.content!==null){t._content_set(t.options.content)}else{t._content_set(r)}var i=t.options.functionInit.call(t.$el,t.$el,t.Content);if(typeof i!=="undefined")t._content_set(i);t.$el.removeAttr("title").addClass("tooltipstered");if(!u&&t.options.iconDesktop||u&&t.options.iconTouch){if(typeof t.options.icon==="string"){t.$elProxy=e('<span class="'+t.options.iconTheme+'"></span>');t.$elProxy.text(t.options.icon)}else{if(t.options.iconCloning)t.$elProxy=t.options.icon.clone(true);else t.$elProxy=t.options.icon}t.$elProxy.insertAfter(t.$el)}else{t.$elProxy=t.$el}if(t.options.trigger=="hover"){t.$elProxy.on("mouseenter."+t.namespace,function(){if(!f()||t.options.touchDevices){t.mouseIsOverProxy=true;t._show()}}).on("mouseleave."+t.namespace,function(){if(!f()||t.options.touchDevices){t.mouseIsOverProxy=false}});if(u&&t.options.touchDevices){t.$elProxy.on("touchstart."+t.namespace,function(){t._showNow()})}}else if(t.options.trigger=="click"){t.$elProxy.on("click."+t.namespace,function(){if(!f()||t.options.touchDevices){t._show()}})}}},_show:function(){var e=this;if(e.Status!="shown"&&e.Status!="appearing"){if(e.options.delay){e.timerShow=setTimeout(function(){if(e.options.trigger=="click"||e.options.trigger=="hover"&&e.mouseIsOverProxy){e._showNow()}},e.options.delay)}else e._showNow()}},_showNow:function(n){var r=this;r.options.functionBefore.call(r.$el,r.$el,function(){if(r.enabled&&r.Content!==null){if(n)r.callbacks.show.push(n);r.callbacks.hide=[];clearTimeout(r.timerShow);r.timerShow=null;clearTimeout(r.timerHide);r.timerHide=null;if(r.options.onlyOne){e(".tooltipstered").not(r.$el).each(function(t,n){var r=e(n),i=r.data("tooltipster-ns");e.each(i,function(e,t){var n=r.data(t),i=n.status(),s=n.option("autoClose");if(i!=="hidden"&&i!=="disappearing"&&s){n.hide()}})})}var i=function(){r.Status="shown";e.each(r.callbacks.show,function(e,t){t.call(r.$el)});r.callbacks.show=[]};if(r.Status!=="hidden"){var s=0;if(r.Status==="disappearing"){r.Status="appearing";if(l()){r.$tooltip.clearQueue().removeClass("tooltipster-dying").addClass("tooltipster-"+r.options.animation+"-show");if(r.options.speed>0)r.$tooltip.delay(r.options.speed);r.$tooltip.queue(i)}else{r.$tooltip.stop().fadeIn(i)}}else if(r.Status==="shown"){i()}}else{r.Status="appearing";var s=r.options.speed;r.bodyOverflowX=e("body").css("overflow-x");e("body").css("overflow-x","hidden");var o="tooltipster-"+r.options.animation,a="-webkit-transition-duration: "+r.options.speed+"ms; -webkit-animation-duration: "+r.options.speed+"ms; -moz-transition-duration: "+r.options.speed+"ms; -moz-animation-duration: "+r.options.speed+"ms; -o-transition-duration: "+r.options.speed+"ms; -o-animation-duration: "+r.options.speed+"ms; -ms-transition-duration: "+r.options.speed+"ms; -ms-animation-duration: "+r.options.speed+"ms; transition-duration: "+r.options.speed+"ms; animation-duration: "+r.options.speed+"ms;",f=r.options.minWidth?"min-width:"+Math.round(r.options.minWidth)+"px;":"",c=r.options.maxWidth?"max-width:"+Math.round(r.options.maxWidth)+"px;":"",h=r.options.interactive?"pointer-events: auto;":"";r.$tooltip=e('<div class="tooltipster-base '+r.options.theme+'" style="'+f+" "+c+" "+h+" "+a+'"><div class="tooltipster-content"></div></div>');if(l())r.$tooltip.addClass(o);r._content_insert();r.$tooltip.appendTo("body");r.reposition();r.options.functionReady.call(r.$el,r.$el,r.$tooltip);if(l()){r.$tooltip.addClass(o+"-show");if(r.options.speed>0)r.$tooltip.delay(r.options.speed);r.$tooltip.queue(i)}else{r.$tooltip.css("display","none").fadeIn(r.options.speed,i)}r._interval_set();e(t).on("scroll."+r.namespace+" resize."+r.namespace,function(){r.reposition()});if(r.options.autoClose){e("body").off("."+r.namespace);if(r.options.trigger=="hover"){if(u){setTimeout(function(){e("body").on("touchstart."+r.namespace,function(){r.hide()})},0)}if(r.options.interactive){if(u){r.$tooltip.on("touchstart."+r.namespace,function(e){e.stopPropagation()})}var p=null;r.$elProxy.add(r.$tooltip).on("mouseleave."+r.namespace+"-autoClose",function(){clearTimeout(p);p=setTimeout(function(){r.hide()},r.options.interactiveTolerance)}).on("mouseenter."+r.namespace+"-autoClose",function(){clearTimeout(p)})}else{r.$elProxy.on("mouseleave."+r.namespace+"-autoClose",function(){r.hide()})}if(r.options.hideOnClick){r.$elProxy.on("click."+r.namespace+"-autoClose",function(){r.hide()})}}else if(r.options.trigger=="click"){setTimeout(function(){e("body").on("click."+r.namespace+" touchstart."+r.namespace,function(){r.hide()})},0);if(r.options.interactive){r.$tooltip.on("click."+r.namespace+" touchstart."+r.namespace,function(e){e.stopPropagation()})}}}}if(r.options.timer>0){r.timerHide=setTimeout(function(){r.timerHide=null;r.hide()},r.options.timer+s)}}})},_interval_set:function(){var t=this;t.checkInterval=setInterval(function(){if(e("body").find(t.$el).length===0||e("body").find(t.$elProxy).length===0||t.Status=="hidden"||e("body").find(t.$tooltip).length===0){if(t.Status=="shown"||t.Status=="appearing")t.hide();t._interval_cancel()}else{if(t.options.positionTracker){var n=t._repositionInfo(t.$elProxy),r=false;if(o(n.dimension,t.elProxyPosition.dimension)){if(t.$elProxy.css("position")==="fixed"){if(o(n.position,t.elProxyPosition.position))r=true}else{if(o(n.offset,t.elProxyPosition.offset))r=true}}if(!r){t.reposition();t.options.positionTrackerCallback.call(t,t.$el)}}}},200)},_interval_cancel:function(){clearInterval(this.checkInterval);this.checkInterval=null},_content_set:function(e){if(typeof e==="object"&&e!==null&&this.options.contentCloning){e=e.clone(true)}this.Content=e},_content_insert:function(){var e=this,t=this.$tooltip.find(".tooltipster-content");if(typeof e.Content==="string"&&!e.options.contentAsHTML){t.text(e.Content)}else{t.empty().append(e.Content)}},_update:function(e){var t=this;t._content_set(e);if(t.Content!==null){if(t.Status!=="hidden"){t._content_insert();t.reposition();if(t.options.updateAnimation){if(l()){t.$tooltip.css({width:"","-webkit-transition":"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms","-moz-transition":"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms","-o-transition":"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms","-ms-transition":"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms",transition:"all "+t.options.speed+"ms, width 0ms, height 0ms, left 0ms, top 0ms"}).addClass("tooltipster-content-changing");setTimeout(function(){if(t.Status!="hidden"){t.$tooltip.removeClass("tooltipster-content-changing");setTimeout(function(){if(t.Status!=="hidden"){t.$tooltip.css({"-webkit-transition":t.options.speed+"ms","-moz-transition":t.options.speed+"ms","-o-transition":t.options.speed+"ms","-ms-transition":t.options.speed+"ms",transition:t.options.speed+"ms"})}},t.options.speed)}},t.options.speed)}else{t.$tooltip.fadeTo(t.options.speed,.5,function(){if(t.Status!="hidden"){t.$tooltip.fadeTo(t.options.speed,1)}})}}}}else{t.hide()}},_repositionInfo:function(e){return{dimension:{height:e.outerHeight(false),width:e.outerWidth(false)},offset:e.offset(),position:{left:parseInt(e.css("left")),top:parseInt(e.css("top"))}}},hide:function(n){var r=this;if(n)r.callbacks.hide.push(n);r.callbacks.show=[];clearTimeout(r.timerShow);r.timerShow=null;clearTimeout(r.timerHide);r.timerHide=null;var i=function(){e.each(r.callbacks.hide,function(e,t){t.call(r.$el)});r.callbacks.hide=[]};if(r.Status=="shown"||r.Status=="appearing"){r.Status="disappearing";var s=function(){r.Status="hidden";if(typeof r.Content=="object"&&r.Content!==null){r.Content.detach()}r.$tooltip.remove();r.$tooltip=null;e(t).off("."+r.namespace);e("body").off("."+r.namespace).css("overflow-x",r.bodyOverflowX);e("body").off("."+r.namespace);r.$elProxy.off("."+r.namespace+"-autoClose");r.options.functionAfter.call(r.$el,r.$el);i()};if(l()){r.$tooltip.clearQueue().removeClass("tooltipster-"+r.options.animation+"-show").addClass("tooltipster-dying");if(r.options.speed>0)r.$tooltip.delay(r.options.speed);r.$tooltip.queue(s)}else{r.$tooltip.stop().fadeOut(r.options.speed,s)}}else if(r.Status=="hidden"){i()}return r},show:function(e){this._showNow(e);return this},update:function(e){return this.content(e)},content:function(e){if(typeof e==="undefined"){return this.Content}else{this._update(e);return this}},reposition:function(){var n=this;if(e("body").find(n.$tooltip).length!==0){n.$tooltip.css("width","");n.elProxyPosition=n._repositionInfo(n.$elProxy);var r=null,i=e(t).width(),s=n.elProxyPosition,o=n.$tooltip.outerWidth(false),u=n.$tooltip.innerWidth()+1,a=n.$tooltip.outerHeight(false);if(n.$elProxy.is("area")){var f=n.$elProxy.attr("shape"),l=n.$elProxy.parent().attr("name"),c=e('img[usemap="#'+l+'"]'),h=c.offset().left,p=c.offset().top,d=n.$elProxy.attr("coords")!==undefined?n.$elProxy.attr("coords").split(","):undefined;if(f=="circle"){var v=parseInt(d[0]),m=parseInt(d[1]),g=parseInt(d[2]);s.dimension.height=g*2;s.dimension.width=g*2;s.offset.top=p+m-g;s.offset.left=h+v-g}else if(f=="rect"){var v=parseInt(d[0]),m=parseInt(d[1]),y=parseInt(d[2]),b=parseInt(d[3]);s.dimension.height=b-m;s.dimension.width=y-v;s.offset.top=p+m;s.offset.left=h+v}else if(f=="poly"){var w=[],E=[],S=0,x=0,T=0,N=0,C="even";for(var k=0;k<d.length;k++){var L=parseInt(d[k]);if(C=="even"){if(L>T){T=L;if(k===0){S=T}}if(L<S){S=L}C="odd"}else{if(L>N){N=L;if(k==1){x=N}}if(L<x){x=L}C="even"}}s.dimension.height=N-x;s.dimension.width=T-S;s.offset.top=p+x;s.offset.left=h+S}else{s.dimension.height=c.outerHeight(false);s.dimension.width=c.outerWidth(false);s.offset.top=p;s.offset.left=h}}var A=0,O=0,M=0,_=parseInt(n.options.offsetY),D=parseInt(n.options.offsetX),P=n.options.position;function H(){var n=e(t).scrollLeft();if(A-n<0){r=A-n;A=n}if(A+o-n>i){r=A-(i+n-o);A=i+n-o}}function B(n,r){if(s.offset.top-e(t).scrollTop()-a-_-12<0&&r.indexOf("top")>-1){P=n}if(s.offset.top+s.dimension.height+a+12+_>e(t).scrollTop()+e(t).height()&&r.indexOf("bottom")>-1){P=n;M=s.offset.top-a-_-12}}if(P=="top"){var j=s.offset.left+o-(s.offset.left+s.dimension.width);A=s.offset.left+D-j/2;M=s.offset.top-a-_-12;H();B("bottom","top")}if(P=="top-left"){A=s.offset.left+D;M=s.offset.top-a-_-12;H();B("bottom-left","top-left")}if(P=="top-right"){A=s.offset.left+s.dimension.width+D-o;M=s.offset.top-a-_-12;H();B("bottom-right","top-right")}if(P=="bottom"){var j=s.offset.left+o-(s.offset.left+s.dimension.width);A=s.offset.left-j/2+D;M=s.offset.top+s.dimension.height+_+12;H();B("top","bottom")}if(P=="bottom-left"){A=s.offset.left+D;M=s.offset.top+s.dimension.height+_+12;H();B("top-left","bottom-left")}if(P=="bottom-right"){A=s.offset.left+s.dimension.width+D-o;M=s.offset.top+s.dimension.height+_+12;H();B("top-right","bottom-right")}if(P=="left"){A=s.offset.left-D-o-12;O=s.offset.left+D+s.dimension.width+12;var F=s.offset.top+a-(s.offset.top+s.dimension.height);M=s.offset.top-F/2-_;if(A<0&&O+o>i){var I=parseFloat(n.$tooltip.css("border-width"))*2,q=o+A-I;n.$tooltip.css("width",q+"px");a=n.$tooltip.outerHeight(false);A=s.offset.left-D-q-12-I;F=s.offset.top+a-(s.offset.top+s.dimension.height);M=s.offset.top-F/2-_}else if(A<0){A=s.offset.left+D+s.dimension.width+12;r="left"}}if(P=="right"){A=s.offset.left+D+s.dimension.width+12;O=s.offset.left-D-o-12;var F=s.offset.top+a-(s.offset.top+s.dimension.height);M=s.offset.top-F/2-_;if(A+o>i&&O<0){var I=parseFloat(n.$tooltip.css("border-width"))*2,q=i-A-I;n.$tooltip.css("width",q+"px");a=n.$tooltip.outerHeight(false);F=s.offset.top+a-(s.offset.top+s.dimension.height);M=s.offset.top-F/2-_}else if(A+o>i){A=s.offset.left-D-o-12;r="right"}}if(n.options.arrow){var R="tooltipster-arrow-"+P;if(n.options.arrowColor.length<1){var U=n.$tooltip.css("background-color")}else{var U=n.options.arrowColor}if(!r){r=""}else if(r=="left"){R="tooltipster-arrow-right";r=""}else if(r=="right"){R="tooltipster-arrow-left";r=""}else{r="left:"+Math.round(r)+"px;"}if(P=="top"||P=="top-left"||P=="top-right"){var z=parseFloat(n.$tooltip.css("border-bottom-width")),W=n.$tooltip.css("border-bottom-color")}else if(P=="bottom"||P=="bottom-left"||P=="bottom-right"){var z=parseFloat(n.$tooltip.css("border-top-width")),W=n.$tooltip.css("border-top-color")}else if(P=="left"){var z=parseFloat(n.$tooltip.css("border-right-width")),W=n.$tooltip.css("border-right-color")}else if(P=="right"){var z=parseFloat(n.$tooltip.css("border-left-width")),W=n.$tooltip.css("border-left-color")}else{var z=parseFloat(n.$tooltip.css("border-bottom-width")),W=n.$tooltip.css("border-bottom-color")}if(z>1){z++}var X="";if(z!==0){var V="",J="border-color: "+W+";";if(R.indexOf("bottom")!==-1){V="margin-top: -"+Math.round(z)+"px;"}else if(R.indexOf("top")!==-1){V="margin-bottom: -"+Math.round(z)+"px;"}else if(R.indexOf("left")!==-1){V="margin-right: -"+Math.round(z)+"px;"}else if(R.indexOf("right")!==-1){V="margin-left: -"+Math.round(z)+"px;"}X='<span class="tooltipster-arrow-border" style="'+V+" "+J+';"></span>'}n.$tooltip.find(".tooltipster-arrow").remove();var K='<div class="'+R+' tooltipster-arrow" style="'+r+'">'+X+'<span style="border-color:'+U+';"></span></div>';n.$tooltip.append(K)}n.$tooltip.css({top:Math.round(M)+"px",left:Math.round(A)+"px"})}return n},enable:function(){this.enabled=true;return this},disable:function(){this.hide();this.enabled=false;return this},destroy:function(){var t=this;t.hide();if(t.$el[0]!==t.$elProxy[0]){t.$elProxy.remove()}t.$el.removeData(t.namespace).off("."+t.namespace);var n=t.$el.data("tooltipster-ns");if(n.length===1){var r=null;if(t.options.restoration==="previous"){r=t.$el.data("tooltipster-initialTitle")}else if(t.options.restoration==="current"){r=typeof t.Content==="string"?t.Content:e("<div></div>").append(t.Content).html()}if(r){t.$el.attr("title",r)}t.$el.removeClass("tooltipstered").removeData("tooltipster-ns").removeData("tooltipster-initialTitle")}else{n=e.grep(n,function(e,n){return e!==t.namespace});t.$el.data("tooltipster-ns",n)}return t},elementIcon:function(){return this.$el[0]!==this.$elProxy[0]?this.$elProxy[0]:undefined},elementTooltip:function(){return this.$tooltip?this.$tooltip[0]:undefined},option:function(e,t){if(typeof t=="undefined")return this.options[e];else{this.options[e]=t;return this}},status:function(){return this.Status}};e.fn[r]=function(){var t=arguments;if(this.length===0){if(typeof t[0]==="string"){var n=true;switch(t[0]){case"setDefaults":e.extend(i,t[1]);break;default:n=false;break}if(n)return true;else return this}else{return this}}else{if(typeof t[0]==="string"){var r="#*$~&";this.each(function(){var n=e(this).data("tooltipster-ns"),i=n?e(this).data(n[0]):null;if(i){if(typeof i[t[0]]==="function"){var s=i[t[0]](t[1],t[2])}else{throw new Error('Unknown method .tooltipster("'+t[0]+'")')}if(s!==i){r=s;return false}}else{throw new Error("You called Tooltipster's \""+t[0]+'" method on an uninitialized element')}});return r!=="#*$~&"?r:this}else{var o=[],u=t[0]&&typeof t[0].multiple!=="undefined",a=u&&t[0].multiple||!u&&i.multiple,f=t[0]&&typeof t[0].debug!=="undefined",l=f&&t[0].debug||!f&&i.debug;this.each(function(){var n=false,r=e(this).data("tooltipster-ns"),i=null;if(!r){n=true}else if(a){n=true}else if(l){console.log('Tooltipster: one or more tooltips are already attached to this element: ignoring. Use the "multiple" option to attach more tooltips.')}if(n){i=new s(this,t[0]);if(!r)r=[];r.push(i.namespace);e(this).data("tooltipster-ns",r);e(this).data(i.namespace,i)}o.push(i)});if(a)return o;else return this}}};var u=!!("ontouchstart"in t);var a=false;e("body").one("mousemove",function(){a=true})})(jQuery,window,document);
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("CERN_Platform"), require("logger"), require("CapabilityTimer"), require("ScriptRequest"));
	else if(typeof define === 'function' && define.amd)
		define(["CERN_Platform", "logger", "CapabilityTimer", "ScriptRequest"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("CERN_Platform"), require("logger"), require("CapabilityTimer"), require("ScriptRequest")) : factory(root["CERN_Platform"], root["logger"], root["CapabilityTimer"], root["ScriptRequest"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_7__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _logger = _interopRequireDefault(__webpack_require__(2));

var _CERN_Platform = _interopRequireDefault(__webpack_require__(0));

var _CapabilityTimer = _interopRequireDefault(__webpack_require__(3));

var _FeatureToggleStorage = _interopRequireDefault(__webpack_require__(4));

var _scriptManager = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// eslint-disable-line camelcase
// eslint-disable-line camelcase

/**
 * @constant
 * @def MPageFeatureToggle object
 */
var MPageFeatureToggle = function () {
  var promiseQueue = Promise.resolve(); // featureToggleStorage manages adding and retrieving the toggles from/to cache

  var featureToggleStorage = new _FeatureToggleStorage["default"]("mpage_featureToggles");
  /**
   * Function to trigger capability timer
   * @param {String} featureToggleName - feature toggle name
   * @param {Boolean | String} isEnabled - status
   * @returns {undefined} function does not return any value
   */

  var triggerTimer = function triggerTimer(featureToggleName, isEnabled) {
    new _CapabilityTimer["default"]("CAP:MPG.CHECK_FEATURE_TOGGLE", _CERN_Platform["default"].getCriterion().CRITERION.CATEGORY_MEAN).addMetaData("toggleName", featureToggleName).addMetaData("isEnabled", String(isEnabled)).capture();
  };
  /**
   * Function to get feature status from COM object
   * @param {String} featureToggleName - feature toggle name
   * @returns {Promise<Object|String>} returns the promise containing toggle status or false will be returned
   */


  var getStatusFromCOMObject = function getStatusFromCOMObject(featureToggleName) {
    // For performance improvement, features will be cached at local scope
    // Calls the COM object once and cache the results in local scope.
    var cachedFeature = featureToggleStorage.getCachedToggleStatus(featureToggleName);

    if (cachedFeature) {
      var isEnabled = cachedFeature.isEnabled;
      triggerTimer(featureToggleName, isEnabled);
      return Promise.resolve({
        featureToggleName: featureToggleName,
        isEnabled: isEnabled
      });
    }

    var featureObject = _CERN_Platform["default"].getWrappedDiscernObject("PVFEATURE");

    return featureObject.isAvailable().then(function (isAvailable) {
      if (isAvailable) {
        return promiseQueue = promiseQueue // eslint-disable-line no-return-assign
        .then(function () {
          return featureObject.invoke("SetFeatureName", [featureToggleName]);
        }).then(function () {
          return featureObject.invoke("IsFeatureToggleEnabled");
        }).then(function (isEnabled) {
          triggerTimer(featureToggleName, isEnabled);
          featureToggleStorage.cacheToggleStatus({
            featureToggleName: featureToggleName,
            isEnabled: Boolean(isEnabled)
          });
          return {
            featureToggleName: featureToggleName,
            isEnabled: Boolean(isEnabled)
          };
        });
      }

      throw new Error("PVFEATURE discern object not available");
    })["catch"](function (error) {
      triggerTimer(featureToggleName, "false");

      _logger["default"].logJSError(error, null, "mpageFeatureToggle.js", "getStatusFromCOMObject");

      return promiseQueue = promiseQueue.then(function () {
        return {
          featureToggleName: featureToggleName,
          isEnabled: false
        };
      }); // eslint-disable-line no-return-assign
    });
  };
  /**
   * Function to get feature status from script
   * @param {String} featureToggleName - feature toggle name
   * @param {String} solutionName - solution name, required only when status to be retrieved from dm_info
   * @returns {Promise<Object|String>} returns the promise containing toggle status or false is returned
   */


  var getStatusFromScript = function getStatusFromScript(featureToggleName, solutionName) {
    if (solutionName === void 0) {
      solutionName = "";
    }

    return new Promise(function (resolve) {
      // For performance improvement, features will be cached at local scope and web storage
      // Calls the CCl once and cache the results in local scope and web storage.
      var cachedFeature = featureToggleStorage.getCachedToggleStatus(featureToggleName);

      if (cachedFeature) {
        var isEnabled = cachedFeature.isEnabled;
        triggerTimer(featureToggleName, isEnabled);
        resolve({
          featureToggleName: featureToggleName,
          isEnabled: isEnabled
        });
      } else {
        _scriptManager["default"].getStatusFromCachedRequests(featureToggleName, solutionName).then(function (_ref) {
          var isEnabled = _ref.isEnabled;
          triggerTimer(featureToggleName, isEnabled);
          featureToggleStorage.cacheToggleStatus({
            featureToggleName: featureToggleName,
            isEnabled: isEnabled
          });
          resolve({
            featureToggleName: featureToggleName,
            isEnabled: isEnabled
          });
        })["catch"](function (error) {
          triggerTimer(featureToggleName, "false");

          _logger["default"].logJSError(error, null, "mpageFeatureToggle.js", "getStatusFromScript");

          resolve({
            featureToggleName: featureToggleName,
            isEnabled: false
          });
        });
      }
    });
  };

  return {
    /**
     * Function to get toggle status from feature toggle name
     * @param {String} featureToggleName - feature toggle name
     * @param {String} solutionName - solution name, required only when status to be retrieved from dm_info
     * @returns {Promise<Object|String>} returns the promise containing toggle status or error message
     */
    getToggleStatus: function getToggleStatus(featureToggleName, solutionName) {
      if (solutionName === void 0) {
        solutionName = "";
      }

      return _CERN_Platform["default"].inMillenniumContext() ? getStatusFromCOMObject(featureToggleName) : getStatusFromScript(featureToggleName, solutionName);
    }
  };
}();

var _default = MPageFeatureToggle;
exports["default"] = _default;
window.MP_FEATURE_TOGGLE = MPageFeatureToggle;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _CERN_Platform = _interopRequireDefault(__webpack_require__(0));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// eslint-disable-line camelcase

/**
 * Function to get the items from session
 * @param {String} sessionName - session name
 * @returns {Object} returns Map of item
 * @private
 */
var getItemsFromSessionStore = function getItemsFromSessionStore(sessionName) {
  try {
    var itemMap = JSON.parse(sessionStorage.getItem(sessionName));
    return _typeof(itemMap) === "object" && !!itemMap ? itemMap : {};
  } catch (error) {
    return {};
  }
};
/**
 * @desc Function to add item to session storage
 * @param {Object} item - item containing feature toggle status
 * @param {String} sessionName - name of the session
 * @returns { undefined } does not return any value
 * @private
 */


var addItemToSessionStore = function addItemToSessionStore(item, sessionName) {
  var itemMap = getItemsFromSessionStore(sessionName);
  itemMap[item.featureToggleName] = item;
  sessionStorage.setItem(sessionName, JSON.stringify(itemMap));
};
/**
 * @class FeatureToggleStorage
 * @def class to store and retrieve the feature toggles from Session Storage for non-Millennium context
 * and local cache for Millennium context
 */


var FeatureToggleStorage = /*#__PURE__*/function () {
  function FeatureToggleStorage(name) {
    this._sessionName = name; // feature toggle map to cache all the toggle data

    this._featureToggleMap = {};

    if (!_CERN_Platform["default"].inMillenniumContext()) {
      // When page refreshes, get the feature from web browser storage and insert into featureToggle map.
      this._featureToggleMap = getItemsFromSessionStore(sessionStorage.getItem(this._sessionName));
    }
  }
  /**
   * @desc Function to destroy the cache
   * @returns { undefined } does not return any value
   */


  var _proto = FeatureToggleStorage.prototype;

  _proto.destroy = function destroy() {
    this._featureToggleMap = {}; // clear the session

    if (!_CERN_Platform["default"].inMillenniumContext()) {
      sessionStorage.removeItem(this._sessionName);
    }
  }
  /**
   * @desc Function to cache the featureToggle
   * @param {Object} featureToggle  - item containing feature toggle details
   * @returns { undefined } does not return any value
   */
  ;

  _proto.cacheToggleStatus = function cacheToggleStatus(featureToggle) {
    this._featureToggleMap[featureToggle.featureToggleName] = featureToggle;

    if (!_CERN_Platform["default"].inMillenniumContext()) {
      addItemToSessionStore(featureToggle, this._sessionName);
    }
  }
  /**
   * @desc Function to get cached toggle status
   * @returns { Object | undefined } returns featureToggle or undefined
   */
  ;

  _proto.getCachedToggleStatus = function getCachedToggleStatus(featureToggleName) {
    return this._featureToggleMap[featureToggleName];
  };

  return FeatureToggleStorage;
}();

exports["default"] = FeatureToggleStorage;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _getFeatureToggleStatus = _interopRequireDefault(__webpack_require__(6));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @const scriptManager
 * @def Script manager to manage same featureToggleName getting called multiple times,
 * before first script with same featureToggleName get resolved.
 */
var scriptManager = function () {
  var pendingScripts = {};
  return {
    /**
     * @def function to get the feature toggle status from cached CCL requests
     * @description This function performs backend script requests to retrieve the toggle status.
     * Also, caches the pending script requests to avoid duplicate script call which matches
     * the toggle name of cached request.
     * Clears the cached requests once resolved.
     * This function improves the performance, when multiple scripts with same toggle name is called at initial load
     * @param { String } featureToggleName - feature toggle name
     * @param { String } solutionName - solution name, required only when status to be retrieved from dm_info
     * @returns {Promise<Object>} promise containing feature toggle status
     */
    getStatusFromCachedRequests: function getStatusFromCachedRequests(featureToggleName, solutionName) {
      if (solutionName === void 0) {
        solutionName = "";
      }

      var pendingScript = pendingScripts[featureToggleName + "|" + solutionName];

      if (pendingScript) {
        return pendingScript.promise;
      }

      var promise = (0, _getFeatureToggleStatus["default"])(featureToggleName, solutionName).then(function (status) {
        // Clear the reference from pendingScripts once script is resolved.
        delete pendingScripts[featureToggleName + "|" + solutionName];
        return status;
      });
      pendingScripts[featureToggleName + "|" + solutionName] = {
        promise: promise
      };
      return promise;
    }
  };
}();

var _default = scriptManager;
exports["default"] = _default;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _CERN_Platform = _interopRequireDefault(__webpack_require__(0));

var _ScriptRequest = _interopRequireDefault(__webpack_require__(7));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// eslint-disable-line camelcase

/**
 * @constant
 * @def criterion object
 */
var _CERN_Platform$getCri = _CERN_Platform["default"].getCriterion().CRITERION,
    userName = _CERN_Platform$getCri.USERNAME,
    positionCd = _CERN_Platform$getCri.POSITION_CD;
/**
 * This function is used to get the feature toggle status.
 * @param {String} featureToggleName - feature toggle name
 * @param {String} solutionName - solution name, required only when status to be retrieved from dm_info
 * @returns {Promise<Object>} The promise used to resolve or reject the data request response
 */


var getFeatureToggleStatus = function getFeatureToggleStatus(featureToggleName, solutionName) {
  if (solutionName === void 0) {
    solutionName = "";
  }

  return new Promise(function (resolve, reject) {
    new _ScriptRequest["default"]().setArtifactInfo({
      artifactId: "mpage-feature-toggle",
      functionName: "getFeatureToggleStatus"
    }).setProgramName("mp_retrieve_feature_toggle").setParameterArray(["^MINE^", "^" + featureToggleName + "^", "^" + userName + "^", positionCd + ".0", "^^", "^" + solutionName + "^"]).setResponseHandler(function (reply) {
      if (reply.getStatus() !== "F") {
        resolve({
          isEnabled: Boolean(reply.getResponse().ISENABLED)
        });
      } else {
        reject(reply);
      }
    }).setErrorStatusHandler(function (responseText, status) {
      reject("Response- " + responseText + " :: status- " + status);
    }).performRequest();
  });
};

var _default = getFeatureToggleStatus;
exports["default"] = _default;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ })
/******/ ]);
});
/*eslint-disable mp-camelcase, no-unused-vars, no-new-wrappers*/

/**
 * Legacy code used to pull the IEVersion.  This will break with IE11, but until we can get the consuming code
 * updates (ed-timeline.js) it will need to stay in place
 */
var ieVersion;
if(/MSIE (\d+\.\d+);/.test(navigator.userAgent)) { //test for MSIE x.x;
    ieVersion = new Number(RegExp.$1); // capture x.x portion and store as a number
}
else {
    ieVersion = 0;
}

/**
 * The CERN_Browser artifact will contain any reusable functions that pertain to the current browser.
 * This class will have functions that return information about what is available in a browser and any other
 * information provided by the browser.
 * @namespace
 */
var CERN_Browser = {
    m_isCanvasAvailable: null,
    m_userAgentString: "",
    m_colorDepth: 0,
    m_screenWidth: 0,
    m_screenHeight: 0,
    m_availableWidth: 0,
    m_availableHeight: 0,
    m_viewportWidth: $(window).innerWidth(),
    m_viewportHeight: $(window).innerHeight(),
    m_orientation: null
};

/*
 * An enumeration of the orientations of a viewport
 */
CERN_Browser.ORIENTATION = {
    LANDSCAPE: "LANDSCAPE",
    PORTRAIT: "PORTRAIT"
};

/**
 * A check to see if the canvas functionality is available within the browser
 * @returns {boolean} true or false if canvas is available in the current browser
 */
CERN_Browser.isCanvasAvailable = function() {
    //if variable is already set, just return the variable value
    if(typeof this.m_isCanvasAvailable !== "boolean") {
        //code to see if canvas is available, use !! to cast the result to a boolean
        this.m_isCanvasAvailable = !!document.createElement("canvas").getContext;
    }

    return this.m_isCanvasAvailable;
};

/**
 * Provides the methods to encode/decode Base64 strings that may not be in UTF-8 format.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding}
 * @namespace Base64
 * @memberof CERN_Browser
 */
CERN_Browser.Base64 = {

    /**
     * Encodes strings and binary data into a Base 64 format.
     *
     * @param {string} str - If not a string, should be a byte array for binary data
     * @returns {string} in Base64 encoding
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa}
     * @memberof CERN_Browser.Base64
     */
    encode: function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
    },

    /**
     * Decodes a string in Base 64.
     *
     * @param {string} str - provides a Base64 encoded string
     * @returns {string} out of Base 64
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob}
     * @memberof CERN_Browser.Base64
     */
    decode: function(str) {
        return decodeURIComponent(escape(window.atob(str)));
    }
};

/**
 * This function retrieves the user agent string from the browser
 * @returns {string} The user agent string for the browser or an empty string if unavailable
 */
CERN_Browser.getUserAgent = function() {
    if(!this.m_userAgentString && navigator && navigator.userAgent) {
        this.m_userAgentString = navigator.userAgent;
    }
    return this.m_userAgentString;
};

/**
 * This function returns the color depth of the current browser.  If unavailable 0 will be returned
 * @returns {number} color depth of the current browser
 */
CERN_Browser.getColorDepth = function() {
    if(!this.m_colorDepth && screen && screen.colorDepth) {
        this.m_colorDepth = screen.colorDepth;
    }
    return this.m_colorDepth;
};

/**
 * This function returns the screen height as defined by operating system
 * @returns {number} The screen height in pixels
 */
CERN_Browser.getScreenHeight = function() {
    if(!this.m_screenHeight && screen && screen.height) {
        this.m_screenHeight = screen.height;
    }
    return this.m_screenHeight;
};

/**
 * This function returns the screen width as defined by the operating system.
 * @returns {number} The screen width in pixels
 */
CERN_Browser.getScreenWidth = function() {
    if(!this.m_screenWidth && screen && screen.width) {
        this.m_screenWidth = screen.width;
    }
    return this.m_screenWidth;
};

/**
 * This function returns the screen resolution in the format of 'WidthxHeight'
 * @returns {string} The screen resolution formatted as 'WidthxHeight'
 */
CERN_Browser.getScreenResolution = function() {
    return this.getScreenWidth() + "x" + this.getScreenHeight();
};

/**
 * This function returns the available height that the browser has to work with.  This will be the
 * screen width minus things like task bars.
 * @returns {number} The available height in pixels
 */
CERN_Browser.getAvailableHeight = function() {
    if(!this.m_availableHeight && screen && screen.availHeight) {
        this.m_availableHeight = screen.availHeight;
    }
    return this.m_availableHeight;
};

/**
 * This function returns the available width that the browser has to work with.  This will be the
 * screen height minus things like task bars.
 * @returns {number} The available width in pixels
 */
CERN_Browser.getAvailableWidth = function() {
    if(!this.m_availableWidth && screen && screen.availWidth) {
        this.m_availableWidth = screen.availWidth;
    }
    return this.m_availableWidth;
};

/**
 * This function returns the available resolution in the format of 'WidthxHeight'
 * @returns {string} The screen resolution formatted as 'WidthxHeight'
 */
CERN_Browser.getAvailableResolution = function() {
    return this.getAvailableWidth() + "x" + this.getAvailableHeight();
};

/**
 * This function returns the current height of the viewport which is the available height minus
 * bookmark bars, tool bars, etc...
 * @returns {number} The current viewport height in pixels
 */
CERN_Browser.getViewportHeight = function() {
    return this.m_viewportHeight;
};

/**
 * This function returns the current width of the viewport which is the available width minus
 * bookmark bars, tool bars, etc...
 * @returns {number} The current viewport width in pixels
 */
CERN_Browser.getViewportWidth = function() {
    return this.m_viewportWidth;
};

/**
 * This function returns the available resolution in the format of 'WidthxHeight'
 * @returns {string} The screen resolution formatted as 'WidthxHeight'
 */
CERN_Browser.getViewportResolution = function() {
    return this.getViewportWidth() + "x" + this.getViewportHeight();
};

/**
 * Returns an enumeration of the orientation of the current viewport.  Is simply calculated by comparing the
 * width and height.
 * @returns {string} An enumeration of the orientation.
 */
CERN_Browser.getOrientation = function() {
    return (this.m_viewportHeight > this.m_viewportWidth) ? this.ORIENTATION.PORTRAIT : this.ORIENTATION.LANDSCAPE;
};


/**
 * This function is used to validate that the window has actually been resized.  There are certain instances where the
 * window.resize
 * event will fire without the window actually being resized.  This mostly occurs in IE8 when adding to the DOM produces scroll
 * bars. If either the height or the width of the window has changes this function will return true.  If both the height and width
 * remain unchanged this function will return false.
 *  @returns {boolean} True if the window has been resized, false otherwise.
 */
CERN_Browser.validateWindowResize = function() {
    //Grab the current width and height of the window
    var newWindowHeight = $(window).innerHeight();
    var newWindowWidth = $(window).innerWidth();

    //Compare to the last time we grabbed the width and height to determine if a resize actually occured
    if(newWindowHeight !== this.m_viewportHeight || newWindowWidth !== this.m_viewportWidth) {
        this.m_viewportHeight = newWindowHeight;
        this.m_viewportWidth = newWindowWidth;
        return true;
    }
    return false;
};

/**
 * This function registers the onbeforeunload browser event.
 * @param {function} unloadEventCallBack function that should be called when this event is triggered.
 * @returns {undefined} does not return any value.
 */
CERN_Browser.setOnBeforeUnload = function(unloadEventCallBack) {
    if (typeof unloadEventCallBack !== "function") {
        logger.logError("Browser Unload Event call back argument is not a function");
        return;
    }
    window.onbeforeunload = unloadEventCallBack;
};

/**
 * This function unbinds the onbeforeunload browser event.
 * @returns {undefined} does not return any value.
 */
CERN_Browser.resetOnBeforeUnload = function() {
    window.onbeforeunload = null;
};
/**
 * The validation library. This object contains a set of static functions which perform
 * standard validation operations.
 * @type {Object}
 */
var CERN_Validate = {};

CERN_Validate.string = {};

/**
 * This function will verify if the value passed in is a string. it will return true if the following conditions are met
 * , otherwise it will return false.
 * typeof value === "string"
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is a string, otherwise false.
 */
CERN_Validate.string.isString = function (value) {
	return typeof value === "string";
};

/**
 * This function will check to see if the string contains a numeric value. It will return true if the following
 * conditions are met, otherwise it will return false.
 * CERN_Validate.string.isString(value) is true
 * The string is a parseable number
 * @param {string} value - The value being tested.
 * @returns {boolean} True if the value is a numeric string, otherwise false.
 */
CERN_Validate.string.isNumeric = function (value) {
	return CERN_Validate.string.isString(value) &&
		/^[-+]?[0-9]*[.,]?[0-9]+$/.test(value) &&
		(CERN_Validate.number.isNumber(parseFloat(value)));
};

/**
 * This function is used to check and see if a string is empty or not. It will return true if the following conditions
 * are met, otherwise it will return false.
 * CERN_Validate.string.isString(value) is true
 * value === ""
 * @param {string} value - The value being tested.
 * @returns {boolean} True if the value is empty, otherwise false.
 */
CERN_Validate.string.isEmpty = function(value) {
	return CERN_Validate.string.isString(value) && value === "";
};

/**
 * This function will determine if a string is blank, meaning it contains only whitespace or is an empty string. This
 * function will return true if the following conditions are met, otherwise it will return false.
 * CERN_Validate.string.isString(value) is true
 * The string is empty or contains only whitespace characters
 * @param {string} value - The value being tested.
 * @returns {boolean} True if the value is empty or contains only whitespace, otherwise false.
 */
CERN_Validate.string.isBlank = function(value) {
	return CERN_Validate.string.isEmpty(value) || /^[\s\n\r]*$/.test(value);
};

CERN_Validate.number = {};

/**
 * This function can be used to see if the value passed in is a number or not. This function will return true if the
 * following conditions are met, otherwise it will return false.
 * typeof value == "number"
 * The value passed in is finite (not infinity, negative infinity or NaN)
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is a number, otherwise false.
 */
CERN_Validate.number.isNumber = function(value) {
	return typeof value === "number" && isFinite(value);
};

/**
 * This function will validate if a value is an integer. It will return true of the following conditions are met,
 * otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value % 1 === 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is an integer, otherwise false.
 */
CERN_Validate.number.isInteger = function(value) {
	return CERN_Validate.number.isNumber(value) && (value % 1 === 0);
};

/**
 * This function will validate if a value is a floating point number. It will return true if the following conditions
 * are met, otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value % 1 !== 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is an integer, otherwise false.
 */
CERN_Validate.number.isFloat = function(value) {
	return CERN_Validate.number.isNumber(value) && (value % 1 !== 0);
};

/**
 * This function will validate if a number is negative. It will return true if the following conditions are met,
 * otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value < 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the number is negative, otherwise false.
 */
CERN_Validate.number.isNegative = function(value) {
	return CERN_Validate.number.isNumber(value) && value < 0;
};

/**
 * This function will validate if a number is positive. It will return true if the following conditions are met,
 * otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value > 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the number is negative, otherwise false.
 */
CERN_Validate.number.isPositive = function(value) {
	return CERN_Validate.number.isNumber(value) && value > 0;
};

/**
 * This function will validate if a number is greater than or equal to another number. It will return true if the
 * following conditions are met, otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * CERN_Validate.number.isNumber(compareTo) is true
 * value >= compareTo
 * @param {number} value - The value being tested.
 * @param {number} compareTo - The number to compare the value against.
 * @returns {boolean} True if the value is greater than or equal to the comparison value, otherwise false.
 */
CERN_Validate.number.isGreaterThanOrEqualTo = function(value, compareTo) {
	return CERN_Validate.number.isNumber(value) && CERN_Validate.number.isNumber(compareTo) && value >= compareTo;
};

/**
 * This function will validate if a number is less than or equal to another number. It will return true if the following
 * conditions are met, otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * CERN_Validate.number.isNumber(compareTo) is true
 * value <= compareTo
 * @param {number} value - The value being tested.
 * @param {number} compareTo - The number to compare the value against.
 * [value is number, compareTo is number, value <= compareTo]
 * @returns {boolean} True if the value is less than or equal to the comparison value, otherwise false.
 */
CERN_Validate.number.isLessThanOrEqualTo = function(value, compareTo) {
	return CERN_Validate.number.isNumber(value) && CERN_Validate.number.isNumber(compareTo) && value <= compareTo;
};

/**
 * This function will validate if a number is zero. It will return true if the following conditions are met, otherwise
 * it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * value === 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is 0, otherwise false.
 */
CERN_Validate.number.isZero = function(value) {
	return CERN_Validate.number.isNumber(value) && value === 0;
};

/**
 * This function will validate if a number is even. It will return true if the following conditions are met, otherwise
 * it will return false.
 * CERN_Validate.number.isInteger(value) is true
 * value % 2 === 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is an even integer, otherwise false.
 */
CERN_Validate.number.isEven = function(value) {
	return CERN_Validate.number.isInteger(value) && value % 2 === 0;
};

/**
 * This function will validate if a number is odd. It will return true if the following conditions are met, otherwise
 * it will return false.
 * CERN_Validate.number.isInteger(value) is true
 * value % 2 !== 0
 * @param {number} value - The value being tested.
 * @returns {boolean} True if the value is an odd integer, otherwise false.
 */
CERN_Validate.number.isOdd = function(value) {
	return CERN_Validate.number.isInteger(value) && value % 2 !== 0;
};

/**
 * This function will validate if a number is within a specified range. This can be both inclusive or exclusive.
 * This function will return true if the following conditions are met, otherwise it will return false.
 * CERN_Validate.number.isNumber(value) is true
 * CERN_Validate.number.isNumber(rangeStart) is true
 * CERN_Validate.number.isNumber(rangeEnd) is true
 * If the inclusive flag is true
 * 		The value is between rangeStart and rangeEnd, but not equal to either
 * If the inclusive flag is false
 *		The value is between rangeStart and rangeEnd or is equal to either
 * @param {number} value - The value being tested.
 * @param {number} rangeStart - The start of the range.
 * @param {number} rangeEnd - The end of the range.
 * @param {boolean} inclusive - Flag indicating if the range is inclusive or not.
 * @returns {boolean} True if the value is within the range, otherwise false.
 */
CERN_Validate.number.isWithinRange = function(value, rangeStart, rangeEnd, inclusive) {
	if(!CERN_Validate.number.isNumber(rangeStart) || !CERN_Validate.number.isNumber(rangeEnd)) {
		return false;
	}
	if(!CERN_Validate.number.isNumber(value)) {
		return false;
	}
	if(rangeStart > rangeEnd) {
		var tempValue = rangeStart;
		rangeStart = rangeEnd;
		rangeEnd = tempValue;
	}
	if(inclusive) {
		return value >= rangeStart && value <= rangeEnd;
	}
	else {
		return value > rangeStart && value < rangeEnd;
	}
};

CERN_Validate.array = {};

/**
 * This function can be used to verify if the value passed in is an array. It will return true if the following
 * conditions are met, otherwise it will return false.
 * Array.prototype.isPrototypeOf(value)
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is an Array, otherwise false.
 */
CERN_Validate.array.isArray = function(value) {
	return Array.prototype.isPrototypeOf(value);
};

/**
 * This function will validate if an array does not contain any elements. It will return true if the following
 * conditions are met, otherwise it will return false.
 * CERN_Validate.array.isArray(value) is true
 * The length of array is equal to 0.
 * @param {Array} value - The value being tested.
 * @returns {boolean} True if the Array is emtpy, otherwise false.
 */
CERN_Validate.array.isEmpty = function(value) {
	return CERN_Validate.array.isArray(value) && value.length === 0;
};

/**
 * This function will validate if an array contains a specific value. It will return true if the following conditions
 * are met, otherwise it will return false.
 * CERN_Validate.array.isArray(value) is true.
 * containsValue is one of the elements defined within the array.
 * @param {Array} value - The array in which we are checking for the containsValue parameter.
 * @param {Object} containsValue - The value we are checking the array for.
 * @returns {boolean} True if the array contains the containsValue parameter.
 */
CERN_Validate.array.contains = function(value, containsValue) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(value[i] === containsValue) {
			return true;
		}
	}
	return false;
};

/**
 * This function will validate that all of the values within an array are strings. It will return true if the following
 * conditions are met.
 * CERN_Validate.array.isArray(value) is true.
 * All values within the array are strings (uses CERN_Validate.string.isString).
 * @param {Array} value - The array being tested.
 * @returns {boolean} True if the array contains only strings.
 */
CERN_Validate.array.containsOnlyStrings = function(value) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(!CERN_Validate.string.isString(value[i])) {
			return false;
		}
	}
	return true;
};

/**
 * This function will validate that all of the values within an array are numbers. It will return true if the following
 * conditions are met.
 * CERN_Validate.array.isArray(value) is true
 * All values within the array are numbers
 * @param {Array} value - The array being tested.
 * @returns {boolean} True if the array contains only numbers.
 */
CERN_Validate.array.containsOnlyNumbers = function(value) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(!CERN_Validate.number.isNumber(value[i])) {
			return false;
		}
	}
	return true;
};

/**
 * This function will validate that all of the values within an array are objects. It will return true if the following
 * conditions are met.
 * CERN_Validate.array.isArray(value) is true.
 * All values within the array are objects.
 * @param {Array} value - The array being tested.
 * @returns {boolean} True if the array contains only Objects.
 */
CERN_Validate.array.containsOnlyObjects = function(value) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(typeof value[i] !== "object") {
			return false;
		}
	}
	return true;
};

/**
 * This function will validate that all of the values within an array are objects of a specified prototype. It will
 * return true if the following conditions are met.
 * CERN_Validate.array.isArray(value) is true.
 * All values within the array are objects of the specified prototype.
 * @param {Array} value - The array being tested.
 * @param {Object.prototype} objectPrototype - The prototype we are testing.
 * @returns {boolean} True if all items in the array are objects of the specified prototype.
 */
CERN_Validate.array.containsOnlyObjectsOfPrototype = function(value, objectPrototype) {
	if(!CERN_Validate.array.isArray(value)) {
		return false;
	}
	var arrayLength = value.length;
	for(var i = 0; i < arrayLength; i++) {
		if(!objectPrototype.prototype.isPrototypeOf(value[i])) {
			return false;
		}
	}
	return true;
};

CERN_Validate.object = {};

/**
 * This function will validate that the value is an object type. It will return true if the following conditions are met.
 * typeof value === "object".
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is an object type, otherwise false.
 */
CERN_Validate.object.isObject = function(value) {
	return typeof value === "object";
};

/**
 * This function will validate that the Object is empty. It will return true if the following conditions are met.
 * CERN_Validate.object.isObject(value) is true.
 * value is completely empty (has no properties).
 * @param {Object} value - The value being tested.
 * @returns {boolean} True if the value is empty, otherwise false.
 */
CERN_Validate.object.isEmpty = function(value) {
	if(!CERN_Validate.object.isObject(value)) {
		return false;
	}
	for(var key in value) {
		if(value.hasOwnProperty(key)) {
			return false;
		}
	}
	return true;
};

/**
 * This function will validate that the Object contains the specified key. It will return true if the following
 * conditions are met.
 * CERN_Validate.object.isObject(value) is true.
 * typeof value[key] !== "undefined".
 * @param {Object} value - The value being tested.
 * @param {Object} key - The key to test for.
 * @returns {boolean} True if the value contains the specified key.
 */
CERN_Validate.object.hasKey = function(value, key) {
	return CERN_Validate.object.isObject(value) && typeof value[key] !== "undefined";
};



/* eslint eqeqeq: 0 */
/* globals MP_PendingData, Util, _g, _gbt, hs, MP_MenuManager, Menu, FlowsheetTable, RenderStrategy, MPageGroupValue, MPageGrouper, MPageEventCodeGroup, MPageEventSetGroup, MPageSequenceGroup, CERN_COMPONENT_TYPE_WORKFLOW */

/**
 * MPageComponent constructor
 * @constructor
 */
function MPageComponent() { // eslint-disable-line no-redeclare

    // General variables
    this.m_alwaysHideHeader = false;
    this.m_AutoSuggestAddTimerName = "";
    this.m_AutoSuggestScript = "";
    this.m_brlookbackUnits = 0;
    this.m_brlookbackUnitTypeFlag = 0;
    this.m_column = 0;
    this.m_componentPreferences = null;
    this.m_compDisp = true;
    this.m_compLoad = false;
    this.m_compLoadTimerName = "";
    this.m_compMenuId = "";
    this.m_componentId = 0.0;
    this.m_componentFilterMean = "";
    this.m_compRenderTimerName = "";
    this.m_componentTable = null;
    this.m_flowsheetTable = null;
    this.criterion = null;
    // m_dateFormat: 1 = date only,2= date/time and 3 = elapsed time
    this.m_dateFormat = 2;
    this.m_displayFilters = null;
    this.m_editMode = false;
    this.m_filterMappingsObj = {};
    this.m_footerText = "";
    this.m_gapCheckBannerDismiss = null;
    // m_grouper_arr: an array of objects structure like {"label":"group label", "eventSets": []}
    this.m_grouper_arr = null;
    this.m_grouperFilterCatalogCodes = null;
    this.m_grouperFilterCatLabel = "";
    this.m_grouperFilterCriteria = null;
    this.m_grouperFilterEventSets = null;
    this.m_grouperFilterLabel = "";
    this.m_groups = null;
    this.m_hasActionsMenu = false;
    this.m_hasCompFilters = false;
    this.m_hasLookBackDropDown = false;
    this.m_includeLineNumber = false;
    this.m_isAlwaysExpanded = false;
    this.m_isCustomizeView = false;
    this.m_isExpanded = false;
    this.m_isPlusAdd = false;
    this.m_isPlusAddCustom = false;
    this.m_isRefreshEnabled = true;
    this.m_isScrollEnabled = false;
    this.m_iViewItemsArr = null;
    this.m_iViewMenuItems = null;
    this.m_label = "";
    this.m_link = "";
    this.m_lookbackDays = 0;
    this.m_lookBackMenuItems = null;
    this.m_lookbackUnits = 0;
    this.m_resultRangeDirection = 0;
    // m_lookbackUnitTypeFlag: 1 = hours,2=Days,3=Weeks,4= Months,5= Years
    this.m_lookbackUnitTypeFlag = 0;
    this.m_menuItems = null;
    this.m_menuOptionNames = [];
    this.m_menuOptions = [];
    this.m_newLink = false;
    this.m_pageGroupSeq = 0;
    this.m_renderStrategy = null;
    this.m_reportId = 0;
    this.m_reportMean = "";
    this.m_resourceRequired = false;
    this.m_rootComponentNode = null;
    this.m_sectionContentNode = null;
    this.m_sequence = 0;
    // m_scope: 1=person,2=encounter
    this.m_scope = 0;
    this.m_ScopeHTML = "";
    this.m_scrollNumber = 0;
    this.m_selectedDataGroup = null;
    this.m_selectedTimeFrame = null;
    this.m_styles = null;
    this.m_subLabel = "";
    // m_toggleStatus: 0 - component off, 1 - component on, 2 - component retuired
    this.m_toggleStatus = 1;

    // properties for toggle icons on component headers
    this.m_activeHeaderToggleIndex = 0;
    this.m_headerToggleObjects = null;

    // the aggregate timer created by the containing view to measure the page load time
    this.m_aggregateTimer = null;
    this.m_hiLookupKey = "";
    this.m_aliasType = "";
    this.m_aliasPoolCd = 0.0;
    this.m_externalDataInd = false;
    this.m_hiTestUri = "";
    // Patient entered data bedrock indicator
    this.m_patEnteredDataInd = false;
    // Medication Reconciliation Statuses
    this.m_medHistory = false;
    this.m_medRecAdmit = false;
    this.m_medRecTransfer = false;
    this.m_medRecCrossEncTx = false;
    this.m_medRecDischarge = false;
    // properties for gapcheck functionality
    this.m_requiredCriteria = null;
    // initialized to null to allow cpo3 and order-profile to differentiate
    // between existing and new views
    this.m_isRequired = false;
    this.m_overrideInd = null;
    this.m_isSatisfied = false;
    this.m_disclaimerText = "";

    // properties for contextual view functionality
    this.m_isContextualViewCompatible = false;
    this.m_isAddedToContextualView = false;
    this.m_contextualViewControl = null;
    this.m_contextualViewControlInPlaceholderView = null;
    this.m_placeholderView = null;
    this.m_rootPlaceholderComponentNode = null;
    this.m_canHaveContextualViewControl = false;
    this.m_sequenceInContextualView = 0;
    this.m_resultCount = 0; // result count of the component

    // callbacks
    this.m_onComponentDisclaimerClose = function() {};
    this.m_onSubLabelChange = function() {};
    this.m_onFinalizeComponent = function() {};
    this.m_onContextualViewToggle = function() {};
    this.m_onUpdateHeader = function() {};
}

// This object is used to convert full bedrock filter field names to their shorthand versions
MPageComponent.prototype.bedrockShorthandConversions = {
    PARENT_ENTITY_ID: "PE_ID",
    PARENT_ENTITY_NAME: "PE_NM",
    CDF_MEANING: "CDF_MN",
    GROUP_SEQ: "G_SQ",
    VALUE_SEQ: "V_SQ",
    FREETEXT_DESC: "FTXT",
    VALUE_TYPE_FLAG: "V_TYP",
    QUALIFIER_FLAG: "Q_FLG",
    CHARGE_ASSIGN: "CH_ASSIGN"
};

/* Adders - functions used to add content to MPageComponent object elements */
MPageComponent.prototype.addDisplayFilter = function(value) {
    if (this.m_displayFilters === null) {
        this.m_displayFilters = [];
    }
    this.m_displayFilters.push(value);
};

/**
 * This function is used to retrieve the always hide header flag.  This flag indicates if the
 * header of a component should always be hidden.  This flag is only supported within the context
 * of a ComponentContainer MPages View.  This flag will be ignored outside of that context
 * @returns {boolean} True if the component header should always be hidden when bing rendered within
 * the ComponentContainer MPagesView, false otherwise.
 */
MPageComponent.prototype.alwaysHideHeader = function(){
    return this.m_alwaysHideHeader;
};

/**
 * Add a filter mapping object to the collection of filter mappings.  Filter mappings are referenced by name, so if a filter already
 * exists with the same name it will be overwritten.
 * @param {String} filterName The name of the filter object to add.
 * @param {Object} filterObject The object containing all of the filter properties used when loading settings.
 * @returns {undefined}
 */
MPageComponent.prototype.addFilterMappingObject = function(filterName, filterObject) {
    // Convert full length field names into short hand if they are not already shorthand
    if (filterObject && typeof this.bedrockShorthandConversions[filterObject.field] !== "undefined") {
        filterObject.field = this.bedrockShorthandConversions[filterObject.field];
    }
    this.m_filterMappingsObj[filterName] = filterObject;
};

MPageComponent.prototype.addIViewMenuItem = function(value) {
    if (this.m_iViewMenuItems === null) {
        this.m_iViewMenuItems = [];
    }
    this.m_iViewMenuItems.push(value);
};

MPageComponent.prototype.addLookbackMenuItem = function(value) {
    if (this.m_lookBackMenuItems === null) {
        this.m_lookBackMenuItems = [];
    }
    this.m_lookBackMenuItems.push(value);
};

MPageComponent.prototype.addGroup = function(value) {
    if (this.m_groups === null) {
        this.m_groups = [];
    }
    this.m_groups.push(value);
};

MPageComponent.prototype.addGrouperFilterCatalogCodes = function(value) {
    if (this.m_grouperFilterCatalogCodes === null) {
        this.m_grouperFilterCatalogCodes = [];
    }
    this.m_grouperFilterCatalogCodes.push(value);
};

MPageComponent.prototype.addGrouperFilterCriteria = function(value) {
    if (this.m_grouperFilterCriteria === null) {
        this.m_grouperFilterCriteria = [];
    }
    this.m_grouperFilterCriteria.push(value);

};

MPageComponent.prototype.addGrouperFilterEventSets = function(value) {
    this.addGrouperFilterCriteria(value);
};

MPageComponent.prototype.addMenuDither = function(itemName) {
    var menuItem = _g(this.m_menuOptions[itemName].id);
    if (menuItem) {
        Util.Style.acss(menuItem, "opts-menu-item-dthr");
        this.m_menuOptions[itemName].isMenuDithered = true;
    }
};

MPageComponent.prototype.addMenuItem = function(value) {
    if (this.m_menuItems === null) {
        this.m_menuItems = [];
    }
    this.m_menuItems.push(value);
};

MPageComponent.prototype.addMenuOption = function(itemName, id, text, ditherOnLoad, evtType, fn) {
    var actionSec = _g("optsMenuActions" + this.m_componentId);
    if (actionSec) {
        if (!actionSec.hasChildNodes()) {
            var isMenuDithered = (ditherOnLoad) ? ditherOnLoad : false;
            this.m_menuOptions[itemName] = {
                itemName: itemName,
                id: id,
                text: text,
                ditherOnLoad: ditherOnLoad,
                isMenuDithered: isMenuDithered,
                evtType: evtType,
                fn: fn
            };
            this.m_menuOptionNames.push(itemName);
        }
    }
};

/**
 * This function is used for clean up activities to avoid memmory leak
 * This function is called before component is removed from dom
 * @returns {undefined} This function does not return a value
 */
MPageComponent.prototype.beforeDestroy = function() {
    CERN_EventListener.removeAllListeners(this, this);
};

/* Getters - functions used to retrieve items stored within the MPageComponent object*/
/**
 * Get the aggregate timer created by the containing view to measure the page load time
 * @returns {AggregateTimer} the aggregate timer created by the containing view to measure the page load time
 */
MPageComponent.prototype.getAggregateTimer = function() {
    return this.m_aggregateTimer;
};

MPageComponent.prototype.getAutoSuggestAddScript = function() {
    return (this.m_AutoSuggestScript);
};

MPageComponent.prototype.getAutoSuggestAddTimerName = function() {
    return (this.m_AutoSuggestAddTimerName);
};

MPageComponent.prototype.getBrLookbackUnits = function() {
    return (this.m_brlookbackUnits);
};

MPageComponent.prototype.getBrLookbackUnitTypeFlag = function() {
    return (this.m_brlookbackUnitTypeFlag);
};

MPageComponent.prototype.getColumn = function() {
    return (this.m_column);
};

MPageComponent.prototype.getCompColor = function() {
    var style = this.getStyles();
    if (style) {
        return style.getColor();
    }
    else {
        return;    // eslint-disable-line consistent-return
    }
};

MPageComponent.prototype.getComponentId = function() {
    return (this.m_componentId);
};

MPageComponent.prototype.getComponentFilterMean = function() {
    return (this.m_componentFilterMean);
};

MPageComponent.prototype.getComponentLoadTimerName = function() {
    return (this.m_compLoadTimerName);
};

MPageComponent.prototype.getComponentRenderTimerName = function() {
    return (this.m_compRenderTimerName);
};

/**
 * Architectural method of creating a component's table to ensure that necessary fields are set.
 * Namely the namespace of the table which ensures unique identifiers for table DOM elements.
 * This helps to enforce namespacing.
 * @returns {ComponentTable} Returns the comonent table associated with this component
 */
MPageComponent.prototype.getComponentTable = function() {
    return this.m_componentTable;
};

/**
 * For each compoent a criterion is defined for usage.  This criterion contains information such
 * as the person, encounter, personnel, etc.
 * @returns {Criterion} Returns a Criterion object containing information such as the patient, encounter, personnel.
 */
MPageComponent.prototype.getCriterion = function() {
    return (this.criterion);
};

MPageComponent.prototype.getCustomizeView = function() {
    return this.m_isCustomizeView;
};

MPageComponent.prototype.getDateFormat = function() {
    // 1 = date only,2= date/time and 3 = elapsed time
    return (this.m_dateFormat);
};

MPageComponent.prototype.getDisplayEnabled = function() {
    return (this.m_compDisp);
};

MPageComponent.prototype.getDisplayFilters = function() {
    return this.m_displayFilters;
};

MPageComponent.prototype.getFilters = function() {
    return (this.m_filters);
};

/**
 * Gets the array of filter mapping objects used to apply MPages View level settings.
 * @returns {Array} An array of filter mapping objects.
 */
MPageComponent.prototype.getFilterMappingsObj = function() {
    return this.m_filterMappingsObj;
};

MPageComponent.prototype.getFooterText = function() {
    return (this.m_footerText);
};

/**
 * This function returns true if the gapcheck banner is dismissed.
 * @returns {boolean}
 */
MPageComponent.prototype.getGapCheckBannerDismiss = function() {
    return this.m_gapCheckBannerDismiss;
};

MPageComponent.prototype.getGrouperCatalogCodes = function(index) {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    if (index !== null && !isNaN(index)) {
        return (this.m_grouper_arr[index]) ? this.m_grouper_arr[index].catalogCodes : "";
    }
};

MPageComponent.prototype.getGrouperCatLabel = function(index) {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    if (index !== null && !isNaN(index)) {
        return (this.m_grouper_arr[index]) ? this.m_grouper_arr[index].catLabel : "";
    }
};

MPageComponent.prototype.getGrouperCriteria = function(index) {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    if (index !== null && !isNaN(index)) {
        return (this.m_grouper_arr[index]) ? this.m_grouper_arr[index].criteria : "";
    }
};

MPageComponent.prototype.getGrouperFilterCatalogCodes = function() {
    return this.m_grouperFilterCatalogCodes;
};

MPageComponent.prototype.getGrouperFilterCatLabel = function() {
    return this.m_grouperFilterCatLabel;
};

MPageComponent.prototype.getGrouperFilterCriteria = function() {
    return this.m_grouperFilterCriteria;
};

MPageComponent.prototype.getGrouperFilterEventSets = function() {
    return (this.getGrouperFilterCriteria());
};

MPageComponent.prototype.getGrouperFilterLabel = function() {
    return this.m_grouperFilterLabel;
};

MPageComponent.prototype.getGrouperEventSets = function(index) {
    return this.getGrouperCriteria(index);
};

MPageComponent.prototype.getGrouperLabel = function(index) {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    if (index !== null && !isNaN(index)) {
        return (this.m_grouper_arr[index]) ? this.m_grouper_arr[index].label : "";
    }
};

MPageComponent.prototype.getGroups = function() {
    if (this.m_groups === null) {
        this.m_groups = [];
    }
    return (this.m_groups);
};

MPageComponent.prototype.getGrp1CatalogCodes = function() {
    return this.getGrouperCatalogCodes(0);
};

MPageComponent.prototype.getGrp1CatLabel = function() {
    return this.getGrouperCatLabel(0);
};

MPageComponent.prototype.getGrp1Criteria = function() {
    return this.getGrouperCriteria(0);
};

MPageComponent.prototype.getGrp1EventSets = function() {
    return this.getGrouperCriteria(0);
};

MPageComponent.prototype.getGrp1Label = function() {
    return this.getGrouperLabel(0);
};

MPageComponent.prototype.getGrp2CatalogCodes = function() {
    return this.getGrouperCatalogCodes(1);
};

MPageComponent.prototype.getGrp2CatLabel = function() {
    return this.getGrouperCatLabel(1);
};

MPageComponent.prototype.getGrp2Criteria = function() {
    return this.getGrouperCriteria(1);
};

MPageComponent.prototype.getGrp2EventSets = function() {
    return this.getGrouperCriteria(1);
};

MPageComponent.prototype.getGrp2Label = function() {
    return this.getGrouperLabel(1);
};

MPageComponent.prototype.getGrp3CatalogCodes = function() {
    return this.getGrouperCatalogCodes(2);
};

MPageComponent.prototype.getGrp3CatLabel = function() {
    return this.getGrouperCatLabel(2);
};

MPageComponent.prototype.getGrp3Criteria = function() {
    return this.getGrouperCriteria(2);
};

MPageComponent.prototype.getGrp3EventSets = function() {
    return this.getGrouperCriteria(2);
};

MPageComponent.prototype.getGrp3Label = function() {
    return this.getGrouperLabel(2);
};

MPageComponent.prototype.getGrp4CatalogCodes = function() {
    return this.getGrouperCatalogCodes(3);
};

MPageComponent.prototype.getGrp4CatLabel = function() {
    return this.getGrouperCatLabel(3);
};

MPageComponent.prototype.getGrp4Criteria = function() {
    return this.getGrouperCriteria(3);
};

MPageComponent.prototype.getGrp4EventSets = function() {
    return this.getGrouperCriteria(3);
};

MPageComponent.prototype.getGrp4Label = function() {
    return this.getGrouperLabel(3);
};

MPageComponent.prototype.getGrp5CatalogCodes = function() {
    return this.getGrouperCatalogCodes(4);
};

MPageComponent.prototype.getGrp5CatLabel = function() {
    return this.getGrouperCatLabel(4);
};

MPageComponent.prototype.getGrp5Criteria = function() {
    return this.getGrouperCriteria(4);
};

MPageComponent.prototype.getGrp5EventSets = function() {
    return this.getGrouperCriteria(4);
};

MPageComponent.prototype.getGrp5Label = function() {
    return this.getGrouperLabel(4);
};

MPageComponent.prototype.getGrp6CatalogCodes = function() {
    return this.getGrouperCatalogCodes(5);
};

MPageComponent.prototype.getGrp6CatLabel = function() {
    return this.getGrouperCatLabel(5);
};

MPageComponent.prototype.getGrp6Criteria = function() {
    return this.getGrouperCriteria(5);
};

MPageComponent.prototype.getGrp6EventSets = function() {
    return this.getGrouperCriteria(5);
};

MPageComponent.prototype.getGrp6Label = function() {
    return this.getGrouperLabel(5);
};

MPageComponent.prototype.getGrp7CatalogCodes = function() {
    return this.getGrouperCatalogCodes(6);
};

MPageComponent.prototype.getGrp7CatLabel = function() {
    return this.getGrouperCatLabel(6);
};

MPageComponent.prototype.getGrp7Criteria = function() {
    return this.getGrouperCriteria(6);
};

MPageComponent.prototype.getGrp7EventSets = function() {
    return this.getGrouperCriteria(6);
};

MPageComponent.prototype.getGrp7Label = function() {
    return this.getGrouperLabel(6);
};

MPageComponent.prototype.getGrp8CatalogCodes = function() {
    return this.getGrouperCatalogCodes(7);
};

MPageComponent.prototype.getGrp8CatLabel = function() {
    return this.getGrouperCatLabel(7);
};

MPageComponent.prototype.getGrp8Criteria = function() {
    return this.getGrouperCriteria(7);
};

MPageComponent.prototype.getGrp8EventSets = function() {
    return this.getGrouperCriteria(7);
};

MPageComponent.prototype.getGrp8Label = function() {
    return this.getGrouperLabel(7);
};

MPageComponent.prototype.getGrp9CatalogCodes = function() {
    return this.getGrouperCatalogCodes(8);
};

MPageComponent.prototype.getGrp9CatLabel = function() {
    return this.getGrouperCatLabel(8);
};

MPageComponent.prototype.getGrp9Criteria = function() {
    return this.getGrouperCriteria(8);
};

MPageComponent.prototype.getGrp9EventSets = function() {
    return this.getGrouperCriteria(8);
};

MPageComponent.prototype.getGrp9Label = function() {
    return this.getGrouperLabel(8);
};

MPageComponent.prototype.getGrp10CatalogCodes = function() {
    return this.getGrouperCatalogCodes(9);
};

MPageComponent.prototype.getGrp10CatLabel = function() {
    return this.getGrouperCatLabel(9);
};

MPageComponent.prototype.getGrp10Criteria = function() {
    return this.getGrouperCriteria(9);
};

MPageComponent.prototype.getGrp10EventSets = function() {
    return this.getGrouperCriteria(9);
};

MPageComponent.prototype.getGrp10Label = function() {
    return this.getGrouperLabel(9);
};

MPageComponent.prototype.getHasActionsMenu = function() {
    return this.m_hasActionsMenu;
};

MPageComponent.prototype.getPreferencesObj = function() {
    return this.m_componentPreferences;
};

MPageComponent.prototype.getIViewItemsArrElement = function(index, nameSelect) {
    if (!this.m_iViewItemsArr) {
        this.m_iViewItemsArr = [];
    }

    if (index !== null && !isNaN(index)) {
        switch (nameSelect) {
            case "BAND":
                return (this.m_iViewItemsArr[index]) ? this.m_iViewItemsArr[index].bandName : "";
            case "SECTION":
                return (this.m_iViewItemsArr[index]) ? this.m_iViewItemsArr[index].sectionName : "";
            case "ITEM":
                return (this.m_iViewItemsArr[index]) ? this.m_iViewItemsArr[index].itemName : "";
            default:
                return "";
        }
    }
};

MPageComponent.prototype.getIViewMenuItems = function() {
    return this.m_iViewMenuItems;
};

MPageComponent.prototype.getLabel = function() {
    return (this.m_label);
};

MPageComponent.prototype.getLink = function() {
    return (this.m_link);
};

MPageComponent.prototype.getViewpointLink = function() {
    return this.m_viewpoint_link;
};

MPageComponent.prototype.getViewLink = function() {
    return this.m_view_link;
};

MPageComponent.prototype.getLookbackDays = function() {
    return (this.m_lookbackDays);
};

MPageComponent.prototype.getLookbackMenuItems = function() {
    return this.m_lookBackMenuItems;
};

MPageComponent.prototype.getResultRangeDirection = function() {
    return (this.m_resultRangeDirection);
};
MPageComponent.prototype.getLookbackUnits = function() {
    return (this.m_lookbackUnits);
};

MPageComponent.prototype.getLookbackUnitTypeFlag = function() {
    return (this.m_lookbackUnitTypeFlag);
};

MPageComponent.prototype.getMedHistory = function() {
    return (this.m_medHistory);
};

MPageComponent.prototype.getMedRecAdmit = function() {
    return (this.m_medRecAdmit);
};

MPageComponent.prototype.getMedRecTransfer = function() {
    return (this.m_medRecTransfer);
};

MPageComponent.prototype.getMedRecCrossEncTx = function() {
    return (this.m_medRecCrossEncTx);
};

MPageComponent.prototype.getMedRecDischarge = function() {
    return (this.m_medRecDischarge);
};

/**
 * Retrieves the menu that is created by the architecture for this component
 * @returns {Menu} The Menu object created for this component by the architecture
 */
MPageComponent.prototype.getMenu = function() {
    return MP_MenuManager.getMenuObject(this.m_compMenuId);
};

MPageComponent.prototype.getMenuItems = function() {
    return this.m_menuItems;
};

MPageComponent.prototype.getMenuOptionNames = function() {
    return this.m_menuOptionNames;
};

MPageComponent.prototype.getMenuOptions = function() {
    return this.m_menuOptions;
};

MPageComponent.prototype.getMPageName = function() {
    return (this.m_MPageName);
};

MPageComponent.prototype.getPageGroupSequence = function() {
    return (this.m_pageGroupSeq);
};

MPageComponent.prototype.getRenderStrategy = function() {
    return this.m_renderStrategy;
};

MPageComponent.prototype.getReportId = function() {
    return (this.m_reportId);
};

MPageComponent.prototype.getReportMean = function() {
    return (this.m_reportMean);
};

MPageComponent.prototype.getRootComponentNode = function() {
    if (this.m_rootComponentNode === null) {
        var style = this.getStyles();
        this.m_rootComponentNode = _g(style.getId());
    }
    return (this.m_rootComponentNode);
};

MPageComponent.prototype.getSectionContentNode = function() {
    if (this.m_sectionContentNode === null) {
        var style = this.getStyles();
        this.m_sectionContentNode = _g(style.getContentId());
    }
    return (this.m_sectionContentNode);
};

MPageComponent.prototype.getSelectedDataGroup = function() {
    return (this.m_selectedDataGroup);
};

MPageComponent.prototype.getSelectedTimeFrame = function() {
    return (this.m_selectedTimeFrame);
};

MPageComponent.prototype.getSequence = function() {
    return (this.m_sequence);
};

MPageComponent.prototype.getScope = function() {
    return (this.m_scope);
};

MPageComponent.prototype.getScopeHTML = function() {
    return (this.m_ScopeHTML);
};

MPageComponent.prototype.getScrollNumber = function() {
    return (this.m_scrollNumber);
};

MPageComponent.prototype.getSubLabel = function() {
    return (this.m_subLabel);
};

MPageComponent.prototype.getToggleStatus = function() {
    return this.m_toggleStatus;
};

/**
 * Determines if the component will respect the pregnancy onset as the default lookback when available
 * @returns {Boolean} true if the onset will be respected, false otherwise
 */
MPageComponent.prototype.getPregnancyLookbackInd = function() {
    return this.m_pregLookbackInd;
};

/**
 * For each component a Healthe Intent lookup key is defined for usage.  This key tells HI who to identify a patient
 * @returns {m_hiLookupKey} Returns a Healthe Intent lookup key.
 */
MPageComponent.prototype.getHILookupKey = function() {
    return (this.m_hiLookupKey);
};

/**
 * For each component a Healthe Intent alias type is defined for usage.  This key tells HI how to identify a patient
 * such as by id or by mrn.
 * @returns {m_aliasType} Returns a Healthe Intent alias type.
 */
MPageComponent.prototype.getAliasType = function() {
    return (this.m_aliasType);
};

/**
 * For each component a Healthe Intent alias pool code is defined for usage.  This key tells HI from what alias pool/group
 * the lookup may be in.
 * @returns {m_aliasPoolCd} Returns a Healthe Intent alias pool code.
 */
MPageComponent.prototype.getAliasPoolCd = function() {
    return (this.m_aliasPoolCd);
};

/**
 * Displays the value for the indicator that determine whether to show data from external sources or not
 * @returns {m_externalDataInd} Returns a true or false.
 */
MPageComponent.prototype.getExternalDataInd = function() {
    return (this.m_externalDataInd);
};

/**
 * getPatientEnteredDataInd Returns the value for the patient entered data indicator which is set in bedrock
 * @returns {boolean} m_patEnteredDataInd - true/false
 */
MPageComponent.prototype.getPatientEnteredDataInd = function() {
    return this.m_patEnteredDataInd;
};
/**
 * Displays the text of the Healthe Intent Test Service URI
 * @returns {m_hiTestUri} Returns a test service URI.
 */
MPageComponent.prototype.getHITestUri = function() {
    return (this.m_hiTestUri);
};

/* Checkers - functions used to check the state of variables contained within the MPageComponent object */
MPageComponent.prototype.hasInfoButton = function() {
    return (this.m_hasInfoButton);
};
MPageComponent.prototype.setSequenceInContextualView = function(value) {
    this.m_sequenceInContextualView = value;
};

MPageComponent.prototype.setHasInfoButton = function(value) {
    this.m_hasInfoButton = (value == 1 ? true : false);
};

MPageComponent.prototype.isInfoButtonEnabled = function() {
    return (this.m_isInfoEnabled);
};

MPageComponent.prototype.setIsInfoButtonEnabled = function(value) {
    this.m_isInfoEnabled = (value == 1 ? true : false);
};

MPageComponent.prototype.showInfoButton = function(compObj, stateInd) {
    var contentBodyObj = this.getSectionContentNode();
    // Then search node for info-icon
    var infoButtons = $(contentBodyObj)
        .find(".info-icon");
    if (stateInd) {
        $(infoButtons)
            .removeClass("hidden");
    }
    else {
        $(infoButtons)
            .addClass("hidden");
    }
};

MPageComponent.prototype.hasCompFilters = function() {
    return (this.m_hasCompFilters);
};

MPageComponent.prototype.hasLookBackDropDown = function() {
    return (this.m_hasLookBackDropDown);
};

MPageComponent.prototype.isDisplayable = function() {
    if (this.isComponentFiltered()) {
        return false;
    }
    return this.m_compDisp;
};

/* Getter and  setter for Gap Check functionality */
/**
 * This method returns the disclaimer text that gets added to the unsatisfied components header
 * @returns {string} Returns a Disclaimer text.
 */
MPageComponent.prototype.getRequiredCompDisclaimerText = function() {
    return this.m_disclaimerText;
};
/**
 * This method sets the disclaimer text at the component level that gets added to the unsatisfied components header
 * @param {string} text :disclaimer text specific to the component.
 * @returns {undefined} this method does not have a return value.
 */
MPageComponent.prototype.setRequiredCompDisclaimerText = function(text) {
    this.m_disclaimerText = text;
};
/**
 * This method returns a number indicating when the component is required (0- Not required, 1-Always
 * required, 2- Required for discharge, 3- Required for admit).
 * @returns {Number} m_requiredCriteria - Number indicating when the component is required
 */
MPageComponent.prototype.getGapCheckCriteria = function() {
    return this.m_requiredCriteria;
};
/**
 * This method sets a numerical value indicating when a component is required (0- Not required, 1-Always
 * required, 2- Required for discharge, 3- Required for admit).
 * Also calls setGapCheckRequiredInd if the component is required in at least one workflow.
 * @param {String}requiredCriteria - value indicating the workflow for which component will be required.
 * @returns {undefined} this method does not have a return value.
 */
MPageComponent.prototype.setGapCheckCriteria = function(requiredCriteria) {
    this.m_requiredCriteria = parseInt(requiredCriteria, 10);
};

MPageComponent.prototype.setOnComponentDisclaimerClose = function(callback) {
    this.m_onComponentDisclaimerClose = callback;
};

/**
 * Gets the callback that is called when the component disclaimer closes.
 * @returns {function} callback
 */
MPageComponent.prototype.getOnComponentDisclaimerClose = function() {
    return this.m_onComponentDisclaimerClose;
};

/**
 * Sets the callback to be called when the component disclaimer closes.
 * @param {function} callback
 */
MPageComponent.prototype.setOnSubLabelChange = function(callback) {
    this.m_onSubLabelChange = callback;
};

/**
 * Gets the callback that is called when the component disclaimer closes.
 * @returns {function} callback
 */
MPageComponent.prototype.getOnSubLabelChange = function() {
    return this.m_onSubLabelChange;
};

/**
 * Sets the callback to be called when the component is finalized.
 * @param {function} callback
 */
MPageComponent.prototype.setOnFinalizeComponent = function(callback) {
    this.m_onFinalizeComponent = callback;
};

/**
 * Gets the callback that is called when the component is finalized.
 * @returns {function} callback
 */
MPageComponent.prototype.getOnFinalizeComponent = function() {
    return this.m_onFinalizeComponent;
};

/**
 * Sets the callback to be called when the contextual view is toggled.
 * @param {function} callback
 */
MPageComponent.prototype.setOnContextualViewToggle = function(callback) {
    this.m_onContextualViewToggle = callback;
};

/**
 * Gets the callback that is called when the contextual view is toggled.
 * @returns {function} callback
 */
MPageComponent.prototype.getOnContextualViewToggle = function() {
    return this.m_onContextualViewToggle;
};
/**
 * This method returns a boolean indicating the component is required or not.
 * @returns {boolean} returns the boolean value set.
 */
MPageComponent.prototype.getGapCheckRequiredInd = function() {
    return this.m_isRequired;
};
/**
 * This method sets a boolean value indicating whether it is a required component or not in the given view based on bedrock setting.
 * @param  {boolean}requiredStatus boolean value set based on the component bedrock setting
 * @returns {undefined} this method does not have a return value.
 */
MPageComponent.prototype.setGapCheckRequiredInd = function(requiredStatus) {
    this.m_isRequired = requiredStatus;
};
/**
 * This method returns a number indicating when the component has to be overridden for gap-check.
 * @returns {number} returns the boolean value set.
 */
MPageComponent.prototype.getGapCheckOverrideInd = function() {
    return this.m_overrideInd;
};
/**
 * This method sets a numerical value indicating when a component is to be overridden (0- Never, 1-Always, 2- * Required for discharge, 3- Required for admit).
 * @param {String}overrideStatus - value indicating the workflow for which component will be required.
 * @returns {undefined} this method does not have a return value.
 */
MPageComponent.prototype.setGapCheckOverrideInd = function(overrideStatus) {
    this.m_overrideInd = parseInt(overrideStatus, 10);
};
/**
 * This method returns a boolean based on the validation which is specific to the component.
 * @returns {boolean} returns the boolean value set.
 */
MPageComponent.prototype.getSatisfiedInd = function() {
    return this.m_isSatisfied;
};
/**
 * This method sets a boolean value after checking the condition required for the discharge process, which is specific to the component.
 * @param  {boolean} statisfiedStatus - value set based on the validation added at component level.
 * @returns {null} this method does not have a return value.
 */
MPageComponent.prototype.setSatisfiedInd = function(statisfiedStatus) {
    this.m_isSatisfied = statisfiedStatus;
};
/**
 * Checks the display filters for the component.
 * @returns {boolean} True if the component should not be displayed because of a filter, false otherwise.
 */
MPageComponent.prototype.isComponentFiltered = function() {
    if (this.m_displayFilters !== null && this.m_displayFilters.length > 0) {
        for (var x = this.m_displayFilters.length; x--; ) {
            var displayFilter = this.m_displayFilters[x];
            if (displayFilter.checkFilters() === false) {
                CERN_EventListener.removeAllListeners(this, this);
                return true;
            }
        }
    }
    return false;
};

MPageComponent.prototype.isAlwaysExpanded = function() {
    return (this.m_isAlwaysExpanded);
};

MPageComponent.prototype.isEditMode = function() {
    return (this.m_editMode);
};

MPageComponent.prototype.isExpanded = function() {
    return (this.m_isExpanded);
};

MPageComponent.prototype.isIViewAdd = function() {};

/**
 * Return true if the component has been defined as including the line number within the
 * title text of the component.
 */
MPageComponent.prototype.isLineNumberIncluded = function() {
    return this.m_includeLineNumber;
};

MPageComponent.prototype.isLoaded = function() {
    return (this.m_compLoad);
};

MPageComponent.prototype.isMenuDithered = function(itemName) {
    return this.m_menuOptions[itemName].isMenuDithered;
};

MPageComponent.prototype.isNewLink = function() {
    return (this.m_newLink);
};

/**
 * Retrieves the plus add indicator that will be used to launch the win32 and custom functionality.
 * @returns {boolean} Flag indicating whether the plus add button on the component header should be displayed or not
 * based on the plusaddcustom indicator,in Millennium Context or non Millennium context and the bedrock settings.
 */
MPageComponent.prototype.isPlusAddEnabled = function() {
    if (this.isPlusAddCustom() && this.m_isPlusAdd) {
        return true;
    }
    if (!CERN_Platform.inMillenniumContext()) {
        return false;
    }
    return (this.m_isPlusAdd);
};

/**
 * Getter for refreshEnabled, a boolean that indicates whether the
 * workflow component will be rendered with an enabled component
 * refresh button or not.
 * @returns {boolean}
 */
MPageComponent.prototype.isRefreshEnabled = function() {
    return (this.m_isRefreshEnabled);
};

MPageComponent.prototype.isResourceRequired = function() {
    return (this.m_resourceRequired);
};

MPageComponent.prototype.isScrollingEnabled = function() {
    return (this.m_isScrollEnabled);
};

/**
 * Retrieves the plus add flag which signifies if the addPlus functionality is custom or not.
 * @returns {boolean} Flag indicating whether the functionality tied to the plus add is custom or not.
 */
MPageComponent.prototype.isPlusAddCustom = function() {
    return (this.m_isPlusAddCustom);
};

MPageComponent.prototype.getStyles = function() {
    return (this.m_styles);
};

/**
 * Retrieves the flag that indicates whether the component is Contextual view compatible
 * @returns {boolean} Flag indicating whether the component is Contextual view compatible
 */
MPageComponent.prototype.isContextualViewCompatible = function() {
    return this.m_isContextualViewCompatible;
};

/**
 * Retrieves the flag that indicates whether the component is added to Contextual view
 * @returns {boolean} Flag indicating whether the component is added to Contextual view
 */
MPageComponent.prototype.isAddedToContextualView = function() {
    return this.m_isAddedToContextualView;
};

 /**
 * Retrieves the instance of MPageUI.Button for the contextual view control in actual component
 * @returns {MPageUI.Button} The instance of MPageUI.Button for the contextual view control in actual component.
 */
MPageComponent.prototype.getContextualViewControl = function() {
    return this.m_contextualViewControl;
};
/**
 * Retrieves the flag that indicates whether the component can have Contextual view control
 * @returns {boolean} Flag indicating whether the component can have Contextual view control
 */
MPageComponent.prototype.canHaveContextualViewControl = function() {
    return this.m_canHaveContextualViewControl;
};

/**
 * Retrieves the instance of MPageUI.Button for the contextual view control in PlaceholderView
 * @returns {MPageUI.Button} The instance of MPageUI.Button for the contextual view control in PlaceholderView.
 */
MPageComponent.prototype.getContextualViewControlInPlaceholderView = function() {
    return this.m_contextualViewControlInPlaceholderView;
};

/**
 * Retrieves the sequence of the component in Contextual view
 * @returns {Number} The value that indicates the sequence of the component in contextual view.
 */
MPageComponent.prototype.getSequenceInContextualView = function(value) {    // eslint-disable-line no-unused-vars
    return this.m_sequenceInContextualView;
};
/**
 * Sets the root node of the component as PlaceholderView
 * @param {Object} obj The dom node representing the placeholder view of component
 */
MPageComponent.prototype.getRootPlaceholderComponentNode = function() {
    if(this.m_rootPlaceholderComponentNode === null || !this.m_rootPlaceholderComponentNode.length) {
        var style = this.getStyles();
        this.m_rootPlaceholderComponentNode = $("#" + style.getId() + "PlaceholderView");
    }
    return (this.m_rootPlaceholderComponentNode);
};

/**
 * Sets the instance of PlaceholderView
 * @param {Object} obj An Instance of PlaceholderView
 */
MPageComponent.prototype.getPlaceholderView = function() {
    return this.m_placeholderView;
};

/**
 * This method returns the number of results charted for a specific component.
 * @returns {Number} result count value.
 */

MPageComponent.prototype.getResultCount = function() {
    return (this.m_resultCount);
};

/* Setters - functions used to set the values of MPageComponent object elements*/

/**
 * Set the aggregate timer created by the containing view to measure the page load time
 * @param {AggregateTimer} value the aggregate timer created by the containing view to measure the page load time
 * @returns {undefined}
 */
MPageComponent.prototype.setAggregateTimer = function(value) {
    this.m_aggregateTimer = value;
};

MPageComponent.prototype.setAlwaysExpanded = function(value) {
    this.m_isAlwaysExpanded = value;
};

MPageComponent.prototype.setAutoSuggestAddScript = function(value) {
    this.m_AutoSuggestScript = value;
};

MPageComponent.prototype.setAutoSuggestAddTimerName = function(value) {
    this.m_AutoSuggestAddTimerName = value;
};

MPageComponent.prototype.setBrLookbackUnits = function(value) {
    this.m_brlookbackUnits = value;
};

MPageComponent.prototype.setBrLookbackUnitTypeFlag = function(value) {
    this.m_brlookbackUnitTypeFlag = value;
};

MPageComponent.prototype.setColumn = function(value) {
    this.m_column = value;
};

MPageComponent.prototype.setCompColor = function(color) {
    var style = this.getStyles();
    if (style) {
        if (color && color.length > 0) {
            style.setColor(color);
        }
    }
};

MPageComponent.prototype.setCompFilters = function(value) {
    this.m_hasCompFilters = value;
};

MPageComponent.prototype.setComponentId = function(value) {
    this.m_componentId = value;
    var styles = this.getStyles();
    if (styles !== null) {
        styles.setComponentId(value);
    }
};

MPageComponent.prototype.setComponentFilterMean = function(value) {
    this.m_componentFilterMean = value;
};

MPageComponent.prototype.setComponentLoadTimerName = function(value) {
    this.m_compLoadTimerName = value;
};

MPageComponent.prototype.setComponentRenderTimerName = function(value) {
    this.m_compRenderTimerName = value;
};

MPageComponent.prototype.setComponentTable = function(componentTable) {
    if (!ComponentTable.prototype.isPrototypeOf(componentTable)) {
        throw new Error("Called setComponentTable on MPageComponent with non ComponentTable type for componentTable parameter");
    }
    this.m_componentTable = componentTable;
};

MPageComponent.prototype.getComponentTable = function() {
    return (this.m_componentTable);
};

MPageComponent.prototype.setFlowsheetTable = function(flowsheetTable) {
    if (!(FlowsheetTable.prototype.isPrototypeOf(flowsheetTable))) {
        throw new Error("Called setFlowsheetTable on MPageComponent with non FlowsheetTable type for FlowsheetTable parameter");
    }

    this.m_flowsheetTable = flowsheetTable;
};

MPageComponent.prototype.getFlowsheetTable = function() {
    return (this.m_flowsheetTable);
};
/**
 * Sets the criterion
 * @param {Criterion} value The Criterion object in which to initialize the component with.
 * @returns {undefined}
 */
MPageComponent.prototype.setCriterion = function(value) {
    this.criterion = value;
};

MPageComponent.prototype.setCustomizeView = function(value) {
    this.m_isCustomizeView = value;
};

MPageComponent.prototype.setDateFormat = function(value) {
    this.m_dateFormat = value;
};

MPageComponent.prototype.setDisplayEnabled = function(value) {
    this.m_compDisp = value;
};

MPageComponent.prototype.setDisplayFilters = function(value) {
    this.m_displayFilters = value;
};

MPageComponent.prototype.setEditMode = function(value) {
    this.m_editMode = value;
};

MPageComponent.prototype.setExpandCollapseState = function(value) {
    this.m_isExpanded = value;
    var i18nCore = i18n.discernabu;
    var parentNode = this.getRootComponentNode();
    var expColNode = Util.Style.g("sec-hd-tgl", parentNode, "span");
    if (value) {
        Util.Style.rcss(parentNode, "closed");
        expColNode[0].innerHTML = "-";
        expColNode[0].title = i18nCore.HIDE_SECTION;
    }
    else {
        Util.Style.acss(parentNode, "closed");
        expColNode[0].innerHTML = "+";
        expColNode[0].title = i18nCore.SHOW_SECTION;
    }
};

MPageComponent.prototype.setExpanded = function(value) {
    this.m_isExpanded = value;
};

/**
 * Sets the filter mappings object which will be used when loading settings from the preferences model.  The filterObj parameter must
 * not be null.  If it is null it will be ignored.
 * @param {Object} filterObj An object which contains the filter mappings of the MPageView object
 * @returns {Boolean} True if the m_filterMappingsObj was set to filterObj, false otherwise
 */
MPageComponent.prototype.setFilterMappingsObj = function(filterObj) {
    if (filterObj) {
        this.m_filterMappingsObj = filterObj;
        return true;
    }
    return false;
};

MPageComponent.prototype.setFooterText = function(value) {
    this.m_footerText = value;
};

/**
 * Sets the gapCheckBannerDismiss object which will indicate whether the banner is dismissed or not.
 * it is set to true when gap check banner is dismissed, false when the banner is to be displayed.
 * @param {Object} value true/false indicating gapCheckBanner is dismissed/shown
 */
MPageComponent.prototype.setGapCheckBannerDismiss = function(value) {
    this.m_gapCheckBannerDismiss = value;
};
MPageComponent.prototype.setGrouperCatalogCodes = function(index, CatalogCodeItem) {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    if (index !== null && !isNaN(index)) {
        if (this.m_grouper_arr[index]) {
            this.m_grouper_arr[index].catalogCodes = CatalogCodeItem;
        }
        else {
            this.m_grouper_arr[index] = {};
            this.m_grouper_arr[index].catalogCodes = CatalogCodeItem;
        }
    }
};

MPageComponent.prototype.setGrouperCatLabel = function(index, label) {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    if (index !== null && !isNaN(index)) {
        if (this.m_grouper_arr[index]) {
            this.m_grouper_arr[index].catLabel = label;
        }
        else {
            this.m_grouper_arr[index] = {};
            this.m_grouper_arr[index].catLabel = label;
        }
    }
};

MPageComponent.prototype.setGrouperCriteria = function(index, Criteria) {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    if (index !== null && !isNaN(index)) {
        if (this.m_grouper_arr[index]) {
            this.m_grouper_arr[index].criteria = Criteria;
        }
        else {
            this.m_grouper_arr[index] = {};
            this.m_grouper_arr[index].criteria = Criteria;
        }
    }
};

MPageComponent.prototype.setGrouperEventSets = function(index, EventSetItem) {
    this.setGrouperCriteria(index, EventSetItem);
};

MPageComponent.prototype.setGrouperLabel = function(index, label) {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    if (index !== null && !isNaN(index)) {
        if (this.m_grouper_arr[index]) {
            this.m_grouper_arr[index].label = label;
        }
        else {
            this.m_grouper_arr[index] = {};
            this.m_grouper_arr[index].label = label;
        }
    }
};

MPageComponent.prototype.setGrp1CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(0, value);
};

MPageComponent.prototype.setGrp1CatLabel = function(value) {
    this.setGrouperCatLabel(0, value);
};

MPageComponent.prototype.setGrp1Criteria = function(value) {
    this.setGrouperCriteria(0, value);
};

MPageComponent.prototype.setGrp1EventSets = function(value) {
    this.setGrouperCriteria(0, value);
};

MPageComponent.prototype.setGrp1Label = function(value) {
    this.setGrouperLabel(0, value);
};

MPageComponent.prototype.setGrp2CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(1, value);
};

MPageComponent.prototype.setGrp2CatLabel = function(value) {
    this.setGrouperCatLabel(1, value);
};

MPageComponent.prototype.setGrp2Criteria = function(value) {
    this.setGrouperCriteria(1, value);
};

MPageComponent.prototype.setGrp2EventSets = function(value) {
    this.setGrouperCriteria(1, value);
};

MPageComponent.prototype.setGrp2Label = function(value) {
    this.setGrouperLabel(1, value);
};

MPageComponent.prototype.setGrp3CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(2, value);
};

MPageComponent.prototype.setGrp3CatLabel = function(value) {
    this.setGrouperCatLabel(2, value);
};

MPageComponent.prototype.setGrp3Criteria = function(value) {
    this.setGrouperCriteria(2, value);
};

MPageComponent.prototype.setGrp3EventSets = function(value) {
    this.setGrouperCriteria(2, value);
};

MPageComponent.prototype.setGrp3Label = function(value) {
    this.setGrouperLabel(2, value);
};

MPageComponent.prototype.setGrp4CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(3, value);
};

MPageComponent.prototype.setGrp4CatLabel = function(value) {
    this.setGrouperCatLabel(3, value);
};

MPageComponent.prototype.setGrp4Criteria = function(value) {
    this.setGrouperCriteria(3, value);
};

MPageComponent.prototype.setGrp4EventSets = function(value) {
    this.setGrouperCriteria(3, value);
};

MPageComponent.prototype.setGrp4Label = function(value) {
    this.setGrouperLabel(3, value);
};

MPageComponent.prototype.setGrp5CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(4, value);
};

MPageComponent.prototype.setGrp5CatLabel = function(value) {
    this.setGrouperCatLabel(4, value);
};

MPageComponent.prototype.setGrp5Criteria = function(value) {
    this.setGrouperCriteria(4, value);
};

MPageComponent.prototype.setGrp5EventSets = function(value) {
    this.setGrouperCriteria(4, value);
};

MPageComponent.prototype.setGrp5Label = function(value) {
    this.setGrouperLabel(4, value);
};

MPageComponent.prototype.setGrp6CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(5, value);
};

MPageComponent.prototype.setGrp6CatLabel = function(value) {
    this.setGrouperCatLabel(5, value);
};

MPageComponent.prototype.setGrp6Criteria = function(value) {
    this.setGrouperCriteria(5, value);
};

MPageComponent.prototype.setGrp6EventSets = function(value) {
    this.setGrouperCriteria(5, value);
};

MPageComponent.prototype.setGrp6Label = function(value) {
    this.setGrouperLabel(5, value);
};

MPageComponent.prototype.setGrp7CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(6, value);
};

MPageComponent.prototype.setGrp7CatLabel = function(value) {
    this.setGrouperCatLabel(6, value);
};

MPageComponent.prototype.setGrp7Criteria = function(value) {
    this.setGrouperCriteria(6, value);
};

MPageComponent.prototype.setGrp7Label = function(value) {
    this.setGrouperLabel(6, value);
};

MPageComponent.prototype.setGrp8CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(7, value);
};

MPageComponent.prototype.setGrp8CatLabel = function(value) {
    this.setGrouperCatLabel(7, value);
};

MPageComponent.prototype.setGrp8Criteria = function(value) {
    this.setGrouperCriteria(7, value);
};

MPageComponent.prototype.setGrp8EventSets = function(value) {
    this.setGrouperCriteria(7, value);
};

MPageComponent.prototype.setGrp8Label = function(value) {
    this.setGrouperLabel(7, value);
};

MPageComponent.prototype.setGrp9CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(8, value);
};

MPageComponent.prototype.setGrp9CatLabel = function(value) {
    this.setGrouperCatLabel(8, value);
};

MPageComponent.prototype.setGrp9Criteria = function(value) {
    this.setGrouperCriteria(8, value);
};

MPageComponent.prototype.setGrp9EventSets = function(value) {
    this.setGrouperCriteria(8, value);
};

MPageComponent.prototype.setGrp9Label = function(value) {
    this.setGrouperLabel(8, value);
};

MPageComponent.prototype.setGrp10CatalogCodes = function(value) {
    this.setGrouperCatalogCodes(9, value);
};

MPageComponent.prototype.setGrp10CatLabel = function(value) {
    this.setGrouperCatLabel(9, value);
};

MPageComponent.prototype.setGrp10Criteria = function(value) {
    this.setGrouperCriteria(9, value);
};

MPageComponent.prototype.setGrp10EventSets = function(value) {
    this.setGrouperCriteria(9, value);
};

MPageComponent.prototype.setGrp10Label = function(value) {
    this.setGrouperLabel(9, value);
};

MPageComponent.prototype.setGrouperFilterCatalogCodes = function(value) {
    this.m_grouperFilterCatalogCodes = value;
};

MPageComponent.prototype.setGrouperFilterCatLabel = function(value) {
    this.m_grouperFilterCatLabel = value;
};

MPageComponent.prototype.setGrouperFilterCriteria = function(value) {
    this.m_grouperFilterCriteria = value;
};

MPageComponent.prototype.setGrouperFilterEventSets = function(value) {
    this.setGrouperFilterCriteria(value);
};

MPageComponent.prototype.setGrouperFilterLabel = function(value) {
    this.m_grouperFilterLabel = value;
};

MPageComponent.prototype.setGroups = function(value) {
    this.m_groups = value;
};

MPageComponent.prototype.setHasActionsMenu = function(value) {
    this.m_hasActionsMenu = value;
};

/**
 * This function is used to set the always hide header flag.  This flag indicates if the
 * header of a component should always be hidden.  This flag is only supported within the context
 * of a ComponentContainer MPages View.  This flag will be ignored outside of that context.
 * @param {boolean} alwaysHide True if the component header should always be hidden when being
 * rendered within the ComponentContainer MPagesView, false otherwise.
 * @returns {undefined} This function does not return a value
 */
MPageComponent.prototype.setAlwaysHideHeader = function(alwaysHide){
    this.m_alwaysHideHeader = alwaysHide;
};

MPageComponent.prototype.setLookBackDropDown = function(value) {
    this.m_hasLookBackDropDown = value;
};

/**
 * Allows each component to define, based on requirements, whether or not to display the number of
 * line items within the title text of the component.
 * @param {Boolean} value If true, the line number associated to the component will display within the
 * title text of the component.  Else, the line number will not display within the title text of the
 * component.
 */
MPageComponent.prototype.setIncludeLineNumber = function(value) {
    this.m_includeLineNumber = value;
};

MPageComponent.prototype.setIViewItemsArrElement = function(index, sBandName, sSectionName, sItemName) {
    if (!this.m_iViewItemsArr) {
        this.m_iViewItemsArr = [];
    }

    if (index !== null && !isNaN(index)) {
        this.m_iViewItemsArr[index] = {
            bandName: sBandName,
            sectionName: sSectionName,
            itemName: sItemName
        };
    }
};

MPageComponent.prototype.setIViewMenuItems = function(value) {
    this.m_iViewMenuItems = value;
};

MPageComponent.prototype.setLabel = function(value) {
    this.m_label = value;
};

MPageComponent.prototype.setLink = function(value) {
    this.m_link = value;
};

MPageComponent.prototype.setViewpointLink = function(value) {
    this.m_viewpoint_link = value;
};

MPageComponent.prototype.setViewLink = function(value) {
    this.m_view_link = value;
};

MPageComponent.prototype.setLoaded = function(value) {
    this.m_compLoad = value;
};

MPageComponent.prototype.setLookbackDays = function(value) {
    this.m_lookbackDays = value;
};

MPageComponent.prototype.setLookbackMenuItems = function(value) {
    this.m_lookBackMenuItems = value;
};

MPageComponent.prototype.setLookbackUnits = function(value) {
    this.m_lookbackUnits = value;
};

MPageComponent.prototype.setResultRangeDirection = function(value) {
    this.m_resultRangeDirection = value;
};
MPageComponent.prototype.setLookbackUnitTypeFlag = function(value) {
    this.m_lookbackUnitTypeFlag = value;
};

MPageComponent.prototype.setMedHistory = function( value) {
    this.m_medHistory = value;
};

MPageComponent.prototype.setMedRecAdmit = function(value) {
    this.m_medRecAdmit = value;
};

MPageComponent.prototype.setMedRecTransfer = function(value) {
    this.m_medRecTransfer = value;
};

MPageComponent.prototype.setMedRecCrossEncTx = function(value) {
    this.m_medRecCrossEncTx = value;
};

MPageComponent.prototype.setMedRecDischarge = function(value) {
    this.m_medRecDischarge = value;
};

/**
 * Sets the menu object that will be used for this component.  The actual menu object is not stored in the component
 * but is instead stored in the MP_MenuManager cache for Menu objects so it can be accessed outside of the component.
 * @param {Menu} menuObj The menu object that will be used when rendering this components menu
 * @returns {undefined}
 */
MPageComponent.prototype.setMenu = function(menuObj) {
    // Store the id for this menu so we can fetch it in the getMenu function
    this.m_compMenuId = menuObj.getId();
    // Store the Menu object into the MenuManager cache of Menu objects
    MP_MenuManager.updateMenuObject(menuObj);
};

MPageComponent.prototype.setMenuItems = function(value) {
    this.m_menuItems = value;
};

MPageComponent.prototype.setMenuOptionNames = function(value) {
    if (value) {
        this.m_menuOptionNames = value;
    }
    else {
        this.m_menuOptionNames = [];
    }
};

MPageComponent.prototype.setMenuOptions = function(value) {
    if (value) {
        this.m_menuOptions = value;
    }
    else {
        this.m_menuOptions = [];
    }
};

MPageComponent.prototype.setMenuOptionText = function(itemName, text) {
    if (text) {
        this.m_menuOptions[itemName].text = text;
        var menuItem = _g(this.m_menuOptions[itemName].id);
        if (menuItem) {
            menuItem.innerHTML = text;
        }
    }
};

MPageComponent.prototype.setMPageName = function(value) {
    this.m_MPageName = value;
};

MPageComponent.prototype.setNewLink = function(value) {
    this.m_newLink = value;
};

MPageComponent.prototype.setPageGroupSequence = function(value) {
    this.m_pageGroupSeq = value;
};

MPageComponent.prototype.setPreferencesObj = function(value) {
    this.m_componentPreferences = value;
};

/**
 * Set the RenderStrategy if not already set.
 * @param {Object} renderStrategy An instance of RenderStrategy.
 */
MPageComponent.prototype.setRenderStrategy = function(renderStrategy) {
    if (!this.m_renderStrategy && renderStrategy && RenderStrategy.prototype.isPrototypeOf(renderStrategy)) {
        renderStrategy.setComponentToRender(this);
        this.m_renderStrategy = renderStrategy;
    }
};

MPageComponent.prototype.setPlusAddEnabled = function(value) {
    this.m_isPlusAdd = value;
};

/**
 * Set the plus add custom indicator flag if the functionality tied to the plus add is custom or not.
 * @param {boolean} plusAddCustomInd Flag indicating whether the functionality tied to the plus add is custom or not.
 */
MPageComponent.prototype.setPlusAddCustomInd = function(plusAddCustomInd) {
    this.m_isPlusAddCustom = plusAddCustomInd;
};

/**
 * Set the refresh enabled boolean. This is used by workflow render strategy
 * to determine whether to draw an enabled component refresh button or not.
 * @param {boolean} refreshEnabledBool
 */
MPageComponent.prototype.setRefreshEnabled = function(refreshEnabledBool) {
    this.m_isRefreshEnabled = refreshEnabledBool;
};

MPageComponent.prototype.setReportId = function(value) {
    this.m_reportId = value;
};

MPageComponent.prototype.setReportMean = function(value) {
    this.m_reportMean = value;
};

MPageComponent.prototype.setResourceRequired = function(value) {
    this.m_resourceRequired = value;
};

MPageComponent.prototype.setRootComponentNode = function(value) {
    this.m_rootComponentNode = value;
};

MPageComponent.prototype.setScope = function(value) {
    this.m_scope = value;
};

MPageComponent.prototype.setScopeHTML = function(value) {
    this.m_ScopeHTML = value;
};

MPageComponent.prototype.setScrollingEnabled = function(value) {
    this.m_isScrollEnabled = value;
};

MPageComponent.prototype.setScrollNumber = function(value) {
    this.m_scrollNumber = value;
};

MPageComponent.prototype.setSectionContentNode = function(value) {
    this.m_sectionContentNode = value;
};

MPageComponent.prototype.setSelectedDataGroup = function(value) {
    this.m_selectedDataGroup = value;
};

MPageComponent.prototype.setSelectedTimeFrame = function(value) {
    this.m_selectedTimeFrame = value;
};

MPageComponent.prototype.setSequence = function(value) {
    this.m_sequence = value;
};

MPageComponent.prototype.setStyles = function(value) {
    this.m_styles = value;
};

MPageComponent.prototype.setSubLabel = function(value) {
    this.m_subLabel = value;
};

MPageComponent.prototype.setToggleStatus = function(toggleStatus) {
    if (typeof toggleStatus === "string") {
        this.m_toggleStatus = parseInt(toggleStatus, 10);
    }
    else if (typeof toggleStatus === "number") {
        this.m_toggleStatus = toggleStatus;
    }
};

/**
 * Sets if the component will respect the pregnancy onset as the default lookback when available
 * @param {Boolean} true if the onset will be respected, false otherwise
 */
MPageComponent.prototype.setPregnancyLookbackInd = function(value) {
    this.m_pregLookbackInd = value;
};

/**
 * Sets the Healthe Intent lookup key.
 * @param {String} Healthe Intent lookup key.
 */
MPageComponent.prototype.setHILookupKey = function(value) {
    this.m_hiLookupKey = value;
};

/**
 *Sets the Healthe Intent alias type for the component.
 * @param {String} Healthe Intent alias type.
 */
MPageComponent.prototype.setAliasType = function(value) {
    this.m_aliasType = value;
};

/**
 * Sets the Healthe Intent alias pool code for each component.
 * @param {Number} Healthe Intent alias pool code.
 */
MPageComponent.prototype.setAliasPoolCd = function(value) {
    this.m_aliasPoolCd = value;
};

/**
 * Sets the value for the indicator that determine whether to show data from external sources or not
 * @param {Boolean} True to show external data, false otherwise.
 */
MPageComponent.prototype.setExternalDataInd = function(value) {
    this.m_externalDataInd = value;
};

/**
 * Sets the value for the indicator that determine whether to show patient entered data or not
 * @param {Boolean} True to show patient entered data, false otherwise.
 */
MPageComponent.prototype.setPatientEnteredDataInd = function(value) {
    this.m_patEnteredDataInd = value;
};


/**
 * Sets the text of the Healthe Intent Test Service URI
 * @param {String} sets the test service URI.
 */
MPageComponent.prototype.setHITestUri = function(value) {
    this.m_hiTestUri = value.replace(/&#047;/g, '/');
};

/**
 * Sets whether the component is Contextual view compatible
 * @param  {boolean}  value [boolean to indicated whether the current component is Contextual view compatible]
 */
MPageComponent.prototype.setContextualViewCompatible = function(value) {
    this.m_isContextualViewCompatible = value;
};

/**
 * Sets the flag whether the component is added Contextual view
 * @param  {boolean}  value [flag whether the component is added Contextual view]
 */
MPageComponent.prototype.setAddedToContextualView = function(value) {
    this.m_isAddedToContextualView = value;
};

/**
 * Called when the component is added or removed from contextual view.
 */
MPageComponent.prototype.toggledFromContextualView = function() {
    this.getOnContextualViewToggle()();
};

/**
 * Sets the instance of MPageUI.Button for the contextual view control in actual component
 * @param  {MPageUI.Button}  value Instance of MPageUI.Button for the contextual view control in actual component
 */
MPageComponent.prototype.setContextualViewControl = function(value) {
    this.m_contextualViewControl = value;
};

/**
 * Sets the flag whether the component can have the control to launch the Contextual view
 * @param  {boolean}  value The flag whether the component can have the control to launch the Contextual view
 */
MPageComponent.prototype.setHasContextualViewControl = function(value) {
    this.m_canHaveContextualViewControl = value;
};

/**
 * Sets the instance of MPageUI.Button for the contextual view control in placeholder view
 * @param  {MPageUI.Button}  value Instance of MPageUI.Button for the contextual view control in in placeholder view.
 */
MPageComponent.prototype.setContextualViewControlInPlaceholderView = function(value) {
    this.m_contextualViewControlInPlaceholderView = value;
};
/**
 * Sets the root node of the component as PlaceholderView
 * @param {Object} obj The dom node representing the placeholder view of component
 */
MPageComponent.prototype.setRootPlaceholderComponentNode = function(obj) {
    this.m_rootPlaceholderComponentNode = obj;
};

/**
 * Sets the instance of PlaceholderView
 * @param {Object} obj An Instance of PlaceholderView
 */
MPageComponent.prototype.setPlaceholderView = function(obj) {
    this.m_placeholderView = obj;
};

/**
 * Sets the sequence of the component in the Contextual View
 * @param {Number} value The sequence of the component in Contextual view.
 */
MPageComponent.prototype.setSequenceInContextualView = function(value) {
    this.m_sequenceInContextualView = value;
};

/**
 * This method sets the number of results charted for a specific component.
 * @param {string} value The result count value.
 * @returns {undefined}
 */

MPageComponent.prototype.setResultCount = function(value) {
    if (value && typeof value === "string") {
        this.m_resultCount = parseInt((value.replace(/[^0-9]+/g, "")), 10);
    }
    else if (typeof value === "number") {
        this.m_resultCount = value;
    }
};

/* Miscellaneous - A variety of functions which are used when rendering the component */

/**
 * This function is used to generate the HTML mark-up for a component when no results have been retrieved for the component.
 * @returns {string} The HTML mark-up that will be used as the component display
 */
MPageComponent.prototype.generateNoDataFoundHTML = function() {
    var i18nCore = i18n.discernabu;
    return ("<h3 class='info-hd'><span class='res-normal'>" + i18nCore.NO_RESULTS_FOUND + "</span></h3><span class='res-none'>" + i18nCore.NO_RESULTS_FOUND + "</span>");
};
/**
 * This function is used to generate the HTML mark-up for a component when a script failure has occurred.
 * @returns {string} The HTML mark-up that will be used as the component display
 */
MPageComponent.prototype.generateScriptFailureHTML = function() {
    var i18nCore = i18n.discernabu;
    var nameSpace = this.getStyles()
        .getNameSpace() + "-";
    // Create the HTML that will be returned to the component
    return "<h3 class='info-hd'><span class='res-normal'>" + i18nCore.ERROR_RETREIVING_DATA + "</span></h3><dl class='" + nameSpace + "info error-message error-text'><dd><span>" + i18nCore.ERROR_RETREIVING_DATA + "</span></dd></dl>";
};
/**
 * Applies a template (class) to the sec-content element, allowing the component to inherit the specified template and its styles
 * @param {string} template : The template (class) to apply to the component
 */
MPageComponent.prototype.applyTemplate = function(template) {
    var contentNode = this.getSectionContentNode();
    Util.Style.acss(contentNode, template);
};

MPageComponent.prototype.createAccordionContent = function() {
    return this.m_renderStrategy.createComponentFilter();
};

MPageComponent.prototype.createAccordionControls = function() {
    var i18nCore = i18n.discernabu;
    var mnuCompId = this.getComponentId();
    var pageControl = $("<div></div>")
        .addClass("lb-pg-hd lb-page-ctrl");

    // Create the filter controls
    var setDefaultControl = $("<a></a>")
        .addClass("setDefault")
        .html(i18nCore.SET_AS_DEFAULT);
    var clearAllControl = $("<a></a>")
        .addClass("resetAll")
        .html(i18nCore.RESET_ALL);

    // Attach the click events
    setDefaultControl.click(function() {
        MP_Core.AppUserPreferenceManager.SaveCompPreferences(mnuCompId);    // eslint-disable-line new-cap
    });
    clearAllControl.click(function() {
        MP_Core.AppUserPreferenceManager.ClearCompPreferences(mnuCompId);    // eslint-disable-line new-cap
    });
    pageControl.append(setDefaultControl);
    pageControl.append(clearAllControl);

    return pageControl;
};

MPageComponent.prototype.createMenu = function() {
    var arr = this.m_menuOptionNames;
    var l = arr.length;
    var actionSec = _g("optsMenuActions" + this.m_componentId);
    if (actionSec) {
        if (actionSec.hasChildNodes()) {
            actionSec.innerHTML = "";
        }

        var d = Util.ce("div");
        for (var i = 0; i < l; i++) {
            var optClass = "opts-menu-item";
            var curOpt = this.m_menuOptions[arr[i]];
            if (curOpt.ditherOnLoad) {
                optClass += " opts-menu-item-dthr";
            }

            var t = Util.cep("div", {
                id: curOpt.id,
                className: optClass
            });
            t.innerHTML = curOpt.text;
            if (curOpt.evtType && typeof curOpt.fn === "function") {
                Util.addEvent(t, curOpt.evtType, curOpt.fn);
            }
            d.appendChild(t);
        }

        if (l > 0) {
            var personalizeSec = _g("optsMenupersonalize" + this.m_componentId);
            if (personalizeSec) {
                Util.Style.acss(personalizeSec, "opts-personalize-sec-divider");
            }
        }
        actionSec.appendChild(d);
    }
};

/**
 * This function is used to parse the various fields of a bedrock component filter.  The objects created from the
 * parsing are returned to the calling function so the application of the filter values can be made.
 * @param {object}    compFilter : The JSON object for a component filter containing all of the necessary information
 * for the specific component filer.
 * @returns {[MPageGroupValue]} An array of MPageGroupValue objects.
 */
MPageComponent.prototype.getFilterValues = function(compFilter) {
    var value = null;
    var valueArr = [];
    var valueCnt = compFilter.VALS.length;
    var valueObj = null;
    var x = 0;
    for (x = 0; x < valueCnt; x++) {
        valueObj = compFilter.VALS[x];
        value = new MPageGroupValue();
        value.setId(valueObj.PE_ID); // PE_ID is shorthand for Parent Entity ID
        value.setName(valueObj.PE_NM); // PE_NM is shorthand for Parent Entity Name
        value.setMeaning(valueObj.CDF_MN); // CDF_MN is shorthand for CDF Meaning
        value.setDescription(CERN_Platform.encoding.htmlDecode(valueObj.FTXT)); // FTXT is shorthand for Freetext Description
        value.setSequence(valueObj.G_SQ); // G_SQ is shorthand for Group Sequence
        value.setValueSequence(valueObj.V_SQ); // V_SQ is shorthand for Value Sequence
        value.setValueTypeFlag(valueObj.V_TYP); // V_TYP is shorthand for Value Type Flag
        value.setQualifierFlag(valueObj.Q_FLG); // Q_FLG is shorthand for Qualifier Flag
        value.setParentId(valueObj.PE_ID2); // PE_ID2 is shorthand for PARENT_ENTITY_ID2
        valueArr.push(value);
    }
    return valueArr;
};

/**
 * Initializes hover functionality for all elements within a specified node that follow a specific pattern:
 * A DL element of class "result-info" immediately followed by an element of class "result-details"
 * @param {node} baseNode : The element to search within (The "scope" of the search)
 */
MPageComponent.prototype.initHovers = function(baseNode) {
    // Obtain all results with the "result-info" class in the base element
    var results = Util.Style.g("result-info", baseNode, "DL");
    // Initialize hovers for each result that follows the pattern
    for (var i = results.length; i--; ) {
        var curResult = results[i];
        // Obtain the element that immediately follows the result in the DOM
        var nextElement = Util.gns(curResult);
        if (nextElement) {
            // If this next element has a "result-details" class, call hs() to set up the hover
            if (Util.Style.ccss(nextElement, "result-details")) {
                hs(curResult, nextElement, this);
            }
        }
    }
};

/**
 * This function is used to process the Category Type Assignment information from a component filter.
 * @param {object} compFilter This component filter object which contains all of the necessary information for this specific
 * component filter
 * @returns {null}
 */
MPageComponent.prototype.loadCategoryTypeAssignments = function(compFilter) {
    var ctaArr = null;
    var ctaCnt = 0;
    var ctaVal = null;
    var curSeq = -1;
    var grouper = null;
    var group = null;
    var x = 0;
    ctaArr = this.getFilterValues(compFilter);
    ctaCnt = ctaArr.length;
    grouper = new MPageGrouper();
    for (x = 0; x < ctaCnt; x++) {
        ctaVal = ctaArr[x];
        if (ctaVal.getSequence() != curSeq) {
            group = new MPageCodeValueGroup();    // eslint-disable-line no-undef
            curSeq = ctaVal.getSequence();
            group.setSequence(curSeq);
            grouper.addGroup(group);
        }
        group.addCode(ctaVal.getId());
    }
    this.addGroup(grouper);
};

/**
 * This function is used to process the Clinical Event Grouper information from a component filter.
 * @param {object} compFilter This component filter object which contains all of the necessary information for this specific
 * component filter
 * @returns {null}
 */
MPageComponent.prototype.loadCEGroupers = function(compFilter) {
    var ceArr = null;
    var ceCnt = 0;
    var curSeq = -1;
    var desc = "";
    var group = null;
    var grouper = null;
    var groupArr = null;
    var groupCnt = 0;
    var id = 0;
    var value = null;
    var x = 0;
    var y = 0;
    // Understood that these grouped results have a title and then a list of event codes associated
    // to them.  The identifier for each group is that the group sequence is the same for the results.
    // Only one field will have a free text description, the other results will be event codes

    // because bedrock is nice enough to store the grouping of event codes seperate from a flat list of
    // the codes, overwrite the existing group with the new MPageGrouper
    groupArr = this.getGroups();
    if (groupArr && groupArr.length !== 0) {
        groupCnt = groupArr.length;
        for (x = 0; x < groupCnt; x++) {
            group = groupArr[x];
            if (group.getSequence() == compFilter.F_SQ) { // F_SQ is shorthand for Filter Sequence
                ceArr = this.getFilterValues(compFilter);
                ceCnt = ceArr.length;
                grouper = new MPageGrouper();
                grouper.setGroupId(group.getGroupId());
                // for alignment with sequencing of groups
                grouper.setGroupName(group.getGroupName());
                for (y = 0; y < ceCnt; y++) {
                    value = ceArr[y];
                    if (value.getSequence() != curSeq) {
                        curSeq = value.getSequence();
                        group = new MPageEventCodeGroup();
                        group.setSequence(curSeq);
                        grouper.addGroup(group);
                    }
                    id = value.getId();
                    desc = value.getDescription();
                    if (id > 0) {
                        group.addEventCode(id);
                    }
                    if (desc !== "") {
                        group.setGroupName(desc);
                    }
                }
                groupArr[x] = grouper;
            }
        }
    }
};

/**
 * This function is used to process the component color information from a component filter.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @returns {null}
 */
MPageComponent.prototype.loadComponentColor = function(compFilter) {
    var colorArr = null;
    var color = null;

    // Make sure the color hasn't already been set by the user preferences
    if (!this.getCompColor()) {
        colorArr = this.getFilterValues(compFilter);
        // Only use the first color returned
        color = colorArr[0].m_meaning.replace("_", "")
            .toLowerCase();
        this.setCompColor(color);
    }
};

/**
 * This function is used to process the Event Code information from a component filter.  This function also handles sequenced Event
 * Code filters.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @returns {null}
 */
MPageComponent.prototype.loadEventCodes = function(compFilter) {
    var compGroups = null;
    var compGroupCnt = 0;
    var ecArr = [];
    var ecCnt = 0;
    var group = null;
    var newGroup = false;
    var x = 0;

    // Locate existing group with the same id
    compGroups = this.getGroups();
    compGroupCnt = compGroups.length;
    for (x = 0; x < compGroupCnt; x++) {
        if (compGroups[x].getSequence() == compFilter.F_SQ) { // F_SQ is shorthand for Filter Sequence
            group = compGroups[x];
            break;
        }
    }

    // Check to see if the existing group is already available.
    if (group) {
        if (group.isSequenced()) {
            // If the group is already sequenced we should be done with this set of event codes
            return;
        }
        else {
            // If the group is available and not already sequenced the we are now examining the
            // EVENT_SEQ and need to clear the previous set of event codes
            group.setEventCodes(null);
        }
    }
    else {
        // No group exists for this component filter so create one.
        group = new MPageEventCodeGroup();
        group.setGroupId(compFilter.F_ID); // F_ID is shorthand for Filter Id(br_datamart_filter_id)
        group.setGroupName(compFilter.F_MN); // F_MN is shorthand for Filter Mean
        group.setSequence(compFilter.F_SQ); // F_SQ is shorthand for Filter Sequence
        // Set a flag indicating that we are creating a new group
        newGroup = true;
    }

    // Load the event codes
    group.setSequenced(compFilter.FC_MN === "EVENT_SEQ" ? true : false); // FC_MN is shorthand for Filter Category Mean
    ecArr = this.getFilterValues(compFilter);
    ecCnt = ecArr.length;
    for (x = 0; x < ecCnt; x++) {
        group.addEventCode(ecArr[x].getId());
    }

    // Store the group in the component
    if (newGroup) {
        this.addGroup(group);
    }
};

/**
 * This function is used to process the Event Set information from a component filter.  This function also handles sequenced Event
 * Set filters.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @returns {null}
 */
MPageComponent.prototype.loadEventSets = function(compFilter) {
    var compGroups = null;
    var compGroupCnt = 0;
    var esArr = null;
    var esCnt = 0;
    var esValue = null;
    var group = null;
    var groupIndx = 0;
    var isMultiValue = false;
    var newGroup = null;
    var seqGroup = null;
    var tempAr = [];
    var tempMap = [];
    var x = 0;
    // Locate existing group with the same id
    compGroups = this.getGroups();
    compGroupCnt = compGroups.length;
    for (x = 0; x < compGroupCnt; x++) {
        if (compGroups[x].getSequence() == compFilter.F_SQ) { // F_SQ is shorthand for Filter Sequence
            group = compGroups[x];
            groupIndx = x;
            break;
        }
    }

    // Check to see if the existing group is already available
    if (group) {
        if (MPageSequenceGroup.prototype.isPrototypeOf(group) || group.isSequenced()) {
            // If the group is already sequenced we should be done with this set of event sets
            return;
        }
        else {
            // If the group is available and not already sequenced the we are now examining the
            // EVENT_SET_SEQ and need to clear the previous set of event codes
            group.setEventSets(null);
        }
    }
    else {
        // No group exists for this component filter so create one
        group = new MPageEventSetGroup();
        group.setGroupId(compFilter.F_ID); // F_ID is shorthand for Filter Id(br_datamart_filter_id)
        group.setGroupName(compFilter.F_MN); // F_MN is shorthand for Filter Mean
        group.setSequence(compFilter.F_SQ); // F_SQ is shorthand for Filter Sequence
        newGroup = true;
    }

    // Load the event sets
    group.setSequenced(compFilter.FC_MN === "EVENT_SET_SEQ" ? true : false); // FC_MN is shorthand for Filter Category Mean
    esArr = this.getFilterValues(compFilter);
    esCnt = esArr.length;
    for (x = 0; x < esCnt; x++) {
        esValue = esArr[x];
        group.addEventSet(esValue.getId());
        tempAr.push(esValue.getId());
        // The isMultiValue is special logic used when loading Vitals sequencing on paired results.
        if (esValue.getName() != "CODE_VALUE") {
            isMultiValue = true;
        }
        MP_Util.AddItemToMapArray(tempMap, esValue.getName(), esValue.getId());    // eslint-disable-line new-cap
    }
    // The isMultiValue is special logic used when loading Vitals sequencing on paired results.
    if (isMultiValue) {
        seqGroup = new MPageSequenceGroup();
        seqGroup.setMultiValue(isMultiValue);
        seqGroup.setItems(tempAr);
        seqGroup.setMapItems(tempMap);
        seqGroup.setSequence(group.getSequence());
        seqGroup.setGroupId(group.getGroupId());
        seqGroup.setGroupName(group.getGroupName());
        if (newGroup) {
            this.addGroup(seqGroup);
        }
        else {
            compGroups[groupIndx] = seqGroup;
        }
        return;
    }

    // Store the group in the component
    if (newGroup) {
        this.addGroup(group);
    }
};

/**
 * This function is used to process the iView Options information from a component filter.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @returns {null}
 */
MPageComponent.prototype.loadIViewOptions = function(compFilter) {
    var iViewArr = null;
    var iViewCnt = 0;
    var iViewItem = null;
    var menuItem = null;
    var x = 0;
    iViewArr = this.getFilterValues(compFilter);
    iViewCnt = iViewArr.length;
    for (x = 0; x < iViewCnt; x++) {
        iViewItem = iViewArr[x];
        menuItem = new MP_Core.MenuItem();
        menuItem.setName(iViewItem.getName());
        menuItem.setDescription(iViewItem.getDescription());
        menuItem.setId(iViewItem.getId());
        menuItem.setValSequence(iViewItem.getValueSequence());
        menuItem.setValTypeFlag(iViewItem.getValueTypeFlag());
        this.addIViewMenuItem(menuItem);
    }
};

/**
 * This function loads the specialized filter mappings for a component if required.
 * @returns {null}
 */
MPageComponent.prototype.loadFilterMappings = function() {
    // Do nothing:  The component will implement this function if necessary
};

/**
 * This function loads the default filter mappings used for all components.  These filter mappings will attempt to handle the parsing
 * and processing of a variety of standard filter types.  If a component needs to handle these types of component filters in a
 * specialized way the component should override the specific filter and handle the processing of the data on its own.
 * @returns {null}
 */
MPageComponent.prototype.loadDefaultFilterMappings = function() {
    // Create filter mappings objects complete with any fields necessary
    this.addFilterMappingObject("EVENT", {
        setFunction: this.loadEventCodes,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("EVENT_SET", {
        setFunction: this.loadEventSets,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("PRIM_EVENT_SET", {
        setFunction: this.loadEventSets,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("COLOR_THEME_CDS", {
        setFunction: this.loadComponentColor,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("LOOK_BACK", {
        setFunction: this.loadLookbackOptions,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("PF_MULTI_SELECT", {
        setFunction: this.loadPowerFormOptions,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("IVIEW_SELECT", {
        setFunction: this.loadIViewOptions,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("CAT_TYPE_ASSIGN", {
        setFunction: this.loadCategoryTypeAssignments,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("CE_GROUP", {
        setFunction: this.loadCEGroupers,
        type: "DEFAULT_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("EVENT_SEQ", {
        setFunction: this.loadEventCodes,
        type: "DEFAULT_SEQUENCED_FILTER",
        field: "ALL"
    });
    this.addFilterMappingObject("EVENT_SET_SEQ", {
        setFunction: this.loadEventSets,
        type: "DEFAULT_SEQUENCED_FILTER",
        field: "ALL"
    });
};

/**
 * This function is used to process the Lookback Options information from a component filter.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @returns {null}
 */
MPageComponent.prototype.loadLookbackOptions = function(compFilter) {
    var lbArr = null;
    var lbCnt = 0;
    var lookback = null;
    var menuItem = null;
    var x = 0;
    lbArr = this.getFilterValues(compFilter);
    lbCnt = lbArr.length;
    for (x = 0; x < lbCnt; x++) {
        lookback = lbArr[x];
        menuItem = new ResultRangeSelection();    // eslint-disable-line no-undef
        menuItem.setUnits(parseInt(lookback.getDescription(), 10));
        menuItem.setScope(this.getScope());
        switch (lookback.getMeaning()
            .toUpperCase()) {
            case "HOURS":
                menuItem.setType(1);
                break;
            case "DAYS":
                menuItem.setType(2);
                break;
            case "WEEKS":
                menuItem.setType(3);
                break;
            case "MONTHS":
                menuItem.setType(4);
                break;
            case "YEARS":
                menuItem.setType(5);
                break;
        }
        menuItem.setDisplay(ResultRangeSelectionUtility.getDisplayText(menuItem));    // eslint-disable-line no-undef
        this.addLookbackMenuItem(menuItem);
    }
    // Add the default value to the menu
    menuItem = new ResultRangeSelection();    // eslint-disable-line no-undef
    menuItem.setUnits(this.getBrLookbackUnits());
    menuItem.setScope(this.getScope());
    menuItem.setType(this.getBrLookbackUnitTypeFlag());
    menuItem.setDisplay(ResultRangeSelectionUtility.getDisplayText(menuItem));    // eslint-disable-line no-undef
    this.addLookbackMenuItem(menuItem);
};

/**
 * This function is utilized to load the individual filter mappings for a component.  These filter mappings are either defined as a
 * default or defined within the individual implementation of a component.
 * @param {object} mappedFilter : The filter mapping object that will be used to load the compFilter information for the component.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 */
MPageComponent.prototype.loadMappedSettings = function(mappedFilter, compFilter) {
    var field = null;
    var type = null;
    var setFunction = null;
    var valueArr = [];
    var valueCnt = 0;
    var value = null;
    var setValues = [];
    var x = 0;
    valueArr = this.getFilterValues(compFilter);
    valueCnt = valueArr.length;

    // Check to make sure all of the necessary elements are established for the filter mapping
    field = mappedFilter.field;
    type = mappedFilter.type;
    setFunction = mappedFilter.setFunction;
    if (!setFunction || !field || !type) {
        return false;
    }

    // Prepare the parameters to pass into the filter setFunction
    for (x = 0; x < valueCnt; x++) {
        value = valueArr[x];
        switch (field.toUpperCase()) {
            case "FTXT": // FTXT is shorthand for Freetext Description
                setValues.push(value.getDescription());
                break;
            case "PE_ID": // PE_ID is shorthand for Parent Entity Id
                setValues.push(value.getId());
                break;
            case "NOMEN":
                setValues.push({
                    nomen_id: value.getId(),
                    seq: value.getValueSequence(),
                    qual_flag: value.getQualifierFlag()
                });
                break;
            case "V_SQ": // V_SQ is shorthand for Value Sequence
                setValues.push({
                    id: value.getId(),
                    seq: value.getValueSequence()
                });
                break;
            case "LOOK_BACK":
                setValues.push({
                    value: value.getDescription(),
                    units: value.getMeaning()
                });
                break;
            case "CH_ASSIGN":
                setValues.push({
                    parent_id: value.getParentId(),
                    id: value.getId()
                });
                break;
            default:
                break;
        }
    }

    // Make the call into the setFunction with the appropriate parameters.
    switch (type.toUpperCase()) {
        case "ARRAY":
        case "NOMEN":
        case "VALUE_SEQ":
            // Using the call function will pass the setValues in as one array of values
            setFunction.call(this, setValues);
            break;
        case "STRING":
        case "NUMBER":
        case "OBJECT":
            // using the apply function will pass the array setValues in as multiple parameters to the setFunction
            setFunction.apply(this, setValues);
            break;
        case "BOOLEAN":
            setFunction.call(this, (setValues[0] === "1") ? true : false);
            break;
        default:
            // Call the function that the component developer has defined to set the value.  This is generic and what is done with the
            // compFilter is up to the component developer.
            setFunction.call(this, compFilter);
            break;
    }
};

/**
 * This function is used to process the PowerForm Options information from a component filter.
 * @param {object} compFilter : This component filter object which contains all of the necessary information for this specific
 * component filter
 * @returns {null}
 */
MPageComponent.prototype.loadPowerFormOptions = function(compFilter) {
    var menuItem = null;
    var pfArr = null;
    var pfCnt = 0;
    var powerForm = null;
    var x = 0;
    pfArr = this.getFilterValues(compFilter);
    pfCnt = pfArr.length;
    for (x = 0; x < pfCnt; x++) {
        powerForm = pfArr[x];
        menuItem = new MP_Core.MenuItem();
        menuItem.setName(powerForm.getName());
        menuItem.setDescription(powerForm.getDescription());
        menuItem.setId(powerForm.getId());
        this.addMenuItem(menuItem);
    }
};

MPageComponent.prototype.openTab = function() {
    alert("ERROR: openTab has not been implemented within the component");    // eslint-disable-line no-alert
};

/**
 * The fireDiagnosisAddedEvent function should be called by
 * the diagnosis-o1, consolidated-problems-o1 and
 * consolidated-problems-o2 components when a new diagnosis is
 * added. The listeners are intended to be structured documentation
 * components.
 */
MPageComponent.prototype.fireDiagnosisAddedEvent = function() {
    CERN_EventListener.fireEvent(this, this, EventListener.EVENT_DIAGNOSIS_ADDED, null);
};

/**
 * The listenForDiagnosisEvents function should be called by components
 * that want to handle the diagnosis added event. It is intended to be called
 * in the documentation-base component so that structured documentation components
 * can completely refresh. This function will cause the caller to listen for events
 * regarding diagnoses from diagnosis, consolidated-problem o1 and o2 and
 * components that use the entity framework.
 */
MPageComponent.prototype.listenForDiagnosisEvents = function() {
    CERN_EventListener.addListener(this, EventListener.EVENT_DIAGNOSIS_ADDED, this.onDiagnosisAdded, this);
    CERN_EventListener.addListener(this, EventListener.EVENT_CONDITIONS_UPDATE, this.onDiagnosisAdded, this);
};

/**
 * The onDiagnosisAdded should be implemented in any class that calls
 * handleDiagnosisAddedEvents()
 */
MPageComponent.prototype.onDiagnosisAdded = function() {
    //
    // this is intentionally a stub and should be implemented by the caller of handleDiagnosesAddedEvents()
    //
};

/**
 * The listenForPrescribedEvents function should be called by components
 * that want to handle the prescriptions added/removed event.
 * This function will cause the caller to listen for events regarding prescriptions removed from home-medications o1 and o2
 * @returns {undefined} This function does not return a value
 */
MPageComponent.prototype.listenForPrescribedEvents = function() {
    CERN_EventListener.addListener(this, EventListener.EVENT_PRESCRIPTION_REMOVED, this.onPrescriptionAddedRemoved, this);
    CERN_EventListener.addListener(this, EventListener.EVENT_ORDER_ACTION, this.onPrescriptionAddedRemoved, this);
};

/**
 * The onPrescriptionAddedRemoved should be implemented in any class that calls
 * handlePrescriptionIsRemovedEvents()
 * @returns {undefined} This function does not return a value
 */
MPageComponent.prototype.onPrescriptionAddedRemoved = function() {
	//
	// this is intentionally a stub and should be implemented by the caller of onPrescriptionAddedRemoved()
	//
};


/**
 * This function is used to refresh the contents of a component.
 */
MPageComponent.prototype.refreshComponent = function() {
    if (this.isDisplayable()) {
        // If we are working with a workflow component clear any flags that may have been set
        if (this.getStyles()
            .getComponentType() === CERN_COMPONENT_TYPE_WORKFLOW) {
            CERN_EventListener.fireEvent(this, this, EventListener.EVENT_CRITICAL_UPDATE, {
                "critical": null
            });
            CERN_EventListener.fireEvent(this, this, EventListener.EVENT_COUNT_UPDATE, {
                "count": null
            });
            CERN_EventListener.fireEvent(this, this, EventListener.EVENT_ERROR_UPDATE, {
                "error": null
            });
        }

        this.startComponentDataRetrieval();
    }
};

MPageComponent.prototype.removeMenuDither = function(itemName) {
    var menuItem = _g(this.m_menuOptions[itemName].id);
    if (menuItem) {
        Util.Style.rcss(menuItem, "opts-menu-item-dthr");
        this.m_menuOptions[itemName].isMenuDithered = false;
    }
};

MPageComponent.prototype.renderAccordion = function(component) {};    // eslint-disable-line no-unused-vars

/**
 * This function will be used to resize the component based on the type.
 */
MPageComponent.prototype.resizeComponent = function() {
    var calcHeight = "";
    var compHeight = 0;
    var compDOMObj = null;
    var compType = this.getStyles()
        .getComponentType();
    var container = null;
    var contentBodyHeight = 0;
    var contentBodyObj = null;
    var miscHeight = 20;
    var viewHeight = 0;

    if (compType === CERN_COMPONENT_TYPE_WORKFLOW) {
        container = $("#vwpBody");
        if (!container.length) {
            return;
        }
        viewHeight = container.height();

        // Make sure component is rendered
        compDOMObj = $("#" + this.getStyles()
            .getId());
        if (!compDOMObj.length) {
            return;
        }

        // Get the overall height of the content-body section if available at this time
        contentBodyObj = compDOMObj.find(".content-body");
        if (contentBodyObj.length) {
            // Get the overall component height
            compHeight = compDOMObj.height();
            // Get the height of the content-body
            contentBodyHeight = contentBodyObj.height();
            // Calculate the estimated max height of the components content-body element
            calcHeight = (viewHeight - (compHeight - contentBodyHeight + miscHeight)) + "px";
            // apply the max-height settings
            contentBodyObj.css("max-height", calcHeight)
                .css("overflow-y", "auto");
        }
    }
    // If the component has a component table, call the table's post-resize function
    if (this.getComponentTable()) {
        this.getComponentTable()
            .updateAfterResize();
    }

    // If the component has a flowsheet table, call the table's post-resize function
    if (this.getFlowsheetTable()) {
        this.getFlowsheetTable()
            .updateAfterResize();
    }
};

MPageComponent.prototype.RetrieveRequiredResources = function() {
    alert("ERROR: RetrieveRequiredResources has not been implemented within the component");    // eslint-disable-line no-alert
};

MPageComponent.prototype.sortGrouperArrayByLabel = function() {
    if (!this.m_grouper_arr) {
        this.m_grouper_arr = [];
    }

    this.m_grouper_arr.sort(function(a, b) {
        if (a.label && b.label) {
            var aLabel = a.label.toUpperCase();
            var bLabel = b.label.toUpperCase();
            if (aLabel < bLabel) {
                return -1;
            }
            else {
                if (aLabel === bLabel) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        }
        else if (a.catLabel && b.catLabel) {
            var aCatLabel = a.catLabel.toUpperCase();
            var bCatLabel = b.catLabel.toUpperCase();
            if (aCatLabel < bCatLabel) {
                return -1;
            }
            else {
                if (aCatLabel === bCatLabel) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        }
        else if (a.label || a.catLabel) {
            return 1;
        }
        else {
            return -1;
        }
    });

};

MPageComponent.prototype.updateLabel = function(value) {
    this.m_label = value;
    var rootComponentNode = this.getRootComponentNode();
    var secHead = Util.gc(rootComponentNode, 0);
    var secTitle = Util.gc(Util.Style.g("sec-title", secHead, "span")[0], 0);
    var anchor = _gbt("a", secTitle);
    if (anchor[0]) { // If secTitle is a link update the link
        anchor[0].innerHTML = value;
    }
    else { // otherwise update just the title
        secTitle.innerHTML = value;
    }
};

MPageComponent.prototype.updateSubLabel = function(value) {
    this.m_subLabel = value;
    this.m_onSubLabelChange(value);

    // Update the Label sub header
    var rootComponentNode = this.getRootComponentNode();
    var totalCount = Util.Style.g("sec-total", rootComponentNode, "span");
    if (totalCount.length) {
        totalCount[0].innerHTML = this.m_subLabel;
    }
};
MPageComponent.prototype.showLoading = function() {
    $(this.getSectionContentNode()).empty();
    this.updateSubLabel(i18n.LOADING_DATA + "...");
};

/* Core - These are the core functions called when instantiating, initializing, rendering and
 * finalizing component.  If you are adding or modifying these functions in any way be sure you
 * understand the full implications of your actions as ALL components and MPages utilize these functions */

/**
 * Perform any special setup needed for the components before being rendered.  The core functionality saves the criterion
 * object in the component and loads the default filter mappings for all components.
 * @param {Criterion} criterion A criterion object which will be used when performing component actions.
 */
MPageComponent.prototype.initializeComponent = function(criterion) {

    // Set the criterion object for the component
    this.setCriterion(criterion);

    // Load the base component filter mappings and any other mappings the component may need.
    this.loadDefaultFilterMappings();
    this.loadFilterMappings();

    // Perform any other initialization that needs to be done for the component.
};

/**
 * This function is used to load all of the component's settings.  The first part of this process loads all of the architectural
 * settings like the expand/collapse state, component color etc...  First the default and Bedrock defined settings are applied.
 * Once those have been set the User's preferences are then used to override any default settings that have been applied.  The
 * second part of the process sets the non-architectural settings like event set and event code settings defined on a per component
 * basis.  This process uses filter mappings to apply the setting in various ways.  The filter mappings can come from the component
 * definition or from an older switch case in the bedrock.js file.
 * @param {object} compSettings : An object which contains all of the settings that will be applied to a specific component.
 */
MPageComponent.prototype.loadComponentSettings = function(compSettings) {
    var compFilter = null;
    var filterCnt = 0;
    var filterMappingObj = null;
    var mappedFilter = null;
    var prefManager = MP_Core.AppUserPreferenceManager;
    var userPrefs = null;
    var x = 0;

    // Load the default settings
    this.setComponentId(compSettings.F_ID); // F_ID is shorthand for Filter Id (br_datamart_filter_id)
    this.setComponentFilterMean(compSettings.F_MN); // F_MN is shorthand for Filter Mean
    this.setReportId(compSettings.R_ID); // R_ID is shorthand for Report Id (br_datamart_report_id)
    this.setReportMean(compSettings.R_MN); // R_MN is shorthand for Report Mean
    this.setLabel(compSettings.LBL);
    this.setMenuOptionNames(null);
    this.setMenuOptions(null);
    this.setLink(compSettings.LNK);
    this.setScrollNumber(compSettings.SCR_NM); // SCR_NM is shorthand for Scroll Number
    this.setScrollingEnabled(compSettings.SCR_EN); // SCR_EN is shorthand for Scroll Enabled
    this.setPlusAddEnabled((compSettings.PLS_AD === 1 ? true : false));
    this.setDateFormat(compSettings.DT_DSP); // DT_DSP is shorthand for Date Display Flag
    this.setBrLookbackUnits(compSettings.LB_UNT || 0); // LB_UNT is shorthand for Lookback Units
    this.setBrLookbackUnitTypeFlag(compSettings.LB_TYP || 0); // LB_TYP is shorthand for Lookback Type Flag
    // The following bedrock settings are not applied if they have already been set at the component level
    this.setLookbackDays(this.getLookbackDays() || 0);
    this.setLookbackUnits(this.getLookbackUnits() || compSettings.LB_UNT || 0); // LB_UNT is shorthand for Lookback Units
    this.setLookbackUnitTypeFlag(this.getLookbackUnitTypeFlag() || compSettings.LB_TYP || 0); // LB_TYP is shorthand for Lookback Type Flag
    this.setScope(this.getScope() || compSettings.SCP); // SCP is shorthand for Scope

    // Retrieve the user level preferences for this component
    // F_ID is shorthand for Filter Id (br_datamart_filter_id)
    userPrefs = prefManager.GetComponentById(compSettings.F_ID, this.criterion.category_mean);    // eslint-disable-line new-cap
    // Load the user level settings if available
    if (userPrefs) {
        this.setIsInfoButtonEnabled(userPrefs.IsInfoButtonEnabled);
        this.setExpanded(userPrefs.expanded);
        this.setColumn(userPrefs.col_seq);
        this.setSequence(userPrefs.row_seq);
        this.setPageGroupSequence(userPrefs.group_seq);
        this.setGrouperFilterLabel(userPrefs.grouperFilterLabel || "");
        this.setGrouperFilterCatalogCodes(userPrefs.grouperFilterCatalogCodes || null);
        this.setGrouperFilterCatLabel(userPrefs.grouperFilterCatLabel || "");
        this.setGrouperFilterCriteria(userPrefs.grouperFilterCriteria || null);
        this.setSelectedTimeFrame(userPrefs.selectedTimeFrame || null);
        this.setSelectedDataGroup(userPrefs.selectedDataGroup || null);
        this.setPreferencesObj(userPrefs.preferencesObj || null);
		if(userPrefs.hasOwnProperty("gapCheckBannerDismiss")){
            this.setGapCheckBannerDismiss(userPrefs.gapCheckBannerDismiss);
        }
        //if the user level preference object and preferencesObj.REQUIRED exist, then check the value for required. 
        //if 1 (banner dismissed), then set the setGapCheckBannerDismiss to true, else to false
        //delete REQUIRED from the preference object as we are moving the gapcheck preference to framework level.
        if ( userPrefs.preferencesObj ) {  
            var savePref  = false;    
            if( userPrefs.preferencesObj.hasOwnProperty("REQUIRED")) {
                savePref = true;
                this.setGapCheckBannerDismiss(!!userPrefs.preferencesObj.REQUIRED);
                delete userPrefs.preferencesObj.REQUIRED;
            }
            if( !Object.keys(userPrefs.preferencesObj).length ) {
                savePref = true;
                userPrefs.preferencesObj = null;
            }
            if( savePref ) {     
                this.setPreferencesObj(userPrefs.preferencesObj);
                this.savePreferences(false);
            }   
        }
        if (userPrefs.compThemeColor) {
            this.setCompColor(userPrefs.compThemeColor);
        }
        // Set the component toggle status.  If defined as 'Required' in bedrock, override the users prefs.
        // 0 - off, 1 - on, 2 - required
        if (userPrefs.toggleStatus !== "undefined" && userPrefs.toggleStatus !== null) {
            if (compSettings.TS !== 2) { // TS is shorthand for Toggle Status
                this.setToggleStatus(userPrefs.toggleStatus);
            }
            else {
                this.setToggleStatus(compSettings.TS); // TS is shorthand for Toggle Status
            }
        }
        else {
            this.setToggleStatus(compSettings.TS); // TS is shorthand for Toggle Status
        }
        // Check for contextual view preferences.
        if (typeof userPrefs.preferencesObj !== "undefined" && userPrefs.preferencesObj !== null) {
            if (typeof userPrefs.preferencesObj.contextualViewPrefs !== "undefined" && userPrefs.preferencesObj.contextualViewPrefs !== null){
                this.setAddedToContextualView(userPrefs.preferencesObj.contextualViewPrefs.isAddedToContextualView);
                this.setSequenceInContextualView(userPrefs.preferencesObj.contextualViewPrefs.row_seq);
            }
        }
    }
    else {
        // No user settings for this component so load client level settings
        this.setExpanded(compSettings.EXP); // EXP is shorthand for Expanded
        this.setColumn(compSettings.C_SQ); // C_SQ is shorthand for Column Sequence
        this.setSequence(compSettings.R_SQ); // R_SQ is shorthand for Row Sequence
        this.setPageGroupSequence(compSettings.G_SQ); // G_SQ is shorthand for Group Sequence
        this.setCompColor(compSettings.THM); // THM is shorthand for Theme
        this.setToggleStatus(compSettings.TS); // TS is shorthand for Toggle Status
    }

    // Load all of the non-standard component settings
    filterMappingObj = this.getFilterMappingsObj();
    filterCnt = compSettings.FILT.length;
    for (x = 0; x < filterCnt; x++) {
        compFilter = compSettings.FILT[x];

        // Check for component defined filters
        mappedFilter = filterMappingObj[compFilter.F_MN]; // F_MN is shorthand for Fitler Mean
        if (mappedFilter) {
            // Call the loadMappedSettings function to load the settings
            this.loadMappedSettings(mappedFilter, compFilter);
            continue;
        }
        else {
            // Check the default mappings if there were no custom mappings
            mappedFilter = filterMappingObj[compFilter.FC_MN]; // FC_MN is shorthand for Filter Category Mean
            if (mappedFilter) {
                // Call the appropriate function of the mapped object
                mappedFilter.setFunction.call(this, compFilter);
                continue;
            }
        }
    }
};

/**
 * This function is used to create the component menu
 */
MPageComponent.prototype.createMainMenu = function() {
    if (this.isDisplayable()) {
        var compId = "mainCompMenu" + this.getStyles()
            .getId();
        var compMenu = new Menu(compId);
        compMenu.setIsRootMenu(true);
        compMenu.setAnchorElementId(compId);
        compMenu.setAnchorActiveClass("opts-menu-open");
        compMenu.setTypeClass("menu-wrkflw-comp-menu");
        compMenu.setAnchorConnectionCorner([ "bottom", "right" ]);
        compMenu.setContentConnectionCorner([ "top", "right" ]);
        compMenu.setContentParentId(this.getStyles()
            .getId());

        // Set this components menu which will also add it to the MenuManager
        this.setMenu(compMenu);
    }
};

/**
 * This function is used to setup any display filters that a component might have.  For instance the Growth Chart
 * component is only valid for individuals younger than the age of 20 yrs, so it should not display when the
 * patient is older than that age.
 */
MPageComponent.prototype.loadDisplayFilters = function() {
    // should be implemented at the component level for setting up display filters.
};

/**
 * This function is used to begin the data retrieval process.  It determines if the component should attempt to retrieve its
 * required data or if it requires some additional resource before it can start the data retrieval process.
 */
MPageComponent.prototype.startComponentDataRetrieval = function() {
    if (this.isResourceRequired()) {
        // This component requires data from a shared resource before it can start the data retrieval process.
        this.RetrieveRequiredResources();    // eslint-disable-line new-cap
    }
    else {
        // Make the necessary calls to start the components data retrieval process.
        this.retrieveComponentData();
    }
};

/**
 * This function is used to make the necessary data retrieval calls for the component.  The base functionality will call the
 * InsertDate function for older components which have not yet been updated to the generic component loading scheme.
 */
MPageComponent.prototype.retrieveComponentData = function() {
    try {
        if (typeof this.InsertData == "function") {
            this.InsertData();    // eslint-disable-line new-cap
        }
    }
    catch (err) {
        MP_Util.LogJSError(err, this, "base-component.js", "retrieveComponentData");    // eslint-disable-line new-cap
        throw (err);
    }

};

/**
 * This is the older base class implementation of the components data retrieval script.  This function should be overridden for each
 * component.
 * @deprecated Component developers should now be suing the retrieveComponentData() function.
 */
MPageComponent.prototype.InsertData = function() {
    alert("ERROR: InsertData has not been implemented within the component");    // eslint-disable-line no-alert
};

/**
 * This function is used to pass the data retrieved for the component to the component for rendering.  The base functionality will
 * call the HandleSuccess function for older components which have not yet been updated to the generic component loading scheme.
 * Newer components will override this function as its main rendering function.
 * @param {object} recordData : The data object returned to the component form its data retrieval calls.
 */
MPageComponent.prototype.renderComponent = function(recordData) {
    // call the default HandleSuccess function if the component has not yet implemented the renderComponent function
    this.HandleSuccess(recordData);    // eslint-disable-line new-cap
};

/**
 * This is the older base class implementation of the components rendering script.  This function should be overridden for each
 * component.
 * @deprecated Component developers should now be suing the renderComponent() function.
 */
MPageComponent.prototype.HandleSuccess = function() {    // eslint-disable-line new-cap
    alert("ERROR: HandleSuccess has not been implemented within the component");    // eslint-disable-line no-alert
};

/**
 * This function will allow the component to handle any preprocessing that may need to take place before
 * calls are made to retrieve the data for the component.  The base class implementation does not perform any
 * actions at this time, but may in the future.  It is recommend that component developers overriding this function
 * still call the base class implementation.
 */
MPageComponent.prototype.preProcessing = function() {

};

/*
 * This function is used to finalize the component once it has finished generating its content.  It will be used to insert the
 * html or jquery element passed into the function into the component's section content node.  Once the content has been added
 * the function will then initialize hovers, initialize subsection toggles and initialize scrolling.
 * @param {string | jQuery} componentContent This will be an HTML string or a jQuery object which will be appended to the
 * component's section content node.
 * @param {string} resultCountText This will be an HTML string or a jQuery object which will be used as the result count shown
 * next to the component title.
 */
MPageComponent.prototype.finalizeComponent = function(componentContent, resultCountText) {
    // replace count text
    var rootComponentNode = this.getRootComponentNode();
    var self = this;
    // There are certain circumstances where a components DOM element will have been removed.
    // ie. selecting a view from the viewpoint drop down and then selecting another.
    if (rootComponentNode) {
        var totalCount = Util.Style.g("sec-total", rootComponentNode, "span");
        if (resultCountText) {
            // sets the result count of the specific component to get it in component load details timer
            self.setResultCount(resultCountText);

            if (totalCount.length) {
                // Make sure the count text is not hidden.
                $(totalCount)
                    .removeClass("hidden");
                totalCount[0].innerHTML = resultCountText;
            }
        }
        else if (totalCount.length) {
            // If there is no count text to show then hide the element so it doesn't take up space.
            $(totalCount)
                .addClass("hidden");
        }

        // replace content with HTML or a jQery object
        var node = this.getSectionContentNode();
        if (typeof componentContent == "string") {
            node.innerHTML = componentContent;
        }
        else {
            $(node)
                .html(componentContent);
        }
        // init hovers
        this.initHovers(node);

        // init subsection toggles
        MP_Util.Doc.InitSubToggles(node, "sub-sec-hd-tgl");    // eslint-disable-line new-cap

        // init scrolling
        // Wrap in timeout to momentarily break the JS processing up and allow the browser to render.
        setTimeout(function() {
            MP_Util.Doc.InitScrolling(Util.Style.g("scrollable", node, "div"), self.getScrollNumber(), "1.6");    // eslint-disable-line new-cap
        }, 0);

        // Check to see if the component has an error message displayed
        var errorElement = $(rootComponentNode)
            .find(".error-message");
        if (errorElement.length) {
            // Add an error icon to the component title
            $(rootComponentNode)
                .find(".sec-title>span:first-child")
                .addClass("error-icon-component");
            // Ensure the bottom border on the error message is red and the padding is consistent
            $(errorElement)
                .css("border", "1px solid #C00")
                .css("padding", "2px 4px");
            // Fire and event to inform any listener that the component has errored
            CERN_EventListener.fireEvent(this, this, EventListener.EVENT_ERROR_UPDATE, {
                "error": true
            });
        }
        else {
            // Remove the error icon in the component title
            $(rootComponentNode)
                .find(".sec-title>span:first-child")
                .removeClass("error-icon-component");
            // Fire and event to inform any listener that the component has not errored
            CERN_EventListener.fireEvent(this, this, EventListener.EVENT_ERROR_UPDATE, {
                "error": false
            });
        }
        if (this.m_flowsheetTable) {
            this.m_flowsheetTable.finalize();
        }
        // If the component has a table, call the finalize method
        else if (this.m_componentTable) {
            this.m_componentTable.finalize();
        }
    }
    // notify the aggregate timer that the component has finished loading
    this.notifyAggregateTimer();

    // runs the callback for the finalize component
    this.getOnFinalizeComponent()(resultCountText);
};

/**
 * This function returns true if the component is marked as required.
 * @returns {boolean} returns the current state of required components.
 */
MPageComponent.prototype.getRequiredInd = function(){
    return ((this.getToggleStatus() === 2) || this.getGapCheckCriteria() > 0);
};

/**
 * This function will be used to notify the aggregate timer that the component is loaded
 * if the containing view has passed the aggregate timer reference to this component.
 */
MPageComponent.prototype.notifyAggregateTimer = function() {
    if (this.m_aggregateTimer instanceof AggregateTimer) {    // eslint-disable-line no-undef
        this.m_aggregateTimer.completeTask(this.getStyles()
            .getId());
    }
};

/**
 * This function will be used to save single component preferences with the option of being save synchronous or asynchronous
 */
MPageComponent.prototype.savePreferences = function(saveAsync) {
    MP_Core.AppUserPreferenceManager.UpdateSingleCompPreferences(this, saveAsync);    // eslint-disable-line new-cap
};

/**
 * This function will be used to handle any processing that needs to take place after the component has been rendered.  If the
 * component developer needs to implement this function it is recommended that the base function is still called within the new
 * implementation.
 */
MPageComponent.prototype.postProcessing = function() {
    // Resize the component appropriately if it is shown within a workflow
    var self = this;
    setTimeout(function() {
        self.resizeComponent();
    }, 50);
    // Any additional functionality that needs to happen after the component is rendered can happen here.
};

/**
 * This function creates the disclaimer which specifies the satisfier condition for the Gap check functionality
 * The visibility of the disclaimer is stored as a object preference and the disclaimer is visible based on the preference value
 * @returns {Object} Object of the Disclaimer.
 */
MPageComponent.prototype.createComponentDisclaimerContainer = function() {
    var self = this;
    var componentId = self.getComponentId();
    var localeString = self.getRequiredCompDisclaimerText() || "";
    var alertBanner = new MPageUI.AlertBanner();    // eslint-disable-line no-undef
    alertBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.ADVISORY);    // eslint-disable-line no-undef
    alertBanner.setPrimaryText(localeString);
    alertBanner.setDismissible(true);
    alertBanner.setCloseFunction(function() {
        self.m_onComponentDisclaimerClose();
        alertBanner.hide();
        var requiredIndObj = $("#reqInd" + componentId);
        requiredIndObj.removeClass("hidden");
        self.setGapCheckBannerDismiss(true);
        self.savePreferences(true);
    });
    return alertBanner;
};
/*eslint-disable complexity*/
/**
 * This function Hides the Required Indicators when the condition is satisfied for a component or it is not
 * required.
 * Contains logic for when the required indicator or the components disclaimer container will be shown.
 * @param {Boolean} gcEnabled Flag indicating whether gap-check is enabled or not for the component.
 * @returns {undefined} This function does not return a value
 */
MPageComponent.prototype.updateComponentRequiredIndicator = function(gcEnabled) {
    var componentNode = this.getRootComponentNode();
    var componentNodeObj = $(componentNode);
    if (componentNode) {
        var componentDisclaimerContainer = componentNodeObj.find(".disclaimer-text");
        if(gcEnabled && !this.getSatisfiedInd()){
            if (this.getGapCheckBannerDismiss()) {
                componentDisclaimerContainer.hide();
                this.m_showGapCheckingHeaderIcon = true;
            }
            else {
                this.displayComponentDisclaimerContainer();
                this.m_showGapCheckingHeaderIcon = false;
            }
        }
        else{
            // Either the component is satisfied or gap-check has to be toggled off for this component
            componentDisclaimerContainer.hide();
            this.m_showGapCheckingHeaderIcon = false;
        }
    }

    this.updateHeader();
};
/*eslint-enable complexity*/
/**
 * This function displays the gapc-check disclaimer banner for the component. It calls the createComponentDisclaimerContainer
 * function if the banner doesn't already exist.
 * @returns {undefined} This function does not return any value.
 */
MPageComponent.prototype.displayComponentDisclaimerContainer = function(){
    var componentNode = this.getRootComponentNode();
    var componentNodeObj = $(componentNode);
    var componentDisclaimerContainer = componentNodeObj.find(".disclaimer-text");
    if(!componentDisclaimerContainer.length){
        var disclaimerObj = this.createComponentDisclaimerContainer();
        var disclaimerMessageHTML = disclaimerObj.render();
        // Add a class to Alert Banner to differentiate it from other banners added to the component
        componentDisclaimerContainer = $(disclaimerMessageHTML).addClass("disclaimer-text");
        var contentNodeHeader = componentNodeObj.find("H2")[0];
        $(contentNodeHeader).after(componentDisclaimerContainer);
        // attach event to the close button
        disclaimerObj.attachEvents();
    }
    componentDisclaimerContainer.show();
};

/**
 * This function creates a group of toggles at the component section header according to the component's toggle related attributes.
 * A <span> tag is created for each toggle icon. Clicking on an icon will automatically changes toggles' css styles and changes
 * ActiveHeaderToggleIndex attribute of this component. When consumed, it will append toggles to component section header.
 * @returns {Object} jQuery object of the toggle images's container
 */
MPageComponent.prototype.createHeaderToggles = function() {
    var self = this;
    var toggles = this.getHeaderToggles();
    if (toggles.length === 0) {
        return null;
    }
    var toggleHTML = '<div class="hdr-toggle-container" id="hdrToggleContainer' + this.getComponentId() + '">';
    var curIndex = this.getActiveHeaderToggleIndex();
    var len = toggles.length;
    for (var i = 0; i < len; i++) {
        // create a custom attribute (part of html5 feature) "data-button-index" to track index
        toggleHTML += '<span class="hdr-toggle ' + (curIndex === i ? toggles[i].active : toggles[i].inactive) + '" data-toggle-button-index="' + i + '">' + (toggles[i].text || '&nbsp;') + '</span>';
    }
    toggleHTML += '</div>';
    var togglesContainer = $(toggleHTML);
    // use delegate event handler on the container level. So each icon doesn't need a separate event handler
    togglesContainer.on("click", "span", function() {
        var index = parseInt($(this)
            .attr("data-toggle-button-index"), 10);
        self.activateHeaderToggle(index);
    });
    return togglesContainer;
};

/**
 * This function activates the header toggle of the provided index by switching to it.
 *
 * @param {Number} index The numeric index of the header toggle to switch to.
 */
MPageComponent.prototype.activateHeaderToggle = function(index) {
    var togglesContainer = $('#hdrToggleContainer' + this.getComponentId());
    var toggles = this.getHeaderToggles();
    var prevIdx = this.getActiveHeaderToggleIndex();
    // Do nothing when clicking on an active button
    if (index === prevIdx) {
        return;
    }
    // change css styles
    var prevButton = togglesContainer.children('[data-toggle-button-index="' + prevIdx + '"]');
    prevButton.removeClass(toggles[prevIdx].active)
        .addClass(toggles[prevIdx].inactive);
    var curButton = togglesContainer.children('[data-toggle-button-index="' + index + '"]');
    curButton.removeClass(toggles[index].inactive)
        .addClass(toggles[index].active);

    this.setActiveHeaderToggleIndex(index);
    this.handleHeaderToggleClick(index);
};


/**
 * It adds a pair of toggle styles.
 *
 * This functionality is superceded by the addHeaderToggle() method.
 *
 * @deprecated Please use addHeaderToggle() instead.
 * @param {string} activeStyle CSS classes when icon is active. CSS class names are separated by spaces
 * @param {string} inactiveStyle CSS classes when icon is inactive. CSS class names are separated by spaces
 * @returns {undefined}
 */
MPageComponent.prototype.addHeaderToggleStyle = function(activeStyle, inactiveStyle) {
    this.addHeaderToggle({
        active: activeStyle,
        inactive: inactiveStyle
    });
};

/**
 * This function handles toggle click event. It's designed for developers to override it.
 * @param {Number} index Currently selected toggle index
 */
MPageComponent.prototype.handleHeaderToggleClick = function(index) {};    // eslint-disable-line no-unused-vars

/**
 * Gets the index of the toggle button that the user currently has selected.
 * @returns {Number} The index of the currently selected toggle button
 */
MPageComponent.prototype.getActiveHeaderToggleIndex = function() {
    return this.m_activeHeaderToggleIndex;
};

/**
 * Sets the index of the toggle button that the user currently has selected.
 * @param {Number} index The index of the toggle button which is currently select by the user
 */
MPageComponent.prototype.setActiveHeaderToggleIndex = function(index) {
    this.m_activeHeaderToggleIndex = index;
};

/**
 * Get toggles' styles in array. Each element is an object with active and inactive attributes that
 * specify css classes for toggle icons
 *
 * This functionality is superceded by the getHeaderToggles() method.
 *
 * @deprecated Please use getHeaderToggles() instead.
 * @returns {Array} Array of objects that specify toggles' active and inactive styles
 */
MPageComponent.prototype.getHeaderToggleStyles = function() {
    return this.getHeaderToggles();
};

/**
 * Set toggles' styles in array. Each element is an object with active and inactive attributes that
 * specify css classes for toggle icons
 *
 * This functionality is superceded by the setHeaderToggles() method.
 *
 * @deprecated Please use setHeaderToggles() instead.
 * @param {Array} toggleStyles Array of objects that specify toggles' active and inactive styles
 */
MPageComponent.prototype.setHeaderToggleStyles = function(toggleStyles) {
    this.setHeaderToggles(toggleStyles);
};

/**
 * Get toggle objects as an array. Each array element is a toggle object with various attributes that defines the header toggles.
 *
 * Currently supported attributes in the toggle objects:
 *  active - {string} the css class to use for the active state
 *  inactive - {string} the css class to use for the inactive state
 *  text - {string} the text to use for the header toggle button
 *
 * @returns{Array} Array of objects that specify toggles' various attributes
 */
MPageComponent.prototype.getHeaderToggles = function() {
    if (this.m_headerToggleObjects === null) {
        this.m_headerToggleObjects = [];
    }
    return this.m_headerToggleObjects;
};

/**
 * Set toggles objects as an array. Each array element is a toggle object various attributes that defines the header toggles.
 *
 * Currently supported attributes in the toggle objects:
 *  active - {string} the css class to use for the active state
 *  inactive - {string} the css class to use for the inactive state
 *  text - {string} the text to use for the header toggle button
 *
 * @param {Array} toggleObjects Array of objects that specify toggles' various attributes
 */
MPageComponent.prototype.setHeaderToggles = function(toggleObjects) {
    this.m_headerToggleObjects = toggleObjects;
};

/**
 * It adds a toggle object to existing array of toggle objects.
 * A new empty array is created if necessary.
 *
 * Currently supported attributes in the toggle object:
 *  active - {string} the css class to use for the active state
 *  inactive - {string} the css class to use for the inactive state
 *  text - {string} the text to use for the header toggle button
 *
 * @param {Object} toggleObject Toggle object to be added.
 */
MPageComponent.prototype.addHeaderToggle = function(toggleObject) {
    if (this.m_headerToggleObjects === null) {
        this.m_headerToggleObjects = [];
    }
    this.m_headerToggleObjects.push(toggleObject);
};

/**
 * Function called within RenderStrategy that allows component level changes to the header link
 * using the component.setLink function.
 * @returns {undefined}
 */
MPageComponent.prototype.onTitleClick = function() {
    if(!CERN_Platform.inMillenniumContext()){
        return;
    }
    var criterion = this.getCriterion();
    var tabLink = this.getLink();
    var viewId = this.getViewLink();
    var viewpointId = this.getViewpointLink();
    // create anchor
    CERN_Platform.viewLink(0, criterion.executable, criterion.person_id, criterion.encntr_id, tabLink, viewId, viewpointId); // eslint-disable-line new-cap
};

/**
 * Updates the 'As Of' display in the component with the last refresh date of the workflow component
 * @returns {jQuery} the refresh button that can be added to the DOM
 */
MPageComponent.prototype.updateComponentAsOfDisplay = function() {
    // Update the as of display in the refresh button hover
    $('#mainCompRefresh' + this.getComponentId())
        .attr("title", this.getAsOfDateString());
};

/**
 * Return an AsOf date string for the title of this component
 * @returns {String} an internationalized as of date string
 */
MPageComponent.prototype.getAsOfDateString = function() {
    // Get the last refresh date and format the display
    var dateObj = new Date();
    var dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
    var dateString = dateFormatter.format(dateObj, mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS);

    // Update the as of display in the refresh button hover
    var rawLabel = this.getLabel() + " - " + i18n.discernabu.AS_OF_TIME.replace("{0}", dateString);
    // this will allow the as of date string to display properly in a title attr of a <div>
    return $('<textarea />')
        .html(rawLabel)
        .text();
};

/**
 * The postDOMLocationChange function is used to provide MPageComponent objects the chance to revert any changes
 * made by the browser when the DOM contents of the component have been relocated. For instance when Dragging
 * and Dropping a component tables are scrolled back to the 0px offset. This scroll reset may produce visual
 * inconsistencies in component. The base class implementation does not perform any actions at this time.
 * It is up to the component that overrides this method to decide how to implement this.
 */
MPageComponent.prototype.postDOMLocationChange = function() {

};

/**
 * Creates the component level Contextual view control
 * @returns {MPageUI.Button} An instance of MPageUI.Button
 */
MPageComponent.prototype.createComponentContextualViewControl = function(){
    if(!this.isContextualViewCompatible()){
        return;
    }
    var contextualViewButton = new MPageUI.Button();    // eslint-disable-line no-undef
    contextualViewButton.setStyle(MPageUI.BUTTON_OPTIONS.STYLE.LINK);    // eslint-disable-line no-undef
    contextualViewButton.setSize(MPageUI.BUTTON_OPTIONS.SIZE.SMALL);    // eslint-disable-line no-undef
    return contextualViewButton;    // eslint-disable-line consistent-return
};

/**
 * Creates a placeholder view of component.
 * @returns {Object} jQuery object that would represent the placeholder View object.
 */
MPageComponent.prototype.createPlaceholderViewOfComponent = function() {
    if(!this.m_placeholderView){
        this.m_placeholderView = new MPageUI.PlaceholderContent();    // eslint-disable-line no-undef
        this.m_placeholderView.setPrimaryText(this.getLabel());
        this.m_contextualViewControlInPlaceholderView = this.createComponentContextualViewControl();
        this.m_contextualViewControlInPlaceholderView.setIcon(MPageUI.ICONS.ICON_MOVE_LEFT);    // eslint-disable-line no-undef
        this.m_placeholderView.setActionableControl(this.m_contextualViewControlInPlaceholderView);
    }
    return $("<div>" + this.m_placeholderView.render() + "</div>").addClass("section").attr("id", this.getStyles().getId() + "PlaceholderView");
};

/**
 * Adds the pending data action for the component by consuming MP_PendingData API
 * @param {[Number, String]} actionId which holds unique Component specific action Id.
 * @returns {boolean} true if Pending action added successfully. false otherwise.
 */
MPageComponent.prototype.addPendingAction = function(actionId) {
    return MP_PendingData.addPendingAction(this.getComponentId(), this.getLabel(), actionId, MP_PendingData.requestLevel.COMPONENT);
};

/**
 * removes pending data action for the component by consuming MP_PendingData API
 * @param {[Number, String]} actionId which holds unique Component specific action Id.
 * @returns {boolean} true if Pending action removed successfully. false otherwise.
 */
MPageComponent.prototype.removePendingAction = function(actionId) {
    return MP_PendingData.removePendingAction(this.getComponentId(), actionId, MP_PendingData.requestLevel.COMPONENT);
};

/**
 * Sets the function that will be called on updateHeader()
 * @param {function} callback
 */
MPageComponent.prototype.setOnUpdateHeader = function(callback) {
    this.m_onUpdateHeader = callback;
};

/**
 * Returns the function that will be called on updateHeader()
 * @returns {function} callback
 */
MPageComponent.prototype.getOnUpdateHeader = function() {
    return this.m_onUpdateHeader;
};

/**
 * Tells the framework that the component headers will need to be re-rendered
 */
MPageComponent.prototype.updateHeader = function() {
    this.m_onUpdateHeader();
};
/* eslint eqeqeq: 0 */
/**
 * The Dummy component style
 * @constructor
 * @returns {undefined} This function does not return a value
 */
function DummyComponentStyle() {
    this.initByNamespace("dummy-component");
}

DummyComponentStyle.prototype = new ComponentStyle();
DummyComponentStyle.prototype.constructor = ComponentStyle;

/**
 * The constructor of dummy component. It sets the criterion and component style
 * objects just like the real components.
 * @constructor
 * @param {Object} criterion - criterion object
 */
function DummyComponent(criterion) {
    this.setCriterion(criterion);
    this.setStyles(new DummyComponentStyle());
}

DummyComponent.prototype = new MPageComponent();
DummyComponent.prototype.constructor = MPageComponent;

/**
 * Override MPageComponent's postProcessing to do nothing.
 * We don't need the resize logic in this dummy component.
 * @returns {undefined} This function does not return a value
 */
DummyComponent.prototype.postProcessing = function() {

};

/**
 * Override MPageComponent's retrieveComponentData to render the UI directly.
 * There's no data to retrieve
 * @returns {undefined} This function does not return a value
 */
DummyComponent.prototype.retrieveComponentData = function() {
    this.renderComponent();
};

/**
 * It displays the informational text on the component that indicates this
 * component is no longer available.
 * @returns {undefined} This function does not return a value
 */
DummyComponent.prototype.renderComponent = function() {
    //Initialize a new alert banner instance
    var alertBanner = new MPageUI.AlertBanner();	//eslint-disable-line no-undef

    //Set the type of alert banner to be displayed
    alertBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.INFO);	//eslint-disable-line no-undef

    //Set the primary text for the alert banner
    alertBanner.setPrimaryText(i18n.discernabu.MPageView.COMPONENT_NOT_AVAILABLE);

    // finalize the component with the informational text
    this.finalizeComponent(alertBanner.render(), "");
};

DummyComponent.prototype.loadComponentSettings = function(compSettings) {
    var prefManager = MP_Core.AppUserPreferenceManager;
    var userPrefs = null;
    //Load Default settings
    this.setComponentId(compSettings.F_ID); // F_ID is shorthand for Filter Id (br_datamart_filter_id)
    this.setReportId(compSettings.R_ID); // R_ID is shorthand for Report Id (br_datamart_report_id)
    this.setReportMean(compSettings.R_MN); // R_MN is shorthand for Report Mean
    this.setLabel(compSettings.LBL);
    this.setPlusAddEnabled(false);

    // Retrieve the user level preferences for this component
    // F_ID is shorthand for Filter Id (br_datamart_filter_id)
    userPrefs = prefManager.GetComponentById(compSettings.F_ID);// eslint-disable-line new-cap
    // Load the user level settings if available
    if (userPrefs) {
        this.setExpanded(userPrefs.expanded);
        this.setColumn(userPrefs.col_seq);
        this.setSequence(userPrefs.row_seq);
        this.setPageGroupSequence(userPrefs.group_seq);
        this.setPreferencesObj(userPrefs.preferencesObj || null);
        if (userPrefs.compThemeColor) {
            this.setCompColor(userPrefs.compThemeColor);
        }
        // Set the component toggle status.  If defined as 'Required' in bedrock, override the users prefs.
        // 0 - off, 1 - on, 2 - required
        if (userPrefs.toggleStatus !== "undefined" && userPrefs.toggleStatus !== null) {
            if (compSettings.TS !== 2) { // TS is shorthand for Toggle Status
                this.setToggleStatus(userPrefs.toggleStatus);
            }
            else {
                this.setToggleStatus(compSettings.TS); // TS is shorthand for Toggle Status
            }
        }
        else {
            this.setToggleStatus(compSettings.TS); // TS is shorthand for Toggle Status
        }
        // Check for contextual view preferences.
        if (typeof userPrefs.preferencesObj !== "undefined" && userPrefs.preferencesObj !== null) {
            if (typeof userPrefs.preferencesObj.contextualViewPrefs !== "undefined" && userPrefs.preferencesObj.contextualViewPrefs !== null){
                this.setAddedToContextualView(userPrefs.preferencesObj.contextualViewPrefs.isAddedToContextualView);
                this.setSequenceInContextualView(userPrefs.preferencesObj.contextualViewPrefs.row_seq);
            }
        }
    }
    else {
        // No user settings for this component so load client level settings
        this.setExpanded(compSettings.EXP); // EXP is shorthand for Expanded
        this.setColumn(compSettings.C_SQ); // C_SQ is shorthand for Column Sequence
        this.setSequence(compSettings.R_SQ); // R_SQ is shorthand for Row Sequence
        this.setPageGroupSequence(compSettings.G_SQ); // G_SQ is shorthand for Group Sequence
        this.setCompColor(compSettings.THM); // THM is shorthand for Theme
        this.setToggleStatus(compSettings.TS); // TS is shorthand for Toggle Status
    }
};
/*
 * CPMPageComponent
 */
function CPMMPageComponent(){
    //These member variable declarations are for reference and don't actually serve a functional purpose
    this.m_menuIds = null;
    this.m_intentionCd = 0;
    this.m_intentionMean = "";
    this.m_conceptCd = 0;
    this.m_conceptMean = "";
    this.m_conceptDisp = "";
    this.m_nodeId = 0;
    this.m_cpComponentId = 0;
    this.m_customContentLocation = "";
    this.m_customOptionsObject = null;
    this.m_triggeringNomenclature = 0;
	this.m_isHidden = false;
	
	this.m_conceptGroupCd = 0;
	this.m_conceptGroupConfig = [];
    this.m_conceptGroupMeanings = [];

    this.m_componentConfig = [];
    this.m_pathwayActions = [];
	
	this.m_pathwayInstanceId = 0;
}

CPMMPageComponent.prototype = new MPageComponent();
CPMMPageComponent.prototype.constructor = MPageComponent;

CPMMPageComponent.prototype.getPathwayInstanceId = function() {
	return this.m_pathwayInstanceId;
};

CPMMPageComponent.prototype.setPathwayInstanceId = function(val) {
	this.m_pathwayInstanceId = val;
};

CPMMPageComponent.prototype.getConceptGroupCd = function() {
    return this.m_conceptGroupCd;
};

CPMMPageComponent.prototype.getNodeId = function() {
    return this.m_nodeId;
};

CPMMPageComponent.prototype.getCpComponentId = function() {
    return this.m_cpComponentId;
};

CPMMPageComponent.prototype.getPathwayActions = function() {
    if(this.m_pathwayActions){
        return this.m_pathwayActions;
    }
    else{
        return([]);
    }
};

CPMMPageComponent.prototype.getPathwayId = function() {
    return this.m_pathwayId;
};

CPMMPageComponent.prototype.setConceptGroupCd = function(val) {
    this.m_conceptGroupCd = val;   
};

CPMMPageComponent.prototype.setNodeId = function(val) {
    this.m_nodeId = val;
};

CPMMPageComponent.prototype.setCpComponentId = function(val) {
    this.m_cpComponentId = val;
};

CPMMPageComponent.prototype.setPathwayActions = function(val) {
    this.m_pathwayActions = val;
};

CPMMPageComponent.prototype.setPathwayId = function(val) {
    this.m_pathwayId = val;
};

CPMMPageComponent.prototype.setComponentConfig = function(val) {
    this.m_componentConfig = val;
};

CPMMPageComponent.prototype.getComponentConfig = function() {
    if (!this.m_componentConfig){
        this.m_componentConfig = [];
    }
    return this.m_componentConfig;
};

CPMMPageComponent.prototype.getConceptGroupConfig = function() {
	if (!this.m_conceptGroupConfig){
		this.m_conceptGroupConfig = [];
	}
    return this.m_conceptGroupConfig;
};

CPMMPageComponent.prototype.setConceptGroupConfig = function(val) {
    this.m_conceptGroupConfig = val;
};

CPMMPageComponent.prototype.getConceptGroupMeanings = function() {
	if (!this.m_conceptGroupMeanings){
		this.m_conceptGroupMeanings = [];
	}
    return this.m_conceptGroupMeanings;
};

CPMMPageComponent.prototype.setConceptGroupMeanings = function(val) {
    if (typeof val == "string"){
        this.m_conceptGroupMeanings = [val];
    }
    else{
        this.m_conceptGroupMeanings = val;
    }   
};

CPMMPageComponent.prototype.processComponentConfig = function(conceptData, componentSettings){
    return;
};

CPMMPageComponent.prototype.processPathwayActions = function(pathwayActions){
    return;
};

CPMMPageComponent.prototype.getCustomContentLocation = function(){
    return this.m_customContentLocation;
};

CPMMPageComponent.prototype.setCustomContentLocation = function(path){
    this.m_customContentLocation = path;
};

CPMMPageComponent.prototype.getMenuIds = function(){
    if (!this.m_menuIds){
        this.m_menuIds = [];
    }
    return this.m_menuIds;
};

CPMMPageComponent.prototype.addMenuId = function(id){
    if (typeof id !== "string"){
        MP_Util.LogError("Id supplied to addMenuId is not a valid string.");
    }
    var menuIdArray = this.getMenuIds();
    menuIdArray.push(id);
};

CPMMPageComponent.prototype.commitChanges = function(flag){
    //Implemented by components
    return;
};

CPMMPageComponent.prototype.cleanUp = function(){
    //Grab the menu id's array and delete menus
    var arrLen = 0;
    var x;
    var y;
    var mLen = 0;
    if (this.m_menuIds && this.m_menuIds.length > 0){
        arrLen = this.m_menuIds.length;
        for (x = arrLen; x--;){
            var menu = MP_MenuManager.getMenuObject(this.m_menuIds[x]);
            var menuItems = menu.getMenuItemArray();
            for (y = 0, mLen = menuItems.length; y < mLen; y++){
                menu.removeMenuItem(menuItems[y]);
            }
            MP_MenuManager.deleteMenuObject(this.m_menuIds[x]);
        }
        this.m_menuIds = null;
    }

    //Remove from global namespace
    var components = CERN_MPageComponents;
    var comp;
    var cLen = components.length;
    for (x = cLen; x--;){
        comp = components[x];
        if (comp.m_componentId === this.getComponentId()){
            components.splice(x, 1); //Remove
        }
    }
};

CPMMPageComponent.prototype.setConceptDisp = function(disp){
    this.m_conceptDisp = disp;
};

CPMMPageComponent.prototype.getConceptDisp = function(){
    return this.m_conceptDisp;
};

CPMMPageComponent.prototype.setConceptCd = function(num){
    if (typeof num !== "number"){
        throw new Error("Invalid Cocnept CD passed to 'setConceptCd'");
    }
    this.m_conceptCd = num;
};

CPMMPageComponent.prototype.getConceptCd = function(){
    return this.m_conceptCd;
};

CPMMPageComponent.prototype.setIntentionCd = function(num){
    if (typeof num !== "number"){
        throw new Error("Invalid Intention CD passed to 'setIntentionCd'");
    }
    this.m_intentionCd = num;
};

CPMMPageComponent.prototype.getIntentionCd = function(){
    return this.m_intentionCd;
};

CPMMPageComponent.prototype.setIntentionMean = function(mean){
    if (typeof mean !== "string"){
        throw new Error("Invalid Intention meaning passed to 'setIntentionMean'");
    }
    this.m_intentionMean = mean;
};

CPMMPageComponent.prototype.getIntentionMean = function(){
    return this.m_intentionMean;
};

CPMMPageComponent.prototype.setConceptMean = function(mean){
    if (typeof mean !== "string"){
        throw new Error("Invalid Concept meaning passed to 'setConceptMean'");
    }
    this.m_conceptMean = mean;
};

CPMMPageComponent.prototype.getConceptMean = function(){
    return this.m_conceptMean;
};

CPMMPageComponent.prototype.loadUserPrefs = function(){
    var userPrefs = MP_Core.AppUserPreferenceManager.GetComponentById(this.getComponentId());
    var preferenceObj;
    if (!userPrefs){
        return;
    }

    preferenceObj = userPrefs.preferencesObj || {};
    this.setPreferencesObj(preferenceObj);
    if (typeof preferenceObj.EXPANDED === 'number'){
        //convert number to bool
        this.setExpanded(!!preferenceObj.EXPANDED);
    }
};

CPMMPageComponent.prototype.setTriggeringNomenclature = function(nomenclatureId){
    if (typeof nomenclatureId !== "number"){
        throw new Error("Type Error: Non-number 'nomenclatureId' passed into CPMMPageComponent method 'setTriggeringNomenclatureId'");
    }
    this.m_triggeringNomenclature = nomenclatureId;
};

CPMMPageComponent.prototype.getTriggeringNomenclature = function(){
    if (!this.m_triggeringNomenclature){
        this.m_triggeringNomenclature = 0;
    }
    return this.m_triggeringNomenclature;
};

CPMMPageComponent.prototype.setCustomOptionsObject = function(obj){
    this.m_customOptionsObject = obj;
};

CPMMPageComponent.prototype.getCustomOptionsObject = function(){
    return this.m_customOptionsObject || null;
};

/**
 * Return if the component is visible in the CPM.  Ex. Add as a Menu item instead.
 * @returns {boolean} - true if visible false if otherwise
 */
CPMMPageComponent.prototype.getIsHidden = function(){
    return this.m_isHidden;
};

/**
 *Sets if the component is to be visible or not
 * @param {boolean} 
 */
CPMMPageComponent.prototype.setIsHidden = function(isHidden){
    if (typeof isHidden !== "boolean") {
        throw new Error("Called setIsHidden on CPMMPageComponent with non boolean type for isHidden parameter");
    }
    this.m_isHidden = isHidden;
};

/**
 * Base method for autosave. To be implmented by components who need autosave functionality
 * @returns{String} - String of JSON showing what Items were saved. 
 */
CPMMPageComponent.prototype.autoSave = function() {
    return("");
};

CPMMPageComponent.attachMethods = function(constructor){
    var CPMPrototype = CPMMPageComponent.prototype;
    var consPrototype = constructor.prototype;
    var key;
    //Loop through all CPMMpageComponent prototype methods
    for (key in CPMPrototype){
        if (CPMPrototype.hasOwnProperty(key)){
            //Only add to the constructor if constructor doesn't already have its own implementation
                if (!consPrototype[key]){
                consPrototype[key] = CPMPrototype[key];
            }
        }
    }
};/**
 * MPageCPNodeController
 * This class must be further implemented in a subclass
 * Handles a map of meanings to component constructors, creating a view, and defines some interface methods
 * @constructor
 */
function MPageCPNodeController(){
    this.m_id = "";
    //Stores the container html id where the view will eventually be rendered
    this.m_containerId = "";
    this.m_nodeConfiguration = null;
    this.m_conceptConfiguration = null;
    this.m_componentList = null;  //Will contain component objects
    this.m_view = null;
    this.m_conceptMean = "";
    this.m_conceptCd = 0;
    this.m_pathwayTypeMean = "";
    this.m_pathwayTypeCd = 0;
    this.m_pathwayId = 0;
    this.m_pathwayInstance = null;
    this.m_customContentLocation = "";
	this.m_isHidden = false;
}

/**
 * Contains the mapping of meanings to component constructors
 * Shared across all instances of MPageCPNodeController
 * @type {{string, constructor}}
 */
MPageCPNodeController.prototype.componentMapping = {};

/**
 * Gets the component mapping map
 * @returns {{string, constructor}}
 */
MPageCPNodeController.prototype.getComponentMapping = function(){
    return this.componentMapping;
};

/**
 * Gets the controller's ID
 * @returns {string|number}
 */
MPageCPNodeController.prototype.getId = function(){
    return this.m_id;
};

/**
 * Sets the controller's ID
 * Throws an error if passed in 'id' is not a string or a number
 * @param {string|number} id - controller's identifier
 */
MPageCPNodeController.prototype.setId = function(id){
    if (typeof id !== 'string' && typeof id !== 'number'){
        throw new Error("Type Error: Invalid 'id' passed into MPageCPNodeController method 'setId'");
    }
    this.m_id = id;
};

/**
 * Gets the Concept Code Value
 * @returns {number}
 */
MPageCPNodeController.prototype.getConceptCd = function(){
    return this.m_conceptCd;
};

/**
 * Sets the Concept Code Value
 * Throws an error if passed in 'conceptCd' is not a number
 * @param {number} conceptCd - Concept Code Value
 */
MPageCPNodeController.prototype.setConceptCd = function(conceptCd){
    if (typeof conceptCd !== 'number'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'setConceptCd'");
    }
    this.m_conceptCd = conceptCd;
};

/**
 * Gets the Pathway ID
 * @returns {number}
 */
MPageCPNodeController.prototype.getPathwayId= function(){
    return this.m_pathwayId;
};

/**
 * Sets the Pathway ID
 * Throws an error if passed in 'pathwayId' is not a number
 * @param {number} pathwayId - Pathway ID
 */
MPageCPNodeController.prototype.setPathwayId= function(pathwayId){
    if (typeof pathwayId !== 'number'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'setPathwayId'");
    }
    this.m_pathwayId = pathwayId;
};


/**
 * Gets the Pathway Type Code Value
 * @returns {number}
 */
MPageCPNodeController.prototype.getPathwayTypeCd = function(){
    return this.m_pathwayTypeCd;
};


/**
 * Sets the Pathway Type Code Value
 * Throws an error if passed in 'pathwayTypeCd' is not a number
 * @param {number} pathwayTypeCd - Pathway Type Code
 */
MPageCPNodeController.prototype.setPathwayTypeCd= function(pathwayTypeCd){
    if (typeof pathwayTypeCd !== 'number'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'setPathwayTypeCd'");
    }
    this.m_pathwayTypeCd = pathwayTypeCd;
};

/**
 * Gets the Pathway Type Code Value
 * @returns {number}
 */
MPageCPNodeController.prototype.getPathwayTypeMean = function(){
    return this.m_pathwayTypeMean;
};


/**
 * Sets the Pathway Type Code Value
 * Throws an error if passed in 'pathwayTypeMean' is not a string
 * @param {number} pathwayTypeMean - Pathway Type Mean
 */
MPageCPNodeController.prototype.setPathwayTypeMean= function(pathwayTypeMean){
    if (typeof pathwayTypeMean !== 'string'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'pathwayTypeMean'");
    }
    this.m_pathwayTypeMean = pathwayTypeMean;
};

/**
 * Gets the Pathway Instance 
 * @returns {number}
 */
MPageCPNodeController.prototype.getPathwayInstance = function(){
    return this.m_pathwayInstance;
};


/**
 * Sets the Pathway Instance
 * Throws an error if passed in 'pathwayInstance' is not a object
 * @param {Object} pathwayInstance - Pathway Instance
 */
MPageCPNodeController.prototype.setPathwayInstance= function(pathwayInstance){
    if (typeof pathwayInstance !== 'object'){
        throw new Error("Type Error: Invalid 'conceptCd' passed into MPageCPNodeController method 'pathwayTypeMean'");
    }
    this.m_pathwayInstance = pathwayInstance;
};

/**
 * Gets the Concept Configuration
 * @returns {object}
 */
MPageCPNodeController.prototype.getConceptConfig = function(){
    return this.m_conceptConfiguration;
};


/**
 * Sets the Concept Configuration 
 * @param {object} conceptConfig - Concept Configuration
 */
MPageCPNodeController.prototype.setConceptConfig = function(conceptConfig){
 
    this.m_conceptConfiguration = conceptConfig;
};

/**
 * Gets the Node Configuration
 * @returns {object}
 */
MPageCPNodeController.prototype.getNodeConfig = function(){
    return this.m_nodeConfiguration;
};


/**
 * Sets the Node Configuration 
 * @param {object} nodeConfig - Node Configuration
 */
MPageCPNodeController.prototype.setNodeConfig = function(nodeConfig){
 
    this.m_nodeConfiguration = nodeConfig;
};


/**
 * Gets the Custom Components static content location
 * Note: This method should be temporary until code is merged into core MPage codebase
 * @returns {string} - file path
 */
MPageCPNodeController.prototype.getCustomContentLocation = function(){
    return this.m_customContentLocation;
};

/**
 * Sets the Custom Components static content location
 * Note: This method should be temporary until code is merged into core MPage codebase
 * @param {string} path - file path
 */
MPageCPNodeController.prototype.setCustomContentLocation = function(path){
    this.m_customContentLocation = path;
};

/**
 * Gets the Container Id
 * The container id is the id of the HTML element that will contain the view/components
 * @returns {string} - HTML ID
 */
MPageCPNodeController.prototype.getContainerId = function(){
    return this.m_containerId;
};

/**
 * Sets the Container Id
 * The container id is the id of the HTML element that will contain the view/components
 * Throws an error if passed in 'id' is not a string or a number
 * @param {string} id - HTML ID of an element within the DOM
 */
MPageCPNodeController.prototype.setContainerId = function(id){
    if (typeof id !== 'string' && typeof id !== 'number'){
        throw new Error("Type Error: Invalid 'id' passed into MPageCPNodeController method 'setContainerId'");
    }
    this.m_containerId = id;
};

/**
 * Gets the Concept Meaning
 * @returns {string} - concept meaning
 */
MPageCPNodeController.prototype.getConceptMean = function(){
    return this.m_conceptMean;
};

/**
 *Sets the Concept Meaning
 * Throws an error if passed in 'mean' is not a string
 * @param {string} mean - concept meaning
 */
MPageCPNodeController.prototype.setConceptMean = function(mean){
    if (typeof mean !== 'string'){
        throw new Error("Type Error: Non-string type 'mean' passed into MPageCPNodeController method 'setCocneptMean'");
    }
    this.m_conceptMean = mean;
};

/**
 * Gets the controller's list of MPageComponents
 * This method will always return an array
 * @returns {Array<MPageComponent>} - an array of MPageComponents
 */
MPageCPNodeController.prototype.getComponentList = function(){
    if (!this.m_componentList){
        this.m_componentList = [];
    }
    return this.m_componentList;
};

/**
 * Sets the controller's list of MPageComponents
 * This method is expected to be used to null an existing array
 * @param {null|Array} list - null to clear the existing array, or an array of MPageComponents
 */
MPageCPNodeController.prototype.setComponentList = function(list){
    this.m_componentList = list;
};

/**
 * Gets the controller's View
 * Creates a new instance of CPNodeView if there isn't an existing view referenced
 * @returns {CPNodeView|Object} - view
 */
MPageCPNodeController.prototype.getView = function(){
    if (!this.m_view){
        this.m_view = new CPNodeView();
    }
    return this.m_view;
};

/**
 * Sets the controller's View
 * @param {CPNodeView} view - instance of CPNodeView or subclass of CPNodeView
 */
MPageCPNodeController.prototype.setView = function(view){
    this.m_view = view;
};

/**
 * Adds a pairing of a meaning and component constructor to the component mapping map
 * Throws an error if the passed in 'meaning' is not a string
 * Throws an error if the passed in 'classConstructor' is not a function
 * Throws an error if the passed in 'meaning' is already stored in the map
 * @param {string} meaning - identifier
 * @param {constructor} classConstructor - component constructor
 */
MPageCPNodeController.prototype.addComponentMapping = function(meaning, classConstructor){
    var componentMapping = this.getComponentMapping();
    if (typeof meaning !== "string"){
        throw new Error("Type Error: Non-string 'meaning' passed into MPageCPNodeController method 'addComponentMapping'");
    }
    if (typeof classConstructor !== "function"){
        throw new Error("Type Error: Non-function 'classConstructor' passed into MPageCPNodeController method 'addComponentMapping'");
    }
    if (componentMapping[meaning]){
        throw new Error("Runtime Error: 'meaning' already exists in MPageCPNodeController componentMapping - '" + meaning + "'");
    }

    componentMapping[meaning] = classConstructor;
};

/**
 * Gets the component constructor based on a meaning
 * Will return null if the meaning does not exist in the component mapping map
 * Throws an error if passed in 'meaning' is not a string
 * @param {string} meaning - identifier
 * @returns {constructor|null} - component constructor
 */
MPageCPNodeController.prototype.getConstructorByMeaning = function(meaning){
    if (typeof meaning !== "string"){
        throw new Error("Type Error: Non-string 'meaning' passed into MPageCPNodeController method 'getConstructorByMeaning'");
    }
    if (!this.getComponentMapping()[meaning]){
        return null;
    }
    return this.getComponentMapping()[meaning];
};

/**
 * Tells the stored view to commit component actions
 * Example: save text from CKEditor
 */
MPageCPNodeController.prototype.commitComponentActions = function(){
    this.getView().commitComponentChanges(true);
};

/**
 * Tells the stored view to undo component actions
 * Example: remove added orders from the scratchpad
 */
MPageCPNodeController.prototype.undoComponentActions = function(){
    this.getView().commitComponentChanges(false);
};

/**
 * Tells the stored view to destroy itself
 * The view should handle cleaning up its components
 */
MPageCPNodeController.prototype.dispose = function(){
    this.getView().destroyView();
};

/**
 * Processes Pathway configuration
 * Sets base information for Pathway
 * @param {Object} config
 */
MPageCPNodeController.prototype.processPathwayConfiguration = function(config){

   	if (!config) {
		throw new Error("Runtime Error: Undefined config passed into CPMController method 'processPathwayConfiguration'");
	}

	this.setPathwayId(config.PATHWAY_ID);
	this.setPathwayTypeMean(config.PATHWAY_TYPE_MEAN);
	this.setPathwayTypeCd(config.PATHWAY_TYPE_CD);

	if(config.CONCEPT_LIST.length == 1){
		this.setConceptConfig(config.CONCEPT_LIST[0].CG_LIST);
	}

    if(config.PATHWAY_INSTANCE){
        this.setPathwayInstance(config.PATHWAY_INSTANCE);
    }

	this.setNodeConfig(config.NODE_LIST);
};

/**
 * Gets concept group configuration by concept group meanings. 
 * @param {Array} meanings - List of meanings to match concetp config on
 * @param {Number} intentionCd -Intention of current component to match concept groups on
 */
MPageCPNodeController.prototype.getConceptGroupConfigByMeaning = function(meanings, intentionCd) {
	var conceptConfig = this.m_conceptConfiguration || [];
	var componentConceptConfig = [];
	for(var x = conceptConfig.length; x--;){
		if(meanings.indexOf(conceptConfig[x].CONCEPT_GROUP_CD_MEAN) >= 0  && intentionCd == conceptConfig[x].INTENTION_CD){
			componentConceptConfig.push(conceptConfig[x]);
		}
	}

	return(componentConceptConfig);
};

/**
 *  
 * Gets a list of actions for the component. 
 * @param {Number} cpComponentId - componentId to retrieve actions for. 
 */
MPageCPNodeController.prototype.getComponentActions = function(cpComponentId) {
    
    var pathwayInstance = null;
    var pathwayActions = null;
    var node = null;
    var component = null;
    var actions = [];
    var x,y;

    pathwayInstance = this.getPathwayInstance();

    if(pathwayInstance){
        pathwayActions = pathwayInstance.PATHWAY_ACTIONS;
        for(x = pathwayActions.NODE_LIST.length; x--;){
            node = pathwayActions.NODE_LIST[x];
            for(y = node.COMPONENT_LIST.length; y--;){
                component = node.COMPONENT_LIST[y];
                if(component.COMPONENT_ID === cpComponentId){
                    actions = component.ACTIONS;
                    return(actions);
                }
            }
        }

    }
    
    return(actions);
};

/**
 * Based on a Node Id, get the 
 * Throws an error if passed in 'nodeId' is not found
 * @param {Number} nodeId - ID of Node to return
 */
MPageCPNodeController.prototype.getNodeById = function(nodeId) {

	var nodes = this.m_nodeConfiguration;

	for(var x = nodes.length; x--;){
		if(nodes[x].CP_NODE_ID == nodeId){
			return(nodes[x]);
		}

	}

};

/**
 * Processes Node configuration
 * This method is meant to be implemented in subclasses
 * Throws an error if this method is called without being overwritten
 * @param {Number} NodeId
 */
MPageCPNodeController.prototype.processNodeConfiguration = function(nodeId){
    throw new Error("Error: 'processNodeConfiguration' not implemented on 'MPageCPNodeController'");
};

/**
 * CPMController
 * Subclass of MPageCPNodeController
 * Handles retrieving CPM config based on a Concept, and the creation of the CPM components and View
 * Handles telling the View when to render, or dispose itself
 * @constructor CPMController
 */
function CPMController(){
    this.m_triggeringNomenclature = 0;
    this.m_customOptionsObject = null;
	this.m_cpmTabMenuId = null;
}

CPMController.prototype = new MPageCPNodeController();
CPMController.prototype.constructor = CPMController;

CPMController.prototype.setCPMTabMenuId = function(menuId){
    this.m_cpmTabMenuId = menuId;
};

CPMController.prototype.getCPMTabMenuId = function(){
    return this.m_cpmTabMenuId;
};

CPMController.prototype.getTriggeringNomenclature = function(){
    return this.m_triggeringNomenclature;
};

CPMController.prototype.setTriggeringNomenclature = function(nomenclatureId){
    if (typeof nomenclatureId !== "number"){
        throw new Error("Type Error: 'nomenclatureId' passed into CPMController method 'setTriggeringNomenclature'");
    }
    this.m_triggeringNomenclature = nomenclatureId;
};

CPMController.prototype.getCustomOptionsObject = function(){
    return this.m_customOptionsObject;
};

CPMController.prototype.setCustomOptionsObject = function(obj){
    this.m_customOptionsObject = obj;
};

var CPM_MPageComponents = null;
var CPMCurrCompIndex = null;

CPMController.prototype.addOutsideComponents = function(componentConfigList) {
	componentConfigList.push({
	    COMP_TYPE_CD_MEANING : "IMPRESSIONS",
	    COMP_DETAIL_LIST : []
	  });
};

CPMController.prototype.processOutsideComponent = function(component, pos) {
	component.setSequence(100 + pos);
	component.setPageGroupSequence(1);
	component.setColumn(1);
};

CPMController.prototype.createCpmConfigRequest = function(pathwayId, conceptCd) {
	var request;

	request = new MP_Core.ScriptRequest(this, "ENG:CPMController_retrieveNodeConfiguration");
	request.setProgramName("cp_load_pathway_config");
	request.setParameters(["^MINE^", pathwayId +".0", conceptCd + ".0"]);
	request.setAsync(true);

	return request;
};

/**
 * Processes the configuration to create components
 * Overrides superclass' implementation
 * Throws an error if nodeConfig evaluates to false
 */
CPMController.prototype.processNodeConfiguration = function(nodeId) {

	var defaultSequence = 900;//arbitrary high sequence and group for use when no sequence or group data is available
	var defaultGroup = 900;
	var config = this.getNodeById(nodeId);
	if (!config) {
		throw new Error("Runtime Error: Undefined config passed into CPMController method 'processNodeConfiguration'");
	}

	var componentConfigList = config.COMPONENT_LIST || [];
	var intentionMean = config.INTENTION_CD_MEANING || "";
	var componentList = this.getComponentList();
	var conceptMean = config.CONCEPT_CD_MEAN || "";
    var conceptDisp = config.CONCEPT_CD_DISP || "";
	var intentionCd = config.INTENTION_CD || 0;
	var conceptCd = config.CONCEPT_CD || 0;
    var pathwayId = this.getPathwayId() || 0;
	var view = this.getView();
	var componentConfig, conceptGroupConfig, componentActions, compMeaning, compConstructor, component, i, cLen, cpComponentId, conceptGroupCd;

	view.setViewSettings(config);

	this.addOutsideComponents(componentConfigList);

	if (CPMCurrCompIndex == undefined) {
		CPMCurrCompIndex = 0;
	} else {
		CPMCurrCompIndex = componentConfigList.length;
	}

	this.buildTabMenu(conceptCd);

	for ( i = 0, cLen = componentConfigList.length; i < cLen; i++) {
		componentConfig = componentConfigList[i];
		compMeaning = componentConfig.COMP_TYPE_CD_MEANING;
        cpComponentId = componentConfig.CP_COMPONENT_ID;
        conceptGroupCd = componentConfig.CONCEPT_GROUP_CD;
		if (!compMeaning) {
			continue;
		}

		compConstructor = this.getConstructorByMeaning(compMeaning);

		if (!compConstructor) {
			continue;
		}

		component = new compConstructor();
		component.setCustomOptionsObject(this.getCustomOptionsObject());
		component.setIntentionCd(intentionCd);
		component.setIntentionMean(intentionMean);
		component.setConceptCd(conceptCd);
		component.setConceptMean(conceptMean);
        component.setConceptDisp(conceptDisp);
		component.setTriggeringNomenclature(this.getTriggeringNomenclature());
		component.setAlwaysExpanded(true);
		component.setCustomContentLocation(this.getCustomContentLocation());
        component.setCpComponentId(cpComponentId);
		component.setComponentId(this.getId() + i);
        component.setNodeId(nodeId);
        component.setPathwayId(pathwayId);
        component.setConceptGroupCd(conceptGroupCd);
		component.setComponentConfig(componentConfig);
		
		if (componentConfig.ROW != 0 && componentConfig.GROUP != 0 && componentConfig.COLUMN != 0){
			component.setSequence(componentConfig.ROW); 
			component.setPageGroupSequence(componentConfig.GROUP);
			component.setColumn(componentConfig.COLUMN);
		}else{
			component.setSequence(defaultSequence); // set sequence to a high sequence if there is no sequence available
			defaultSequence ++; //increment to prevent multiple components with the same sequence
			component.setPageGroupSequence(defaultGroup);
			component.setColumn(1);
		}

        //Any actions taken from the component. 
        componentActions = this.getComponentActions(cpComponentId);  
        component.setPathwayActions(componentActions);
        component.processPathwayActions(componentActions);
		
		//Get the concept level config needed
		conceptGroupConfig = this.getConceptGroupConfigByMeaning(component.getConceptGroupMeanings(), intentionCd);
		component.setConceptGroupConfig(conceptGroupConfig);
	
        component.processComponentConfig(componentConfig, conceptGroupConfig);

		if (!component.getIsHidden()) {
			componentList.push(component);
			view.addComponent(component);
		}
		
		//Hardcoded lookback logic for CPM. Because Vitals and labs are updated
		//to honor scope correctly this reverts the scope to operate like it was
		//before it was correct
		if(component instanceof VitalsCPMComponent || component instanceof LabsCPMComponent){
			component.setScope(2);
		}
		
	}
}; 

CPMController.prototype.buildTabMenu = function(conceptCd) {
	var menuContainer = $("#" + this.getCPMTabMenuId());
	var compSelMenuId = "cpmTabMenu" + conceptCd;
	var compSelMenu = null;
    var cpmDocI18n = i18n.discernabu.cpm_core_o1;

	//If the menu item already exists remove it
	if (MP_MenuManager.getMenuObject(compSelMenuId)) {
		MP_MenuManager.deleteMenuObject(compSelMenuId);
	}
	
	//Create the menu
	compSelMenu = new Menu(compSelMenuId);
	compSelMenu.setTypeClass("menu-page-menu");
	compSelMenu.setIsRootMenu(true);	
	compSelMenu.setLabel("");
	compSelMenu.setAutoFlipVertical(false);
	compSelMenu.setAnchorElementId("chxTabsMenu" + conceptCd);
	compSelMenu.setAnchorConnectionCorner(["bottom","right"]);
	compSelMenu.setContentConnectionCorner(["top","right"]);
	
    // For the sake of consistency pre-load the links and diagrams menu items and default to disabled.
    // this is to facilitate the functionality of having components show up in the menu dithered regardless of if they are on the page or not
    
	var linksMenuItem = "cpmTabLinksMenu" + conceptCd;
    var linksItem = new Menu(linksMenuItem);
    linksItem.setLabel(cpmDocI18n.LINKSLABEL);
    linksItem.setCloseOnClick(false);
    linksItem.setAnchorConnectionCorner(["top","left"]);
    linksItem.setContentConnectionCorner(["top","right"]);
    linksItem.setIsDisabled(true);
    linksItem.setTypeClass("diaglinks-cpm-menu-item-disabled");
    compSelMenu.addMenuItem(linksItem);
    
    var diagramMenuItem = "cpmTabDiagramsMenu" + conceptCd;
    var diagramItem = new Menu(diagramMenuItem);
    diagramItem.setLabel(cpmDocI18n.DIAGLABEL);
    diagramItem.setCloseOnClick(false);
    diagramItem.setAnchorConnectionCorner(["top","left"]);
    diagramItem.setContentConnectionCorner(["top","right"]);
    diagramItem.setIsDisabled(true);
    diagramItem.setTypeClass("diaglinks-cpm-menu-item-disabled");
    compSelMenu.addMenuItem(diagramItem);



	//Add the menu object to the menu manager
	MP_MenuManager.addMenuObject(compSelMenu);
	
	//Create CPM Tab specific menu
	menuContainer.append("<div id='chxTabsMenu"+conceptCd+"' class='cpm-tab-menu-inactive'>&nbsp;</div>");
		
};

/**
 * Sets the required fields on the stored View
 */
CPMController.prototype.configureView = function(){
    var view = new CPMView();
    view.setName("CPM");
    view.setId("cpm" + this.getId());
    view.setRenderStrategyConstructor(CPMRenderStrategy);
    view.setCustomCSS("wf cpm");
    view.setContainer($("#" + this.getContainerId()));
    view.setContainerId(this.getContainerId());
    this.setView(view);
};

/**
 * Begins rendering the view/components in the HTML element specified by the Container ID
 * Throws an error if the containerId has not been set
 */
CPMController.prototype.render = function(){
    var containerId = this.getContainerId();
    var view = this.getView();
    if (!containerId){
        throw new Error("Runtime Error: No 'containerId' set on instance of 'CPMController'");
    }
    //Empty the container's innerHTML so we can fill it with what we want
    $("#" + this.getContainerId()).empty();

    view.initializeComponents();
    view.renderMPage();
};


var CPM_Util = function () {
	return {
		refreshComponentsToStorage : function (components) {
			if (!components || !components.length) {
				return;
			}
			
			if(!CPMCurrCompIndex) CPMCurrCompIndex =0 ;

			CPM_MPageComponents = [];
    			
			for (var x = CPMCurrCompIndex, xl = components.length;
				x < xl;
				x++) {
				if (components[x]) {
					CPM_MPageComponents.push(components[x]);
				}
			}
		}
	};
}();	



/**
 * Sets the layout of the components within the view
 * Note: This logic is in place until this is configurable
 */

CPMController.prototype.processComponentLayout = function() {
	var componentList = this.getComponentList();
	var component, i, cLen;
	var vitalsComponentIndex = -1;
	var labsComponentIndex = -1;
	
	CPM_Util.refreshComponentsToStorage(componentList);

	for ( i = 0, cLen = componentList.length; i < cLen; i++) {
		component = componentList[i];
		component.setPageGroupSequence(1);
		component.setColumn(1);

		if (typeof NewOrdersCPMComponent !== 'undefined' && component instanceof NewOrdersCPMComponent) {
			component.setSequence(97);
		} else if (typeof AllergyComponentCPM !== 'undefined' && component instanceof AllergyComponentCPM) {
			component.setSequence(0);
		} else if (typeof LabsCPMComponent !== 'undefined' && component instanceof LabsCPMComponent) {
			labsComponentIndex = i;
			component.setSequence(1);
		} else if (typeof VitalsCPMComponent !== 'undefined' && component instanceof VitalsCPMComponent) {
			vitalsComponentIndex = i;
			component.setSequence(2);
		} else if (typeof DiagramCPMComponent !== 'undefined' && component instanceof DiagramCPMComponent) {
			component.setSequence(96);
		} else if (typeof DocumentsCPMComponent !== 'undefined' && component instanceof DocumentsCPMComponent) {
			component.setSequence(4);
		} else if (typeof PhysicianImpressionsCPMComponent !== 'undefined' && component instanceof PhysicianImpressionsCPMComponent) {
			component.setSequence(98);
		} else if (typeof TreatAssessmentComponentCPM !== 'undefined' && component instanceof TreatAssessmentComponentCPM) {
			component.setSequence(96);
		} else {
			this.processOutsideComponent(component, i);
		}
	}	
	
	if(vitalsComponentIndex >= 0 && labsComponentIndex >= 0){
		componentList[vitalsComponentIndex].setSequence(2);
		componentList[vitalsComponentIndex].setPageGroupSequence(0);
		componentList[vitalsComponentIndex].setColumn(2);
		componentList[labsComponentIndex].setSequence(1);
		componentList[labsComponentIndex].setPageGroupSequence(0);
		componentList[labsComponentIndex].setColumn(1);
		}
};

/**
 * Retrieves the CPM Configuration
 * If the AJAX call returns with success, the controller will process the configuration and begin rendering
 */
CPMController.prototype.retrieveNodeConfiguration = function() {
	var self = this;
	var conceptCd = self.getConceptCd();
    var pathwayId = self.getPathwayId();

	if (!conceptCd) {
		throw new Error("Runtime Error: No concept mean set on CPMController.  Cannot retrieve node configuration.");
	}

	MP_Core.XmlStandardRequest(null, this.createCpmConfigRequest(pathwayId, conceptCd), function(reply) {
		var statusMessage = "";
		var response = null;
		var x = 0;
		var nodeId = 0;
		self.configureView();

		if (!reply) {
			statusMessage = "Error retrieving CPM Configuration";
		}

		if (reply.getStatus() === 'S') {
			response = reply.getResponse();
			if (!response) {
				throw new Error("Runtime Error: Undefined 'response' from CPMController method 'retrieveNodeConfiguration'");
			}

			self.processPathwayConfiguration(response);
			//Find One Treatment Node
			//Currently all that is supported by CPM
			var nodes = self.getNodeConfig();
			for (var x = nodes.length; x--;){
				if(nodes[x].INTENTION_CD_MEANING == "TREATMENTS"){
					nodeId = nodes[x].CP_NODE_ID;
					break;
				}
			}
			
			
			self.processNodeConfiguration(nodeId);
			
			if(nodes && nodes.length && nodes[0].NODE_NAME == "!CONCEPT ONLY!"){ 
				// since there is no pathway id associated with the concept we are calling prcessComponentLayout to assign the 
				// sequencing manually
				self.processComponentLayout();
			}
			self.render();
			return;

		} else if (reply.getStatus() === 'Z') {
			statusMessage = "No configuration for this result type was found";
		} else {
			statusMessage = "Error retrieving configuration";
		}

		$("#" + self.getContainerId()).html(statusMessage);
	});
};function CPMRenderStrategy(){}

CPMRenderStrategy.prototype = new RenderStrategy();
CPMRenderStrategy.prototype.constructor = CPMRenderStrategy;

CPMRenderStrategy.prototype.createComponentHeader = function(){
    //Create the header shell
    var header = $("<h2></h2>").addClass("cpm "+this.componentStyle.getHeaderClass());

    //Add the toggle control
    this.addComponentSection(header, this.createComponentToggleControl());

    //Add the title to the header
    this.addComponentSection(header, this.createComponentTitle());
    
    return header[0];
};

/**
 * Creates the component toggle control found in the header. This control handles expanding/collapsing
 * the component
 * @param {MPageComponent} component the component for which we are creating the toggle control
 * @return {Object} the DOM element for the component toggle control
 */
CPMRenderStrategy.prototype.createComponentToggleControl = function() {
    //If component is always expanded, we do not create the toggle control
    if(this.component.isAlwaysExpanded()) {
        return null;
    }
    return $("<div></div>").addClass("cpm-sec-hd-tgl").attr("title", this.i18nCore.HIDE_SECTION)[0];
};

/**
 * The CPM summary components do not use the accordion. Sets the supertype's function
 * to null.
 * @returns {null} null
 */
CPMRenderStrategy.prototype.createComponentAccordion = function() {
	return null;
};

CPMRenderStrategy.prototype.createComponentTitle = function(){
	var componentTitleContainer = $("<span></span>").addClass("cpm-header "+this.componentStyle.getTitle());

	//Create the component anchor
	this.addComponentSection(componentTitleContainer, this.createComponentAnchor());
	
	//Create the component loading section
	this.addComponentSection(componentTitleContainer, this.createComponentSubTitleSection());
	
	//Try adding the plus add control
	this.addComponentSection(componentTitleContainer, this.createPlusAddControl());
	
	//Create the header separator
	this.addComponentSection(componentTitleContainer, this.createHeaderSeparator());
	
	//Try adding the header dropdown menu
	this.addComponentSection(componentTitleContainer, this.createHeaderDropdown());
	
	return componentTitleContainer[0];
};

CPMRenderStrategy.prototype.createHeaderSeparator = function(){
	return "<span class='header-separator'></span>";
};/* globals CERN_Platform */

/* The use of DiscernObjectFactory is preserved over the use of getWrappedDiscernObject
considering that the COM objects have nested COM objects as properties and
getWrappedDiscernObject does not cover this scenario.
*/


var InteractionChecking = function () {
	var mcObj;
	var isDllSupported = true;
	/**
	 * Checks if the current browser is IE/Edge based on the userAgent value in the navigator object
	 * Trident is IE's engine and the presence of the string "Trident/7.0" against the string MSIE or Edge confirms that it is IE
	 * @returns {Boolean} true if current browser is IE, else false
	 */
	var isIE = function() {
		return /(MSIE|Edge|Trident\/7.0)/gi.test(navigator.userAgent);
	};
	/**
	 * Adds an interaction object to an existing array that is passed in.
	 * @param  {Array} aObj - The array that will contain the interaction objects.
	 * @param {Object} iObj - The interaction object that will be stored inside the array passed in.
	 * @param {Number} iIdx - The index for the interaction object.
	 * @param {Number} pIdx - The parent index of the interaction object.
	 */
	function AddInteraction(aObj, iObj, iIdx, pIdx) {
		try{
			var i = aObj.length;
			aObj[i] = {idx: iIdx, pIdx: pIdx, iObj: iObj};
		}
		catch (error) {
			throw new Error("ERROR in function AddInteraction(idx[" + iIdx + "],pIdx[" + pIdx + "]): " + error.message);
		}
	}
	/**
	 * Searches for a matching synonym_id in a passed in array and returns the array's index.
	 * @param   {Array} arr - The array that will contain synonym_id's to search for.
	 * @param   {Number} id - The id to search for in the Array that is passed in.
	 * @returns {Number}    - The index number of the array where a match was found, if not found returns -1.
	 */
	function findSynonymId(arr, id) {
		try{
			var l = arr.length;
			for (var i = 0; i < l; i++) {
				if (arr[i].synonym_id == id) {
					return (i);
				}
			}
			return (-1);
		}
		catch (error) {
			throw new Error("ERROR in function findSynonymId(id[" + id + "]): " + error.message);
		}
	}
	
	/**
	 * Searches for a matching severity AND type in a passed in array and returns the array's index.
	 * @param   {Array}            arr - The array that will contain severity and type to search for.
	 * @param   {String}      severity - The severity to search for in the Array that is passed in.
	 * @param   {String}          type - The type to search for in the Array that is passed in.
	 * @param   {String}   silSeverity - The SIL severity level to search for in the Array that is passed in.
	 * @param   {String} silConfidence - The SIL confidence level to search for in the Array that is passed in.
	 * @returns {Number}               - The index number of the array where a match was found, if not found returns -1.
	 */
	function findTypeCombo(arr, severity, type, silSeverity, silConfidence) {
		try{
		var l = arr.length;
		for (var i = 0; i < l; i++) {
			if ((severity && type && arr[i].SeverityLevel == severity && arr[i].InteractionType == type) 
				|| (silSeverity && silConfidence
				&& arr[i].SilSeverityLevel == silSeverity && arr[i].SilConfidenceLevel == silConfidence)) {
				return (i);
			}
		}
		return (-1);
		}
		catch (error) {
			throw new Error("ERROR in function findTypeCombo(severity[" + severity + "],type[" + type + "],silSeverity[" + silSeverity + "],silConfidence[" + silConfidence + "]): " + error.message);
		}
	}
	
	/**
	 * Adds an interaction object for each medication found to an existing array that is passed in.
	 * @param {Array} arr - The array that will contain the interaction objects.
	 * @param {Object} retrievedProperties - The properties of the interaction object that will be stored inside the array passed in, if not already in the medication group.
	 */
	 function AddInteractionByMedication(arr, retrievedProperties) {
		try {
			var aLen = arr.length;
			var tLen;
			if (aLen == 0) {
				arr[aLen] = {
					synonym_name: retrievedProperties.subjectEntityName,
					synonym_id: retrievedProperties.subjectSynonymId,
					types: []
				};
				tLen = arr[aLen].types.length;
				arr[aLen].types[tLen] = {
					SeverityLevel: retrievedProperties.severityLevel,
					InteractionType: retrievedProperties.interactionType,
					SilSeverityLevel: retrievedProperties.silSeverityLevel,
					SilConfidenceLevel: retrievedProperties.silConfidenceLevel
				};
			}
			else {
				var synIdx = findSynonymId(arr, retrievedProperties.subjectSynonymId);
				if (synIdx == -1) {
					arr[aLen] = {
						synonym_name: retrievedProperties.subjectEntityName,
						synonym_id: retrievedProperties.subjectSynonymId,
						types: []
					};
				}
				else {
					aLen = synIdx;
				}
				tLen = arr[aLen].types.length;
				var typeIdx = -1;
				if (tLen > 0) {
					typeIdx = findTypeCombo(
						arr[aLen].types, retrievedProperties.severityLevel, retrievedProperties.interactionType, retrievedProperties.silSeverityLevel, retrievedProperties.silConfidenceLevel
					);
				}
				if (typeIdx == -1) {
					arr[aLen].types[tLen] = {
						SeverityLevel: retrievedProperties.severityLevel,
						InteractionType: retrievedProperties.interactionType,
						SilSeverityLevel: retrievedProperties.silSeverityLevel,
						SilConfidenceLevel: retrievedProperties.silConfidenceLevel
					};
				}
			}
		}
		catch (error) {
			throw new Error("ERROR in function AddInteractionByMed(): " + error.message);
		}
	}

	/**
	 * retrieves the properties of the interactionChecking object depending on whether the current browser is IE or Edge
	 * @param {Array} arr - The array that will contain the interaction objects.
	 * @param {Object} interactionCheckObj - The interaction object that will be stored inside the array passed in, if not already in the medication group.
	 * @returns {undefined|Promise<undefined>} - nothing on IE or a promise on Edge
	 */
	function AddInteractionByMed(arr, interactionCheckObj, isIExplorer) {
		var aLen = arr.length;
		var retrievedProperties = {};
		var subjectEntityName, subjectSynonymId, severityLevel, interactionType, silSeverityLevel, silConfidenceLevel;
		if(isIExplorer) {
			subjectEntityName = interactionCheckObj.SubjectEntityName;
			subjectSynonymId = interactionCheckObj.SubjectSynonymId;
			severityLevel = interactionCheckObj.SeverityLevel;
			interactionType = interactionCheckObj.InteractionType;
			silSeverityLevel = interactionCheckObj.SilSeverityLevel;
			silConfidenceLevel = interactionCheckObj.SilConfidenceLevel;
			retrievedProperties = {
				subjectEntityName: subjectEntityName,
				subjectSynonymId: subjectSynonymId,
				severityLevel: severityLevel,
				interactionType: interactionType,
				silSeverityLevel: silSeverityLevel,
				silConfidenceLevel: silConfidenceLevel
			};
			AddInteractionByMedication(arr, retrievedProperties);
		} else {
			var promisesArr = [];
			promisesArr.push(
				new Promise(function(resolve, reject) {
					interactionCheckObj.getHostProperty("SubjectEntityName").then(function(subEntityName) {
						subjectEntityName = subEntityName;
						resolve();
					});
				}),
				new Promise(function(resolve, reject) {
					interactionCheckObj.getHostProperty("SubjectSynonymId").then(function(subSynonymId) {
						subjectSynonymId = subSynonymId;
						resolve();
					});
				}),
				new Promise(function(resolve, reject) {
					interactionCheckObj.getHostProperty("SeverityLevel").then(function(sevLevel) {
						severityLevel = sevLevel;
						resolve();
					});
				}),
				new Promise(function(resolve, reject) {
					interactionCheckObj.getHostProperty("InteractionType").then(function(iType) {
						interactionType = iType;
						resolve();
					});
				}),
				new Promise(function(resolve, reject) {
					interactionCheckObj.getHostProperty("SilSeverityLevel").then(function(silSevLevel) {
						silSeverityLevel = silSevLevel;
						resolve();
					});
				}),
				new Promise(function(resolve, reject) {
					interactionCheckObj.getHostProperty("SilConfidenceLevel").then(function(silConfLevel) {
						silConfidenceLevel = silConfLevel;
						resolve();
					});
				})
			);
			return Promise.all(promisesArr).then(function() {
				retrievedProperties = {
					subjectEntityName: subjectEntityName,
					subjectSynonymId: subjectSynonymId,
					severityLevel: severityLevel,
					interactionType: interactionType,
					silSeverityLevel: silSeverityLevel,
					silConfidenceLevel: silConfidenceLevel
				};
				AddInteractionByMedication(arr, retrievedProperties);
			});
		}
	}

	/**
	 * utility function to set the value of interactionType to be used in the AddInteraction function
	 * and to increment the count of currently found interactions
	 * @param {Number} interactionTypeFromObj 
	 * @param {Object} myInteractions 
	 * @param {Object} iObj 
	 * @param {Number} k 
	 * @param {Number} j 
	 * @param {Object} knownInteractionTypes 
	 * @returns {undefined} nothing
	 */
	function updateInteractionsWithInteractionType(interactionTypeFromObj, myInteractions, iObj, interactionIndex, interactionCheckIndex, knownInteractionTypes) {
		var interactionType;
		switch(interactionTypeFromObj){
			case 0:
				interactionType = knownInteractionTypes.arrDrugDrug;
				break;
			case 1:
				interactionType = knownInteractionTypes.arrDrugAllergy;
				break;
			case 2:
				interactionType = knownInteractionTypes.arrDrugFood;
				break;
			case 3:
				interactionType = knownInteractionTypes.arrDupTherapy;
				break;
			case 4:
				interactionType = knownInteractionTypes.arrIVCompatibility;
				break;
			default:
				logger.logJSError("Error in trying to set the interaction type.", "Interaction Checking", "inn_util_interaction_checking.js", "GetInteractions");
				break;
		}
		AddInteraction(interactionType, iObj, interactionIndex, interactionCheckIndex);
		myInteractions.interactionCnt++;
	}

	/**
	 * utility function to set the types of interactions in the object that is to be returned by the GetInteractions function
	 * @param {Object} myInteractions - object containing interactions
	 * @param {Object} knownInteractionTypes - object containing the types of interactions
	 */
	function setInteractionTypes (myInteractions, knownInteractionTypes) {
		myInteractions.DrugDrugInteractions = knownInteractionTypes.arrDrugDrug;
		myInteractions.DrugAllergyInteractions = knownInteractionTypes.arrDrugAllergy;
		myInteractions.DrugFoodInteractions = knownInteractionTypes.arrDrugFood;
		myInteractions.DupTherapyInteractions = knownInteractionTypes.arrDupTherapy;
		myInteractions.IVCompatibilityInteractions = knownInteractionTypes.arrIVCompatibility;
	}

	/** Format and return an array of interactions for the calling application.
	  * @param   {Object}  iccObj - interaction check collection.
	  * @returns {Object|Promise<Object>} myInteractions - returns the object if browser is IE, else a promise that resolves with it
			myInteractions Object that contains arrays of each type of Interaction...
				* Medications
				* DrugDrugInteractions
				* DrugAllergyInteractions
				* DrugFoodInteractions
				* DupTherapyInteractions
				* IVCompatibilityInteractions
				Each type of interaction will contain an iObj Object that has the following properties:
					SubjectComponentName
					CausingComponentName
					CausingCatalogCd
					SubjectCatalogCd
					CausingSynonymId
					toString
					SubjectEntityCKI
					CausingEntityCKI
					OverrideReasonCd
					OverrideReasonDisp
					PreviousOverrideReasonCd
					PreviousOverrideReasonDisp
					CausingEntityUniqueString
					CausingEntityName
					CausingEntityId
					CausingEntityType
						[0] EntityUnknown
						[1] EntityOrder
						[2] EntityAllergy
						[3] EntityFood
					SubjectEntityUniqueString
					SubjectEntityName
					SubjectEntityId
					SubjectEntityType
						[0] EntityUnknown
						[1] EntityOrder
						[2] EntityAllergy
						[3] EntityFood
					SeverityDescription
					SeverityLevel
						[0] NoSeverity
						[1] MinorSeverity
						[2] ModerateSeverity
						[3] MajorSeverity
					InteractionDescription
					InteractionType
						[0] DrugDrugInteraction
						[1] DrugAllergyInteraction
						[2] DrugFoodInteraction
						[3] DuplicateTherapyInteraction 
						[4] IVCompatibilityInteraction
					TransactionUniqueId
					SubjectSynonymId
					SubjectSynonymId
					CategoryLevelType
					CausingEntityComponentCKI
					SubjectEntityComponentCKI
	*/
	function GetInteractions(iccObj) {
		var knownInteractionTypes = {
			arrDrugDrug : {type: "Drug Drug Interaction"},
			arrDrugAllergy : {type: "Drug Allergy Interaction"},
			arrDrugFood : {type: "Drug Food Interaction"},
			arrDupTherapy : {type: "Duplicate Therapy Interaction"},
			arrIVCompatibility : {type: "IV Compatibility Interaction"}
		};
		var arrMedications = [];
		if (typeof iccObj.GetInteractionCheckAtEx == "undefined") {
			alert("The registered version of PVInteractionCheckingCom.dll does not support Interaction Checking from this MPage.  Please contact your system administrator.");
			isDllSupported = false;
			return isIE() ? null : Promise.resolve(null);
		} else {
			isDllSupported = true;
		}
		/* on IE, the constituent methods of the discernObject are synchronous 
			and asynchronous on Edge
		*/
		if(isIE()) {
			try{
				var iccCnt = iccObj.GetInteractionCheckCount();
				if (iccCnt > 0) {
					var myInteractions = [];
					myInteractions.interactionCnt = 0;
					for (var j = 0; j < iccCnt; j++) {
						var icObj = iccObj.GetInteractionCheckAtEx(j);
						var giCnt = icObj.InteractionCollection.GetInteractionCount();
						if (giCnt > 0) {
							for (var k = 0; k < giCnt; k++) {
								var iObj = icObj.InteractionCollection.GetInteractionAt(k);
								updateInteractionsWithInteractionType(iObj.InteractionType, myInteractions, iObj, k, j, knownInteractionTypes);
								AddInteractionByMed(arrMedications, iObj, true);
							}
						}
					}
					myInteractions.Medications = arrMedications;
					setInteractionTypes(myInteractions, knownInteractionTypes);
					return myInteractions;
				} else {
					return null;
				}
			} catch (error) {
				throw new Error("ERROR in function GetInteractions(): " + error.message);
			}
		} else {
			try {
				// Gets the interaction check count(iccCnt) from interaction check collection object (iccObj)
				return iccObj.GetInteractionCheckCount().then(function (iccCnt) {
					if (iccCnt > 0) {
						var myInteractions = [];
						myInteractions.interactionCnt = 0;
						var iccPromises = [];
						for (var j = 0; j < iccCnt; j++) {
							iccPromises.push(
								// Gets the individual interaction count(giCnt) at each interaction check(icObj)
								iccObj.GetInteractionCheckAtEx(j).then(function (icObj) {
									return icObj.InteractionCollection.GetInteractionCount().then(function (giCnt) {
										if (giCnt > 0) {
											var giPromises = [];
											for (var k = 0; k < giCnt; k++) {
												giPromises.push(
													// Gets the details of each interaction(iObj).
													icObj.InteractionCollection.GetInteractionAt(k).then(function (iObj) {
														return iObj.getHostProperty("InteractionType").then(function (iType) {
															updateInteractionsWithInteractionType(iType, myInteractions, iObj, k, j, knownInteractionTypes);
															return AddInteractionByMed(arrMedications, iObj, false)
														});
													})
												);
											}
											return Promise.all(giPromises);
										}
									});
								})
							);
						}
						return Promise.all(iccPromises).then(function () {
							myInteractions.Medications = arrMedications;
							setInteractionTypes(myInteractions, knownInteractionTypes);
							return myInteractions;
						}).catch(function (error) {
							throw new Error("ERROR in function GetInteractions(): " + error.message);
						});
					}
					else {
						return null;
					}
				}).catch(function (error) {
					throw new Error(error);
				});
			} catch (error) {
				throw new Error("ERROR in function GetInteractions(): " + error.message);
			}
		}
	}

	return {
		/**
		 * Initializes the Interaction Checking variable by creating a Medication Collection object from the Discern Object Factory.
		 */
		init: function (){
			try {
				if (mcObj == null) {
                    mcObj = window.external.DiscernObjectFactory("MEDICATIONCOLLECTION");
                }
                return (true);
			} catch (error) {
				throw new Error("ERROR in function init(): " + error.message);
			}
			
		},
		
		/**
		 * Gets the value for isDllSupported, so the caller can determine if checking interactions will be supported via PVInteractionCheckingCom.dll.
		 * @return  {Boolean} isDllSupported - The value of the variable isDllSupported will be returned.
		 */
		GetisDllSupported: function() {
			return (isDllSupported);
		},
		
		/**
		 * Removes a single medication object from the medication collection object. 
		 * @param  {Number} x - The index of the medication inside the medication collection that is to be removed.
		 * @returns {Promise<undefined>}
		 */
		RemoveMedicationAt: function (x) {
			return new Promise(function(resolve, reject) {
				try {
					if(isIE()) {
						mcObj.RemoveMedicationAt(x);
						resolve();
					} else {
						mcObj.RemoveMedicationAt(x).then(function() {
							resolve();
						}).catch(function(error) {
							reject(new Error("ERROR in function RemoveMedicationAt(" + x + "): " + error.message));
						});
					}
				} catch (error) {
					reject(new Error("ERROR in function RemoveMedicationAt(" + x + "): " + error.message));
				}
			});
		},
		
		/**
		 * Clears or empties the Medication Collection Object.
		 */
		ClearMedicationCollection: function() {
			return new Promise(function(resolve, reject) {
				try {
					if(isIE()) {
						mcObj.Clear();
						resolve();
					} else {
						mcObj.Clear().then(function() {
							resolve();
						}).catch(function(error) {
							reject(new Error("ERROR in function ClearMedicationCollection(): " + error.message));
						});
					}
				} catch (error) {
					reject(new Error("ERROR in function ClearMedicationCollection(): " + error.message));
				}
			});
		},
		
		/**
		 * Adds a medication object to the Medication Collection.
		 * @param {Number} synonym_id    - The synonymn_id of the medication.
		 * @param {String} mnemonic      - The mnemonic of the medication.
		 * @param {String} order_details - The order details of the medication.
		 * @param {Number} venue_type    - The venue type of the medication.
		 * @returns {Promise<undefined>}
		 */
		AddMedication: function(synonym_id, mnemonic, order_details, venue_type) {
			var currentContext = this;
			return new Promise(function(resolve, reject) {
				try {
					if (mcObj == null) {
						currentContext.init();
					}
					var medObj = window.external.DiscernObjectFactory("MEDICATIONOB");
						if(isIE()) {
						var mc_cnt = mcObj.GetMedicationCount();
						medObj.AddSynonym(synonym_id, mnemonic);
						medObj.UniqueIdentifier = mc_cnt.toString() + mnemonic + synonym_id.toString();
						medObj.mnemonic = mnemonic;
						medObj.OrderDetails = order_details;
						medObj.VenueType = venue_type;
						mcObj.AddMedication(medObj);
						resolve();
					} else {
						return mcObj.GetMedicationCount().then(function(mc_cnt) {
							return medObj.AddSynonym(synonym_id, mnemonic).then(function() {
								medObj.UniqueIdentifier = mc_cnt.toString() + mnemonic + synonym_id.toString();
								medObj.mnemonic = mnemonic;
								medObj.OrderDetails = order_details;
								medObj.VenueType = venue_type;
								return mcObj.AddMedication(medObj).then(function() {
									resolve();
								});
							});
						}).catch(function(error) {
							reject(new Error("ERROR in function AddMedication(" + synonym_id + "," + mnemonic + "," + order_details + "," + venue_type + "): " + error.message));
						});
					}
				} catch (error) {
					reject(new Error("ERROR in function AddMedication(" + synonym_id + "," + mnemonic + "," + order_details + "," + venue_type + "): " + error.message));
				}
			});
		},
		
		/**
		 * Returns a promise that resolves with the number of medications found inside the Medication COllection object.
		 */
		GetMedicationCnt: function () {
			return new Promise(function(resolve, reject) {
				try {
					if(isIE()) {
						var count = mcObj.GetMedicationCount();
						resolve(count);
					}
					mcObj.GetMedicationCount().then(function(count) {
						resolve(count);
					}).catch(function(error) {
						reject(new Error("ERROR in function GetMedicationCnt(): " + error.message));
					});
				} catch(error) {
					reject(new Error("ERROR in function GetMedicationCnt(): " + error.message));
				};
			});
		},
		
		/**
		 * Checks for interactions between the medication collection and the patient profile and returns the collection to the caller.
		 * @param   {Number} pid      - The person_id of the patient in which the interaction checking will be performed.
		 * @returns {Promise<Object>} - A promise that resolves with the object containing interaction-details
		 */
		CheckforInteractions: function (pid){
			return new Promise(function(resolve, reject) {
				try {
					if(isIE()) {
						var mc_cnt = mcObj.GetMedicationCount();
						if (mc_cnt > 0) {
							var pvicObj = window.external.DiscernObjectFactory("PVINTERACTIONCHECKING");
							iccObj = pvicObj.CheckMedicationsInteractions(mcObj, pid);
							var iccCnt = iccObj.GetInteractionCheckCount();
							if (iccCnt > 0) {
								var interactions = GetInteractions(iccObj);
								resolve(interactions);
							} else {
								resolve(null);
							}
						} else {
							resolve(null);
						}
					} else {
						return mcObj.GetMedicationCount().then(function(medicationCount) {
							if (medicationCount > 0) {
								var pvicObj = window.external.DiscernObjectFactory("PVINTERACTIONCHECKING");
								return pvicObj.CheckMedicationsInteractions(mcObj, pid).then(function(interactionCheckCollectionObj) {
									return interactionCheckCollectionObj.GetInteractionCheckCount().then(function(iccCnt) {
										if (iccCnt > 0) {
											return GetInteractions(interactionCheckCollectionObj).then(function(interactions) {
												resolve(interactions);
											});
										} else {
											resolve(null);
										}
									});
								});
							} else {
								resolve(null);
							}
						}).catch(function(error) {
							reject(new Error("ERROR in function CheckforInteractions(): " + error.message));
						});
					}
				} catch(error) {
					reject(new Error("ERROR in function CheckforInteractions(): " + error.message));
				}
			});
		}
	};
}();
/**
 * CPNodeView
 * This class is a subclass of MPageView.
 * Handles rendering the components.
 * @constructor
 */
function CPNodeView(){
    this.m_id = 0;
    this.m_customCSS = "";
    this.m_renderStrategy = null;
    this.m_containerId = "";
}

CPNodeView.prototype = new MPageView();
CPNodeView.prototype.constructor = CPNodeView;

/**
 *
 * @returns {number}
 */
CPNodeView.prototype.getId = function(){
    return this.m_id;
};

CPNodeView.prototype.setId = function(id){
    if (typeof id !== 'string' && typeof id !== 'number'){
        throw new Error("Type Error: Invalid 'id' passed into CPNodeView method 'setId'");
    }
    this.m_id = id;
};

CPNodeView.prototype.setContainerId = function(id){
    this.m_containerId = id;
};

CPNodeView.prototype.getContainerId = function(){
    return this.m_containerId;
};

CPNodeView.prototype.getCustomCSS = function(){
    return this.m_customCSS;
};

CPNodeView.prototype.setCustomCSS = function(css){
    if (typeof css !== 'string'){
        throw new Error("Type Error: Non-string 'css' passed into CPNodeView method 'setCustomCSS'");
    }
    this.m_customCSS = css;
};

CPNodeView.prototype.getRenderStrategyConstructor = function(){
    return this.m_renderStrategy;
};

CPNodeView.prototype.setRenderStrategyConstructor = function(rsConstructor){
    if (typeof rsConstructor !== 'function'){
        throw new Error("Type Error: Non-constructor 'rsConstructor' passed into CPNodeView method 'setRenderStrategyConstructor'");
    }
    this.m_renderStrategy = rsConstructor;
};

CPNodeView.prototype.createNewRenderStrategy = function(){
    var renderStrategy = this.getRenderStrategyConstructor();
    if (renderStrategy){
        return new renderStrategy();
    } else {
        return new RenderStrategy();
    }
};

CPNodeView.prototype.resizeComponents = function(){
    var componentList = this.getComponents() || [];
    var component;
    var cLen = componentList.length;

    for (;cLen--;){
        component = componentList[cLen];
        if (component.isDisplayable()){
            component.resizeComponent();
        }
    }
};

CPNodeView.prototype.resizeView = function(){
    this.resizeComponents();
};

CPNodeView.prototype.initializeComponents = function(){
    var componentList = this.getComponents() || [];
    var component;
    var criterion = this.getCriterion();
    var cLen = componentList.length;
    var i;

    for (i = 0; i < cLen; i++){
        component = componentList[i];
        if (!component){
            continue;
        }
        //Set component's criterion
        component.initializeComponent(criterion);
        //component.loadUserPrefs();
        //Attempts to load display filters for component
        component.loadDisplayFilters();
        component.createMainMenu();
        component.preProcessing();
    }
};

//CPNodeView.prototype.storeViewComponents = function(componentList){
//    //Overriding this method so components aren't stored in the global namespace
//    return;
//};

CPNodeView.prototype.renderComponents = function(componentList){
    var container = this.getContainer();
    MPageView.prototype.renderComponents.call(this, componentList);

    if (container && container.length){
        container.addClass(this.getCustomCSS());
    }
};

CPNodeView.prototype.attachEvents = function(component){
    if (!component){
        return;
    }
    var i18nCore = i18n.discernabu;
    var componentRootNode = component.getRootComponentNode();
    var jqRootNode = $(componentRootNode);
    //var prefObj = component.getPreferencesObj() || {};
    //Ensure reference to object exists within component (in event getPreferencesObj returned null)
    //component.setPreferencesObj(prefObj);

    //Attaching click events to component expand/collapse toggle
    jqRootNode.find(".cpm-sec-hd-tgl").click(function(event){
        var isExpanded = 0;
        if (jqRootNode.hasClass("closed")){
            jqRootNode.removeClass("closed");
            this.innerHTML = "-";
            this.title = i18nCore.HIDE_SECTION;
            //isExpanded = 1;
        } else {
            jqRootNode.addClass("closed");
            this.innerHTML = "+";
            this.title = i18nCore.SHOW_SECTION;
        }
        //prefObj["EXPANDED"] = isExpanded;
        //component.savePreferences(false); //Synchronous for now
    });

};

CPNodeView.prototype.renderMPage = function(){
    var self = this;
    var componentList = this.getComponents() || [];
    var component;
    var resizeTimer = null;
    var cLen = componentList.length;
    var i;

    this.renderComponents(componentList);

    for (i = 0; i < cLen; i++){
        component = componentList[i];
        if (!component.isLoaded()){
            component.setLoaded(true);
            component.startComponentDataRetrieval();
        }
        //Attach header toggle
        this.attachEvents(component);
    }

    MP_Util.Doc.SetupExpandCollapse(this.getContainerId());

    //Attach resize event
    $(window).on("resize." + this.getId(), function(){
        if (resizeTimer){
            clearTimeout(resizeTimer);
        }
        resizeTimer = setTimeout(function(){
            self.resizeView();
        }, 500);
    });
};

CPNodeView.prototype.getCriterion = function(){
    //Using this temporarily
    var js_criterion = JSON.parse(m_criterionJSON);
    return MP_Util.GetCriterion(js_criterion, CERN_static_content);
};

/**
 * Calls the cleanUp method on all its components.
 * This method will likely get called when the view is closed.
 */
CPNodeView.prototype.cleanComponents = function(){
    var componentList = this.getComponents() || [];
    var cLen = componentList.length;

    for (; cLen--;){
        componentList[cLen].cleanUp();
    }
};

CPNodeView.prototype.commitComponentChanges = function(flag){
    var componentList = this.getComponents() || [];
    var cLen = componentList.length;

    for (;cLen--;){
        componentList[cLen].commitChanges(flag);
    }
};

CPNodeView.prototype.destroyView = function(){
    this.cleanComponents();
    //Removes the view's resize event handler
    $(window).off("." + this.getId());
};

function CPMView(){

}

CPMView.prototype = new CPNodeView();
CPMView.prototype.constructor = CPMView;
/*global RenderStrategy */
/**
 * The FusionRenderStrategy object
 * This object is used to placeholder for components extending FusionComponent only. It inherits from the base
 * RenderStrategy object. None of the base methods are implemented except for createComponentShell.
 * @constructor
 * @author Murtuza Syed
 */
function FusionRenderStrategy() {}

FusionRenderStrategy.prototype = new RenderStrategy();
FusionRenderStrategy.prototype.constructor = RenderStrategy;

/**
 * Overrides the RenderStrategy method for creating the component's container.
 * This function just creates an empty placeholder for the component to mount. 
 * The component takes care of rendering the header, body, toolbar, banner and footer sections. 
 * @returns {Object} The DOM object representing the component header
 */
FusionRenderStrategy.prototype.createComponentShell = function() {
	return this.createComponentContainer();
};
/* Hover Mouse Over */
/* Hover Mouse Over */
function hmo(evt, n, comp){
    evt = evt || window.event;
    var s = n.style, p = getPosition(evt), vp = gvs(), so = gso(), left = p.x + 20, top = p.y + 20;
    n._ps = n.previousSibling;
    n.hmo = true;

    //Helper function to check if the hover's previous sibling (the one that initiates the hover) has been removed from the DOM.
    function checkHoverSourceExists() {
    	try {
	    	//If we're not hovering over the element anymore, then stop checking
	    	if(!n.hmo) {
	    		return;
	    	}
	    	//If the hover's anchor no longer exists, remove the hover and return
	    	if(!$(comp.getSectionContentNode()).find($(n._ps)).length) {
	    		$(n).remove();
	    		return;
	    	}
	    	//If we've made it this far, the hover anchor still exists and we are still hovering, so continue polling.
	    	setTimeout(checkHoverSourceExists, 1000);
    	} catch(exe) {
    		return;
    	}
    }

    function hover(){
        if (n.hmo === true) { //make sure the cursor has not moused out prior to displaying
        	//Make call to begin checking that the hover's parent has not been removed from the DOM
        	checkHoverSourceExists();
			if (comp) {
				if (comp.isEditMode()) {
					 clearTimeout(n.timer);
					return;
				}
			}

			s.display = "block";
		    if(left + n.offsetWidth > vp[1] + so[1]) {
				left = left - 40 - n.offsetWidth;
				if(left < 0) {
					left = 0;
				}
			}

			if(top + n.offsetHeight > vp[0] + so[0]) {
				if(top - 40 - n.offsetHeight < so[0]) {
					if(left > 0) {
						top = 10 + so[0];
					}
				} else {
					top = top - 40 - n.offsetHeight;
				}
			}
			document.body.appendChild(n);
            s.left = left + "px";
            s.top = top + "px";
            n.show = true;
        }
    }
    n.timer = setTimeout(hover, 500);
}
/* Hover Mouse Move */
function hmm(evt, n, comp){

    if (!n.show) {
        return;
    }

    if (comp) {
		if (comp.isEditMode()) {
			clearTimeout(n.timer);
			return;
		}
	}
    var s = n.style, p = getPosition(evt), vp = gvs(), so = gso(), left = p.x + 20, top = p.y + 20;

    if (left + n.offsetWidth > vp[1] + so[1]) {
        left = left - 40 - n.offsetWidth;
        if (left < 0) {
            left = 0;
        }
    }

    if (top + n.offsetHeight > vp[0] + so[0]) {
        if (top - 40 - n.offsetHeight < so[0]) {
            if (left > 0) {
                top = 10 + so[0];
            }
        }
        else {
            top = top - 40 - n.offsetHeight;
        }
    }
    evt = evt || window.event;
    s.top = top + "px";
    s.left = left + "px";
}

/* Hover Mouse Out*/
function hmt(evt, n, comp){
	if (comp) {
		if (comp.isEditMode()) {
			clearTimeout(n.timer);
			return;
		}
	}
    n.hmo = false;
    if (!n._ps)
        n._ps = n.previousSibling;
    clearTimeout(n.timer);
    evt = evt || window.event;
    n.style.display = "";
    Util.ia(n, n._ps);
    n.show = false;
}

/* Hover Setup */
function hs(e, n, comp){
    var priorBgColor = e.style.backgroundColor;
    var priorBorderColor = e.style.borderColor;
	var editMode;
	if (n && n.tagName == "DIV") {
        e.onmouseenter = function(evt){
		if (comp) {
			 if (comp.isEditMode()) {
				return;
			}
		}
			e.onmouseover = null;
			e.onmouseout = null;
			hmo(evt, n, comp);
        };
        e.onmouseover = function(evt){
		if (comp) {
			 if (comp.isEditMode()|| Util.Style.ccss(this, "row-selected")) {
				return;
			}
		}
			e.style.backgroundColor = "#FFFFCC";
            e.style.borderColor = "#CCCCCC";
            hmo(evt, n, comp);
        };
        e.onmousemove = function(evt){
		if (comp) {
			 if (comp.isEditMode()|| Util.Style.ccss(this, "row-selected")) {
				return;
			}
		}
			e.style.backgroundColor = "#FFFFCC";
            e.style.borderColor = "#CCCCCC";
            hmm(evt, n, comp);
        };
        e.onmouseout = function(evt){
            e.style.backgroundColor = priorBgColor;
            e.style.borderColor = priorBorderColor;
            hmt(evt, n, comp);
        };
        e.onmouseleave = function(evt){
            e.style.backgroundColor = priorBgColor;
            e.style.borderColor = priorBorderColor;
            e.onmouseover = null;
            e.onmouseout = null;
            hmt(evt, n, comp);
        };
        e.onmouseup = function(evt){
            if (comp) {
                if (!comp.isEditMode()) {
                    return;
                }

                e.style.backgroundColor = priorBgColor;
                e.style.borderColor = priorBorderColor;
                hmt(evt, n, comp);
            }
        };
        Util.Style.acss(n, "hover");
    }
}

////// Healthe library 
 /*extern window, document*/
 /**
  * @fileOverview

     <h1>Utility Methods</h1>
     <p>
     These are universal utility methods, designed for speed, size and agnostic browser support. There are several namespaces:
     </p>
     <dl>
         <dt>Util</dt>
         <dd>General Utility methods</dd>
         <dd>Included in util.core.js</dd>
         <dt>Util.EventCache</dt>
         <dd>Object for ensuring proper garbage collection.</dd>
         <dd>Included in util.core.js</dd>
         <dt>Util.Convert</dt>
         <dd>Conversion Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.convert.js is not included.</dd>
         <dt>Util.Cookie</dt>
         <dd>Cookie Management Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.cookie.js is not included.</dd>
         <dt>Util.Detect</dt>
         <dd>Detection Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.detect.js is not included.</dd>
         <dt>Util.i18n</dt>
         <dd>Internationalization (i18n) Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.i18n.js is not included.</dd>
         <dt>Util.Load</dt>
         <dd>DOM-Loaded event Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.load.js is not included.</dd>
         <dt>Util.Pos</dt>
         <dd>Positioning Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.pos.js is not included.</dd>
         <dt>Util.Style</dt>
         <dd>CSS Utility methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.style.js is not included.</dd>
         <dt>Util.Timeout</dt>
         <dd>Session Management methods</dd>
         <dd>External module; will be an <strong>empty object</strong> if util.timeout.js is not included.</dd>
     </dl>
     <h2>Notes</h2>
     <p>All modules are aggregated together by Maven into a single file, util.js.</p>
     <p>Validated with JSLint.</p>
  */

 /**
  * Returns an element based on the id provided, <code>null</code> if no element exists.
  * @param {String} i The id.
  * @return {Node} An element with the id specified, <code>null</code> if no such element exists.
  * @static
  * @global
  * @fullname Get Element By ID
  */
 function _g(i) {
     return document.getElementById(i);
 }

 /**
  * Returns all elements from within the specified context matching the tag name provided, <code>null</code> if no
  * elements exist.
  * @param {String} t The tag name.
  * @param {Node} [e] The element to search within. Defaults to the document body.
  * @return {array} An array of elements with the tag name specified, <code>null</code> if no elements exist.
  * @static
  * @global
  * @fullname Get Elements By Tag Name
  */
 function _gbt(t, e) {
     e = e || document;
     return e.getElementsByTagName(t);
 }

 /**
  * Utility methods
  * @namespace Util
  * @static
  * @global
  */
 var Util = function () {

     var _e = [], _d = document, _w = window;

     return {
         /**
          * The Event Cache makes it possible to ensure all events attached to the DOM or browser instances are
          * properly "flushed away" after the page is unloaded. This prevents memory leaks in some implementations.
          *
          * @property
          * @memberof Util
          * @name EventCache
          */
         EventCache : function () {
             var l = [];
             return {

                 /**
                  * Add an event to the Event Cache.
                  * @param {Node} o The element or object to which the event is attached.
                  * @param {String} e The event name, e.g. "click" or "mouseover".
                  * @param {Function} f The function attached.
                  *
                  * @static
                  * @function
                  * @memberof Util.EventCache
                  * @name add
                  */
                 add : function (o, e, f) {
                     l.push(arguments);
                 },

                 /**
                  * Remove an event from the Event Cache.
                  * @param {Node} o The element or object to which the event is attached.
                  * @param {String} e The event name, e.g. "click" or "mouseover".
                  * @param {Function} f The function to detach.
                  *
                  * @static
                  * @function
                  * @memberof Util.EventCache
                  * @name remove
                  */
                 remove : function (o, e, f) {
                     var n;
                     for (var i = l.length - 1; i >= 0; i = i - 1) {
                         if (o == l[i][0] && e == l[i][1] && f == l[i][2]) {
                             n = l[i];
                             if (n[0].removeEventListener) {
                                 n[0].removeEventListener(n[1], n[2], n[3]);
                             }
                             else if (n[0].detachEvent) {
                                 if (n[1].substring(0, 2) != "on") {
                                     n[1] = "on" + n[1];
                                 }
                                 n[0].detachEvent(n[1], n[0][e + f]);
                             }
                         }
                     }
                 },

                 /**
                  * Remove all events from the Cache.
                  *
                  * @static
                  * @function
                  * @memberof Util.EventCache
                  * @name flush
                  */
                 flush : function () {
                     var e;
                     for (var i = l.length - 1; i >= 0; i = i - 1) {
                         var o = l[i];
                         if (o[0].removeEventListener) {
                             o[0].removeEventListener(o[1], o[2], o[3]);
                         }
                         e = o[1];
                         if (o[1].substring(0, 2) != "on") {
                             o[1] = "on" + o[1];
                         }
                         if (o[0].detachEvent) {
                             o[0].detachEvent(o[1], o[2]);
                             if (o[0][e + o[2]]) {
                                 o[0].detachEvent(o[1], o[0][e + o[2]]);
                             }
                         }
                     }
                 }
             };
         }(),

         /**
          * Creates an element within the document, without a parent, as if by <code>document.createElement</code>. This method
          * has better performance, as it caches instances of created objects and clones them, rather than manipulate the
          * document directly.
          * @param {String} t The tag name of the element to create.
          * @return {Node} A new element.
          *
          * @static
          * @function
          * @memberof Util
          * @name ce
          * @fullname Create Element
          */
         ce : function (t) {
             var a = _e[t];
             if (!a) {
                 a = _e[t] = _d.createElement(t);
             }
             if (!a) {
                 return null;
             }
             else {
                 return a.cloneNode(false);
             }
         },

         /**
          * Creates an element within the document, without a parent, as if by <code>document.createElement</code>. Any
          * given properites will then be set onto the newly created element. This method has better performance, as it
          * caches instances of created objects and clones them, rather than manipulate the document directly.
          * @param {String} t The tag name of the element to create.
          * @param {Object} [p] The properties to set onto the created element, (e.g. <code>{ "href" : "index.html", "name" : "theName"}</code>).
          * @return {Node} A new element.
          *
          * @static
          * @function
          * @memberof Util
          * @name cep
          * @fullname Create Element with Properties
          */
         cep : function (t, p) {
             var e = this.ce(t);
             return this.mo(e, p);
         },

         /**
          * Merges two option objects.
          * @param {Object} o1 The option object to be modified.
          * @param {Object} o2 The option object containing properties to be copied.
          * @param {Boolean} d True if properties on o1 should be immutable, false otherwise.
          * @return {Object} An object containing properties.
          *
          * @static
          * @function
          * @memberof Util
          * @name mo
          * @fullname Merge Objects
          */
         mo : function (o1, o2, d) {
             o1 = o1 || {};
             o2 = o2 || {};
             var p;
             for (p in o2) {
                 if (p) {
                     o1[p] = (o1[p] === undefined) ? o2[p] : !d ? o2[p] : o1[p];
                 }
             }
             return o1;
         },

         /**
          * Deletes an element from the DOM.
          * @param {Node} e The element to delete.
          *
          * @static
          * @function
          * @memberof Util
          * @name de
          * @fullname Delete Element
          */
         de : function (e) {
             if (e) {
                 this.gp(e).removeChild(e);
             }
         },

         /**
          * Universal event-bubbling cancel method.
          * @param {event} e The event object, (not required in IE).
          *
          * @static
          * @function
          * @memberof Util
          * @name cancelBubble
          * @fullname Cancel Event Bubble
          */
         cancelBubble : function (e) {
             e = _w.event || e;
             if (!e) {
                 return;
             }

             if (e.stopPropagation) {
                 e.stopPropagation();
             }
             else {
                 e.cancelBubble = true;
             }
         },

         /**
          * Universal event default behavior prevention method.
          * @param {event} e The event object, (not required in IE).
          *
          * @static
          * @function
          * @memberof Util
          * @name preventDefault
          * @fullname Prevent Default Behavior
          */
         preventDefault : function (e) {
             e = _w.event || e;

             if (!e) {
                 return;
             }

             if (e.preventDefault) {
                 e.preventDefault();
             }
             else {
                 e.returnValue = false;
             }
         },

         /**
          * Returns the an element's offset values, traversing the tree for an accurate value.
          * @param {Node} e The element to evaluate.
          * @return {array} The offset left and offset top, in pixels, in the form of [left, top].
          *
          * @static
          * @function
          * @memberof Util
          * @name goff
          * @fullname Get Element Offset Values
          */
         goff : function (e) {
             var l = 0, t = 0;
             if (e.offsetParent) {
                 while (e.offsetParent) {
                     l += e.offsetLeft;
                     t += e.offsetTop;
                     e = e.offsetParent;
                 }
             }
             else if (e.x || e.y) {
                 l += e.x || 0;
                 t += e.y || 0;
             }
             return [l, t];
         },

         /**
          * Returns an accurate parent node; Some browsers will return a Text Node.
          * @param {Node} e The element to evaluate.
          * @return {Node} The actual parent node.
          *
          * @static
          * @function
          * @memberof Util
          * @name gp
          * @fullname Get Parent
          */
         gp : function (e) {
             if (!e.parentNode) {
                 return e;
             }
             e = e.parentNode;
             while (e.nodeType === 3 && e.parentNode) {
                 e = e.parentNode;
             }
             return e;
         },


         /**
          * Some browsers will return a Text Node, so this method returns an accurate child node.
          * @param {Node} e The element to evaluate.
          * @param {int} [i] The child node index, default is 0.
          * @return {Node} The actual child node.
          *
          * @static
          * @function
          * @memberof Util
          * @name gc
          * @fullname Get Child Node
          */
         gc : function (e, i) {
             i = i || 0;
             var j = -1;

             if (!e.childNodes[i]) {
                 return null;
             }

             e = e.childNodes[0];
             while (e && j < i) {
                 if (e.nodeType === 1) {
                     j++;
                     if (j === i) {
                         break;
                     }
                 }
                 e = this.gns(e);
             }
             return e;
         },

         /**
          * For a given node, returns a list of children of NODETYPE 1, (Element).
          * @param {Node} e The node to evaluate.
          * @return {array} A collection of child nodes.
          *
          * @static
          * @function
          * @memberof Util
          * @name gcs
          * @fullname Get All Child Nodes
          */
         gcs : function (e) {

             var r = [], es = e.childNodes;
             for (var i = 0; i < es.length; i++) {
                 var x = es[i];
                 if (x.nodeType === 1) {
                     r.push(x);
                 }
             }
             return r;
         },

         /**
          * Returns an accurate next sibling node; Some browsers will return a Text Node.
          * @param {Node} e The element to evaluate.
          * @return {Node} The actual next sibling node.
          *
          * @static
          * @function
          * @memberof Util
          * @name gns
          * @fullname Get Next True Sibling
          */
         gns : function (e) {
			if (!e) {
				return null;
			}
             var a = e.nextSibling;
             while (a && a.nodeType !== 1) {
                 a = a.nextSibling;
             }
             return a;
         },

         /**
          * Returns an accurate previous sibling node; Some browsers will return a Text Node.
          * @param {Node} e The element to evaluate.
          * @return {Node} The actual previous sibling node.
          *
          * @static
          * @function
          * @memberof Util
          * @name gps
          * @fullname Get Previous True Sibling
          */
         gps : function (e) {
             var a = e.previousSibling;
             while (a && a.nodeType !== 1) {
                 a = a.previousSibling;
             }
             return a;
         },

         /**
          * Appends a child to the specified node.
          * @param {Node} e The element to append.
          * @param {Node} p The new parent node.
          * @return {Node} The appended element.
          *
          * @static
          * @function
          * @memberof Util
          * @name ac
          * @fullname Append Child
          */
         ac : function (e, p) {
             p.appendChild(e);
             return e;
         },

         /**
          * Insert a node after a specified node.
          * @param {Node} nn The new node to insert.
          * @param {Node} rn The reference node for insertion.
          *
          * @static
          * @function
          * @memberof Util
          * @name ia
          * @fullname Insert After
          */
         ia : function (nn, rn) {
             var p = Util.gp(rn), n = Util.gns(rn);
             if (n) {
                 p.insertBefore(nn, n);
             }
             else {
                 Util.ac(nn, p);
             }
         },

         /**
          * Adds a Javscript event to the given element with full browser compatiblity and plugs for any memory leaks.
          * @param {Node} o The object receiving the event.
          * @param {String} e The event name to attach.
          * @param {Function} f The function to run when the event is invoked.
          *
          * @static
          * @function
          * @memberof Util
          * @name addEvent
          * @fullname Add Javascript Event
          */
         addEvent : function (o, e, f) {

             function ae(obj, evt, fnc) {
                 if (!obj.myEvents) {
                     obj.myEvents = {};
                 }

                 if (!obj.myEvents[evt]) {
                     obj.myEvents[evt] = [];
                 }

                 var evts = obj.myEvents[evt];
                 evts[evts.length] = fnc;
             }

             function fe(obj, evt) {

                 if (!obj || !obj.myEvents || !obj.myEvents[evt]) {
                     return;
                 }

                 var evts = obj.myEvents[evt];

                 for (var i = 0, len = evts.length; i < len; i++) {
                     evts[i]();
                 }
             }

             if (o.addEventListener) {
                 o.addEventListener(e, f, false);
                 Util.EventCache.add(o, e, f);
             }
             else if (o.attachEvent) {
                 o["e" + e + f] = f;
                 o[e + f] = function () {
                     o["e" + e + f](window.event);
                 };
                 o.attachEvent("on" + e, o[e + f]);
                 Util.EventCache.add(o, e, f);
             }
             else {
                 ae(o, e, f);
                 o['on' + e] = function () {
                     fe(o, e);
                 };
             }
         },

         /**
          * Remove a Javscript event from the given element with full browser compatiblity and plugs for any memory leaks.
          * @param {Node} o The object honoring the event.
          * @param {String} e The event name.
          * @param {Function} f The function to remove.
          *
          * @static
          * @function
          * @memberof Util
          * @name removeEvent
          * @fullname Remove Javascript Event
          */
         removeEvent : function (o, e, f) {
             Util.EventCache.remove(o, e, f);
         },

         /**
         * Uses the native browser window object to create a new window.
         * <p>
         * <strong>NOTE:</strong> This method will utilize DOM methodology only <em>truly</em> supported by desktop
         * browsers. While some mobile browsers may allow this call, most will not. Use with caution, in specific use
         * cases.
         * </p>
         *
         * @param {String} u The url of the popup to open.
         * @param {String} n The name of the popup window.
         * @param {Object} [o The object params. If an object is not provided, the browser defaults will be used.
         * @param {String} [o.lb]  Include location bar, (default is true).
         * @param {String} [o.mb] Include menu bar, (default is true).
         * @param {String} [o.rz] Allow resize, (default is true).
         * @param {String} [o.scb] Include scrollbars, (default is true).
         * @param {String} [o.stb] Include status bar, (default is true).
         * @param {String} [o.tb] Include toolbar, (default is true).
         * @param {int} [o.w] The value for the width of the popup window.
         * @param {int} [o.h] The value for the height of the popup window.
         * @param {int} [o.tp] The value for top. (NOT SUPPORTED YET)
         * @param {int} [o.lft] The value for the left position of the popup. (NOT SUPPORTED YET)
         * @param {int} [o.sx] The screen x value. (NOT SUPPORTED YET)
         * @param {int} [o.sy] The screen y value. (NOT SUPPORTED YET)
         * @param {String} [o.dp] The value for the dependent popup property (yes or no). (NOT SUPPORTED YET)
         * @param {String} [o.dr] The value for the directories property (yes or no). (NOT SUPPORTED YET)
         * @param {String} [o.fs] The value for the fullscreen property (yes or no). (NOT SUPPORTED YET)
         * @return <code>True</code> if the window popup was successful, <code>false</code> otherwise or if the client
         * does not support popup windows.
         *
         * @static
         * @function
         * @memberof Util
         * @name popup
         * @fullname Popup New Window
         */
         popup : function (u, n, o) {
             if (!window.open) {
                 return false;
             }

             var d = {
                 w : screen.width,
                 h : screen.height,
                 rz : true,
                 mb : true,
                 scb : true,
                 stb : true,
                 tb : true,
                 lb : true,
                 tp : null,
                 lft : null,
                 sx : null,
                 sy : null,
                 dp : "no",
                 dr : "no",
                 fs : "no"
             };

             function f(n, v)
             {
                 if (!v) {
                     return "";
                 }
                 return n + '=' + v + ',';
             }

             function fs() {
                 o = o || {};
                 var p, n = {};
                 for (p in d) {
                     if (p) {
                         n[p] = o[p] !== undefined ? o[p] : d[p];
                     }
                 }
                 return n;
             }

             o = fs();
             var p = f("dependent", o.dp) + f("directories", o.dr) + f("fullscreen", o.fs) + f("location", o.lb ? 1 : 0) + f("menubar", o.mb) + f("resizable", o.rz ? 1 : 0) + f("scrollbars", o.scb ? 1 : 0) + f("status", o.stb ? 1 : 0) + f("toolbar", o.tb ? 1 : 0) + f("top", o.tp) + f("left", o.lft) + f("width", o.w) + f("height", o.h) + f("screenX", o.sx) + f("screenY", o.sy);
             p = p.substring(0, p.length - 1);
             var nw = window.open(u, n, p);
             window.blur();

             if (nw.focus) {
                 nw.focus();
             }

             return true;
         },
         Convert : {},
         Cookie : {},
         Detect : {},
         i18n : {},
         Load : {},
         Pos : {},
         Style : {},
         Timeout : {}
     };
 }();

 /**
  * Insert a node after a specified node.
  * @param {Node} nn The new node to insert.
  * @param {Node} rn The reference node for insertion.
  *
  * @deprecated
  * @static
  * @global
  */
 function insertAfter(nn, rn) {
     Util.ia(nn, rn);
 }

 Util.addEvent(window, 'unload', Util.EventCache.flush);

 /*extern _gbt, Util*/

 /**
 * @fileOverview
 *
 * <h1>CSS Utility module and namespace</h1>
 * <p>This module assists with managing CSS selectors and classnames.</p>
 * <h2>Usage</h2>
 * <p>Import this file <em>after</em> util.core.js.</p>
 */

 /**
 * Style Utility methods.
 * @namespace Util.Style
 * @global
 * @static
 */
 Util.Style = function() {

     return {
         /**
         * Indicates if an element has been applied with a single given CSS Classname.
         * @param {HTMLElement} e  - The element to evaluate.
         * @param {String} c - The single CSS Classname to check.
         * @return {Boolean} True if the classname contains the given class, false otherwise.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name ccss
         * @fullname Contains CSS Class
         */
         ccss: function(e, c) {
             if (typeof (e.className) === 'undefined' || !e.className || !e.getAttribute("class")) {
                 return false;
             }
             var a = e.getAttribute('class').split(' ');
             for (var i = 0, b = a.length; i < b; i++) {
                 if (a[i] === c) {
                     return true;
                 }
             }
             return false;
         },

         /**
         * Adds a given CSS Classname to the given element.
         * @param {Node} e The element to evaluate.
         * @param {String} c The classname to apply.
         * @return {Node} The element with the CSS Classname applied.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name acss
         * @fullname Add CSS Class
         */
         acss: function(e, c) {
             if (this.ccss(e, c)) {
                 return e;
             }
             e.className = (e.className ? e.className + ' ' : '') + c;
             return e;
         },

         /**
         * Removes a given CSS Classname from the given element.
         * @param {Node} e The element to evaluate.
         * @param {String} c The classname to remove.
         * @return {Node} The element, with the CSS Classname removed.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name rcss
         * @fullname Remove CSS Class
         */
         rcss: function(e, c) {
             if (!this.ccss(e, c)) {
                 return e;
             }
             var a = e.className.split(' '), d = "";
             for (var i = 0, b = a.length; i < b; i++) {
                 var f = a[i];
                 if (f !== c) {
                     d += d.length > 0 ? (" " + f) : f;
                 }
             }
             e.className = d;
             return e;
         },

         /**
         * Toggles a given CSS Classname on a given element.
         * @param {Node} e The element to evaluate.
         * @param {String} c The classname to toggle.
         * @return {Boolean} True if the element now contains the classname, false if it was removed.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name tcss
         * @fullname Toggle CSS Class
         */
         tcss: function(e, c) {
             if (this.ccss(e, c)) {
                 this.rcss(e, c);
                 return false;
             }
             else {
                 this.acss(e, c);
                 return true;
             }
         },

         /**
         * Clears any opacity setting back to whatever is defined in CSS.
         * @param {Node} e The element whose opacity setting should be reset.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name co
         * @fullname Clear Opacity
         */
         co: function(e) {
             e.style.MozOpacity = "";
             e.style.opacity = "";
             e.style.filter = "";
         },

         /**
         * Returns an array of elements with the designated classname.
         * @param {String} c The CSS classname.
         * @param {Node} [e] The parent element to search within, defaults to document.
         * @param {String} [t] The tagname to scope the results, defaults to all tags.
         *
         * @static
         * @function
         * @memberof Util.Style
         * @name g
         * @fullname Get Elements by Classname
         */
         g: function(c, e, t) {
             e = e || document;
             t = t || '*';
             var ns = [], es = _gbt(t, e), l = es.length;
             for (var i = 0, j = 0; i < l; i++) {
                 if (this.ccss(es[i], c)) {
                     ns[j] = es[i];
                     j++;
                 }
             }
             return ns;
         }
     };
 } ();

 Util.Pos = function () {

    return {
        /**
         * Returns the actual scrolled offset within the window.
         * @return {array} A Javascript array containing the distance scrolled within the window as [top distance, left distance].
         *
         * @static
         * @function
         * @memberof Util.Pos
         * @name gso
         * @fullname Get Scrolled Offset
         */
        gso : function () {
            var d = document, b = d.body, w = window, e = d.documentElement, et = e.scrollTop, bt = b.scrollTop, el = e.scrollLeft, bl = b.scrollLeft;
            if (typeof w.pageYOffset === "number") {
                return [w.pageYOffset, w.pageXOffset];
            }
            if (typeof et === "number") {
                if (bt > et || bl > el) {
                    return [bt, bl];
                }
                return [et, el];
            }
            return [bt, bl];
        },

        /**
         * Returns an array of offset parameters for a given element.
         * @param {Node} e The element to evaluate. If null, undefined or invalid, zeroed offsets are returned.
         * @return {array} A Javascript array of the given element's offsets, relative to any scrolled distance within the window,
         * indexed as [top, left, height, width].  The array will be zeroed out if the element provided is invalid.
         *
         * @static
         * @function
         * @memberof Util.Pos
         * @name goo
         * @fullname Get Object Offsets
         */
        goo : function (e) {
            if (e) {
                return [e.offsetTop, e.offsetLeft, e.offsetHeight, e.offsetWidth];
            }
            return [0, 0, 0, 0];
        },

        /**
         * Returns the true position of a given object by parsing the offset tree.
         * @param {Node} e The DOM element.
         * @return {array} A Javascript array containing the "true" top and left of the given element indexed as [top, left].  The
         * array will be zeroed out if the element provided is invalid.
         *
         * @static
         * @function
         * @memberof Util.Pos
         * @name gop
         * @fullname Get Object Position
         */
        gop : function (e) {
            var l = 0, t = 0;
            if (e.offsetParent)
            {
                l = e.offsetLeft;
                t = e.offsetTop;
                e = e.offsetParent;
                while (e)
                {
                    l += e.offsetLeft;
                    t += e.offsetTop;
                    e = e.offsetParent;
                }
            }
            return [t, l];
        },

        /**
         * Returns an array of size characteristics for the viewport.
         * @return {array} The size of the viewport as a Javascript array, indexed as [height, width].
         *
         * @static
         * @function
         * @memberof Util.Pos
         * @name gvs
         * @fullname Get Viewport Size
         */
        gvs : function () {
            var n = window, d = document, b = d.body, e = d.documentElement;
             // the more standards compliant browsers (mozilla/netscape/opera/IE7) use window.innerWidth and window.innerHeight
            if (typeof n.innerWidth !== 'undefined') {
                return [n.innerHeight, n.innerWidth];
            }
            // IE6 in standards compliant mode (i.e. with a valid doctype as the first line in the document)
            else if (typeof e !== 'undefined' && typeof e.clientWidth !== 'undefined' && e.clientWidth !== 0) {
                return [e.clientHeight, e.clientWidth];
            }
            // older versions of IE
            else {
                return [b.clientHeight, b.clientWidth];
            }
        }
    };
}();

//////end healthe library

// The following functions were copied from Util.Core, a module within the Healthe Widget Library
// http://prototyping.healthe.cerner.corp/repo/release/site/com.cerner.healthe.navigator/healthe-widget-library/1.2/jsdoc/

function getPosition(e) {
    e = e || window.event;
    var cursor = { x: 0, y: 0 };
    if (e.pageX || e.pageY) {
        cursor.x = e.pageX;
        cursor.y = e.pageY;
    }
    else {
        var de = document.documentElement;
        var b = document.body;
        cursor.x = e.clientX +
                               (de.scrollLeft || b.scrollLeft) - (de.clientLeft || 0);
        cursor.y = e.clientY +
                               (de.scrollTop || b.scrollTop) - (de.clientTop || 0);
    }
    return cursor;
}

// The following functions were copied from Util.Style, a module within the Healthe Widget Library
// http://prototyping.healthe.cerner.corp/repo/release/site/com.cerner.healthe.navigator/healthe-widget-library/1.2/jsdoc/

function gvs() {
    var n = window, d = document, b = d.body, e = d.documentElement;
    // the more standards compliant browsers (mozilla/netscape/opera/IE7) use window.innerWidth and window.innerHeight
    if (typeof n.innerWidth !== 'undefined') {
        return [n.innerHeight, n.innerWidth];
    }
    // IE6 in standards compliant mode (i.e. with a valid doctype as the first line in the document)
    else if (typeof e !== 'undefined' && typeof e.clientWidth !== 'undefined' && e.clientWidth !== 0) {
        return [e.clientHeight, e.clientWidth];
    }
    // older versions of IE
    else {
        return [b.clientHeight, b.clientWidth];
    }
}

function gso() {
    var d = document, b = d.body, w = window, e = d.documentElement, et = e.scrollTop, bt = b.scrollTop, el = e.scrollLeft, bl = b.scrollLeft;
    if (typeof w.pageYOffset === "number") {
        return [w.pageYOffset, w.pageXOffset];
    }
    if (typeof et === "number") {
        if (bt > et || bl > el) {
            return [bt, bl];
        }
        return [et, el];
    }
    return [bt, bl];
}
/* eslint eqeqeq: 0 */
/* globals MPageComponent */
/**
 * Project: mp_component_defs
 * Version 1.0.0
 * Released 7/6/2010
 * @author Greg Howdeshell
 */

Function.prototype.method = function(name, func) {	//eslint-disable-line no-extend-native
    this.prototype[name] = func;
    return this;
};

Function.method("inherits", function(Parent) {
    var d = {},
        p = (this.prototype = new Parent());
    this.method("uber", function uber(name) {
        if (!(name in d)) {
            d[name] = 0;
        }
        var f, r, t = d[name],
            v = Parent.prototype;
        if (t) {
            while (t) {
                v = v.constructor.prototype;
                t -= 1;
            }
            f = v[name];
        }
        else {
            f = p[name];
            if (f == this[name]) {
                f = v[name];
            }
        }
        d[name] += 1;
        r = f.apply(this, Array.prototype.slice.apply(arguments, [1]));
        d[name] -= 1;
        return r;
    });
    return this;
});

/**
 * Creates getters and setters for the class based on attributeName.
 *
 * Example:
 *
 * MyClass.createAttribute("Color", "blue");
 *
 * The call above will create this.getColor() and this.setColor(value).
 * A member variable mColor will also be created, with the default value of
 * "blue".
 *
 */
Function.prototype.createAttribute = function(attributeName, defaultValue) {	//eslint-disable-line no-extend-native
    this.prototype["m_" + attributeName] = defaultValue;

    this.prototype["get" + attributeName] = function() {
        return this["m_" + attributeName];
    };

    this.prototype["set" + attributeName] = function(value) {
        this["m_" + attributeName] = value;
    };
};

function MPageComponentInteractive() {
    this.m_DocPrivObj = null;
    this.m_DocPrivMask = 0;

    MPageComponentInteractive.method("setPrivObj", function(value) {
        this.m_DocPrivObj = value;
    });


    MPageComponentInteractive.method("getDocPrivObj", function() {
        return (this.m_DocPrivObj);
    });


    MPageComponentInteractive.method("setIsCompViewable", function(value) {
        this.m_isCompViewable = value;
    });


    MPageComponentInteractive.method("setIsCompAddable", function(value) {
        this.m_isCompAddable = value;
    });


    MPageComponentInteractive.method("setIsCompModifiable", function(value) {
        this.m_isCompModifiable = value;
    });


    MPageComponentInteractive.method("setIsCompUnchartable", function(value) {
        this.m_isCompUnchartable = value;
    });


    MPageComponentInteractive.method("setIsCompSignable", function(value) {
        this.m_isCompSignable = value;
    });


    MPageComponentInteractive.method("getCompPrivMask", function() {
        var VIEW_MASK = parseInt("1", 2);
        var ADD_MASK = parseInt("10", 2);
        var MODIFY_MASK = parseInt("100", 2);
        var UNCHART_MASK = parseInt("1000", 2);
        var SIGN_MASK = parseInt("10000", 2);
        var privMask = 0;
        privMask = ((this.m_isCompViewable) ? VIEW_MASK : 0) | //Add View Privs if true
            ((this.m_isCompAddable) ? ADD_MASK : 0) | //Add Add Privs if true
            ((this.m_isCompModifiable) ? MODIFY_MASK : 0) | //Add Mod Privs if true
            ((this.m_isCompUnchartable) ? UNCHART_MASK : 0) | //Add Uchart Privs if true
            ((this.m_isCompSignable) ? SIGN_MASK : 0);
        //Add Sign Privs if true

        return (privMask);
    });


    MPageComponentInteractive.method("getPrivFromArray", function(eventCd, array) {
        var i = array.length;
        while (i--) {
            if (eventCd == array[i].EVENT_CD) {
                return (true);
            }
        }
        return (false);
    });


    MPageComponentInteractive.method("isResultEventCodeSignable", function(eventCd) {
        if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
                .EVENT_PRIVILEGES.VIEW_RESULTS.GRANTED.EVENT_CODES)) {
            return (true);
        }
        else {
            return (false);
        }
    });


    MPageComponentInteractive.method("isResultEventCodeAddable", function(eventCd) {
        if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
                .EVENT_PRIVILEGES.ADD_DOCUMENTATION.GRANTED.EVENT_CODES)) {
            return (true);
        }
        else {
            return (false);
        }
    });


    MPageComponentInteractive.method("isResultEventCodeModifiable", function(eventCd) {
        if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
                .EVENT_PRIVILEGES.MODIFY_DOCUMENTATION.GRANTED.EVENT_CODES)) {
            return (true);
        }
        else {
            return (false);
        }
    });


    MPageComponentInteractive.method("isResultEventCodeUnchartable", function(eventCd) {
        if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
                .EVENT_PRIVILEGES.UNCHART_DOCUMENTATION.GRANTED.EVENT_CODES)) {
            return (true);
        }
        else {
            return (false);
        }
    });


    MPageComponentInteractive.method("isResultEventCodeSignable", function(eventCd) {
        if (this.getPrivFromArray(eventCd, this.m_DocPrivObj.getResponse()
                .EVENT_PRIVILEGES.SIGN_DOCUMENTATION.GRANTED.EVENT_CODES)) {
            return (true);
        }
        else {
            return (false);
        }
    });


    MPageComponentInteractive.method("getEventCdPrivs", function(component, eventArr) {
        var self = this;
        var criterion = this.getCriterion();
        var paramEventCd = MP_Util.CreateParamArray(eventArr, 1);	//eslint-disable-line new-cap
        var paramPrivMask = this.getCompPrivMask();
        var sendAr = ["^MINE^", criterion.provider_id + ".0", paramEventCd, "0.0", paramPrivMask, criterion.ppr_cd + ".0"];
        var request = new MP_Core.ScriptRequest(this, "ENG:MPG.MPCINTERACTIVE - Get Doc prefs");

        request.setArtifactInfo({
            artifactId: "mpage-component-defs",
            functionName: "getEventCdPrivs"
        });

        request.setParameters(sendAr);
        request.setName("getCompPrivs");
        request.setProgramName("MP_GET_PRIVS_BY_CODE_JSON");
        request.setAsync(false);
        MP_Core.XMLCCLRequestCallBack(component, request, function(replyObj){	//eslint-disable-line new-cap
            self.processEventCdReply(replyObj);
        });
    });


    MPageComponentInteractive.method("processEventCdReply", function(reply) {
        this.m_DocPrivObj = reply;
    });
}

MPageComponentInteractive.inherits(MPageComponent);

/*
 * The MPage grouper provides a means in which to group MPageGroups together into an
 * array for results such as Blood Pressure where each group is a sequence of events.
 */
function MPageGrouper() {
    this.m_groups = null;
    MPageGrouper.method("setGroups", function(value) {
        this.m_groups = value;
    });


    MPageGrouper.method("getGroups", function() {
        return this.m_groups;
    });


    MPageGrouper.method("addGroup", function(value) {
        if (this.m_groups === null) {
            this.m_groups = [];
        }
        this.m_groups.push(value);
    });
}

MPageGrouper.inherits(MPageGroup);

function MPageGroup() {
    this.m_groupName = "";
    this.m_groupSeq = 0;
    this.m_groupId = 0;
    MPageGroup.method("setGroupId", function(value) {
        this.m_groupId = value;
    });


    MPageGroup.method("getGroupId", function() {
        return this.m_groupId;
    });


    MPageGroup.method("setGroupName", function(value) {
        this.m_groupName = value;
    });


    MPageGroup.method("getGroupName", function() {
        return this.m_groupName;
    });


    MPageGroup.method("setSequence", function(value) {
        this.m_groupSeq = value;
    });


    MPageGroup.method("getSequence", function() {
        return this.m_groupSeq;
    });
}

function MPageEventSetGroup() {
    this.m_eventSets = null;
    this.m_isSequenced = false;
    MPageEventSetGroup.method("isSequenced", function() {
        return this.m_isSequenced;
    });


    MPageEventSetGroup.method("setSequenced", function(value) {
        this.m_isSequenced = value;
    });


    MPageEventSetGroup.method("getEventSets", function() {
        return this.m_eventSets;
    });


    MPageEventSetGroup.method("setEventSets", function(value) {
        this.m_eventSets = value;
    });


    MPageEventSetGroup.method("addEventSet", function(value) {
        if (this.m_eventSets === null) {
            this.m_eventSets = [];
        }
        this.m_eventSets.push(value);
    });
}

MPageEventSetGroup.inherits(MPageGroup);

function MPageCatalogCodeGroup() {
    this.m_catalogCodes = null;
    this.m_isSequenced = false;
    MPageCatalogCodeGroup.method("isSequenced", function() {
        return this.m_isSequenced;
    });


    MPageCatalogCodeGroup.method("setSequenced", function(value) {
        this.m_isSequenced = value;
    });


    MPageCatalogCodeGroup.method("getCatalogCodes", function() {
        return this.m_catalogCodes;
    });


    MPageCatalogCodeGroup.method("setCatalogCodes", function(value) {
        this.m_catalogCodes = value;
    });


    MPageCatalogCodeGroup.method("addCatalogCode", function(value) {
        if (this.m_catalogCodes === null) {
            this.m_catalogCodes = [];
        }
        this.m_catalogCodes.push(value);
    });

}

MPageCatalogCodeGroup.inherits(MPageGroup);

function MPageEventCodeGroup() {
    this.m_eventCodes = null;
    this.m_isSequenced = false;
    MPageEventCodeGroup.method("isSequenced", function() {
        return this.m_isSequenced;
    });


    MPageEventCodeGroup.method("setSequenced", function(value) {
        this.m_isSequenced = value;
    });


    MPageEventCodeGroup.method("getEventCodes", function() {
        return this.m_eventCodes;
    });


    MPageEventCodeGroup.method("setEventCodes", function(value) {
        this.m_eventCodes = value;
    });


    MPageEventCodeGroup.method("addEventCode", function(value) {
        if (this.m_eventCodes === null) {
            this.m_eventCodes = [];
        }
        this.m_eventCodes.push(value);
    });

}

MPageEventCodeGroup.inherits(MPageGroup);

function MPageCodeValueGroup() {
    this.m_codes = null;
    MPageCodeValueGroup.method("getCodes", function() {
        return this.m_codes;
    });


    MPageCodeValueGroup.method("setCodes", function(value) {
        this.m_codes = value;
    });


    MPageCodeValueGroup.method("addCode", function(value) {
        if (this.m_codes === null) {
            this.m_codes = [];
        }
        this.m_codes.push(value);
    });

}

MPageCodeValueGroup.inherits(MPageGroup);

//The MPageSequenceGroup is a grouper of items such as filter means, event codes, event sets, etc.
function MPageSequenceGroup() {
    this.m_items = null;
    this.m_mapItems = null;
    this.m_isMultiType = false;

    MPageSequenceGroup.method("getItems", function() {
        return this.m_items;
    });


    MPageSequenceGroup.method("setItems", function(value) {
        this.m_items = value;
    });


    MPageSequenceGroup.method("addItem", function(value) {
        if (this.m_items === null) {
            this.m_items = [];
        }
        this.m_items.push(value);
    });


    MPageSequenceGroup.method("setMultiValue", function(value) {
        this.m_isMultiType = value;
    });


    MPageSequenceGroup.method("isMultiValue", function() {
        return (this.m_isMultiType);
    });


    MPageSequenceGroup.method("getMapItems", function() {
        return this.m_mapItems;
    });


    MPageSequenceGroup.method("setMapItems", function(value) {
        this.m_mapItems = value;
    });

}

MPageSequenceGroup.inherits(MPageGroup);

function MPageGroupValue() {
    this.m_description = "";
    this.m_id = 0.0;
    this.m_meaning = "";
    this.m_name = "";
    this.m_qualifierFlag = 0;
    this.m_sequence = 0;
    this.m_valSequence = 0;
    this.m_valTypeFlag = 0;
    this.m_parentId = 0.0;
}

/**
 * returns parent_entity_id2 value.
 * @returns {number} - m_parentId 
 */
MPageGroupValue.prototype.getParentId = function() {
    return this.m_parentId;
};

/**
 * Set parent_entity_id2 value
 * @param {number} id - parent_entity_id2 value from the Bedrock
 * @returns {undefined} This function does not return a value
 */
MPageGroupValue.prototype.setParentId = function(id) {
    this.m_parentId = id;
};

MPageGroupValue.prototype.getId = function() {
    return this.m_id;
};

MPageGroupValue.prototype.setId = function(id) {
    this.m_id = id;
};

MPageGroupValue.prototype.getName = function() {
    return this.m_name;
};

MPageGroupValue.prototype.setName = function(name) {
    this.m_name = name;
};

MPageGroupValue.prototype.getSequence = function() {
    return this.m_sequence;
};

MPageGroupValue.prototype.setSequence = function(sequence) {
    this.m_sequence = sequence;
};

MPageGroupValue.prototype.getDescription = function() {
    return this.m_description;
};

MPageGroupValue.prototype.setDescription = function(description) {
    this.m_description = description;
};

MPageGroupValue.prototype.getMeaning = function() {
    return this.m_meaning;
};

MPageGroupValue.prototype.setMeaning = function(meaning) {
    this.m_meaning = meaning;
};

MPageGroupValue.prototype.getValueSequence = function() {
    return this.m_valSequence;
};

MPageGroupValue.prototype.setValueSequence = function(valSequence) {
    this.m_valSequence = valSequence;
};

MPageGroupValue.prototype.getValueTypeFlag = function() {
    return this.m_valTypeFlag;
};

MPageGroupValue.prototype.setValueTypeFlag = function(valTypeFlag) {
    this.m_valTypeFlag = valTypeFlag;
};

MPageGroupValue.prototype.getQualifierFlag = function() {
    return this.m_qualifierFlag;
};

MPageGroupValue.prototype.setQualifierFlag = function(qualFlag) {
    this.m_qualifierFlag = qualFlag;
};


/*eslint-disable no-unused-vars*/
var CERN_COMPONENT_TYPE_SUMMARY = 1;
var CERN_COMPONENT_TYPE_WORKFLOW = 2;	//eslint-disable-line no-redeclare
/*eslint-enable no-unused-vars*/

function ComponentStyle() {	//eslint-disable-line new-cap, no-unused-vars, no-redeclare
    this.m_nameSpace = "";
    this.m_id = "";
    this.m_className = "section";
    this.m_contentId = "";
    this.m_contentClass = "sec-content";
    this.m_headerClass = "sec-hd";
    this.m_headToggle = "sec-hd-tgl";
    this.m_secTitle = "sec-title";
    this.m_aLink = "";
    this.m_secTotal = "sec-total";
    this.m_info = "";
    this.m_subSecHeaderClass = "sub-sec-hd";
    this.m_subSecTitleClass = "sub-sec-title";
    this.m_subSecContentClass = "sub-sec-content";
    this.m_contentBodyClass = "content-body";
    this.m_searchBoxDiv = "search-box-div";
    this.m_subTitleDisp = "sub-title-disp";
    // If a component may be on a page multiple times, a unique identifier such as the component id will need to be set on the style
    // The unique identifier is only utilized on styles that are placeholders to be replaced at a later point.
    this.m_componentId = 0;
    this.m_color = "";
    //This is the component type which determines how it will be rendered in the View
    this.m_componentType = null;

    /**
     * Initializes the component style with the provided namespace to utilize throughout the component.
     * @param {Object} value
     */
    ComponentStyle.method("initByNamespace", function(value) {
        this.m_nameSpace = value;
        this.m_id = value;
        this.m_className += (" " + value + "-sec");
        this.m_contentId = value + "Content";
        this.m_aLink = value + "Link";
        this.m_info = value + "-info";
    });


    ComponentStyle.method("getNameSpace", function() {
        return this.m_nameSpace;
    });


    ComponentStyle.method("getId", function() {
        return this.m_id + this.m_componentId;
    });


    ComponentStyle.method("getClassName", function() {
        return this.m_className;
    });


    ComponentStyle.method("getColor", function() {
        return this.m_color;
    });


    ComponentStyle.method("getContentId", function() {
        return this.m_contentId + this.m_componentId;
    });


    ComponentStyle.method("getContentBodyClass", function() {
        return this.m_contentBodyClass;
    });


    ComponentStyle.method("getContentClass", function() {
        return this.m_contentClass;
    });


    ComponentStyle.method("getHeaderClass", function() {
        return this.m_headerClass;
    });


    ComponentStyle.method("getHeaderToggle", function() {
        return this.m_headToggle;
    });


    ComponentStyle.method("getTitle", function() {
        return this.m_secTitle;
    });


    ComponentStyle.method("getLink", function() {
        return this.m_aLink;
    });


    ComponentStyle.method("getTotal", function() {
        return this.m_secTotal;
    });


    ComponentStyle.method("getInfo", function() {
        return this.m_info;
    });


    ComponentStyle.method("getSearchBoxDiv", function() {
        return this.m_searchBoxDiv;
    });


    ComponentStyle.method("getSubSecContentClass", function() {
        return this.m_subSecContentClass;
    });


    ComponentStyle.method("getSubSecContentClass", function() {
        return this.m_subSecContentClass;
    });


    ComponentStyle.method("getSubSecHeaderClass", function() {
        return this.m_subSecHeaderClass;
    });


    ComponentStyle.method("getSubSecTitleClass", function() {
        return this.m_subSecTitleClass;
    });


    ComponentStyle.method("getSubTitleDisp", function() {
        return this.m_subTitleDisp;
    });


    ComponentStyle.method("getComponentType", function() {
        return this.m_componentType;
    });


    ComponentStyle.method("setComponentId", function(value) {
        this.m_componentId = value;
    });


    ComponentStyle.method("setNameSpace", function(value) {
        this.m_nameSpace = value;
    });


    ComponentStyle.method("setId", function(value) {
        this.m_id = value;
    });


    ComponentStyle.method("setClassName", function(value) {
        this.m_className = value;
    });


    ComponentStyle.method("setColor", function(value) {
        this.m_color = value;
        this.setClassName(this.getClassName() + " " + value);
    });


    ComponentStyle.method("setContextId", function(value) {
        this.m_contentId = value;
    });


    ComponentStyle.method("setContentBodyClass", function(value) {
        this.m_contentBodyClass = value;
    });


    ComponentStyle.method("setContentClass", function(value) {
        this.m_contentClass = value;
    });


    ComponentStyle.method("setContextClass", function(value) {
        this.m_contentClass = value;
    });


    ComponentStyle.method("setHeaderClass", function(value) {
        this.m_headerClass = value;
    });


    ComponentStyle.method("setHeaderToggle", function(value) {
        this.m_headToggle = value;
    });


    ComponentStyle.method("setSearchBoxDiv", function(value) {
        this.m_searchBoxDiv = value;
    });


    ComponentStyle.method("setSubSecContentClass", function(value) {
        this.m_subSecContentClass = value;
    });


    ComponentStyle.method("setSubSecHeaderClass", function(value) {
        this.m_subSecHeaderClass = value;
    });


    ComponentStyle.method("setSubSecTitleClass", function(value) {
        this.m_subSecTitleClass = value;
    });


    ComponentStyle.method("setSubTitleDisp", function(value) {
        this.m_subTitleDisp = value;
    });


    ComponentStyle.method("setTitle", function(value) {
        this.m_secTitle = value;
    });


    ComponentStyle.method("setLink", function(value) {
        this.m_aLink = value;
    });


    ComponentStyle.method("setTotal", function(value) {
        this.m_secTotal = value;
    });


    ComponentStyle.method("setInfo", function(value) {
        this.m_info = value;
    });


    ComponentStyle.method("setComponentType", function(value) {
        this.m_componentType = value;
    });
}

/**
 * Sorts the MPage Components by group sequence, then by column, and lastly by row.
 * @param {MPageComponent} c1 Component one to compare against
 * @param {MPageComponent} c2 Component two to compare against
 * @returns {Short} Returns the sequence in which the components should display.
 *
 * @author Greg Howdeshell
 */
function SortMPageComponentRows(c1, c2) {
    if (c1.getSequence() < c2.getSequence()) {
        return -1;
    }
    if (c1.getSequence() > c2.getSequence()) {
        return 1;
    }
    return 0;
}

function SortMPageComponentCols(c1, c2) {
    if (c1.getColumn() < c2.getColumn()) {
        return -1;
    }
    if (c1.getColumn() > c2.getColumn()) {
        return 1;
    }
    return SortMPageComponentRows(c1, c2);	//eslint-disable-line new-cap
}

function SortMPageComponents(c1, c2) {	//eslint-disable-line no-unused-vars
    if (c1.getPageGroupSequence() < c2.getPageGroupSequence()) {
        return -1;
    }
    if (c1.getPageGroupSequence() > c2.getPageGroupSequence()) {
        return 1;
    }
    return SortMPageComponentCols(c1, c2);	//eslint-disable-line new-cap
}
/*globals MP_Timezone, SortMPageComponents, MD_reachViewerDialog, AutoSuggestControl, ThemeSelector, hs,
MessageModal, ErrorModal, WarningModal, InfoModal, BusyModal,CapabilityTimer,MP_PendingData, MPageFusion, log,
GetCookieValueUtil, ReportLauncher */

/*
 The scope of an MPage object and Components are during rendering of the page.  However,
 once the page has been rendered these items are lost.  Because there is a need to refresh
 components, the components on a 'page' must be globally stored to allow for refreshing of data.
 */
var CERN_EventListener = null; //eslint-disable-line no-redeclare, mp-camelcase
var CERN_MPageComponents = null;
//A global object which keeps a mapping of Report Means to the components which should be instantiated.
//Supporting functionality is located in the MP_Util namespace
var CERN_ObjectDefinitionMapping = {};
var CERN_BrowserDevInd = false; //eslint-disable-line no-redeclare
var CK_DATA = {};

var STR_PAD_LEFT = 1;
var STR_PAD_RIGHT = 2;
var STR_PAD_BOTH = 3;

/* If the browser does not define the addAll function for the Array */
if (!Array.prototype.addAll) {
    Array.prototype.addAll = function(v) { //eslint-disable-line no-extend-native
        if (v && v.length > 0) {
            for (var x = 0, xl = v.length; x < xl; x++) {
                this.push(v[ x ]);
            }
        }
    };
}

/**
 *  Since IE10 is the minimum browser version, we no longer need an implementation of Array.prototype.indexOf.
 *  This check is being left in place to allow SWx to quickly identify if the client does not have the
 *  proper version of IE installed on the Citrix Box.
 **/
if (!Array.prototype.indexOf) {
    throw new Error("Browser version does not contain an implementation of Array.prototype.indexOf");
}

/**
 *  Since IE10 is the minimum browser version, we no longer need an implementation of Function.prototype.bind.
 *  This check is being left in place to allow SWx to quickly identify if the client does not have the
 *  proper version of IE installed on the Citrix Box.
 **/
if (!Function.prototype.bind) {
    throw new Error("Browser version does not contain an implementation of Function.prototype.bind");
}

/**
 *  Since IE10 is the minimum browser version, we no longer need an implementation of document.getElementsByClassName.
 *  This check is being left in place to allow SWx to quickly identify if the client does not have the
 *  proper version of IE installed on the Citrix Box.
 **/
if (!document.getElementsByClassName) {
    throw new Error("Browser version does not contain an implementation of document.getElementsByClassName");
}

/**
 * this function populates an object, which is used to log into Splunk
 * @param {object} errorDetails - The object associated to the error that has occurred
 * @param {object} contextDetails - The context in which the error has occurred
 * @param {string} stackTrace - The stackTrace of the error occured
 * @returns {object} - remoteLogInfo object
 */
function populateRemoteLogInfoObject(errorDetails, contextDetails, stackTrace) {
    return {
        errorLevel: "Page Level Error",
        errorInfo: errorDetails,
        contextInfo: contextDetails,
        stackTrace: stackTrace
    };
}

/**
 * this function overrides the browsers error handling functionality so we can display a user friendly
 * rather than the browsers technical dialog.
 * @param {string} message - The message associated to the error that has occurred
 * @param {string} file - The file where the error has occurred
 * @param {number} lineNumber - The line number the error was thrown from
 * @param {number} columnNumber - The column number in the file where the error originated
 * @param {Error} error - The error that was intercepted by the window.onerror.
 * 		This parameter is defined in IE11+ and as such, must be ignored if
 * 		it is not defined.
 * @returns {boolean}
 */
window.onerror = function(message, file, lineNumber, columnNumber, error) {
    var errorModal = null;
    var refreshButton = null;
    var closeButton = null;
    var source = i18n.UNKNOWN;
    var criterionData = null;
    var categoryMean = null;
    var errorDetails = {
        errorMessage: message,
        line: lineNumber,
        columnNumber: columnNumber,
        // Trimming file name from file path
        file: file.search(/([a-zA-Z0-9-_]+\.js)|(\/group\?)/) !== -1 ? file.match(/([a-zA-Z0-9-_]+\.js)|(\/group\?)/)[0] : file
    };
    var contextDetails = null;
    //checking if the criterion is set(In some cases like setting invalid view point names, criterion is not set)
    if(typeof m_criterionJSON !== "undefined")
    {
        criterionData = CERN_Platform.getCriterion().CRITERION;
        categoryMean = criterionData.CATEGORY_MEAN;
        contextDetails = {
            VIEW: criterionData.CATEGORY_MEAN,
            VIEW_POINT: (typeof m_viewpointJSON !== "undefined" && m_viewpointJSON) ? JSON.parse(m_viewpointJSON).VP_INFO.VIEWPOINT_NAME : "",
            PERSON_ID: criterionData.PERSON_ID,
            ENCNTRS: criterionData.ENCNTRS,
            PRSNL_ID: criterionData.PRSNL_ID,
            POSITION_CD: criterionData.POSITION_CD,
            PPR_CD: criterionData.PPR_CD,
            LOGICAL_DOMAIN_ID: criterionData.LOGICAL_DOMAIN_ID,
            USER: criterionData.USERNAME,
            APP_NAME: criterionData.EXECUTABLE ? criterionData.EXECUTABLE.split(".")[0] : "",
            RELEASE_VERSION: criterionData.RELEASE_VERSION
        };
        if("WORKLIST_RELEASE_VERSION" in criterionData) {
            contextDetails.WORKLIST_RELEASE_VERSION = criterionData.WORKLIST_RELEASE_VERSION;
        }
    }
    // Accessing callee/caller is seen as potentially dangerous, so wrap it
    // in a try/catch block
    try {
        if (error && error.stack) {
            source = error.stack;
        } else {
            source = arguments.callee.caller.toString(); //eslint-disable-line no-caller
        }
    } catch (err) {
        //Intentionally empty catch
    }

    var localLogInfo = i18n.UNEXPECTED_ERROR_CAUGHT + "<br />" +
        i18n.discernabu.JS_ERROR + ": " + message + "<br />" +
        i18n.FILE + ": " + file + "<br />" +
        i18n.LINE_NUMBER + ": " + lineNumber + "<br />" +
        i18n.SOURCE + ": " + source + "<br />";

    // If variable source holds the translated text "Unknown" then replaced it with English text to log into timer and splunk.
    var stackTrace = (source === i18n.UNKNOWN) ? "Unknown" : source;

    // create CAP:MPG_Page_Level_Error_Details to log the essential details on Olympus to investigate the page level errors.
    var errorContextCapTimer = new CapabilityTimer("CAP:MPG_Page_Level_Error_Details", categoryMean);
    errorContextCapTimer.addMetaData("err", JSON.stringify(errorDetails));
    errorContextCapTimer.addMetaData("context", JSON.stringify(contextDetails));
    errorContextCapTimer.addMetaData("sTrace", stackTrace);
    errorContextCapTimer.capture();

    var serverURLObj = MP_StackProcessor.populateServerURL(stackTrace);
    var uniqueGroupTokensObj = MP_StackProcessor.populateUniqueGroupTokens(stackTrace);
    //Assign the grouptokens object to the error details object
    Object.assign(errorDetails, serverURLObj, uniqueGroupTokensObj);
    var sanitizedStackTrace = MP_StackProcessor.populateSanitizedStackTrace(stackTrace, serverURLObj, uniqueGroupTokensObj);

    var remoteLogInfo = populateRemoteLogInfoObject(errorDetails, contextDetails, sanitizedStackTrace);

    //Immediately enable logging to report the page level error for Blackbird/Console and Splunk
    log.setLoggingActive(true);
    logger.logError(localLogInfo, {
        loggedObject: remoteLogInfo
    });

    //Throw the error when we are developing in a browser, otherwise show the modal to the user
    if (CERN_BrowserDevInd) {
        throw (new Error(i18n.UNEXPECTED_ERROR_CAUGHT + "<br />" + i18n.discernabu.JS_ERROR + ": " + message + "<br />" + i18n.FILE + ": " + file + "<br />" + i18n.LINE_NUMBER + ": " + lineNumber));
    }
    else {

        //Create a modal dialog and ask the user if they would like to refresh or continue
        errorModal = MP_ModalDialog.retrieveModalDialogObject("errorModal");
        if (!errorModal) {
            errorModal = MP_Util.generateModalDialogBody("errorModal", "error", i18n.PAGE_ERROR, i18n.PAGE_ERROR_ACTION);
            errorModal.setHeaderTitle(i18n.ERROR_OCCURED);
            //Create and add the refresh button
            refreshButton = new ModalButton("refreshButton");
            refreshButton.setText(i18n.REFRESH).setCloseOnClick(true);
            refreshButton.setOnClickFunction(function() {
                //Refresh the page
                CERN_Platform.refreshMPage();
            });

            errorModal.addFooterButton(refreshButton);
            //Create and add the close button
            closeButton = new ModalButton("closeButton");
            closeButton.setText(i18n.CLOSE).setCloseOnClick(true);
            errorModal.addFooterButton(closeButton);
        }
        MP_ModalDialog.updateModalDialogObject(errorModal);
        MP_ModalDialog.showModalDialog("errorModal");

        //Returning true supresses the error in FireFox and IE but allows it to propegate in Chrome
        return true;
    }
};


/**
 * this EventListener listens to all promise rejections and handles details so we can display a user friendly
 * rather than the browsers technical dialog.
 * @param {Event} event - unHandeledRejection emited when proise without catch block is rejected
 */
window.addEventListener("unhandledrejection", function(event){
    var criterionData = null;
    var categoryMean = null;
    var contextDetails = null;
    var errorDetails = null;
    var source = null;
    var eventDetailReason = event.detail ? event.detail.reason : null;

    if(eventDetailReason) {
        if (eventDetailReason.message) {
            errorDetails = eventDetailReason.message;
        } else {
            errorDetails = eventDetailReason;
        }

        if (eventDetailReason.stack) {
            source = eventDetailReason.stack;
        } else {
            source = "Unhandled Promise Rejection";
        }
    } else {
        errorDetails = "Unhandled rejection";
        source = "Unhandled Promise Rejection";
    }

    // checking if the criterion is set(In some cases like setting invalid view point names, criterion is not set)
    if(typeof m_criterionJSON !== "undefined")
	{
        criterionData = CERN_Platform.getCriterion().CRITERION;
        categoryMean = criterionData.CATEGORY_MEAN;
        contextDetails = {
            VIEW: criterionData.CATEGORY_MEAN,
            VIEW_POINT: (typeof m_viewpointJSON !== "undefined" && m_viewpointJSON) ? JSON.parse(m_viewpointJSON).VP_INFO.VIEWPOINT_NAME : "",
            PERSON_ID: criterionData.PERSON_ID,
            ENCNTRS: criterionData.ENCNTRS,
            PRSNL_ID: criterionData.PRSNL_ID,
            POSITION_CD: criterionData.POSITION_CD,
            PPR_CD: criterionData.PPR_CD,
            LOGICAL_DOMAIN_ID: criterionData.LOGICAL_DOMAIN_ID,
            USER: criterionData.USERNAME,
            APP_NAME: criterionData.EXECUTABLE ? criterionData.EXECUTABLE.split('.')[0] : '',
            RELEASE_VERSION: criterionData.RELEASE_VERSION
        };
        if("WORKLIST_RELEASE_VERSION" in criterionData) {
            contextDetails.WORKLIST_RELEASE_VERSION = criterionData.WORKLIST_RELEASE_VERSION;
        }
    }

    var errorContextCapTimer = new CapabilityTimer("CAP:MPG_Page_Level_Uncaught_Rejection_Details", categoryMean);
    errorContextCapTimer.addMetaData("err", JSON.stringify(errorDetails));
    errorContextCapTimer.addMetaData("context", JSON.stringify(contextDetails));
    errorContextCapTimer.addMetaData("sTrace", source);
    errorContextCapTimer.capture();

    var localLogInfo = i18n.UNEXPECTED_ERROR_CAUGHT + "\n" +
        i18n.discernabu.JS_ERROR + ": " + errorDetails + "\n" +
        i18n.SOURCE + ": " + source + "\n" +
        "errorOrigin: Unhandled promise rejection \n";

    var remoteLogInfo = populateRemoteLogInfoObject(errorDetails, contextDetails, source);
    remoteLogInfo.errorOrigin = "Unhandled promise rejection";
    // Force activation of blackbird logging since we are tracking errors
    log.setLoggingActive(true);
    // Log the error
    logger.logError(localLogInfo, {
        loggedObject: remoteLogInfo
    });
});

/**
 * Stack Sanitization methods
 * @namespace
 */
var MP_StackProcessor = function () {
    return {
        /**
         * This function retrieves the serverURL out of the stack trace and
         * adds the server URL property into an object
         * @param {String} stackTrace - The stackTrace of the error occured
         * @returns {Object} - This object contains only the server URL
         */
        populateServerURL: function (stackTrace) {
            // Regex to get server URL from all occurrences in the stacktrace
            var serverURLRegex  = /(http|https):\/\/([\w\.\:\-]+\/){4}(?=[\w\.\-\/]+\.js)/gi;
            return (serverURLRegex.test(stackTrace)) ? { serverURL: stackTrace.match(serverURLRegex )[ 0 ] } : {};
        },
        /**
         * This function retrieves the unique group tokens out of the stack trace and
         * adds them as unique group token property into an object
         * @param {String} stackTrace - The stackTrace of the error occured
         * @returns {Object} - This object contains only the unique group tokens
         */
        populateUniqueGroupTokens: function (stackTrace) {
            // Regex to get group tokens from all occurrences in the stacktrace
            // Example for matched groupToken: 'http://ip85lintodr01.ip.devcerner.net:8080/mpage-content/solgm.ip.devcerner.net/MPAGES_6_12/js/group?[{"g_id":"MPAGES_6_12","a_id":"com.cerner.discernabu.assembly:mpages-6-16","t":["GEA23X","CeEk0M","ft9jJQ","gNMAoa","NCDYm1","ucFy5e","Vv3D0F"]}]'
            // The {5} notatation in regex matches quantifiers or charcters exactly 5 times which is mentioned before in [] or ()
            var groupTokenRegex = /(http|https):\/\/([\w\.\:\-]+\/){5}group\?\[\{[\[\'\"\w\_\:\,\.\-\]]+\}\]/g;
            var groupTokensUrl = stackTrace.match(groupTokenRegex);
            var uniqueGroupTokensUrl = groupTokensUrl ? groupTokensUrl.filter(function (value, index, self) {
                return self.indexOf(value) === index;
            }) : [];
            return uniqueGroupTokensUrl.reduce(function (accumulator, token, index) {
                accumulator[ "groupToken" + (index + 1) ] = token;
                return accumulator;
            }, {});
        },
        /**
         * This function populates the sanitized stacktrace by removal of the redundant serverURL and group token from the stackTrace
         * @param {String} stackTrace - The stackTrace of the error occured
         * @param {Object} serverURLObj - This object contains only the server URL
         * @param {Object} uniqueGroupTokensObj - This object contains only the unique group tokens
         * @returns {String} sanitizedStackTrace - The string which contains the sanitized stacktrace for splunk logging
         */
        populateSanitizedStackTrace: function (stackTrace, serverURLObj, uniqueGroupTokensObj) {
            var sanitizedStackTrace = stackTrace;
            // Regex to escape the matched special regex character
            var escapeSplRegexChar = /[-[\]{}()*+!<=:?.\/\\^$|#\s,]/g;
            sanitizedStackTrace = Object.entries(uniqueGroupTokensObj).reduce(function (sanitizedStackTrace, uniqueGroupTokensObj) { //eslint-disable-line no-shadow
                var key = uniqueGroupTokensObj[0];
                var value = uniqueGroupTokensObj[1];
                //Replace the group token from the stacktrace with placeholder by escaping the matched special regex character
                return sanitizedStackTrace.replace(new RegExp(value.replace(escapeSplRegexChar, '\\$&'), 'g'), key);
            }, sanitizedStackTrace);
            if (serverURLObj && serverURLObj.serverURL) {
                //Replace the server URL from the stacktrace with empty string by escaping the matched special regex character
                sanitizedStackTrace = sanitizedStackTrace.replace(new RegExp(serverURLObj.serverURL.replace(escapeSplRegexChar, '\\$&'), 'g'), "");
            }
            return sanitizedStackTrace;
        }
    };
}();

/**
 * Core utility methods
 * @namespace
 */
var MP_Core = function() { //eslint-disable-line no-redeclare
    return {
        /**
         * This function returns the normalcy class associated with the result
         * @param result - is the MP_Core.Measurement object.
         */
        GetNormalcyClass: function(result) {
            var normalcy = "res-normal";
            var normalcyMeaning = result.getNormalcy();
            if (normalcyMeaning) {
                switch (normalcyMeaning.meaning) {
                    case "LOW":
                        normalcy = "res-low";
                        break;
                    case "HIGH":
                        normalcy = "res-high";
                        break;
                    case "ABNORMAL":
                        normalcy = "res-abnormal";
                        break;
                    case "CRITICAL":
                    case "EXTREMEHIGH":
                    case "PANICHIGH":
                    case "EXTREMELOW":
                    case "PANICLOW":
                    case "VABNORMAL":
                    case "POSITIVE":
                        normalcy = "res-severe";
                        break;
                }
            }
            return normalcy;
        },
        /**
         * This function associates appropriate styles to the results.
         * @param result - is the MP_Core.Measurement object.
         * @param excludeUOM - This value indicates whether to add the Unit of measurement or not.
         */
        GetNormalcyResultDisplay: function (result, excludeUOM) {
            var ar = ["<span class='", MP_Core.GetNormalcyClass(result), "'><span class='res-ind'>&nbsp;</span><span class='res-value'>", MP_Core.GetEventViewerLink(result, CERN_Platform.encoding.htmlEncode(MP_Util.Measurement.GetString(result, null, "longDateTime2", excludeUOM))), "</span>", MP_Util.Measurement.GetModifiedIcon(result), "</span>"]; //eslint-disable-line new-cap
            return ar.join("");
        },
        /**
         * This function links the result viewer to the respective results.
         * @param result - is the MP_Core.Measurement object.
         * @param sResultDisplay - This contains the  value that needs to be displayed.
         */
        GetEventViewerLink: function (result, sResultDisplay) {
            var params = [result.getPersonId(), result.getEncntrId(), result.getEventId(), "\"EVENT\""];
            var ar = ["<a onclick='MP_Util.LaunchClinNoteViewer(", params.join(","), "); return false;' href='#'>", sResultDisplay, "</a>"];
            return ar.join("");
        },
        /**
         * The criterion object stores information about the request in context such as the patient/person, encounter/visit,
         * provider/personnel, relationship etc.
         * @constructor
         * @param {object} criterionObj The parses criterion object derived from the global m_criterionJSON
         * @param {string} staticContentBaseUrl The url to the static content location.  Does not contain actual subfolder paths.
         */
        Criterion: function(criterionObj, staticContentBaseUrl) {
            var m_patInfo = null;
            var m_prsnlInfo = null;
            var m_encntrOverride = [];

            this.person_id = criterionObj.PERSON_ID;
            this.encntr_id = (criterionObj.ENCNTRS.length > 0) ? criterionObj.ENCNTRS[ 0 ].ENCNTR_ID : 0;
            this.provider_id = criterionObj.PRSNL_ID;
            this.username = criterionObj.USERNAME || "";
            this.executable = criterionObj.EXECUTABLE;
            this.static_content = staticContentBaseUrl;
            this.position_cd = criterionObj.POSITION_CD;
            this.ppr_cd = criterionObj.PPR_CD;
            this.release_identifier = criterionObj.RELEASE_IDENTIFIER;
            this.release_version = criterionObj.RELEASE_VERSION;
            this.debug_ind = criterionObj.DEBUG_IND;
            CERN_BrowserDevInd = ((parseInt(this.debug_ind, 10) & 0x01) === 1) ? true : false;
            this.help_file_local_ind = criterionObj.HELP_FILE_LOCAL_IND;
            this.category_mean = criterionObj.CATEGORY_MEAN;
            this.locale_id = ((parseInt(this.debug_ind, 10) & 0x02) === 2) ? "en_us" : criterionObj.LOCALE_ID;
            this.logical_domain_id = (typeof criterionObj.LOGICAL_DOMAIN_ID !== "undefined") ? criterionObj.LOGICAL_DOMAIN_ID : null;
            this.is_utc = criterionObj.IS_UTC;
            if("WORKLIST_RELEASE_VERSION" in criterionObj) {
                this.worklist_release_version = criterionObj.WORKLIST_RELEASE_VERSION;
            }
            try {
                if (CERN_Platform.inMillenniumContext()) {
                    this.client_tz = criterionObj.CLIENT_TZ;
                }
                else {
                    this.client_tz = MP_Timezone.getTzIndex();
                    var timeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;    //eslint-disable-line new-cap
                    if(!timeZoneName) {
                        timeZoneName = MP_Timezone.getName();
                    }
                    document.cookie = "mp_client_tz=" + encodeURIComponent(timeZoneName) + ";path=/";
                }
            } catch (err) {
                logger.logWarning("Unable to set client time zone");
                this.client_tz = 0; //utc
                document.cookie = "mp_client_tz=" + encodeURIComponent(MP_Timezone.getName()) + ";path=/";
            }

            this.facility_cd = criterionObj.ENCNTR_LOCATION.FACILITY_CD;

            var encounterOverrideArray = criterionObj.ENCNTR_OVERRIDE;

            if (encounterOverrideArray) {
                for (var x = encounterOverrideArray.length; x--;) {
                    m_encntrOverride.push(encounterOverrideArray[ x ].ENCNTR_ID);
                }
            }
            else {
                m_encntrOverride.push(this.encntr_id);
            }

            this.setPatientInfo = function(value) {
                m_patInfo = value;
            };


            this.getPatientInfo = function() {
                return m_patInfo;
            };

            this.getPersonnelInfo = function() {
                if (!m_prsnlInfo) {
                    m_prsnlInfo = new MP_Core.PersonnelInformation(this.provider_id, this.person_id);
                }
                return m_prsnlInfo;
            };

            /**
             * @returns List of encounters that are considered 'ACTIVE'.
             * In the rare case that encounter override is needed, this will return the encounter neccessary to pass
             * to a service for retrieval of data.
             */
            this.getEncounterOverride = function() {
                return m_encntrOverride;
            };



        },
        PatientInformation: function() {
            var m_dob = null;
            var m_sex = null;
            var m_adminSex = null;
            var m_birthSex = null;
            var m_name = "";

            this.setSex = function(value) {
                m_sex = value;
            };
            this.getSex = function() {
                return m_sex;
            };
            this.setAdminSex = function(value) {
                m_adminSex = value;
            };
            this.getAdminSex = function() {
                return m_adminSex;
            };
            this.setBirthSex =  function(value) {
                m_birthSex = value;
            };
            this.getBirthSex = function() {
                return m_birthSex;
            };
            this.setDOB = function(value) {
                m_dob = value;
            };
            this.getDOB = function() {
                return m_dob;
            };
            this.setName = function(value) {
                m_name = value;
            };
            this.getName = function() {
                return m_name;
            };
        },

        PeriopCases: function() {
            var m_case_id = null;
            var m_days = null;
            var m_hours = null;
            var m_mins = null;
            var m_cntdwn_desc_flag = null;

            this.setCaseID = function(value) {
                m_case_id = value;
            };
            this.getCaseID = function() {
                return m_case_id;
            };
            this.setDays = function(value) {
                m_days = value;
            };
            this.getDays = function() {
                return m_days;
            };
            this.setHours = function(value) {
                m_hours = value;
            };
            this.getHours = function() {
                return m_hours;
            };
            this.setMins = function(value) {
                m_mins = value;
            };
            this.getMins = function() {
                return m_mins;
            };
            this.setCntdwnDscFlg = function(value) {
                m_cntdwn_desc_flag = value;
            };
            this.getCntdwnDscFlg = function() {
                return m_cntdwn_desc_flag;
            };
        },

        ScriptRequest: function(component, loadTimerName) {
            var m_comp = component || null;
            var m_load = loadTimerName || "";
            var m_name = "";
            var m_programName = "";
            var m_params = null;
            var m_blobIn = null;
            var m_async = true;
            var m_responseHandler = null;
            var m_timer = null;
            var m_source = null;
            var m_execCallback = false;
            // The object to hold MP_Core API's consumer artifact's related information such as artifactId and caller function name
            var m_artifactInfo = null;

            //Specify whether the consumer is expecting raw data
            var m_requiresRawData = false;

            this.setExecCallback = function(value) {
                m_execCallback = value;
            };

            this.getExecCallback = function() {
                return m_execCallback;
            };

            this.logCompletion = function(reply) {
                logger.logMessage("<b>Request Ended</b><br /><ul>" +
                    "<li>program: " + m_programName + "</li>" +
                    "<li>end_time: " + new Date() + "</li>" +
                    "<li>status: " + reply.status + "</li></ul>");
            };

            this.logStart = function() {
                logger.logMessage("<b>Request Started</b><br /><ul>" +
                    "<li>program: " + m_programName + "</li>" +
                    "<li>start_time: " + new Date() + "</li></ul>");
            };

            this.start = function() {
                MP_Core.XMLCCLRequestCallBack(this.m_comp, this); //eslint-disable-line new-cap
            };

            this.getResponseHandler = function() {
                return m_responseHandler;
            };

            this.setResponseHandler = function(responseHandler) {
                m_responseHandler = responseHandler;
            };

            this.getTimer = function() {
                return m_timer;
            };

            this.setTimer = function(timer) {
                m_timer = timer;
            };

            this.getComponent = function() {
                return m_comp;
            };
            this.getLoadTimer = function() {
                return m_load;
            };
            this.setName = function(value) {
                m_name = value;
            };
            this.getName = function() {
                return m_name;
            };
            this.setProgramName = function(value) {
                m_programName = value;
            };
            this.getProgramName = function() {
                return m_programName;
            };
            this.setParameters = function(value) {
                m_params = value;
            };
            this.getParameters = function() {
                return m_params;
            };
            this.setRequestBlobIn = function(value) {
                m_blobIn = value;
            };
            this.getRequestBlobIn = function() {
                return m_blobIn;
            };
            this.setAsync = function(value) { // eslint-disable-line chromium-errors
                m_async = value;
            };
            this.isAsync = function() {
                return m_async;
            };
            this.getSource = function() {
                return m_source;
            };
            this.setSource = function(source) {
                m_source = source;
            };
            this.getRequiresRawData = function() {
                return m_requiresRawData;
            };
            this.setRequiresRawData = function(requiresRaw) {
                m_requiresRawData = requiresRaw;
            };

            /**
             * Retrieves the consumer artifact's information object
             * @returns {object} Object of the consumer artifact's information
             */
            this.getArtifactInfo = function() {
                return m_artifactInfo;
            };

            /**
             * Sets the values for actifact information object. This is an optional field.
             * @param {object} artifactInfo The artifact information to log into the error details.
             */
            this.setArtifactInfo = function(artifactInfo) {
                // The provided artifactInfo should be an object type or null
                if((typeof artifactInfo === "object" && !Array.isArray(artifactInfo)) || artifactInfo === null) {
                    this.m_artifactInfo = artifactInfo;
                }
                else {
                    throw new Error("MP_Core.setArtifactInfo: artifactInfo parameter must be an object type or null");
                }
            };
        },
        ScriptReply: function(component) {
            //used to syne a request to a reply
            var m_name = "";
            //by default every script reply is 'f'ailed unless otherwise noted
            var m_status = "F";
            var m_err = "";
            var m_resp = null;
            var m_comp = component;

            this.setName = function(value) {
                m_name = value;
            };
            this.getName = function() {
                return m_name;
            };
            this.setStatus = function(value) {
                m_status = value;
            };
            this.getStatus = function() {
                return m_status;
            };
            this.setError = function(value) {
                m_err = value;
            };
            this.getError = function() {
                return m_err;
            };
            this.setResponse = function(value) {
                m_resp = value;
            };
            this.getResponse = function() {
                return m_resp;
            };
            this.getComponent = function() {
                return m_comp;
            };
        },
        PersonnelInformation: function(prsnlId, patientId) {
            var m_prsnlId = prsnlId;
            //if m_viewableEncntrs remains null, error in retrieval of viewable encntr
            var m_viewableEncntrs = null;
            //load valid encounter list from patcon wrapper
            var patConObj = null;
            try {
                patConObj = CERN_Platform.getDiscernObject("PVCONTXTMPAGE"); // eslint-disable-line new-cap, chromium-errors
                logger.logDiscernInfo(null, "PVCONTXTMPAGE", "mp_core.js", "PersonnelInformation");
                if (patConObj) {
                    m_viewableEncntrs = patConObj.GetValidEncounters(patientId); //eslint-disable-line new-cap
                    logger.logDebug("Viewable Encounters: " + m_viewableEncntrs);
                }
            }
            catch (e) {
            }
            finally {
                //release used memory
                patConObj = null;
            }

            this.getPersonnelId = function() {
                return m_prsnlId;
            };
            /**
             * Returns the associated encounter that the provide has the ability to see
             */
            this.getViewableEncounters = function() { // eslint-disable-line chromium-errors
                return m_viewableEncntrs;
            };
        },
        /**
         * Create and return shared resource (viewableEncntrs) for the "Viewable Encounters" for the provided patient person_id.
         * If run within the context of win32 applications, the function will leverage PVCONTXTMPAGE and GetValidEncounters:
         *   https://wiki.ucern.com/display/public/MPDEVWIKI/GetValidEncounters
         * If run outside of win32 applications (MPages web service), this function will leverage request 3200310 (msvc_svr_get_clinctx).
         *
         * Consumers of this function should check the shared resource object that is returned to determine if data exists:
         *   viewableEncntrsObj.isResourceAvailable() && viewableEncntrsObj.getResourceData()
         *
         * If those do not both evaluate to true, the consumer should then add a listener for "viewableEncntrInfoAvailable", which will be invoked when the shared resource data is available.
         *
         * @param patientId The person_id of the patient to retrieve viewable encounters
         * @param {String} securityConceptString - Security concept string to filter out valid encounters
         * @returns {object} An object that contains the status of retrieving the viewable encounters, and a string of the comma separated viewable encounters (if available)
         */
        GetViewableEncntrs: function(patientId, securityConceptString) { // eslint-disable-line chromium-errors
            /**
             * Returns the associated encounter(s) that the currently authenticated provider has the ability to see, from PVCONTXTMPAGE.
             * This logic will be consumed from win32 MPages where PVCONTXTMPAGE is available.
             * @returns {string} List of viewable encounters, comma separated
             */
            function getViewableFromPvContxtMpage() {
                var patConObj = null;
                var m_viewableEncntrs = "";
                try {
                    patConObj = CERN_Platform.getDiscernObject("PVCONTXTMPAGE"); // eslint-disable-line new-cap, chromium-errors
                    logger.logDiscernInfo(null, "PVCONTXTMPAGE", "mp_core.js", "getViewableFromPvContxtMpage");
                    if (patConObj) {
                        m_viewableEncntrs = patConObj.GetValidEncounters(patientId, securityConceptString); //eslint-disable-line new-cap
                        logger.logDebug("Viewable Encounters obtained from PVCONTXTMPAGE: " + m_viewableEncntrs);
                    }
                }
                catch (e) {
                }
                finally {
                    //release used memory
                    patConObj = null;
                }
                return m_viewableEncntrs;
            }


            /**
             * Make async call to retrieve viewable encounters from clinical context service, using the script mp_get_valid_encounters.
             * The clinical context service (msvc_svr_get_clinctx, 3200310) will return the authorized (viewable) encounters for the patient in context:
             *   Application Number: 3202004
             *   Task Number: 3202004
             *   Request Number: 3200310
             * This logic will be consumed when PVCONTXTMPAGE is not available.
             * @returns {null}
             */
            function retrieveEncntrsFromClinicalContext() {
                var params = [];
                var artifactInfo = {
                    artifactId: "mpage-core",
                    functionName: "retrieveEncntrsFromClinicalContext"
                };
                var request = new MP_Core.ScriptRequest();
                var programName = "mp_get_valid_encounters";
                //Pass security concept string if available
                if(securityConceptString) {
                    params = [ "^MINE^", patientId + ".0", securityConceptString ];
                } else {
                    params = [ "^MINE^", patientId + ".0" ];
                }
                request.setProgramName(programName);
                request.setArtifactInfo(artifactInfo);
                request.setParameters(params);
                request.setAsync(true); // eslint-disable-line chromium-errors
                request.setExecCallback(true);
                MP_Core.XMLCCLRequestCallBack(null, request, handleContextFromService); //eslint-disable-line new-cap
            }

            /**
             * Callback to Handle the reply object from retrieveEncntrsFromClinicalContext()
             * @param {object} MP_Core.ScriptReply object
             * @returns {null}
             */
            function handleContextFromService(replyObj) {
                var m_viewableEncntrs = "";

                // Get the viewableEncntrs SharedResource
                var veResource = MP_Resources.getSharedResource("viewableEncntrs");

                if (replyObj.getStatus() === "S") {
                    try {
                        var recordData = replyObj.getResponse();
                        m_viewableEncntrs = $.map(recordData.AUTH_ENCOUNTER.AUTH_ENCOUNTERS, function(o) {
                            return o.ENCOUNTER_ID + ".0";
                        }).join(",");
                        logger.logDebug("Viewable Encounters obtained from ClinicalContext service: " + m_viewableEncntrs);
                    }
                    catch (err) {
                        logger.logJSError(err, this, "mp_core.js", "GetViewableEncntrs");
                    }
                }
                else {
                    logger.logError("Unable to successfully retrieve Viewable Encounters from ClinicalContext service");
                }

                veResource.setIsAvailable(true);
                veResource.setIsBeingRetrieved(false);
                veResource.setResourceData(m_viewableEncntrs);

                //Fire event for all listeners
                CERN_EventListener.fireEvent(null, self, "viewableEncntrInfoAvailable", veResource);
            }

            var self = this;
            var m_viewableEncntrs = "";

            // create the viewable encounters resource shared resource
            var veResource = MP_Resources.getSharedResource("viewableEncntrs");
            if (!veResource) {
                veResource = new SharedResource("viewableEncntrs");
                MP_Resources.addSharedResource("viewableEncntrs", veResource);
            }

            if (veResource.isResourceAvailable() && veResource.getResourceData()) {
                return veResource;
            }
            else {
                //Attempt to retrieve the viewable encounters from PVCONTXTMPAGE
                m_viewableEncntrs = getViewableFromPvContxtMpage();

                //If we obtained the viewable encounters from PVCONTXTMPAGE, set here, and return SR object
                if (m_viewableEncntrs) {
                    veResource.setResourceData(m_viewableEncntrs);
                    veResource.setIsAvailable(true);
                    return veResource;

                }
                else {
                    //Check to see if the shared resource is currently retrieving data
                    if (!veResource.isBeingRetrieved()) {
                        //Kick off the resource retrieval from ClinicalContext service
                        veResource.setIsBeingRetrieved(true);
                        retrieveEncntrsFromClinicalContext();
                    }
                    //Return the shared resource, which at this point should have isResourceAvailable() == false && getResourceData() == null
                    return veResource;
                }
            }
        },
        /**
         * @deprecated
         * Creates and runs a request for a component based on the specified component, program, and parameter array.
         * This function assumes the script call is being made for a component. This function populates a ScriptRequest
         * object and passes it off to the XmlStandardRequest method, passing null for the callback.
         * @param {MPageComponent} component  component object for which the script is being called.
         * @param {String} program  the CCL program to be run.
         * @param {Array} paramAr  the parameter array to be passed to the CCL program.
         * @param {Boolean} async  whether the script call should be asynchronous or not. (Recommended that it
         * be asynchronous).
         */
        XMLCclRequestWrapper: function(component, program, paramAr, async) {
            var loadTimer = null;
            var renderTimer = null;
            var request = null;
            var artifactInfo = null;
            if (MPageComponent.prototype.isPrototypeOf(component)) {
                //create a component script request
                request = new ComponentScriptRequest();
                request.setComponent(component);
                //Create the loadTimer and renderTimer
                loadTimer = new RTMSTimer(component.getComponentLoadTimerName(), component.getCriterion().category_mean);
                renderTimer = new RTMSTimer(component.getComponentRenderTimerName(), component.getCriterion().category_mean);
                request.setLoadTimer(loadTimer);
                request.setRenderTimer(renderTimer);
                artifactInfo = {
                    artifactId: component.getComponentFilterMean(),
                    functionName: "MP_Core.XMLCclRequestWrapper"
                };
            }
            else {
                //Create a standard script request object
                request = new ScriptRequest();
                artifactInfo = {
                    artifactId: "mpage-core",
                    functionName: "XMLCclRequestWrapper"
                };
            }
            request.setProgramName(program);
            request.setArtifactInfo(artifactInfo);
            request.setParameterArray(paramAr || []);
            request.setAsyncIndicator(typeof async === "boolean" ? async : true); // eslint-disable-line chromium-errors
            request.performRequest();
        },
        /**
         * @deprecated
         * As a means in which to provide the consumer to handle the response of the script request, this method
         * provide an encapsulated means in which to call the XMLCCLRequest and return a ReplyObject with data
         * about the response that can be utilized for evaluation.
         * @param component  The component in which is executing the request
         * @param oldRequestObj  A deprecated MP_Core.ScriptRequest Object containing the information about the script being executed
         * @param funcCallBack  The function to execute once the execution of the request has been completed
         */
        XMLCCLRequestCallBack: function(component, oldRequestObj, funcCallback) {
            MP_Core.XmlStandardRequest(component, oldRequestObj, funcCallback); //eslint-disable-line new-cap
        },
        /**
         * @deprecated
         * This wraps the XML requests being made. This function is called by XMLCclRequestWrapper and XMLCCLRequestCallBack.
         * Note that both component and callback are optional. However, if you want something to occur upon the script
         * completing, one or the other must be provided.
         * @param {MPageComponent} component . This parameter is an MPageComponent object. Specific methods will be called on this
         * component to render it, but only if it is provided.
         * @param {ScriptRequest} oldRequestObj   A deprecated MP_Core.ScriptRequest Object containing the information about the script being executed
         * @param {Function} funcCallBack  the function to be called upon a request returning.
         */
        XmlStandardRequest: function(component, oldRequestObj, funcCallback) {
            var loadTimer = null;
            var renderTimer = null;
            var request = null;
            if (MPageComponent.prototype.isPrototypeOf(component)) {
                //create a component script request
                request = new ComponentScriptRequest();
                request.setComponent(component);
                //Create the loadTimer and renderTimer
                loadTimer = new RTMSTimer(component.getComponentLoadTimerName(), component.getCriterion().category_mean);
                renderTimer = new RTMSTimer(component.getComponentRenderTimerName(), component.getCriterion().category_mean);
                request.setLoadTimer(loadTimer);
                request.setRenderTimer(renderTimer);
            }
            else {
                //Create a standard script request object
                request = new ScriptRequest();
                //Create the load timer
                loadTimer = new RTMSTimer(oldRequestObj.getLoadTimer());
                request.setLoadTimer(loadTimer);
            }
            //Copy over the remaining fields of the oldRequestObj
            request.setName(oldRequestObj.getName());
            request.setProgramName(oldRequestObj.getProgramName());
            request.setArtifactInfo(oldRequestObj.getArtifactInfo());
            request.setResponseHandler(funcCallback);
            request.setDataBlob(oldRequestObj.getRequestBlobIn() || "");
            request.setParameterArray(oldRequestObj.getParameters() || []);
            request.setAsyncIndicator(oldRequestObj.isAsync()); // eslint-disable-line chromium-errors
            request.setRawDataIndicator(oldRequestObj.getRequiresRawData());
            request.performRequest();
        },
        XMLCCLRequestThread: function(name, component, request) {
            var m_name = name;
            var m_comp = component;

            var m_request = request;
            m_request.setName(name);

            this.getName = function() {
                return m_name;
            };
            this.getComponent = function() {
                return m_comp;
            };
            this.getRequest = function() {
                return m_request;
            };
        },
        XMLCCLRequestThreadManager: function(callbackFunction, component, handleFinalize) {
            var m_threads = null;
            var m_replyAr = null;

            var m_isData = false;
            var m_isError = false;
            var x = 0;

            this.addThread = function(thread) {
                if (!m_threads) {
                    m_threads = [];
                }
                m_threads.push(thread);
            };

            this.begin = function() {
                if (m_threads && m_threads.length > 0) {
                    for (x = m_threads.length; x--;) {
                        //start each xmlcclrequest
                        var thread = m_threads[ x ];
                        MP_Core.XMLCCLRequestCallBack(thread.getComponent(), thread.getRequest(), this.completeThread); //eslint-disable-line new-cap
                    }
                }
                else {
                    if (handleFinalize) {
                        var countText = (component.isLineNumberIncluded() ? "(0)" : "");
                        component.finalizeComponent(MP_Util.HandleNoDataResponse(component.getStyles().getNameSpace()), countText); //eslint-disable-line new-cap
                        //After the component has rendered call the postProcessing function to perform any additional actions
                        component.postProcessing();
                    }
                    else {
                        callbackFunction(null, component);
                    }
                }
            };

            this.completeThread = function(reply) {
                if (!m_replyAr) {
                    m_replyAr = [];
                }
                if (reply.getStatus() === "S") {
                    m_isData = true;
                }
                else if (reply.getStatus() === "F") {
                    m_isError = true;
                }

                m_replyAr.push(reply);
                if (m_replyAr.length === m_threads.length) {
                    var countText = (component.isLineNumberIncluded() ? "(0)" : "");
                    var errMsg = null;
                    try {
                        if (handleFinalize) {
                            if (m_isError) {
                                //handle error response
                                errMsg = [];
                                for (x = m_replyAr.length; x--;) {
                                    var rep = m_replyAr[ x ];
                                    if (rep.getStatus() === "F") {
                                        errMsg.push(rep.getError());
                                    }
                                }
                                component.finalizeComponent(MP_Util.HandleErrorResponse(component.getStyles().getNameSpace(), errMsg.join("<br />")), ""); //eslint-disable-line new-cap
                            }
                            else if (!m_isData) {
                                //handle no data
                                countText = (component.isLineNumberIncluded() ? "(0)" : "");
                                component.finalizeComponent(MP_Util.HandleNoDataResponse(component.getStyles().getNameSpace()), countText); //eslint-disable-line new-cap
                            }
                            else {
                                callbackFunction(m_replyAr, component);
                            }
                        }
                        else {
                            callbackFunction(m_replyAr, component);
                        }
                    }
                    catch (err) {
                        logger.logJSError(err, component, "mp_core.js", "XMLCCLRequestThreadManager");
                        var i18nCore = i18n.discernabu;
                        errMsg = [ "<b>", i18nCore.JS_ERROR, "</b><br /><ul><li>", i18nCore.MESSAGE, ": ", err.message, "</li><li>", i18nCore.NAME, ": ", err.name, "</li><li>", i18nCore.NUMBER, ": ", (err.number & 0xFFFF), "</li><li>", i18nCore.DESCRIPTION, ": ", err.description, "</li></ul>" ];
                        component.finalizeComponent(MP_Util.HandleErrorResponse(component.getStyles().getNameSpace(), errMsg.join("")), ""); //eslint-disable-line new-cap
                    }
                    finally {
                        if (component && typeof component.postProcessing !== "undefined") {
                            //After the component has rendered call the postProcessing function to perform any additional actions
                            component.postProcessing();
                        }
                    }
                }
            };
        },
        MapObject: function(name, value) {
            this.name = name;
            this.value = value;
        },


        ReferenceRangeResult: function() {
            //results
            var m_valNLow = -1,
                m_valNHigh = -1,
                m_valCLow = -1,
                m_valCHigh = -1;
            //units of measure
            var m_uomNLow = null,
                m_uomNHigh = null,
                m_uomCLow = null,
                m_uomCHigh = null;
            //text results
            var m_valNLowText = "",
                m_valNHighText = "",
                m_valCLowText = "",
                m_valCHighText = "";
            // flag to indicate validity of results
            var m_isNLowValid = 0,
                m_isNHighValid = 0,
                m_isCLowValid = 0,
                m_isCHighValid = 0;
            // modifier values
            var m_modifierNLow = "",
                m_modifierNHigh = "",
                m_modifierCLow = "",
                m_modifierCHigh = "";
            this.init = function(refRange, codeArray) {
                var nf = MP_Util.GetNumericFormatter(); //eslint-disable-line new-cap
                m_valCLow = nf.format(refRange.CRITICAL_LOW.NUMBER);
                if (refRange.CRITICAL_LOW.UNIT_CD != "") { //eslint-disable-line eqeqeq
                    m_uomCLow = MP_Util.GetValueFromArray(refRange.CRITICAL_LOW.UNIT_CD, codeArray); //eslint-disable-line new-cap
                }
                if (refRange.CRITICAL_LOW_TEXT) {
                    m_valCLowText = refRange.CRITICAL_LOW_TEXT;
                }
                if (refRange.CRITICAL_LOW.ISVALID) {
                    if (refRange.CRITICAL_LOW.MODIFIER_CD) {
                        m_modifierCLow = MP_Util.GetValueFromArray(refRange.CRITICAL_LOW.MODIFIER_CD, codeArray).display;  //eslint-disable-line new-cap
                    }
                    m_isCLowValid = refRange.CRITICAL_LOW.ISVALID;
                }
                m_valCHigh = nf.format(refRange.CRITICAL_HIGH.NUMBER);
                if (refRange.CRITICAL_HIGH.UNIT_CD != "") { //eslint-disable-line eqeqeq
                    m_uomCHigh = MP_Util.GetValueFromArray(refRange.CRITICAL_HIGH.UNIT_CD, codeArray); //eslint-disable-line new-cap
                }
                if (refRange.CRITICAL_HIGH_TEXT) {
                    m_valCHighText = refRange.CRITICAL_HIGH_TEXT;
                }
                if (refRange.CRITICAL_HIGH.ISVALID) {
                    if (refRange.CRITICAL_HIGH.MODIFIER_CD) {
                        m_modifierCHigh = MP_Util.GetValueFromArray(refRange.CRITICAL_HIGH.MODIFIER_CD, codeArray).display; //eslint-disable-line new-cap
                    }
                    m_isCHighValid = refRange.CRITICAL_HIGH.ISVALID;
                }
                m_valNLow = nf.format(refRange.NORMAL_LOW.NUMBER);
                if (refRange.NORMAL_LOW.UNIT_CD != "") { //eslint-disable-line eqeqeq
                    m_uomNLow = MP_Util.GetValueFromArray(refRange.NORMAL_LOW.UNIT_CD, codeArray); //eslint-disable-line new-cap
                }
                if (refRange.NORMAL_LOW_TEXT) {
                    m_valNLowText = refRange.NORMAL_LOW_TEXT;
                }
                if (refRange.NORMAL_LOW.ISVALID) {
                    if (refRange.NORMAL_LOW.MODIFIER_CD) {
                        m_modifierNLow = MP_Util.GetValueFromArray(refRange.NORMAL_LOW.MODIFIER_CD, codeArray).display;  //eslint-disable-line new-cap
                    }
                    m_isNLowValid = refRange.NORMAL_LOW.ISVALID;
                }
                m_valNHigh = nf.format(refRange.NORMAL_HIGH.NUMBER);
                if (refRange.NORMAL_HIGH.UNIT_CD != "") { //eslint-disable-line eqeqeq
                    m_uomNHigh = MP_Util.GetValueFromArray(refRange.NORMAL_HIGH.UNIT_CD, codeArray); //eslint-disable-line new-cap
                }
                if (refRange.NORMAL_HIGH_TEXT) {
                    m_valNHighText = refRange.NORMAL_HIGH_TEXT;
                }
                if (refRange.NORMAL_HIGH.ISVALID) {
                    if (refRange.NORMAL_HIGH.MODIFIER_CD) {
                        m_modifierNHigh = MP_Util.GetValueFromArray(refRange.NORMAL_HIGH.MODIFIER_CD, codeArray).display;  //eslint-disable-line new-cap
                    }
                    m_isNHighValid = refRange.NORMAL_HIGH.ISVALID;
                }
            };
            this.getNormalLow = function() {
                return m_valNLow;
            };
            this.getNormalHigh = function() {
                return m_valNHigh;
            };
            this.getNormalLowUOM = function() {
                return m_uomNLow;
            };
            this.getNormalHighUOM = function() {
                return m_uomNHigh;
            };
            this.getCriticalLow = function() {
                return m_valCLow;
            };
            this.getCriticalHigh = function() {
                return m_valCHigh;
            };
            this.getCriticalLowUOM = function() {
                return m_uomCLow;
            };
            this.getCriticalHighUOM = function() {
                return m_uomCHigh;
            };
            this.getNormalLowValidity = function () {
                return m_isNLowValid;
            };
            this.getNormalHighValidity = function () {
                return m_isNHighValid;
            };
            this.getCriticalLowValidity = function () {
                return m_isCLowValid;
            };
            this.getCriticalHighValidity = function () {
                return m_isCHighValid;
            };
            this.getNormalLowText = function () {
                return m_valNLowText;
            };
            this.getNormalHighText = function () {
                return m_valNHighText;
            };
            this.getCriticalLowText = function () {
                return m_valCLowText;
            };
            this.getCriticalHighText = function () {
                return m_valCHighText;
            };
            this.getNormalLowModifier = function () {
                return m_modifierNLow;
            };
            this.getNormalHighModifier = function () {
                return m_modifierNHigh;
            };
            this.getCriticalLowModifier = function () {
                return m_modifierCLow;
            };
            this.getCriticalHighModifier = function () {
                return m_modifierCHigh;
            };
            this.toNormalInlineString = function() {
                var low = (m_uomNLow) ? m_uomNLow.display : "";
                var high = (m_uomNHigh) ? m_uomNHigh.display : "";
                if (m_valNLow != 0 || m_valNHigh != 0) { //eslint-disable-line eqeqeq
                    return (m_valNLow + "&nbsp;" + low + " - " + m_valNHigh + "&nbsp;" + high);
                }
                else {
                    return "";
                }
            };
            this.toCriticalInlineString = function() {
                var low = (m_uomCLow) ? m_uomCLow.display : "";
                var high = (m_uomCHigh) ? m_uomCHigh.display : "";
                if (m_valCLow != 0 || m_valCHigh != 0) { //eslint-disable-line eqeqeq
                    return (m_valCLow + "&nbsp;" + low + " - " + m_valCHigh + "&nbsp;" + high);
                }
                else {
                    return "";
                }
            };
        },

        QuantityValue: function() {
            var m_val, m_precision;
            var m_uom = null;
            var m_refRange = null;
            var m_rawValue = 0;
            var m_hasModifier = false;
            this.init = function(result, codeArray) {
                var quantityValue = result.QUANTITY_VALUE;
                var referenceRange = result.REFERENCE_RANGE;
                for (var l = 0, ll = quantityValue.length; l < ll; l++) {
                    var numRes = quantityValue[ l ].NUMBER;
                    m_precision = quantityValue[ l ].PRECISION;
                    if (!isNaN(numRes)) {
                        m_val = MP_Util.Measurement.SetPrecision(numRes, m_precision); //eslint-disable-line new-cap
                        m_rawValue = numRes;
                    }
                    if (quantityValue[ l ].MODIFIER_CD != "") { //eslint-disable-line eqeqeq
                        var modCode = MP_Util.GetValueFromArray(quantityValue[ l ].MODIFIER_CD, codeArray); //eslint-disable-line new-cap
                        if (modCode) {
                            m_val = modCode.display + m_val;
                            m_hasModifier = true;
                        }
                    }
                    if (quantityValue[ l ].UNIT_CD != "") { //eslint-disable-line eqeqeq
                        m_uom = MP_Util.GetValueFromArray(quantityValue[ l ].UNIT_CD, codeArray); //eslint-disable-line new-cap
                    }
                    for (var m = 0, ml = referenceRange.length; m < ml; m++) {
                        m_refRange = new MP_Core.ReferenceRangeResult();
                        m_refRange.init(referenceRange[ m ], codeArray);
                    }
                }
            };

            this.getValue = function() {
                return m_val;
            };
            this.getRawValue = function() {
                return m_rawValue;
            };
            this.getUOM = function() {
                return m_uom;
            };
            this.getRefRange = function() {
                return m_refRange;
            };
            this.getPrecision = function() {
                return m_precision;
            };
            this.toString = function() {
                if (m_uom) {
                    return (m_val + " " + m_uom.display);
                }
                return m_val;
            };
            this.hasModifier = function() {
                return m_hasModifier;
            };
        },
        //measurement.init(meas.EVENT_ID, meas.PERSON_ID, meas.ENCNTR_ID, eventCode, dateTime, MP_Util.Measurement.GetObject(meas.MEASUREMENTS[k], codeArray));
        Measurement: function() {
            var m_eventId = 0.0;
            var m_personId = 0.0;
            var m_encntrId = 0.0;
            var m_eventCode = null;
            var m_dateTime = null;
            var m_updateDateTime = null;
            var m_result = null;
            var m_normalcy = null;
            var m_status = null;
            var m_comment = "";
            var m_comment_ind = 0;
            var m_classification = "";

            this.init = function(eventId, personId, encntrId, eventCode, dateTime, resultObj, updateDateTime) {
                m_eventId = eventId;
                m_personId = personId;
                m_encntrId = encntrId;
                m_eventCode = eventCode;
                m_dateTime = dateTime;
                m_result = resultObj;
                m_updateDateTime = updateDateTime;
            };

            this.initFromRec = function(measObj, codeArray) {
                var effectiveDateTime = new Date();
                var updateDateTime = new Date();
                m_eventId = measObj.EVENT_ID;
                m_personId = measObj.PATIENT_ID;
                m_encntrId = measObj.ENCOUNTER_ID;
                m_classification = measObj.CLASSIFICATION;
                m_eventCode = MP_Util.GetValueFromArray(measObj.EVENT_CD, codeArray); //eslint-disable-line new-cap
                effectiveDateTime.setISO8601(measObj.EFFECTIVE_DATE);
                m_dateTime = effectiveDateTime;
                m_result = MP_Util.Measurement.GetObject(measObj, codeArray); //eslint-disable-line new-cap
                updateDateTime.setISO8601(measObj.UPDATE_DATE);
                m_updateDateTime = updateDateTime;
                m_normalcy = MP_Util.GetValueFromArray(measObj.NORMALCY_CD, codeArray); //eslint-disable-line new-cap
                m_status = MP_Util.GetValueFromArray(measObj.STATUS_CD, codeArray); //eslint-disable-line new-cap
                m_comment = measObj.COMMENT;
                m_comment_ind = measObj.HAS_COMMENTS_IND;
            };

            this.getEventId = function() {
                return m_eventId;
            };
            this.getPersonId = function() {
                return m_personId;
            };
            this.getEncntrId = function() {
                return m_encntrId;
            };
            this.getClassification = function() {
                return m_classification;
            };
            this.getEventCode = function() {
                return m_eventCode;
            };
            this.getDateTime = function() {
                return m_dateTime;
            };
            this.getUpdateDateTime = function() {
                return m_updateDateTime;
            };
            this.getResult = function() {
                return m_result;
            };
            this.setNormalcy = function(value) {
                m_normalcy = value;
            };
            this.getNormalcy = function() {
                return m_normalcy;
            };
            this.setStatus = function(value) {
                m_status = value;
            };
            this.getStatus = function() {
                return m_status;
            };
            this.isModified = function() {
                if (m_status) {
                    var mean = m_status.meaning;
                    if (mean === "MODIFIED" || mean === "ALTERED") {
                        return true;
                    }
                }
                return false;
            };
            this.getComment = function() {
                return m_comment;
            };
            this.getCommentsIndicator = function() {
                return m_comment_ind;
            };
        },
        MenuItem: function() {
            var m_name = "";
            var m_desc = "";
            var m_id = 0.0;
            var m_meaning;
            var m_valSequence = 0;
            //This is used as the primary grouping value for IView bands
            var m_valTypeFlag = 0;
            //This is used to determine which is the band, section, or item

            this.setDescription = function(value) {
                m_desc = value;
            };
            this.getDescription = function() {
                return m_desc;
            };
            this.setName = function(value) {
                m_name = value;
            };
            this.getName = function() {
                return m_name;
            };
            this.setId = function(value) {
                m_id = value;
            };
            this.getId = function() {
                return m_id;
            };
            this.setMeaning = function(value) {
                m_meaning = value;
            };
            this.getMeaning = function() {
                return m_meaning;
            };
            this.setValSequence = function(value) {
                m_valSequence = value;
            };
            this.getValSequence = function() {
                return m_valSequence;
            };
            this.setValTypeFlag = function(value) {
                m_valTypeFlag = value;
            };
            this.getValTypeFlag = function() {
                return m_valTypeFlag;
            };
        },
        CriterionFilters: function(criterion) {
            var m_criterion = criterion;
            var m_evalAr = [];

            this.addFilter = function(type, value) {
                m_evalAr.push(new MP_Core.MapObject(type, value));
            };
            this.checkFilters = function() {
                var patInfo = m_criterion.getPatientInfo();
                for (var x = m_evalAr.length; x--;) {
                    var filter = m_evalAr[ x ];
                    var dob = null;
                    switch (filter.name) {
                        case MP_Core.CriterionFilters.SEX_MEANING:
                            var sex = patInfo.getSex();
                            if (sex) {
                                if (filter.value == sex.meaning) { //eslint-disable-line eqeqeq
                                    continue;
                                }
                            }
                            return false;
                        case MP_Core.CriterionFilters.DOB_OLDER_THAN:
                            dob = patInfo.getDOB();
                            if (dob) {
                                if (dob <= filter.value) {
                                    continue;
                                }
                            }
                            return false;
                        case MP_Core.CriterionFilters.DOB_YOUNGER_THAN:
                            dob = patInfo.getDOB();
                            if (dob) {
                                if (dob >= filter.value) {
                                    continue;
                                }
                            }
                            return false;
                        case MP_Core.CriterionFilters.ADMIN_SEX_MEANING:
                            var adminSex = patInfo.getAdminSex();
                            if (adminSex) {
                                if (filter.value == adminSex.meaning) { //eslint-disable-line eqeqeq
                                    continue;
                                }
                            }
                            return false;
                        case MP_Core.CriterionFilters.BIRTH_SEX_MEANING:
                            var birthSex = patInfo.getBirthSex();
                            if (birthSex) {
                                if (filter.value == birthSex.meaning) { //eslint-disable-line eqeqeq
                                    continue;
                                }
                            }
                            return false;
                        default:
                            logger.logError("Unhandled criterion filter");
                            return false;
                    }
                }
                return true;
            };
        },
        CreateSimpleError: function(component, sMessage) {
            var errMsg = [];
            var i18nCore = i18n.discernabu;
            var countText = (component.isLineNumberIncluded() ? "(0)" : "");
            errMsg.push("<b>", i18nCore.DISCERN_ERROR, "</b><br /><ul><li>", sMessage, "</li></ul>");
            component.finalizeComponent(MP_Util.HandleErrorResponse(component.getStyles().getNameSpace(), errMsg.join("")), countText); //eslint-disable-line new-cap
            //After the component has rendered call the postProcessing function to perform any additional actions
            component.postProcessing();
        },
        /**
         * Generates the HTMl for informational messages that will be displayed to the user.  The msgType parameter will be used to determine
         * the correct styling for the message applied. If the message type cannot be mapped to a supported message or the field is left blank, the
         * default styling will be applied.  If custom styling should be applied for the message the customClass parameter can be used to override
         * any of the default properties of the standard messaging styles.
         * @param {string} msgType This must be a string that represents the type of message being created.  The currently supported message types are error,
         * warning, information and busy.  If your message type does not match one of those listed, the default styling will be applied.  This parameter can also be
         * left blank to utilize the default styling.
         * @param {string} msgText This will be the first line of the message and will potentially be styled based on the message type being used.
         * @param {string} msdDetails This will be the text immediately following the msgText line.  This text will not be stylized.
         * @param {string} customClass This is the optional custom class that can be added to the message container which will allow for custom styling of the message
         * information.
         * @returns {string} The HTML markup of the information message to display to the user.
         */
        generateUserMessageHTML: function(msgType, msgText, msgDetails, customClass) {
            var msgHTML = "";

            //check the messageType to make sure it is a string
            if (typeof msgType !== "string") {
                logger.logError("generateUserMessageHTML only accepts msgType parameters of string");
                return "";
            }

            //Determine which HTML string to use based on the type
            switch (msgType.toLowerCase()) {
                case "error":
                    //generate the error HTML
                    msgHTML = "<div class='error-container " + (customClass || "") + "'><span class='error-text message-info-text'>" + (msgText || "") + "</span>" + (msgDetails || "") + "</div>";
                    break;
                case "warning":
                    //generate the warning HTML
                    msgHTML = "<div class='warning-container " + (customClass || "") + "'><span class='message-info-text'>" + (msgText || "") + "</span>" + (msgDetails || "") + "</div>";
                    break;
                case "information":
                    //generate the information HTML
                    msgHTML = "<div class='information-container " + (customClass || "") + "'><span class='message-info-text'>" + (msgText || "") + "</span>" + (msgDetails || "") + "</div>";
                    break;
                case "busy":
                    //generate the busy HTML
                    msgHTML = "<div class='busy-container " + (customClass || "") + "'><span class='message-info-text'>" + (msgText || "") + "</span>" + (msgDetails || "") + "</div>";
                    break;
                default:
                    msgHTML = "<div class='default-container " + (customClass || "") + "'><span class='message-info-text'>" + (msgText || "") + "</span>" + (msgDetails || "") + "</div>";
                    break;
            }
            return msgHTML;
        }
    };
}();
//Constants for CriterionFilter items
MP_Core.CriterionFilters.SEX_MEANING = 1;
MP_Core.CriterionFilters.DOB_OLDER_THAN = 2;
MP_Core.CriterionFilters.DOB_YOUNGER_THAN = 3;
MP_Core.CriterionFilters.ADMIN_SEX_MEANING = 4;
MP_Core.CriterionFilters.BIRTH_SEX_MEANING = 5;

MP_Core.AppUserPreferenceManager = function() {
    var m_criterion = null;
    var m_prefIdent = "";
    var m_jsonObject = null;

    //sets the gapcheck banner preference if user level preference set.
    var gapCheckBannerPreference = function(compObj,tempObj) {
        if (compObj.getGapCheckBannerDismiss() !== null) {
            tempObj.gapCheckBannerDismiss = compObj.getGapCheckBannerDismiss();
        }
    };
    var promiseQueue = Promise.resolve();

    return {
        /**
         * Allows for the initialization of the manager to store what criterion and preference identifier to
         * utilize for retrieval of preferences
         * @param {Object} criterion
         * @param {Object} preferenceIdentifier
         */
        Initialize: function(criterion, preferenceIdentifier) {
            m_criterion = criterion;
            m_prefIdent = preferenceIdentifier;
            m_jsonObject = {};
        },
        SetPreferences: function(prefString, viewId) {
            var viewIdentifier = viewId ? viewId : m_prefIdent;
            m_jsonObject[viewIdentifier] = MP_Core.AppUserPreferenceManager.isValidUserPref({
                artifactId: "mpage-core",
                functionName: "SetPreferences"
            },prefString);
        },
        LoadPreferences: function(viewId) {
            return new Promise(function(resolve, reject) {
                if (!m_criterion) {
                    logger.logError("Validation Failed: the AppUserPreferenceManager must be initialized prior to usage.");
                    reject();
                    return;
                }

                var prefIdent = viewId ? viewId : m_prefIdent;

                //If preferences have already been loaded just return
                if (m_jsonObject[prefIdent]) {
                    resolve(m_jsonObject[prefIdent]);
                    return;
                }

                var artifactInfo = {
                    artifactId: "mpage-core",
                    functionName: "LoadPreferences"
                };
                var prefRequest = new ScriptRequest();
                prefRequest.setProgramName("MP_GET_USER_PREFS");
                prefRequest.setArtifactInfo(artifactInfo);
                prefRequest.setParameterArray([ "^mine^", m_criterion.provider_id + ".0", "^" + prefIdent + "^", 3202020]);
                prefRequest.setResponseHandler(function(scriptReply) {
                    var status = scriptReply.getStatus();
                    var prefsResponse = scriptReply.getResponse();
                    if (status === "Z") {
                        resolve(null);
                        return;
                    }
                    else if (status === "S") {
                        m_jsonObject[prefIdent] = MP_Core.AppUserPreferenceManager.isValidUserPref(
                            artifactInfo,
                            prefsResponse.PREF_STRING,
                            prefRequest.getProgramName()
                        );
                        resolve(m_jsonObject[prefIdent]);
                    }
                    else {
                        logger.logError(scriptReply.getError());
                        reject(scriptReply.getError());
                    }
                });
                prefRequest.performRequest();
            });
        },
        /**
         * GetPreferences will return the users preferences for the application currently logged into.
         */
        GetPreferences: function(viewId) {
            var viewIdentifier = viewId ? viewId : m_prefIdent;
            if (!m_criterion) {
                return Promise.resolve(null);
            }
            if (!m_jsonObject[viewIdentifier]) {
                return this.LoadPreferences(viewIdentifier);  //eslint-disable-line new-cap
            }

            return Promise.resolve(m_jsonObject[viewIdentifier]);
        },
        SavePreferences: function(reload) {
            return new Promise(function(resolve, reject) {
                var body = document.body;
                var groups = Util.Style.g("col-group", body, "div");
                var grpId = 0;
                var colId = 0;
                var rowId = 0;
                var compId = 0;

                var jsonObject = {};
                jsonObject.user_prefs = {};
                var userPrefs = jsonObject.user_prefs;
                userPrefs.page_prefs = {};
                var pagePrefs = userPrefs.page_prefs;
                pagePrefs.components = [];
                pagePrefs.workspace_prefs = {};
                var components = pagePrefs.components;

                //alert("groups.length: " + groups.length)
                for (var x = 0, xl = groups.length; x < xl; x++) {
                    //TODO: be aware that when the organizer level component can be moved, this x+1 will need to be modified
                    grpId = x + 1;
                    //get liquid layout
                    var liqLay = Util.Style.g("col-outer1", groups[ x ], "div");
                    if (liqLay.length > 0) {
                        //get each child column
                        var cols = Util.gcs(liqLay[ 0 ]);
                        for (var y = 0, yl = cols.length; y < yl; y++) {
                            colId = y + 1;
                            var rows = Util.gcs(cols[ y ]);
                            for (var z = 0, zl = rows.length; z < zl; z++) {
                                var component = {};
                                rowId = z + 1;
                                compId = jQuery(rows[ z ]).attr("id");
                                var compObj = MP_Util.GetCompObjByStyleId(compId);  //eslint-disable-line new-cap
                                component.id = compObj.getComponentId();
                                component.group_seq = grpId;
                                component.col_seq = colId;
                                component.row_seq = rowId;
                                component.preferencesObj = compObj.getPreferencesObj();
                                //Add color if there was a user-level preference set.
                                if (compObj.getCompColor()) {
                                    component.compThemeColor = compObj.getCompColor();
                                }

                                gapCheckBannerPreference(compObj,component);
                                //Since we are updating the toggle status for all components we will need to make sure all required
                                //components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
                                //Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
                                //and not allow the user to toggle that component even though they should be able to.
                                component.toggleStatus = (compObj.getToggleStatus() === 2) ? 1 : compObj.getToggleStatus();
                                component.grouperFilterLabel = compObj.getGrouperFilterLabel();
                                component.grouperFilterCatLabel = compObj.getGrouperFilterCatLabel();
                                component.grouperFilterCriteria = compObj.getGrouperFilterCriteria();
                                component.grouperFilterCatalogCodes = compObj.getGrouperFilterCatalogCodes();
                                component.selectedTimeFrame = compObj.getSelectedTimeFrame();
                                component.selectedDataGroup = compObj.getSelectedDataGroup();
                                if (jQuery(rows[ z ]).hasClass("closed")) {
                                    component.expanded = false;
                                }
                                else {
                                    component.expanded = true;
                                }
                                components.push(component);
                            }
                        }
                    }
                }

                //Add all components with toggle status of 0.
                if (m_jsonObject[m_prefIdent] &&
                    m_jsonObject[m_prefIdent].user_prefs &&
                    m_jsonObject[m_prefIdent].user_prefs.page_prefs &&
                    m_jsonObject[m_prefIdent].user_prefs.page_prefs.components &&
                    m_jsonObject[m_prefIdent].user_prefs.page_prefs.components.length > 0) {
                    m_jsonObject[m_prefIdent].user_prefs.page_prefs.components.forEach(function (currentComponent) {
                        // In the below condition, groups.length more than zero in summary view and qoc view,
                        // but groups.length is zero in workflow since there is no div tag with 'col-group' class in the workflow view.
                        // toggleStatus indicates the bedrock preference of the component in the view as Off(0).
                        if ((groups.length && currentComponent.toggleStatus === 0) || !groups.length) {
                            components.push(currentComponent);
                        }
                    });
                }

                // Copy the workspace prefs to jsonObject.
                if (m_jsonObject[m_prefIdent] &&
                    m_jsonObject[m_prefIdent].user_prefs &&
                    m_jsonObject[m_prefIdent].user_prefs.page_prefs &&
                    m_jsonObject[m_prefIdent].user_prefs.page_prefs.workspace_prefs) {
                        jsonObject.user_prefs.page_prefs.workspace_prefs = m_jsonObject[m_prefIdent].user_prefs.page_prefs.workspace_prefs;
                }

                return WritePreferences(jsonObject, false, m_prefIdent)  //eslint-disable-line new-cap
                    .then(function(){
                        if (reload === undefined || reload) {
                            CERN_Platform.refreshMPage();
                        }
                        resolve();
                    }).catch(reject);

            });
        },
        ClearCompPreferences: function(componentId) {
            var compObj = MP_Util.GetCompObjById(componentId);  //eslint-disable-line new-cap
            var viewId = compObj.criterion.category_mean;
            var prefObj = m_jsonObject[viewId];
            var filterArr = null;
            var strEval = MP_Core.AppUserPreferenceManager.isValidUserPref({
                artifactId: "mp_core",
                functionName: "ClearCompPreferences"
            }, JSON.stringify(prefObj));

            if (strEval != null) { //eslint-disable-line eqeqeq
                var strObj = strEval.user_prefs.page_prefs.components;
                for (var x = strObj.length; x--;) {
                    if (strEval && strObj[ x ].id === componentId) {
                        strObj[ x ].grouperFilterLabel = "";
                        strObj[ x ].grouperFilterCatLabel = "";
                        strObj[ x ].grouperFilterCriteria = filterArr;
                        strObj[ x ].grouperFilterCatalogCodes = filterArr;

                        strObj[ x ].selectedTimeFrame = "";
                        strObj[ x ].selectedDataGroup = "";
                    }
                }
                compObj.setLookbackUnits(compObj.getBrLookbackUnits());
                compObj.setLookbackUnitTypeFlag(compObj.getBrLookbackUnitTypeFlag());
                compObj.setGrouperFilterLabel("");
                compObj.setGrouperFilterCatLabel("");
                compObj.setGrouperFilterCriteria(filterArr);
                compObj.setGrouperFilterCatalogCodes(filterArr);
                compObj.setSelectedTimeFrame("");
                compObj.setSelectedDataGroup("");
                compObj.setPreferencesObj(null);
                compObj.setGapCheckBannerDismiss(null);
                m_jsonObject[viewId] = strEval;
                return WritePreferences(m_jsonObject[viewId], false, viewId)  //eslint-disable-line new-cap
                    .then(function(){
                        //Use the component's render strategy to update the view after clearing settings
                        var renderStrategy = compObj.getRenderStrategy();
                        if (renderStrategy) {
                            var uniqueComponentId = renderStrategy.getComponentId();
                            var componentLookbackMenu = $("#lookbackContainer" + uniqueComponentId);
                            if (componentLookbackMenu.length) {
                                componentLookbackMenu.replaceWith(renderStrategy.createComponentLookback());
                            }

                            var componentFilterMenu = $("#filterDropDownMenu" + uniqueComponentId);
                            if (componentFilterMenu.length) {
                                componentFilterMenu.replaceWith(renderStrategy.createComponentFilter());
                            }
                        }

                        $(compObj.getSectionContentNode()).empty();
                        compObj.startComponentDataRetrieval();
                    });
            }
        },
        UpdatePrefsIdentifier: function(prefIdentifier) {
            if (prefIdentifier && typeof prefIdentifier === "string") {
                m_prefIdent = prefIdentifier;
            }
        },
        //Updates the component preferences from the components array passed into the function
        UpdateAllCompPreferences: function(componentArr, changePos, saveAsync) {
            var compId = 0;
            var compPrefs = null;
            var compPrefsCnt = 0;
            var compPrefsMap = {};
            var component = null;
            var componentDiv = null;
            var columnDiv = null;

            var namespace = "";
            var newPrefsInd = false;
            var prefObj = null;
            var prefIndx = 0;
            var tempObj = {};
            var x = 0;

            //If saveAsync is anything other then true set it to false
            if (!saveAsync) {
                saveAsync = false;
            }

            //Check the componentArr and make sure is is populated
            if (!componentArr || !componentArr.length) {
                return Promise.resolve();
            }

            //Create the prefs object if it doesnt already exist
            prefObj = m_jsonObject[componentArr[0].criterion.category_mean] || {
                user_prefs: {
                    page_prefs: {
                        components: []
                    }
                }
            };

            //Check to make sure the structure exists so we can populate it
            prefObj.user_prefs = prefObj.user_prefs || {
                page_prefs: {
                    components: []
                }
            };

            prefObj.user_prefs.page_prefs = prefObj.user_prefs.page_prefs || {
                components: []
            };

            prefObj.user_prefs.page_prefs.components = prefObj.user_prefs.page_prefs.components || [];
            compPrefs = prefObj.user_prefs.page_prefs.components;

            //Create a component map so we do not have to loop through the array for each component
            compPrefsCnt = compPrefs.length;
            for (x = compPrefsCnt; x--;) {
                compPrefsMap[ compPrefs[ x ].id ] = x;
            }

            //Loop through all of the components and update their preferences in the preferences object.
            compPrefsCnt = componentArr.length;
            for (x = compPrefsCnt; x--;) {
                component = componentArr[ x ];
                //Check to see if there is an existing preferences object
                if (typeof compPrefsMap[ component.getComponentId() ] !== "undefined") {
                    //Update exiting component preferences
                    prefIndx = compPrefsMap[ component.getComponentId() ];
                    tempObj = compPrefs[ prefIndx ];
                    newPrefsInd = false;
                }
                else {
                    tempObj = {};
                    newPrefsInd = true;
                }
                //Save the components basic settings
                tempObj.id = component.getComponentId();
                tempObj.group_seq = component.getPageGroupSequence();
                tempObj.col_seq = component.getColumn();
                tempObj.row_seq = component.getSequence();
                tempObj.preferencesObj = component.getPreferencesObj();
                //Since we are updating the toggle status for all components we will need to make sure all required
                //components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
                //Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
                //and not allow the user to toggle that component even though they should be able to.
                tempObj.toggleStatus = (component.getToggleStatus() === 2) ? 1 : component.getToggleStatus();
                tempObj.expanded = component.isExpanded();
                //Update the infoButton information
                tempObj.IsInfoButtonEnabled = component.isInfoButtonEnabled();
                if(component.getCompColor()){
                    tempObj.compThemeColor = component.getCompColor();
                }

                gapCheckBannerPreference(component,tempObj);

                if (component.getGrouperFilterLabel()) {
                    tempObj.grouperFilterLabel = component.getGrouperFilterLabel();
                }
                if (component.getGrouperFilterCriteria()) {
                    tempObj.grouperFilterCriteria = component.getGrouperFilterCriteria();
                }
                if (component.getGrouperFilterCatLabel()) {
                    tempObj.grouperFilterCatLabel = component.getGrouperFilterCatLabel();
                }
                if (component.getGrouperFilterCatalogCodes()) {
                    tempObj.grouperFilterCatalogCodes = component.getGrouperFilterCatalogCodes();
                }

                if (component.getSelectedTimeFrame()) {
                    tempObj.selectedTimeFrame = component.getSelectedTimeFrame();
                }
                if (component.getSelectedDataGroup()) {
                    tempObj.selectedDataGroup = component.getSelectedDataGroup();
                }

                //Push the new preferences object into the array
                if (newPrefsInd) {
                    compPrefs.push(tempObj);
                    //Update the mapping with the new element info
                    compPrefsMap[ tempObj.id ] = compPrefs.length - 1;
                }
            }

            //If the changePos flag has been set we will need to update the positions of all components without blowing away existing
            // preferences.
            if (changePos) {
                for (x = compPrefsCnt; x--;) {
                    component = componentArr[ x ];
                    namespace = component.getStyles().getNameSpace();
                    compId = component.getComponentId();
                    //Get component div, if the component is added to contextual view get their ghosted version.
                    if (component.isAddedToContextualView()  && MPageFusion.coreAPI.base.mediaQuery.atLeast("XL")) {
                        componentDiv = $("#" + namespace + compId + "PlaceholderView");
                    } else {
                        componentDiv = $("#" + namespace + compId);
                    }
                    if (componentDiv.length) {
                        //Get the preferences object
                        prefIndx = compPrefsMap[ component.getComponentId() ];
                        tempObj = compPrefs[ prefIndx ];
                        //Get the parent of that component container and find out which index it is located at and use that as the sequence.
                        columnDiv = componentDiv.parent();
                        tempObj.col_seq = columnDiv.index() + 1;
                        tempObj.row_seq = componentDiv.index();
                        //Save the new column and sequence back into the component
                        component.setColumn(tempObj.col_seq);
                        component.setSequence(tempObj.row_seq);
                    }
                }
            }

            //Save the preferences back to the preferences object.
            m_jsonObject[componentArr[0].criterion.category_mean] = prefObj;
            return WritePreferences(m_jsonObject[componentArr[0].criterion.category_mean], saveAsync, componentArr[0].criterion.category_mean);  //eslint-disable-line new-cap
        },
        UpdateSingleCompPreferences: function(componentObject, saveAsync) {
            return MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences([ componentObject ], false, saveAsync);  //eslint-disable-line new-cap
        },
        SaveCompPreferences: function(componentId, theme, expCol, changePos, infoButton) {
            return new Promise(function(resolve, reject){
                var compObj = MP_Util.GetCompObjById(componentId);  //eslint-disable-line new-cap
                var prefObj = m_jsonObject[compObj.criterion.category_mean];
                var noMatch = true;
                var x;
                var strEval = MP_Core.AppUserPreferenceManager.isValidUserPref({
                    artifactId: "mp_core",
                    functionName: "SaveCompPreferences"
                }, JSON.stringify(prefObj));

                if (strEval != null && !changePos) { //eslint-disable-line eqeqeq
                    var strObj = strEval.user_prefs.page_prefs.components;

                    for (x = strObj.length; x--;) {
                        if (strEval && strObj[ x ].id === componentId) {
                            noMatch = false;
                            if (theme) {
                                strObj[ x ].compThemeColor = theme;
                            }
                            if (expCol) {
                                if (expCol == "1") { //eslint-disable-line eqeqeq
                                    strObj[ x ].expanded = true;
                                }
                                else {
                                    strObj[ x ].expanded = false;
                                }
                            }

                            if (infoButton) {
                                if (infoButton == "1") {//eslint-disable-line eqeqeq
                                    strObj[ x ].IsInfoButtonEnabled = 1;
                                }
                                else {
                                    strObj[ x ].IsInfoButtonEnabled = 0;
                                }
                            }

                            gapCheckBannerPreference(compObj,strObj[ x ]);

                            if (compObj.getGrouperFilterLabel()) {
                                strObj[ x ].grouperFilterLabel = compObj.getGrouperFilterLabel();
                            }
                            if (compObj.getGrouperFilterCatLabel()) {
                                strObj[ x ].grouperFilterCatLabel = compObj.getGrouperFilterCatLabel();
                            }
                            // Update grouperFilterCriteria even when it is set to null so that stale value
                            // is cleared from the database
                            if (compObj.getGrouperFilterCriteria() || compObj.getGrouperFilterCriteria() === null) {
                                strObj[ x ].grouperFilterCriteria = compObj.getGrouperFilterCriteria();
                            }
                            if (compObj.getGrouperFilterCatalogCodes() || compObj.getGrouperFilterCatalogCodes() === null) {
                                strObj[ x ].grouperFilterCatalogCodes = compObj.getGrouperFilterCatalogCodes();
                            }
                            else {
                                strObj[ x ].grouperFilterCatalogCodes = [];
                            }

                            if (compObj.getSelectedTimeFrame()) {
                                strObj[ x ].selectedTimeFrame = compObj.getSelectedTimeFrame();
                            }
                            if (compObj.getSelectedDataGroup()) {
                                strObj[ x ].selectedDataGroup = compObj.getSelectedDataGroup();
                            }
                            //Save the components toggle status and the column and sequence information
                            //Since we are updating the toggle status for all components we will need to make sure all required
                            //components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
                            //Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
                            //and not allow the user to toggle that component even though they should be able to.
                            strObj[ x ].toggleStatus = (compObj.getToggleStatus() === 2) ? 1 : compObj.getToggleStatus();
                            strObj[ x ].col_seq = compObj.getColumn();
                            strObj[ x ].row_seq = compObj.getSequence();
                            strObj[ x ].preferencesObj = compObj.getPreferencesObj();
                        }
                    }

                    if (noMatch) {//single comp change but comp doesn't have user prefs
                        var tempObj = {};
                        tempObj.id = componentId;
                        tempObj.group_seq = compObj.getPageGroupSequence();
                        tempObj.col_seq = compObj.getColumn();
                        tempObj.row_seq = compObj.getSequence();
                        tempObj.preferencesObj = compObj.getPreferencesObj();
                        tempObj.compThemeColor = theme;

                        gapCheckBannerPreference(compObj,tempObj);

                        if (compObj.getGrouperFilterLabel()) {
                            tempObj.grouperFilterLabel = compObj.getGrouperFilterLabel();
                        }
                        if (compObj.getGrouperFilterCriteria()) {
                            tempObj.grouperFilterCriteria = compObj.getGrouperFilterCriteria();
                        }
                        if (compObj.getGrouperFilterCatLabel()) {
                            tempObj.grouperFilterCatLabel = compObj.getGrouperFilterCatLabel();
                        }
                        if (compObj.getGrouperFilterCatalogCodes()) {
                            tempObj.grouperFilterCatalogCodes = compObj.getGrouperFilterCatalogCodes();
                        }

                        if (compObj.getSelectedTimeFrame()) {
                            tempObj.selectedTimeFrame = compObj.getSelectedTimeFrame();
                        }
                        if (compObj.getSelectedDataGroup()) {
                            tempObj.selectedDataGroup = compObj.getSelectedDataGroup();
                        }
                        //Save the components toggle status
                        //Since we are updating the toggle status for all components we will need to make sure all required
                        //components get marked as On(1) and not required(2).  Because if the bedrock preferences change from
                        //Required to On for a component the existing user prefs toggle status of Required will override the bedrock preference
                        //and not allow the user to toggle that component even though they should be able to.
                        tempObj.toggleStatus = (compObj.getToggleStatus() === 2) ? 1 : compObj.getToggleStatus();

                        tempObj.expanded = compObj.isExpanded();
                        strObj.push(tempObj);
                    }
                    m_jsonObject[compObj.criterion.category_mean] = strEval;
                    return WritePreferences(m_jsonObject[compObj.criterion.category_mean], false, compObj.criterion.category_mean) //eslint-disable-line new-cap
                        .then(resolve)
                        .catch(reject);
                }
                else {
                    if (compObj) {
                        if (theme && compObj.setCompColor) {
                            compObj.setCompColor(theme);
                        }
                        if (expCol && compObj.setExpandCollapseState) {
                            compObj.setExpandCollapseState(expCol == "1"); //eslint-disable-line eqeqeq
                        }
                        if (infoButton && compObj.setIsInfoButtonEnabled) {
                            compObj.setIsInfoButtonEnabled(infoButton == "1" ? 1 : 0); //eslint-disable-line eqeqeq
                        }
                        return MP_Core.AppUserPreferenceManager.UpdateSingleCompPreferences(compObj); //eslint-disable-line new-cap
                    }
                }
            });
        },
        ClearPreferences: function(viewId) {
            // Launch the Pending Data Modal if any pending actions exist for the component(s) in the current view.
            // Otherwise, continue to clear the View level preferences and refresh the active view.
            MP_PendingData.launchPendingDataDialog(MP_PendingData.requestLevel.VIEW, function(){
                WritePreferences(null, false, viewId) //eslint-disable-line new-cap
                    .then(function(){
                        //Refresh the active view when we'll do soft refresh.
                        MP_Viewpoint.refreshActiveView();
                    });
            });
        },

        /**
        * This function is responsible for validating user preference json String.
        * @param {Object} artifactDetails - contains functionName and artifact id.
        * @param {Object} prefString - user preference json data.
        * @param {String} programName - ccl script name.
        * @returns {Object | null} - The Object corresponding to the given JSON text or null.
        */
        isValidUserPref: function(artifactDetails, prefString, programName){
            var parsedString = null;
            try{
                parsedString = JSON.parse(prefString);
            }catch(sTrace){
                var criterion = CERN_Platform.getCriterion().CRITERION;
                var errorContextCapTimer = new CapabilityTimer(
                    "CAP:MPG_Component_Level_Error_Details",
                    artifactDetails && artifactDetails.artifactId
                        ? artifactDetails.artifactId
                        : "No Additional Info"
                );
                var errorInfo = {
                    artifactInfo: artifactDetails || null,
                    script: programName || ""
                };
                var contextInfo = {
                    VIEW: criterion.CATEGORY_MEAN,
                    VIEW_POINT: (typeof m_viewpointJSON !== "undefined" && m_viewpointJSON) ? JSON.parse(m_viewpointJSON).VP_INFO.VIEWPOINT_NAME : "",
                    PERSON_ID: criterion.PERSON_ID,
                    ENCNTRS: criterion.ENCNTRS,
                    PRSNL_ID: criterion.PRSNL_ID,
                    POSITION_CD: criterion.POSITION_CD,
                    PPR_CD: criterion.PPR_CD,
                    LOGICAL_DOMAIN_ID: criterion.LOGICAL_DOMAIN_ID,
                    USER: criterion.USERNAME,
                    APP_NAME: criterion.EXECUTABLE ? criterion.EXECUTABLE.split(".")[0] : "",
                    RELEASE_VERSION: criterion.RELEASE_VERSION
                };
                if("WORKLIST_RELEASE_VERSION" in criterion) {
                    contextInfo.WORKLIST_RELEASE_VERSION = criterion.WORKLIST_RELEASE_VERSION;
                }
                //Capture the error in Lights On
                errorContextCapTimer.addMetaData("err", JSON.stringify(errorInfo));
                errorContextCapTimer.addMetaData("context", JSON.stringify(contextInfo));
                errorContextCapTimer.addMetaData("sTrace", sTrace.name + ": " + sTrace.message);
                errorContextCapTimer.capture();
                // Also log content to blackbird
                new ScriptRequest().logErrorCaptureDetails("JSON Parsing Error", errorInfo, contextInfo, sTrace.message);
            }
            return parsedString;
        },

        /**
         * Returns the json object associated to the primary div id of the component.
         * It is assumed LoadPreferences has been called prior to execution.
         *
         * @param {Object} id - The ID that we're trying to match with a component.
         *
         * @returns {MPageComponent|null} The matching component, if found. Otherwise, null.
         *
         * @public
         */
        GetComponentById: function(id, viewId) {
            var viewIdentifier = viewId ? viewId : m_prefIdent;
            var match = null;
            // If anything goes wrong within the try block, we'll just return null.
            try {
                m_jsonObject[viewIdentifier].user_prefs.page_prefs.components.some(function(component) {
                    if (component.id == id) { //eslint-disable-line eqeqeq
                        match = component;
                        return true;
                    }
                });
            }
            catch (err) {
                // Stop error propagation
            }
            finally {
                return match;
            }
        }
    };

    function WritePreferences(jsonObject, saveAsync, viewId) {
        var inEdge = CERN_Platform.inEdgeContext();
        var isAsync = inEdge || !!saveAsync;
        function save(){
            return new Promise(function(resolve, reject) {
                var prefs = (jsonObject != null) ? JSON.stringify(jsonObject) : ""; //eslint-disable-line eqeqeq
                var artifactInfo = {
                    artifactId: "mpage-core",
                    functionName: "WritePreferences"
                };
                //Create the script request and perform it
                var prefIdent = viewId ? viewId : m_prefIdent;
                var prefRequest = new ScriptRequest();
                prefRequest.setProgramName("MP_MAINTAIN_USER_PREFS");
                prefRequest.setArtifactInfo(artifactInfo);
                // Always behave asynchronously in edge, allow for synchronous requests if specified in edge
                prefRequest.setAsyncIndicator(isAsync); // eslint-disable-line chromium-errors
                prefRequest.setParameterArray([ "^mine^", m_criterion.provider_id + ".0", "^" + prefIdent + "^", "~" + prefs + "~", 3202020]);
                prefRequest.setResponseHandler(function(scriptReply) {
                    var status = scriptReply.getStatus();

                    if (status === "Z") {
                        m_jsonObject[prefIdent] = null;
                    }
                    else if (status === "S") {
                        m_jsonObject[prefIdent] = jsonObject;
                    }
                    else {
                        logger.logError(scriptReply.getError());
                        reject(scriptReply.getError());
                    }
                    resolve();
                });
                prefRequest.performRequest();
            });
        }
        if (isAsync){
            var saveRequest = promiseQueue.then(save);
            promiseQueue = saveRequest.catch(function() {
                logger.logError("Failed to save user preferences.");
            });
            var currPromise = promiseQueue;
            return currPromise
                .finally(function() {
                    if (currPromise === promiseQueue) {
                        // Avoid memory leaks by clearing queue if no other requests in progess
                        promiseQueue = Promise.resolve();
                    }
                });
        }
        return save();
    }
}();

/**
 * @namespace
 */
var MP_Util = function() { //eslint-disable-line no-redeclare
    var m_df = null;
    var m_nf = null;
    var m_codeSets = [];
    /**
     * Logs error details, if any, thrown in LaunchClinNoteViewer function
     * @param {error} err - error details to be logged
     */
    function HandleLaunchClinNoteViewerError(err) {
        logger.logJSError(err, null, "mp_core.js", "LaunchClinNoteViewer");
        alert(i18n.discernabu.CAN_NOT_VIEW_RESULTS + "  " + i18n.CONTACT_ADMINISTRATOR); //eslint-disable-line no-alert
    };
    return {
        addComponentsToGlobalStorage: function(components) {
            //If you try to add nothing, just return
            if (!components || !components.length) {
                return;
            }
            //If for some reason the global component storage is null, new it up
            if (CERN_MPageComponents === null) {
                CERN_MPageComponents = [];
            }
            //Store this view's components in the global component list
            for (var x = 0, xl = components.length; x < xl; x++) {
                if (components[ x ]) {
                    CERN_MPageComponents.push(components[ x ]);
                }
            }
        },
        removeComponentsFromGlobalStorage: function(components) {
            // If you try to remove nothing, just return
            if (!components || !components.length || !CERN_MPageComponents) {
                return;
            }

            // remove components from CERN_MPageComponents
            components.forEach( function (componentObj) {
                var index = CERN_MPageComponents.indexOf(componentObj);
                if (index !== -1) {
                    CERN_MPageComponents.splice(index, 1);
                }
            });
        },
        GetComponentArray: function(components) {
            var grpAr = [];
            var colAr = [];
            var rowAr = [];
            var curCol = -1;
            var curGrp = -1;

            //first layout the group/columns/rows of components
            if (components != null) { //eslint-disable-line eqeqeq
                components.sort(SortMPageComponents);

                for (var x = 0, xl = components.length; x < xl; x++) {
                    var component = components[ x ];

                    if (component.isDisplayable()) {//based on filter logic, only display if criteria is met
                        var compGrp = component.getPageGroupSequence();
                        var compCol = component.getColumn();

                        if (compGrp != curGrp) { //eslint-disable-line eqeqeq
                            curCol = -1;
                            colAr = [];
                            grpAr.push(colAr);
                            curGrp = compGrp;
                        }

                        if (compCol != curCol) { //eslint-disable-line eqeqeq
                            rowAr = [];
                            colAr.push(rowAr);
                            curCol = compCol;
                        }
                        rowAr.push(component);
                    }
                }
            }
            return grpAr;
        },
        /**
         * Helper utility to retrieve the <code>Criterion</code> Object generated from the provide JSON
         * @param js_criterion  The JSON associated to the criterion data that is to be loaded
         * @param static_content  The <code>String</code> location in which the static content resides
         */
        GetCriterion: function(js_criterion, static_content) {
            logger.logDebug("Criterion: " + JSON.stringify(js_criterion));
            var jsCrit = js_criterion.CRITERION;
            if (jsCrit && !jsCrit.RELEASE_VERSION && window.releaseInfo) {
                jsCrit.RELEASE_IDENTIFIER = window.releaseInfo.mpagesCoreReleaseIdentifier || "";
                jsCrit.RELEASE_VERSION = window.releaseInfo.mpagesCoreReleaseVersion || "";
                if (window.releaseInfo.mode === "^ORG^") {
                    jsCrit.WORKLIST_RELEASE_IDENTIFIER = window.releaseInfo.mpagesOrganizerReleaseIdentifier || "";
                    jsCrit.WORKLIST_RELEASE_VERSION = window.releaseInfo.mpagesOrganizerReleaseVersion || "";
                }
            }
            var criterion = new MP_Core.Criterion(jsCrit, static_content);
            var codeArray = MP_Util.LoadCodeListJSON(jsCrit.CODES); //eslint-disable-line new-cap
            var jsPatInfo = jsCrit.PERSON_INFO;
            var patInfo = new MP_Core.PatientInformation();
            patInfo.setName(jsPatInfo.PERSON_NAME);
            patInfo.setSex(MP_Util.GetValueFromArray(jsPatInfo.SEX_CD, codeArray)); //eslint-disable-line new-cap
            patInfo.setAdminSex(MP_Util.GetValueFromArray(jsPatInfo.ADMIN_SEX_CD, codeArray)); //eslint-disable-line new-cap
            patInfo.setBirthSex(MP_Util.GetValueFromArray(jsPatInfo.BIRTH_SEX_CD, codeArray)); //eslint-disable-line new-cap
            if (jsPatInfo.ABS_DOB != undefined && jsPatInfo.ABS_DOB != "") { //eslint-disable-line eqeqeq
                var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})" +"(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\.([0-9]+))?)?" +"Z?)?)?)?"; // eslint-disable-line space-infix-ops
                var d = jsPatInfo.ABS_DOB.match(new RegExp(regexp));
                var dt = new Date(d[ 1 ], d[3] - 1, d[5],d[7],d[8],d[10]);
                patInfo.setDOB(dt);
            }
            criterion.setPatientInfo(patInfo);
            return criterion;
        },
        /**
         * Calculates the within time from the provide date and time.
         * @param dateTime  The <code>Date</code> Object in which to calculate the within time
         * @returns <code>String</code> representing the time that has passed from the provided date and time
         */
        CalcWithinTime: function(dateTime) {
            return (GetDateDiffString(dateTime, null, null, true)); //eslint-disable-line new-cap
        },
        /**
         * Calculates the age of a patient from a given point in time.  If the point in time is not provided, the current date/time is
         * utilized
         * @param birthDt  The <code>Date</code> Object in which to calculate the age of the patient
         * @param fromDate  The <code>Date</code> Object in which to calculate the age of the patient from.  This is useful in
         * cases
         * where the patient is deceased and the date utilized is the deceased date.
         * @returns <code>String</code> representing the age of the patient
         */
        CalcAge: function(birthDt, fromDate) {
            //If from Date is null (not passed in) then set to current Date
            fromDate = (fromDate) ? fromDate : new Date();
            return (GetDateDiffString(birthDt, fromDate, 1, false)); //eslint-disable-line new-cap
        },
        /**
         * Display the date and time based on the configuration of the component
         * @param component  The component in which holds the configuration for the date formatting
         * @param date  The date in which to properly format
         * @returns <code>String</code> representing the date and time of the date provided
         */
        DisplayDateByOption: function(component, date) {
            var df = MP_Util.GetDateFormatter(); //eslint-disable-line new-cap
            switch (component.getDateFormat()) {
                case 1:
                    return (df.format(date, mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR));
                case 2:
                    return (df.format(date, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR));
                case 3:
                    return (MP_Util.CalcWithinTime(date)); //eslint-disable-line new-cap
                case 4:
                    //Display No Date.  Additional logic will need to be applied to hide column.
                    return ("&nbsp");
                default:
                    return df.format(date, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR);
            }
        },
        LaunchMenu: function(menuId, componentId) {
            var menu = _g(menuId);
            MP_Util.closeMenuInit(menu, componentId);
            if (menu != null) {  //eslint-disable-line eqeqeq
                if (Util.Style.ccss(menu, "menu-hide")) {
                    _g(componentId).style.zIndex = 2;
                    Util.Style.rcss(menu, "menu-hide");
                }
                else {
                    _g(componentId).style.zIndex = 1;
                    Util.Style.acss(menu, "menu-hide");
                }
            }
        },
        LaunchCompFilterSelection: function(compId, eventSetIndex, applyFilterInd) {
            var component = MP_Util.GetCompObjById(compId); //eslint-disable-line new-cap
            var i18nCore = i18n.discernabu;
            var style = component.getStyles();
            var ns = style.getNameSpace();
            var mnuDisplay;
            var newFilterAppliedSpan;
            var filterAppliedArr;
            var lbDropDownDiv;

            if (eventSetIndex === -1) {
                mnuDisplay = i18nCore.FACILITY_DEFINED_VIEW;
            }
            else {
                if (ns === "ohx" || ns === "ohx2") {
                    mnuDisplay = component.getGrouperCatLabel(eventSetIndex).toString();
                }
                else {
                    mnuDisplay = component.getGrouperLabel(eventSetIndex).toString();
                }
            }
            var dispVar = i18nCore.FACILITY_DEFINED_VIEW;
            var styleId = style.getId();
            var loc = component.getCriterion().static_content;
            var mnuId = styleId + "TypeMenu";
            var z = 0;

            if (ns === "ohx" || ns === "ohx2") {
                var catCodeList = component.getGrouperCatalogCodes(eventSetIndex);
            }
            else {
                var eventSetList = component.getGrouperCriteria(eventSetIndex);
            }

            //Set component prefs variables with filter settings
            if (ns === "ohx" || ns === "ohx2") {
                component.setGrouperFilterCatLabel(mnuDisplay);
            }
            else {
                component.setGrouperFilterLabel(mnuDisplay);
            }
            if (mnuDisplay !== dispVar) {

                if (ns === "ohx" || ns === "ohx2") {
                    component.setGrouperFilterCatalogCodes(catCodeList);
                }
                else {
                    component.setGrouperFilterCriteria(eventSetList);
                }

            }
            else {
                component.setGrouperFilterCriteria(null);
                component.setGrouperFilterCatalogCodes(null);
            }

            //Find Filter Applied msg span and replace it only if the Facility defined view is not selected
            var filterAppliedSpan = _g("cf" + compId + "msg");
            if (filterAppliedSpan) {
                // Remove the old span element
                Util.de(filterAppliedSpan);
            }
            if (mnuDisplay !== dispVar) {
                newFilterAppliedSpan = Util.ce("span");
                filterAppliedArr = [ "<span id='cf", compId, "msg' class='filter-applied-msg' title='", mnuDisplay, "'>", i18nCore.FILTER_APPLIED, "</span>" ];
                newFilterAppliedSpan.innerHTML = filterAppliedArr.join("");
                lbDropDownDiv = _g("lbMnuDisplay" + compId);
                Util.ia(newFilterAppliedSpan, lbDropDownDiv);
            }
            else {
                newFilterAppliedSpan = Util.ce("span");
                filterAppliedArr = [ "<span id='cf", compId, "msg' class='filter-applied-msg' title=''></span>" ];
                newFilterAppliedSpan.innerHTML = filterAppliedArr.join("");
                lbDropDownDiv = _g("lbMnuDisplay" + compId);
                Util.ia(newFilterAppliedSpan, lbDropDownDiv);
            }

            //Find the content div
            var contentDiv = _g("Accordion" + compId + "ContentDiv");
            contentDiv.innerHTML = "";

            //Create the new content div innerHTML with the select list
            var contentDivArr = [];
            contentDivArr.push("<div id='cf", mnuId, "' class='acc-mnu'>");
            contentDivArr.push("<span id='cflabel", compId, "' onclick='MP_Util.LaunchMenu(\"", mnuId, "\", \"", styleId, "\");'>", i18nCore.FILTER_LABEL, mnuDisplay, "<a id='compFilterDrop", compId, "'><img src='", loc, "/images/3943_16.gif'></a></span>");
            contentDivArr.push("<div class='cvClassFilterSpan lb-mnu-selectWindow lb-menu2 menu-hide' id='", mnuId, "'><div class='acc-mnu-contentbox'>");
            contentDivArr.push("<div><span id='cf", styleId, "' class='cf-mnu' onclick='MP_Util.LaunchCompFilterSelection(", compId, ",-1,1);'>", i18nCore.FACILITY_DEFINED_VIEW, "</span></div>");

            var groupLen = component.m_grouper_arr.length;
            for (z = 0; z < groupLen; z++) {
                if (component.getGrouperLabel(z)) {
                    contentDivArr.push("<div><span id='cf", styleId, z, "' class='cf-mnu' onclick='MP_Util.LaunchCompFilterSelection(", compId, ",", z, ",1);'>", component.getGrouperLabel(z).toString(), "</span></div>");
                }
                if (component.getGrouperCatLabel(z)) {
                    contentDivArr.push("<div><span id='cf", styleId, z, "' class='cf-mnu' onclick='MP_Util.LaunchCompFilterSelection(", compId, ",", z, ",1);'>", component.getGrouperCatLabel(z).toString(), "</span></div>");
                }
            }
            contentDivArr.push("</div></div></div>");
            contentDiv.innerHTML = contentDivArr.join("");

            if (applyFilterInd === 1) {
                if (mnuDisplay === i18nCore.FACILITY_DEFINED_VIEW) {
                    component.startComponentDataRetrieval();
                }
                else {

                    if (ns === "ohx" || ns === "ohx2") {
                        component.FilterRefresh(mnuDisplay, catCodeList); //eslint-disable-line new-cap
                    }
                    else {
                        component.FilterRefresh(mnuDisplay, eventSetList); //eslint-disable-line new-cap
                    }

                }
            }
        },
        closeMenuInit: function(inMenu, compId) {
            var menuId;
            var docMenuId = compId + "Menu";
            var lbMenuId = compId + "Mnu";
            var cfMenuId = compId + "TypeMenu";

            var menuLeave = function(e) {
                if (!e) {
                    e = window.event;
                }
                if (e.relatedTarget.id == inMenu.id) {  //eslint-disable-line eqeqeq
                    Util.Style.acss(inMenu, "menu-hide");
                }
                e.stopPropagation();
                Util.cancelBubble(e);
            };
            if (inMenu.id == docMenuId || inMenu.id == lbMenuId || inMenu.id == cfMenuId) { //eslint-disable-line eqeqeq
                menuId = compId;
            }
            if (!e)
                var e = window.event;
            if (window.attachEvent) {
                Util.addEvent(inMenu, "mouseleave", function() {
                    Util.Style.acss(inMenu, "menu-hide");
                    _g(menuId).style.zIndex = 1;
                });
            }
            else {
                Util.addEvent(inMenu, "mouseout", menuLeave);
            }
        },
        /**
         * Provides the ability to construct the text that is to be placed after the label of the Component.
         * Each component defines whether or not the number of items within the component should be displayed
         * in the title of the component.  This is a requirements decision and will have to be answered upon creation
         * of the component.  In addition, the lookback units and scope have been moved to the
         * subtitle text line and are no longer necessary in the title text.
         *
         * The requirement is for each component to define whether or not the contract exists to display a number of items
         * within the component header.  The reason for this contract is when 'no results found' is displayed, the count of zero
         * must be displayed to indicate to the user if there are items within the component.  As for components who do not display
         * a count, the user will still have to manually open the component to determine whether or not data exists.
         *
         * TODO: The future thought is that in the case of 'no results found' or 'error retrieving data', an additional indicator
         * will be added to the component in some manner to indicate the status.  This is important with components such as Laboratory
         * and Vitals for examples where the count of items is not displayed within the title text.
         *
         * @param component The {@see MPageComponent} in which to add the title text within.
         * @param nbr The count of the list items displayed within the component
         * @param optionalText Optional text to allow each consumer to place text within the header of the component.
         */
        CreateTitleText: function(component, nbr, optionalText) {
            var ar = [];
            if (component.isLineNumberIncluded()) {
                ar.push("(", nbr, ")");
            }
            if (optionalText && optionalText !== "") {
                ar.push(" ", optionalText);
            }
            return ar.join("");
        },
        /**
         * A helper utility to determine if a content body should be considered scrollable
         * @param component  The component in which is being evaluated
         * @param nbr  The number of items in which to consider scrolling enabled
         */
        GetContentClass: function(component, nbr) {
            if (component.isScrollingEnabled()) {
                var scrollNbr = component.getScrollNumber();
                if (nbr > scrollNbr && scrollNbr > 0) {
                    return "content-body scrollable";
                }
            }
            return "content-body";
        },
        /**
         * CreateTimer will create a SLA timer and start the timer prior to returning.
         * @param {String} timerName The timer name to start
         * @param {String} subTimerName The subtimer name to start
         * @param {String} metaData1
         * @param {String} metaData2
         * @param {String} metaData3
         */
        CreateTimer: function(timerName, subTimerName, metaData1, metaData2, metaData3) {
            var rtmsTimer = new RTMSTimer(timerName, subTimerName).addMetaData("rtms.legacy.metadata.1", metaData1 || null).addMetaData("rtms.legacy.metadata.2", metaData2 || null).addMetaData("rtms.legacy.metadata.3", metaData3 || null);
            rtmsTimer.start();
            return rtmsTimer;
        },
        /**
         * Retrieves the code values for a given code set
         * @param {number} codeSet The code set in which to retrieve
         * @param {boolean} async A boolean value indicating if the script call should be asynchronous.
         * @returns A list of code from the code set
         */
        GetCodeSet: function(codeSet, async) { // eslint-disable-line chromium-errors
            var codes = [];
            var artifactInfo = {
                artifactId: "mpage-core",
                functionName: "GetCodeSet"
            };
            var codeSetRequest = new ScriptRequest();
            codeSetRequest.setProgramName("MP_GET_CODESET");
            codeSetRequest.setArtifactInfo(artifactInfo);
            codeSetRequest.setParameterArray([ "^MINE^", codeSet + ".0" ]);
            codeSetRequest.setAsyncIndicator(async); // eslint-disable-line chromium-errors
            codeSetRequest.setResponseHandler(function(dataReply) {
                var codeSetObj = dataReply.getResponse();
                if (dataReply.getStatus() === "S") {
                    codes = MP_Util.LoadCodeListJSON(codeSetObj.CODES); //eslint-disable-line new-cap
                }
            });
            codeSetRequest.performRequest();
            return codes;
        },
        /**
         * Retrieves the code values for a given code set asynchronously and returns the
         * source codes. If the codes are in the Shared Resource then the query to MP_GET_CODESET
         * is not made
         *
         * @param {number} codeSet The code set in which to retrieve
         * @param {Function} Callback function called when the code set values are retrieved
         */

        GetCodeSetAsync: function(codeSet, successCallbackFunction, errorCallbackFunction) {
            try {
                var codes = [];
                var resourceName = "CODESET_" + codeSet + ".0";
                //Check for the codes in Shared Resource
                var codeSetToken = MP_Resources.getSharedResource(resourceName);
                if (codeSetToken && codeSetToken.isResourceAvailable()) {
                    successCallbackFunction(codeSetToken.getResourceData());
                }
                else {
                    var artifactInfo = {
                        artifactId: "mpage-core",
                        functionName: "GetCodeSetAsync"
                    };
                    var codeSetRequest = new ScriptRequest();
                    codeSetRequest.setProgramName("MP_GET_CODESET");
                    codeSetRequest.setArtifactInfo(artifactInfo);
                    codeSetRequest.setParameterArray([ "^MINE^", codeSet + ".0" ]);
                    codeSetRequest.setResponseHandler(function(dataReply) {
                        var codeSetObj = dataReply.getResponse();
                        if (codeSetObj && dataReply.getStatus() === "S") {
                            codes = codeSetObj.CODES;
                            codeSetToken = new SharedResource(resourceName);
                            if (codeSetToken) {
                                codeSetToken.setResourceData(codes);
                                codeSetToken.setIsAvailable(true);
                                MP_Resources.addSharedResource(resourceName, codeSetToken);
                            }
                            successCallbackFunction(codes);
                        }
                        else if (dataReply.getStatus() === "Z") {
                            logger.logError("No source codes retrieved, Code Set: " + codeSet);
                            if (errorCallbackFunction) {
                                errorCallbackFunction(dataReply);
                            }
                        }
                        else {
                            logger.logError("There was an error retrieving source codes, Code Set: " + codeSet);
                            if (errorCallbackFunction) {
                                errorCallbackFunction(dataReply);
                            }
                        }
                    });
                    codeSetRequest.performRequest();
                }
            }
            catch (err) {
                logger.logJSError(err, null, "mp_core.js", "GetCodeSetAsync");
            }
        },

        /**
         * Will return a Promise resolving with a code value objects contained in the given code set.
         * @param {number} codeSet The codeset to retrieve the code value from
         * @returns {Promise<Array>} Promise that resolves with list of code value object
         */
        GetCodeSetP: function(codeSet) {
            return new Promise(function(resolve, reject){
                MP_Util.GetCodeSetAsync(codeSet, resolve, reject); //eslint-disable-line new-cap
            });
        },

        /**
         * Will return a code object from the mapped list by the cdf_meaning
         * @param mapCodes  The map of code values to search
         * @param meaning  The cdf_meaning of the code value to search
         * @returns The code object associated to the cdf_meaning provides.  Else null
         */
        GetCodeByMeaning: function(mapCodes, meaning) {
            for (var x = mapCodes.length; x--;) {
                var code = mapCodes[ x ].value;
                if (code.meaning == meaning)  //eslint-disable-line eqeqeq
                    return code;
            }
            return null;
        },
        GetCodeValueByMeaning: function(meaning, codeSet) { // eslint-disable-line chromium-errors
            var list = m_codeSets[ codeSet ];
            if (!list) {
                list = m_codeSets[ codeSet ] = MP_Util.GetCodeSet(codeSet, false);  // eslint-disable-line new-cap, chromium-errors
            }
            if (list && list.length > 0) {
                for (var x = list.length; x--;) {
                    var code = list[ x ].value;
                    if (code.meaning === meaning) {
                        return code;
                    }
                }
            }
            return null;
        },
        /**
         * Will return a Promise resolving with a code object with the given meaning
         * @param {string} meaning The CDF_MEANING to identify
         * @param {number} codeSet The codeset to retrieve the code value from
         * @returns {Promise} Promise that resolves with code value object or null if not found
         */
        GetCodeValueByMeaningP: function(meaning, codeSet) {
            return MP_Util.GetCodeSetP(codeSet) //eslint-disable-line new-cap
                .then(function(codes){
                    var matchingCode = MP_Util.GetCodeByMeaning(MP_Util.LoadCodeListJSON(codes), meaning); //eslint-disable-line new-cap
                    if (matchingCode) {
                        return matchingCode;
                    }
                    return null;
                });
        },
        /**
         * Will search for a value within the provided mapped array and return the value associated to the name/value pair
         * @param mapItems  The mapped array of items to search through
         * @param item  The item in which to search
         * @returns The value from the name/value pair
         */
        GetItemFromMapArray: function(mapItems, item) {
            for (var x = 0; x < mapItems.length; x++) {
                if (mapItems[ x ].name == item)  //eslint-disable-line eqeqeq
                    return mapItems[ x ].value;
            }
        },
        /**
         * Add an item to the array of items associated to the map key
         * @param mapItems  The map array to search within
         * @param key  The primary key that will be searching for within the map array
         * @param value  The object that is to be added to the map array
         */
        AddItemToMapArray: function(mapItems, key, value) {
            var ar = MP_Util.GetItemFromMapArray(mapItems, key); //eslint-disable-line new-cap
            if (!ar) {
                ar = [];
                mapItems.push(new MP_Core.MapObject(key, ar));
            }
            ar.push(value);
        },

        CreateClinNoteLink: function(patient_id, encntr_id, event_id, display, docViewerType, pevent_id) {
            var docType = (docViewerType && docViewerType > "") ? docViewerType : "STANDARD";
            var doclink = "";
            if (event_id > 0) {
                var ar = [];
                ar.push(patient_id, encntr_id, event_id, "\"" + docType + "\"", pevent_id);
                doclink = "<a onclick='javascript:MP_Util.LaunchClinNoteViewer(" + ar.join(",") + "); return false;' href='#'>" + display + "</a>";
            }
            else {
                doclink = display;
            }
            return (doclink);
        },

        /**
         * Sorting by Collation Sequence: The sortBySequence function will return a flag either -1,0, or 1 according to the SEQUENCE field
         *
         * @param {item a, item b} a,b are two items whose SEQUENCE field will be compared to each other
         * @returns {integer} 0 if SEQUENCE is equal, 1 if item a's SEQUENCE is greater than item B's SEQUENCE, -1 if
         * less
         */
        SortBySequence: function(a, b) {
            try {
                var aSeq = a.SEQUENCE;
                var bSeq = b.SEQUENCE;

                // If the sequence is not defined then the value is either 0 or nothing, it would take the alternate route
                if (a.SEQUENCE) {
                    if (aSeq > bSeq) {
                        return 1;
                    }
                    else {
                        if (aSeq < bSeq) {
                            return -1;
                        }
                        return 0;
                    }
                }
            }
            catch (err) {
                MP_Util.LogJSError(err, this, "mp_core.js", "sortBySequence"); //eslint-disable-line new-cap
            }
        },

        /**
         * Retrieves a document for viewing via the MPages RTF viewer
         * @param {Object} eventId The parent or child event id for retrieval
         * @param {Object} docViewerType
         * 0: Parent Event Id retrieval of child event blobs
         * 1: Event Id blob retrieval
         * 2: Long text retrieval
         * 3: Micro Detail retrieval
         * 4: Anatomic Pathology retrieval
         */
        LaunchClinNoteViewer: function(patient_id, encntr_id, event_id, docViewerType, pevent_id) {
            /*eslint-disable new-cap*/
            var m_dPersonId = parseFloat(patient_id);
            var m_dPeventId = parseFloat(pevent_id);
            var viewerObj = CERN_Platform.getWrappedDiscernObject("PVVIEWERMPAGE"); // eslint-disable-line new-cap
            logger.logDiscernInfo(null, "PVVIEWERMPAGE", "mp_core.js", "LaunchClinNoteViewer");
            switch (docViewerType) {
                case "AP":
                    viewerObj.invoke("CreateAPViewer").then(function() {
                        return viewerObj.invoke("AppendAPEvent", [ event_id, m_dPeventId ]);
                    }).then(function() {
                        viewerObj.invoke("LaunchAPViewer");
                    }).catch(function(err) {
                        HandleLaunchClinNoteViewerError(err);
                    });
                    break;
                case "DOC":
                    viewerObj.invoke("CreateDocViewer", [ m_dPersonId ]).then(function() {
                        if (MP_Util.IsArray(event_id)) {
                            // event_id array is reversed to maintain passivity
                            return event_id.reverse().reduce(function(previousPromise, nextId) {
                                return previousPromise.then(function() {
                                    return viewerObj.invoke("AppendDocEvent", [ nextId ]);
                                });
                            }, Promise.resolve());
                        }
                        else {
                            return viewerObj.invoke("AppendDocEvent", [ event_id ]);
                        }
                    }).then(function() {
                        viewerObj.invoke("LaunchDocViewer");
                    }).catch(function(err) {
                        HandleLaunchClinNoteViewerError(err);
                    });
                    break;
                case "EVENT":
                    viewerObj.invoke("CreateEventViewer", [ m_dPersonId ]).then(function() {
                        if (MP_Util.IsArray(event_id)) {
                            // event_id array is reversed to maintain passivity
                            return event_id.reverse().reduce(function(previousPromise, nextId) {
                                return previousPromise.then(function() {
                                    return viewerObj.invoke("AppendEvent", [ nextId ]);
                                });
                            }, Promise.resolve());
                        }
                        else {
                            return viewerObj.invoke("AppendEvent", [ event_id ]);
                        }
                    }).then(function() {
                        viewerObj.invoke("LaunchEventViewer");
                    }).catch(function(err) {
                        HandleLaunchClinNoteViewerError(err);
                    });
                    break;
                case "MICRO":
                    viewerObj.invoke("CreateMicroViewer", [ m_dPersonId ]).then(function() {
                        if (MP_Util.IsArray(event_id)) {
                            // event_id array is reversed to maintain passivity
                            return event_id.reverse().reduce(function(previousPromise, nextId) {
                                return previousPromise.then(function() {
                                    return viewerObj.invoke("AppendMicroEvent", [ nextId ]);
                                });
                            }, Promise.resolve());
                        }
                        else {
                            return viewerObj.invoke("AppendMicroEvent", [ event_id ]);
                        }
                    }).then(function() {
                        viewerObj.invoke("LaunchMicroViewer");
                    }).catch(function(err) {
                        HandleLaunchClinNoteViewerError(err);
                    });
                    break;
                case "GRP":
                    viewerObj.invoke("CreateGroupViewer").then(function() {
                        if (MP_Util.IsArray(event_id)) {
                            // event_id array is reversed to maintain passivity
                            return event_id.reverse().reduce(function(previousPromise, nextId) {
                                return previousPromise.then(function() {
                                    return viewerObj.invoke("AppendGroupEvent", [ nextId ]);
                                });
                            }, Promise.resolve());
                        }
                        else {
                            return viewerObj.invoke("AppendGroupEvent", [ event_id ]);
                        }
                    }).then(function() {
                        viewerObj.invoke("LaunchGroupViewer");
                    }).catch(function(err) {
                        HandleLaunchClinNoteViewerError(err);
                    });
                    break;
                case "PROC":
                    viewerObj.invoke("CreateProcViewer", [ m_dPersonId ]).then(function() {
                        if (MP_Util.IsArray(event_id)) {
                            // event_id array is reversed to maintain passivity
                            return event_id.reverse().reduce(function(previousPromise, nextId) {
                                return previousPromise.then(function() {
                                    return viewerObj.invoke("AppendProcEvent", [ nextId ]);
                                });
                            }, Promise.resolve());
                        }
                        else {
                            return viewerObj.invoke("AppendProcEvent", [ event_id ]);
                        }
                    }).then(function() {
                        viewerObj.invoke("LaunchProcViewer");
                    }).catch(function(err) {
                        HandleLaunchClinNoteViewerError(err);
                    });
                    break;
                case "HLA":
                    viewerObj.invoke("CreateAndLaunchHLAViewer", [ m_dPersonId, event_id ]).catch(function(err) {
                        HandleLaunchClinNoteViewerError(err);
                    });
                    break;
                case "NR":
                    viewerObj.invoke("LaunchRemindersViewer", [ event_id ]).catch(function(err) {
                        HandleLaunchClinNoteViewerError(err);
                    });
                    break;
                case "STANDARD":
                    alert(i18n.discernabu.CAN_NOT_VIEW_RESULTS); // eslint-disable-line no-alert
                    break;
            }
            /*eslint-enable new-cap*/
        },
        IsArray: function(input) {
            return ( typeof (input) === "object" && ( input instanceof Array));
        },
        IsString: function(input) {
            return ( typeof (input) === "string");
        },
        HandleNoDataResponse: function(nameSpace) {  //eslint-disable-line no-unused-vars
            var i18nCore = i18n.discernabu;
            return ("<h3 class='info-hd'><span class='res-normal'>" + i18nCore.NO_RESULTS_FOUND + "</span></h3><span class='res-none'>" + i18nCore.NO_RESULTS_FOUND + "</span>");
        },
        HandleErrorResponse: function(nameSpace, errorMessage) {
            var ar = [];
            var i18nCore = i18n.discernabu;
            //Create the HTML that will be returned to the component
            var ns = (nameSpace && nameSpace.length > 0) ? nameSpace + "-" : "";
            ar.push("<h3 class='info-hd'><span class='res-normal'>", i18nCore.ERROR_RETREIVING_DATA, "</span></h3>");
            ar.push("<dl class='", ns, "info error-message error-text'><dd><span>", i18nCore.ERROR_RETREIVING_DATA, "</span></dd></dl>");
            //log the error out to the JSLogger
            if (errorMessage && errorMessage.length) {
                logger.logError(i18n.COMPONENTS + ": " + nameSpace + "<br />" + errorMessage);
            }
            return ar.join("");
        },
        GetValueFromArray: function(name, array) {
            if (array != null) {  //eslint-disable-line eqeqeq
                for (var x = 0, xi = array.length; x < xi; x++) {
                    if (array[ x ].name == name) {  //eslint-disable-line eqeqeq
                        return (array[ x ].value);
                    }
                }
            }
            return (null);
        },

        GetCompObjById: function(id) {
            var comps = CERN_MPageComponents;
            var cLen = comps.length;
            for (var i = cLen; i--;) {
                var comp = comps[ i ];
                if (comp.m_componentId === id) {
                    return comp;
                }
            }
            return (null);
        },
        GetCompObjByStyleId: function(id) {
            var cLen = CERN_MPageComponents.length;
            for (var i = cLen; i--;) {
                var comp = CERN_MPageComponents[ i ];
                var styles = comp.getStyles();
                if (styles.getId() === id) {
                    return comp;
                }
            }
            return (null);
        },
        LoadCodeListJSON: function(parentElement) {
            var codeArray = [];
            var codeElement = null;
            if (parentElement != null) {  //eslint-disable-line eqeqeq
                for (var x = 0; x < parentElement.length; x++) {
                    var codeObject = {};
                    codeElement = parentElement[ x ];
                    codeObject.codeValue = codeElement.CODE;
                    codeObject.display = codeElement.DISPLAY;
                    codeObject.description = codeElement.DESCRIPTION;
                    codeObject.codeSet = codeElement.CODE_SET;
                    codeObject.sequence = codeElement.SEQUENCE;
                    codeObject.meaning = codeElement.MEANING;
                    var mapObj = new MP_Core.MapObject(codeObject.codeValue, codeObject);
                    codeArray.push(mapObj);
                }
            }
            return (codeArray);
        },
        LoadPersonelListJSON: function(parentElement) {
            var personnelArray = [];
            var codeElement;
            if (parentElement != null) {  //eslint-disable-line eqeqeq
                for (var x = 0; x < parentElement.length; x++) {
                    var prsnlObj = {};
                    codeElement = parentElement[ x ];
                    prsnlObj.id = codeElement.ID;
                    //If available retrieve the beg and end date and time for a prsnl name
                    if (codeElement.BEG_EFFECTIVE_DT_TM) {
                        prsnlObj.beg_dt_tm = codeElement.BEG_EFFECTIVE_DT_TM;
                        //create the string object for comparisons purposes
                        prsnlObj.beg_dt_tm_string = /[0-9]+-[0-9]+-[0-9]+/.exec(codeElement.BEG_EFFECTIVE_DT_TM) + "T" + /[0-9]+:[0-9]+:[0-9]+/.exec(codeElement.BEG_EFFECTIVE_DT_TM) + "Z";
                    }
                    if (codeElement.END_EFFECTIVE_DT_TM) {
                        prsnlObj.end_dt_tm = codeElement.END_EFFECTIVE_DT_TM;
                        //create the string object for comparisons purposes
                        prsnlObj.end_dt_tm_string = /[0-9]+-[0-9]+-[0-9]+/.exec(codeElement.END_EFFECTIVE_DT_TM) + "T" + /[0-9]+:[0-9]+:[0-9]+/.exec(codeElement.END_EFFECTIVE_DT_TM) + "Z";
                    }
                    prsnlObj.fullName = codeElement.PROVIDER_NAME.NAME_FULL;
                    prsnlObj.firstName = codeElement.PROVIDER_NAME.NAME_FIRST;
                    prsnlObj.middleName = codeElement.PROVIDER_NAME.NAME_MIDDLE;
                    prsnlObj.lastName = codeElement.PROVIDER_NAME.NAME_LAST;
                    prsnlObj.userName = codeElement.PROVIDER_NAME.USERNAME;
                    prsnlObj.initials = codeElement.PROVIDER_NAME.INITIALS;
                    prsnlObj.title = codeElement.PROVIDER_NAME.TITLE;
                    var mapObj = new MP_Core.MapObject(prsnlObj.id, prsnlObj);
                    personnelArray[ x ] = mapObj;
                }
            }
            return (personnelArray);
        },
        LoadPhoneListJSON: function(parentElement) {
            var phoneArray = [];
            var codeElement = null;
            var phoneLen = 0;
            if (parentElement) {
                for (var x = parentElement.length; x--;) {
                    var phoneObj = {};
                    codeElement = parentElement[ x ];
                    phoneObj.personId = codeElement.PERSON_ID;
                    //fill in each phone for this person id
                    phoneLen = codeElement.PHONES.length;
                    phoneObj.phones = [];
                    for (var y = 0; y < phoneLen; y++) {
                        var phoneListing = {};
                        phoneListing.phoneNum = codeElement.PHONES[ y ].PHONE_NUM;
                        phoneListing.phoneType = codeElement.PHONES[ y ].PHONE_TYPE;
                        phoneObj.phones.push(phoneListing);
                    }
                    var mapObj = new MP_Core.MapObject(phoneObj.personId, phoneObj);
                    phoneArray[ x ] = mapObj;
                }
            }
            return (phoneArray);
        },
        WriteToFile: function(sText) {
            try {
                var ForAppending = 8;
                var TriStateFalse = 0;
                var fso = new ActiveXObject("Scripting.FileSystemObject");
                var newFile = fso.OpenTextFile("c:\\temp\\test.txt", ForAppending, true, TriStateFalse); //eslint-disable-line new-cap
                newFile.write(sText);
                newFile.close();
            }
            catch (err) {
                var strErr = "Error:";
                strErr += "\nNumber:" + err.number;
                strErr += "\nDescription:" + err.description;
                document.write(strErr);
            }
        },

        /**
         *  Javascript string pad
         *  @see http://www.webtoolkit.info/
         **/
        pad: function(str, len, pad, dir) {
            if (typeof (len) === "undefined") {
                len = 0;
            }
            if (typeof (pad) === "undefined") {
                pad = " ";
            }
            if (typeof (dir) === "undefined") {
                dir = STR_PAD_RIGHT;
            }

            if (len + 1 >= str.length) {

                switch (dir) {

                    case STR_PAD_LEFT:
                        str = Array(len + 1 - str.length).join(pad) + str;
                        break;

                    case STR_PAD_BOTH:
                        var padlen = 0;
                        var right = Math.ceil(( padlen = len - str.length) / 2);
                        var left = padlen - right;
                        str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);
                        break;

                    default:
                        str = str + Array(len + 1 - str.length).join(pad);
                        break;

                } // switch
            }
            return str;
        },

        /**
         * Launches graph in a modal window viewable in the Powerchart framework
         * @param {number} eventCd The event code to retrieve results for
         * @param {number} compId The numberical id of the component to lookup
         * @param {number} groupId The groupId to pass into the graphing utility
         */
        GraphResults: function(eventCd, compID, groupID) {
            var component = MP_Util.GetCompObjById(compID); //eslint-disable-line new-cap
            var encntrOption = "";
            var i18nCore = i18n.discernabu;
            var lookBackText = "";
            var lookBackType = (component.getLookbackUnitTypeFlag()) ? component.getLookbackUnitTypeFlag() : "2";
            var lookBackUnits = (component.getLookbackUnits()) ? component.getLookbackUnits() : "365";
            var parameters = "";
            var replaceText = "";
            var scope = component.getScope();
            var criterion = component.getCriterion();

            if (scope > 0) {
                switch (lookBackType) {
                    case 1:
                        replaceText = i18nCore.LAST_N_HOURS.replace("{0}", lookBackUnits);
                        break;

                    case 2:
                        replaceText = i18nCore.LAST_N_DAYS.replace("{0}", lookBackUnits);
                        break;

                    case 3:
                        replaceText = i18nCore.LAST_N_WEEKS.replace("{0}", lookBackUnits);
                        break;

                    case 4:
                        replaceText = i18nCore.LAST_N_MONTHS.replace("{0}", lookBackUnits);
                        break;

                    case 5:
                        replaceText = i18nCore.LAST_N_YEARS.replace("{0}", lookBackUnits);
                        break;

                    default:
                        replaceText = i18nCore.LAST_N_DAYS.replace("{0}", lookBackUnits);
                        break;
                }

                switch (scope) {
                    case 1:
                        lookBackText = i18nCore.ALL_N_VISITS.replace("{0}", replaceText);
                        encntrOption = "0.0";
                        break;
                    case 2:
                        lookBackText = i18nCore.SELECTED_N_VISIT.replace("{0}", replaceText);
                        encntrOption = criterion.encntr_id + ".0";
                        break;
                }
            }
            else {
                logger.logError("No scope defined for component " + component.getLabel());
                return;
            }


            //Mobile Reach - To Launch Graph viewer
            if (!CERN_Platform.inMillenniumContext()) {
                parameters = "^MINE^," + criterion.person_id + ".0," + encntrOption + "," + eventCd + ".0,^" + criterion.static_content + "/discrete-graphing^," + groupID + ".0," + criterion.provider_id + ".0," + criterion.position_cd + ".0," + criterion.ppr_cd + ".0," + lookBackUnits + "," + lookBackType + ",200,^" + lookBackText + "^,^^,^^,^^,1";
                MD_reachViewerDialog.LaunchReachGraphViewer(parameters); //eslint-disable-line new-cap
            }
            else {
                parameters = "^MINE^," + criterion.person_id + ".0," + encntrOption + "," + eventCd + ".0,^" + criterion.static_content + "\\discrete-graphing^," + groupID + ".0," + criterion.provider_id + ".0," + criterion.position_cd + ".0," + criterion.ppr_cd + ".0," + lookBackUnits + "," + lookBackType + ",200,^" + lookBackText + "^";
                ReportLauncher.launchCCLReport("mp_retrieve_graph_results", parameters, {
                    modal: true,
                    showButtons: false,
                    showToolbar: false,
                    width: 1200,
                    height: 700,
                    useEdge: CERN_Platform.inEdgeContext()
                });
            }

            Util.preventDefault();
        },
        ReleaseRequestReference: function(reqObj) {
            if (CERN_Platform.inMillenniumContext() && XMLCCLREQUESTOBJECTPOINTER) {
                for (var id in XMLCCLREQUESTOBJECTPOINTER) {
                    if (XMLCCLREQUESTOBJECTPOINTER[ id ] === reqObj) {
                        delete (XMLCCLREQUESTOBJECTPOINTER[ id ]);
                    }
                }
            }
        },
        /**
         * Message box similar to alert or confirm with customizable options.
         * @param msg {string} String message or html to display in message box
         * @param title {string}  Title of the message box
         * @param btnTrueText {string}  Text value of the true option button, will default to 'OK' if omitted.
         * @param btnFalseText {string}  Text value of the false option button.  No false button will be created if omitted.
         * @param falseBtnFocus {boolean}  Sets the default focus to the false button.
         * @param cb {object}  Callback function to fire on true button click.
         */
        AlertConfirm: function(msg, title, btnTrueText, btnFalseText, falseBtnFocus, cb) {
            var btnTrue = "<button id='acTrueButton' data-val='1'>" + ((btnTrueText) ? btnTrueText : i18n.discernabu.CONFIRM_OK) + "</button>";
            var btnFalse = "";
            if (btnFalseText) {
                btnFalse = "<button id='acFalseButton' data-val='0'>" + btnFalseText + "</button>";
            }
            if (!title) {
                title = "&nbsp;";
            }

            var closeBox = function() {
                var btnVal = parseInt(this.getAttribute("data-val"), 10);
                $(".modal-div").remove();
                $(".modal-dialog").remove();
                $("html").css("overflow", "auto");
                //reset overflow
                if (btnVal && typeof cb === "function") {
                    cb();
                }
            };
            var modalDiv = Util.cep("div", {
                "className": "modal-div"
            });
            var dialog = Util.cep("div", {
                "className": "modal-dialog"
            });

            dialog.innerHTML = "<div class='modal-dialog-hd'>" + title + "</div>" + "<div class='modal-dialog-content'>" + msg + "</div>" + "<div class='modal-dialog-ft'><div class='modal-dialog-btns'>" + btnTrue + btnFalse + "</div></div>";

            var docBody = document.body;
            Util.ac(modalDiv, docBody);
            Util.ac(dialog, docBody);

            Util.addEvent(_g("acTrueButton"), "click", closeBox);
            if (btnFalseText) {
                Util.addEvent(_g("acFalseButton"), "click", closeBox);
            }

            if (falseBtnFocus && btnFalseText) {
                _g("acFalseButton").focus();
            }
            else {
                _g("acTrueButton").focus();
            }

            $("html").css("overflow", "hidden");
            //disable page scrolling when modal is enabled
            $(modalDiv).height($(document).height());
        },

        CreateAutoSuggestBoxHtml: function(component, elementId) {
            var searchBoxHTML = [];
            var txtBoxId = "";
            var compNs = component.getStyles().getNameSpace();
            var compId = component.getComponentId();
            if (elementId) {
                txtBoxId = compNs + elementId + compId;
            }
            else {
                txtBoxId = compNs + "ContentCtrl" + compId;
            }

            searchBoxHTML.push("<div class='search-box-div'><form name='contentForm' onSubmit='return false'><input type='text' id='", txtBoxId, "'", " class='search-box'></form></div>");
            return searchBoxHTML.join("");
        },
        AddAutoSuggestControl: function(component, queryHandler, selectionHandler, selectDisplayHandler, itemId) {
            new AutoSuggestControl(component, queryHandler, selectionHandler, selectDisplayHandler, itemId); //eslint-disable-line no-new
        },
        RetrieveAutoSuggestSearchBox: function(component) {
            var componentNamespace = component.getStyles().getNameSpace();
            var componentId = component.getComponentId();
            return _g(componentNamespace + "ContentCtrl" + componentId);
        },
        CreateParamArray: function(ar, type) {
            var returnVal = (type === 1) ? "0.0" : "0";
            if (ar && ar.length > 0) {
                if (ar.length > 1) {
                    if (type === 1) {
                        returnVal = "value(" + ar.join(".0,") + ".0)";
                    }
                    else {
                        returnVal = "value(" + ar.join(",") + ")";
                    }
                }
                else {
                    returnVal = (type === 1) ? ar[ 0 ] + ".0" : ar[ 0 ];
                }
            }
            return returnVal;
        },
        /**
         * This method is used to overlay the content of a component with a transparent DIV and also show the loading icon (spinner) in the center of that container.
         * @param {String} resultContainerId The id of the element which should be covered by the spinner.
         * @param {number} skipOffsetFlag Pass a 1 to not use the offset and instead set the margin-top
         * @param {String} spinnerId Spinner div Id that is used to reference the spinner
         * @returns null
         */
        LoadSpinner: function(resultContainerID, skipOffsetFlag, spinnerId) {
            if (resultContainerID && typeof resultContainerID === "string") {
                var resultContainer = $("#" + resultContainerID);
                var contentHeight = resultContainer.height();
                var styleProp = "";

                if (skipOffsetFlag) {
                    styleProp = "height: " + contentHeight + "px; margin-top: -" + contentHeight + "px;";
                }
                else {
                    var offset = resultContainer.offsetParent();
                    var loadingIconTop = offset.height() - contentHeight;
                    styleProp = "height: " + contentHeight + "px; top: " + loadingIconTop + "px;";
                }

                if (spinnerId) {
                    resultContainer.append("<div id='" + spinnerId + "' class='loading-screen' style='" + styleProp + "'><div class='loading-spinner'>&nbsp;</div></div>");
                }
                else {
                    resultContainer.append("<div class='loading-screen' style='" + styleProp + "'><div class='loading-spinner'>&nbsp;</div></div>");
                }
            }
        },
        /**
         * Will get the date formatter associate to the locale loaded by the driver
         * @returns The date formatter to utilize for the loaded locale
         */
        GetDateFormatter: function() {
            if (!m_df) {
                m_df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
            }
            return m_df;
        },
        /**
         * Will get the numeric formatter associate to the locale loaded by the driver
         * @returns The numeric formatter to utilize for the loaded locale
         */
        GetNumericFormatter: function() {
            if (!m_nf) {
                m_nf = new mp_formatter.NumericFormatter(MPAGE_LOCALE);
            }
            return m_nf;
        },
        /**
         * To display a ModalDialog with the output of the reportName script.
         * The driver script will be called to get the details of the report and if the response is success,
         * the response text will be displayed in the body of the dialog.
         * If there is any failure in the response, an error dialog will be displayed with error message and
         * on closing the dialog report modal dialog will be displayed with text "No data found" in the body.
         * On click of print button will open a print dialog to perform the printing.
         * @param reportName {String} name of the report to be executed.
         * @param person_id {String} personId Person id of the patient in string format with '.0' on the end.
         * @param encounter_id {int} encounterId Encounter id of the patient in string format with '.0' on the end.
         * @returns null
         */
        PrintReport: function(reportName, personId, encounterId) {
            var convertRTFtoHTML = 1;
            var reportContents = "";

            /**
             * This function will create and iFrame and populate it with the results of
             * the report.  Once that is done it executes the print functionality
             */
            function printReportOutput() {
                try {
                    var iframeObj = document.createElement("iframe");
                    iframeObj.setAttribute("display", "none");
                    document.body.appendChild(iframeObj);

                    var printWindow = iframeObj.contentWindow;
                    var docObject = printWindow ? printWindow.document : null;
                    if (docObject) {
                        docObject.write(reportContents);
                        docObject.close();
                        printWindow.focus();
                        printWindow.print();
                    }
                }
                catch (err) {
                    logger.logJSError(err, null, "mpage-core.js", "PrintReport");
                }
                finally {
                    $(iframeObj).remove();
                }
            }

            //Retrieve the print report modalDialog object
            var printDialog = MP_ModalDialog.retrieveModalDialogObject("printDialog");
            if (!printDialog) {
                printDialog = new ModalDialog("printDialog");
                printDialog.setHeaderTitle("&nbsp;");
                MP_ModalDialog.addModalDialogObject(printDialog);

                //Create the cancel button
                var cancelButton = new ModalButton("cancelButton");
                cancelButton.setText(i18n.discernabu.CONFIRM_CANCEL);
                cancelButton.setCloseOnClick(true);
                printDialog.addFooterButton(cancelButton);

                //Create the print button
                var printButton = new ModalButton("printButton");
                printButton.setText(i18n.PRINT);
                printButton.setCloseOnClick(false);
                printButton.setOnClickFunction(printReportOutput);
                printDialog.addFooterButton(printButton);
            }

            //Show the modal dialog before we make the synchronous request
            MP_ModalDialog.showModalDialog("printDialog");

            //Create a script request to get the results from the print report
            var artifactInfo = {
                artifactId: "mpage-core",
                functionName: "PrintReport"
            };
            var reportRequest = new ScriptRequest();
            reportRequest.setName("Print Report Script Request");
            reportRequest.setProgramName("pwx_rpt_driver_to_mpage");
            reportRequest.setArtifactInfo(artifactInfo);
            reportRequest.setParameterArray([ "^MINE^", "^" + reportName + "^", personId, encounterId, convertRTFtoHTML ]);
            reportRequest.setRawDataIndicator(true);
            reportRequest.setResponseHandler(function(replyObj) {
                //Reset the cursor to default
                $("body").css("cursor", "default");
                //Get the reply from the script
                reportContents = replyObj.getResponse();
                //Update the contents of the modal dialog with the reply from the script request or the No Data Found i18n
                printDialog.setBodyHTML(reportContents || i18n.NO_DATA_FOUND);
            });
            reportRequest.performRequest();

            // Show the cursor as busy, this indicates the system is processing the request.
            // It will be reset to default when success/failed response is returned.
            $("body").css("cursor", "wait");
        },
        CalculatePrecision: function(valRes) {
            var precision = 0;
            var str = (MP_Util.IsString(valRes)) ? valRes : valRes.toString();  //eslint-disable-line new-cap
            var decLoc = str.search(/\.(\d)/);
            if (decLoc !== -1) {
                var strSize = str.length;
                precision = strSize - decLoc - 1;
            }
            return precision;
        },
        /**
         * Will create a date/time in the format neccessary for passing as a prompt parameter
         */
        CreateDateParameter: function(date) {
            var day = date.getDate();
            var month = "";
            var rest = date.format("yyyy HH:MM:ss");
            switch (date.getMonth()) {
                case (0):
                    month = "JAN";
                    break;
                case (1):
                    month = "FEB";
                    break;
                case (2):
                    month = "MAR";
                    break;
                case (3):
                    month = "APR";
                    break;
                case (4):
                    month = "MAY";
                    break;
                case (5):
                    month = "JUN";
                    break;
                case (6):
                    month = "JUL";
                    break;
                case (7):
                    month = "AUG";
                    break;
                case (8):
                    month = "SEP";
                    break;
                case (9):
                    month = "OCT";
                    break;
                case (10):
                    month = "NOV";
                    break;
                case (11):
                    month = "DEC";
                    break;
                default:
                    alert("unknown month"); //eslint-disable-line no-alert
            }
            return (day + "-" + month + "-" + rest);
        },
        /**
         * @deprecated Use logger.logDebug(debug) instead.
         * This method will log a debug message.
         * @param {string} debugString - The debug string to be logged.
         */
        LogDebug: function(debugString) {
            logger.logDebug(debugString);
        },
        /**
         * @deprecated Use logger.logWarning(warning) instead.
         * This method will log a warning.
         * @param {string} warnString - The warning string to be logged.
         */
        LogWarn: function(warnString) {
            logger.logWarning(warnString);
        },
        /**
         * @deprecated Use logger.logMessage(message) instead.
         * This method will log a message.
         * @param {string} infoString - The message string to be logged.
         */
        LogInfo: function(infoString) {
            logger.logMessage(infoString);
        },
        /**
         * @deprecated Use logger.logError(error) instead.
         * This method will log an error.
         * @param {string} errorString - The error string to be logged.
         */
        LogError: function(errorString) {
            logger.logError(errorString);
        },
        /**
         * @deprecated Use logger.logScriptCallInfo(...) instead.
         * @param {MPageComponent} component - The component for which the info is being logged.
         * @param {ScriptRequest} request - The script request that was made.
         * @param {string} file - The JS file from which the script call was made.
         * @param {string} funcName - The function from which the script call was made.
         */
        LogScriptCallInfo: function(component, request, file, funcName) {
            logger.logScriptCallInfo(component, request, file, funcName);
        },
        /**
         * @deprecated Use logger.logScriptCallError(...) instead.
         * @param {MPageComponent} component - The component for which the error is being logged.
         * @param {ScriptRequest} request - The script request that was made.
         * @param {string} file - The JS file from which the script call was made.
         * @param {string} funcName - The function from which the call was made.
         */
        LogScriptCallError: function(component, request, file, funcName) {
            logger.logScriptCallError(component, request, file, funcName);
        },
        /**
         * @deprecated Use logger.logJSError(...) instead.
         * @param {Error} err - The error that occurred.
         * @param {MPageComponent} component - The component in which the error originated.
         * @param {string} file - The JS file from which the JavaScript error originated.
         * @param {string} funcName - The function from which the JavaScript error originated.
         */
        LogJSError: function(err, component, file, funcName) {
            logger.logJSError(err, component, file, funcName);
        },
        /**
         * @deprecated Use logger.logDiscernInfo(...) instead.
         * @param {MPageComponent} component - The component from which the information is being logged.
         * @param {string} objectName - The name of the object for which information is being logged.
         * @param {string} file - The JS file from which the information is being logged.
         * @param {string} funcName - The function from which the information is being logged.
         */
        LogDiscernInfo: function(component, objectName, file, funcName) {
            logger.logDiscernInfo(component, objectName, file, funcName);
        },
        /**
         * @deprecated Use logger.logMPagesEventInfo(...) instead.
         * @param {MPageComponent} component - The component from which the information is being logged.
         * @param {string} eventName - The name of the event that occurred.
         * @param {string} params - The parameters associated to the MPages event.
         * @param {string} file - The JS file from which the information is being logged.
         * @param {string} funcName - The function from which the information is being logged.
         */
        LogMpagesEventInfo: function(component, eventName, params, file, funcName) {
            logger.logMPagesEventInfo(component, eventName, params, file, funcName);
        },
        /**
         * @deprecated Use logger.logCCLNewSessionWindowInfo(...) instead.
         * @param {MPageComponent} component - The component from which the information is being logged.
         * @param {string} params - The parameters associated to the CCLNEWSESSIONWINDOW.
         * @param {string} file - The JS file from which the information is being logged.
         * @param {string} funcName - The function from which the information is being logged.
         */
        LogCclNewSessionWindowInfo: function(component, params, file, funcName) {
            logger.logCCLNewSessionWindowInfo(component, params, file, funcName);
        },
        /**
         * @deprecated Use logger.logTimerInfo(...) instead.
         * @param {string} timerName - The name of the timer.
         * @param {string} subTimerName - The sub timer name.
         * @param {string} timerType - The type of timer.
         * @param {string} file - The JS file from which the information is being logged.
         * @param {string} funcName - The function from which the information is being logged.
         */
        LogTimerInfo: function(timerName, subTimerName, timerType, file, funcName) {
            logger.logTimerInfo(timerName, subTimerName, timerType, file, funcName);
        },
        AddCookieProperty: function(compId, propName, propValue) {
            var cookie = CK_DATA[ compId ];
            if (!cookie) {
                cookie = {};
            }
            cookie[ propName ] = propValue;
            CK_DATA[ compId ] = cookie;
        },
        GetCookieProperty: function(compId, propName) {
            var cookie = CK_DATA[ compId ];
            if (cookie && cookie[ propName ]) {
                return cookie[ propName ];
            }
            else {
                return null;
            }
        },
        WriteCookie: function() {
            var cookieJarJSON = JSON.stringify(CK_DATA);
            document.cookie = "CookieJar=" + cookieJarJSON + ";";
        },
        RetrieveCookie: function() {
            var cookies = document.cookie;
            var match = cookies.match(/CookieJar=({[^;]+})(;|\b|$)/);
            if (match && match[ 1 ]) {
                CK_DATA = JSON.parse(match[ 1 ]);
            }
        },

        GetCookieValue: GetCookieValueUtil,

        /**
         * This function is used to generate the HTML content for a modal dialog that is intended to display an informational message to the user.
         * If the modal dialog with the id of modalId does not already exist it will be created, but will not be added to the modal dialog collection
         * in MP_ModalDialog.
         * @param {string} modalId The id of an existing modal dialog or the id that will be given to the modal dialog that will be created.
         * @param {string} messageType The type of message that will be created.  Different styling will be applied to different message types.  A default
         * value of "" is a valid value for this parameter.
         * @param {string} line1 This first line of the informational message.  This line could potentially be stylized based on the messageType.
         * @param {string} line2 This is the second line of the information message.  It will not be styled based on the messageType
         * @returns {ModalDialog}  The updated or newly create object that inherits from ModalDialog.
         */
        generateModalDialogBody: function(modalId, messageType, line1, line2) {
            var modal = null;

            //Check to see if this modal dialog already exists.  If not go ahead and create it.
            modal = MP_ModalDialog.retrieveModalDialogObject(modalId);

            //Create a modal dialog here
            if (!modal) {
                switch (messageType.toLowerCase()) {
                    case "error":
                        modal = new ErrorModal(modalId);
                        break;
                    case "warning":
                        modal = new WarningModal(modalId);
                        break;
                    case "information":
                        modal = new InfoModal(modalId);
                        break;
                    case "busy":
                        modal = new BusyModal(modalId);
                        break;
                    default:
                        modal = new MessageModal(modalId);
                        break;
                }
            }

            //Apply the proper margins for User informational messages
            //Generate the proper HTML string based on the type passed into the function
            //Apply the new message to the modal
            //
            modal.setMessage(line1, line2);

            return modal;
        },
        /**
         * Creates a mapping between a string identifier and an object definition.  The object definition is only mapped
         * when the objectDefinition parameter is an actual object.
         * @param {string} mappingId : An id associated to the specific object definition that will be mapped.  This id is case
         * insensitive.
         * @param {function} objectDefinition : A reference to the definition of the object being mapped
         * @returns {boolean} True if the object mapping was added successfully, false otherwise.
         */
        setObjectDefinitionMapping: function(mappingId, objectDefinition) {
            // Make sure the mappingID is a string
            if (typeof mappingId !== "string") {
                return false;
            }
            mappingId = mappingId.toUpperCase();

            // Make sure we are mapping an object definition which would be a function
            if (typeof objectDefinition === "function") {
                CERN_ObjectDefinitionMapping[ mappingId ] = objectDefinition;
                return true;
            }
            return false;
        },
        /**
         * Retrieves the object mapped to a specific mappingId if it is defined in the CERN_ObjectDefinitionMapping object
         * @param {string} mappingId : The id mapped to a specific object in the CERN_ObjectDefintionMapping object.   This id is case
         * insensitive.
         * @returns {function} The object definition mapped to the mappingId passed into the function.
         */
        getObjectDefinitionMapping: function(mappingId) {
            //Make sure the mappingID is a string
            if (typeof mappingId !== "string") {
                return null;
            }
            mappingId = mappingId.toUpperCase();
            //Attempt to retrieve the object definition
            if (typeof CERN_ObjectDefinitionMapping[ mappingId ] === "undefined") {
                return null;
            }
            return CERN_ObjectDefinitionMapping[ mappingId ];
        },
        /**
         * Updates the object definition mapped to the identifier passed into the function.  If no object is mapped to the
         * identifier then no updates are made to the CERN_ObjectDefinitionMapping object.
         * @param {string} mappingId : An id associated to the specific object definition that will be mapped.  This id is case
         * insensitive.
         * @param {function} objectDefinition : A reference to the definition of the object being mapped
         * @returns {boolean} True if the object mapping was updated successfully, false otherwise.
         */
        updateObjectDefinitionMapping: function(mappingId, objectDefinition) {
            //Make sure the mappingID is a string
            if (typeof mappingId !== "string") {
                return null;
            }
            mappingId = mappingId.toUpperCase();
            //Make sure an object definition already exists for this mappingId
            if (typeof CERN_ObjectDefinitionMapping[ mappingId ] === "undefined") {
                logger.logMessage("Object mapping does not exists for " + mappingId);
                return false;
            }
            //Make sure we are mapping an object definition which would be a function
            if (typeof objectDefinition === "function") {
                CERN_ObjectDefinitionMapping[ mappingId ] = objectDefinition;
                return true;
            }
            return false;
        },
        /**
         * Removes the object definition mapped to the identifier passed into the function.
         * @param {string} mappingId : An id associated to the specific object definition that will be removed.  This id is case
         * insensitive.
         * @returns {boolean} True if the object mapping was removed successfully, false otherwise.
         */
        removeObjectDefinitionMapping: function(mappingId) {
            //Make sure the mappingID is a string
            if (typeof mappingId !== "string") {
                return null;
            }
            mappingId = mappingId.toUpperCase();
            //Make sure the object definition exists before we attempt to delete it
            if (typeof CERN_ObjectDefinitionMapping[ mappingId ] === "undefined") {
                logger.logMessage("Object mapping does not exists for " + mappingId);
                return false;
            }
            return delete CERN_ObjectDefinitionMapping[ mappingId ];
        },

        /**
         * This function stringifies the passed in object.
         * It determines whether to stringify fields ending in _id or _cd as a float according to parameter skipIDAndCDFields;
         * It determines whether to surround fields ending in _dt_tm with "\/Date()\/" according to parameter skipDates;
         * It determines whether to replace the UTC time zone offset designator ("Z") with "+00:00" according to parameter isUTC;
         * Any additional fields provided by parameter additionalFields are stringified as a float.
         * CAUTION:
         * 1) Parameter additionalFields only works on fields with non-negative numbers. It does nothing to negative numbers
         * 2) Duplicates in parameter additionalFields are not allowed.
         * 3) "XXX_REPLACE_DT_START_XXX" and "XXX_REPLACE_DT_END_XXX" are preserved words.
         *    Parameter obj cannot have the same text content or field names.
         *
         * @param {object} obj - An object to be stringified
         * @param {number} skipIDAndCDFields - Flag to skip fields ending in _id or _cd.
         *                                     1: Do not stringify fields ending in _id and _cd as a float
         *                                     0: Stringify fields ending in _id and _cd as a float
         * @param {number} skipDates - Flag to surround fields ending in _dt_tm with "\/Date()\/".
         *                             1: Do not surround fields ending in _dt_tm with "\/Date()\/".
         *                             0: Surround fields ending in _dt_tm will with "\/Date()\/".
         * @param {boolean} isUTC - When skipDates is 0, indicate whether to save the UTC time zone offset as +00:00 for the fields ending in _dt_tm.
         *                          True: Replace the UTC time zone offset designator ("Z") with "+00:00"
         *                          False: Do not change the time zone offset.
         * @param {string[]} [additionalFields] - Distinct additional fields to be stringified as a float.
         * @returns {string} Returns a JSON string which can be passed to back-end.
         * @public
         * @static
         * @example
         * var output = MP_Util.enhancedStringify(
         *      {
         *          DOSE_UNIT_CD: 1234,
         *          DOSE_VALUE: 1,
         *          INVALID_NUMBER_VALUE: -7,
         *          INTAKE_VOLUME: 0.99
         *          ADMIN_DT_TM: new Date(2017, 0, 15, 13, 30, 45, 745),
         *          PERSONNEL_ID: 5678
         *      },
         *      0, // Add .0 to the end of fields ending in _id and _cd
         *      0, // Surround fields ending in dt_tm with "\/Date()\/"
         *      true, // Fields ending in dt_tm are in UTC ("YYYY-MM-DDThh:mm:ss.sZ")
         *      [ "DOSE_VALUE", "INVALID_NUMBER_VALUE", "INTAKE_VOLUME"] // Additional fields to saved as floats which do not end in _id or _cd
         * );
         * // output is
         * "{\"DOSE_UNIT_CD\":1234.0,\"DOSE_VALUE\":1.0,\"INVALID_NUMBER_VALUE\":-7,\"INTAKE_VOLUME\":0.99,\"ADMIN_DT_TM\":\"\/Date(2017-01-15T19:30:45.745+00:00)\/\",\"PERSONNEL_ID\":5678.0}"
         */
        enhancedStringify: function(obj, skipIDAndCDFields, skipDates, isUTC, additionalFields) {

            var replacedJSONStr;
            var findString;
            var regExpObject;
            var floatTypeFields = additionalFields || [];

            /**
             * dateAndIdReplacer works as the JSON.stringify() replacer function.
             * It prepares the date fields (_dt_tm) by inserting placeholders which will be replaced by "\/Date()\/" later logic.
             * It saves _id and _cd fields to floatTypeFields when they need be stringified as floats.
             * @param {string} key - key name in an object
             * @param {*} value - value of a key in an object.
             * @returns {*} Returns a value to add to the JSON string
             * @private
             */
            var dateAndIdReplacer = function(key, value) {

                if (typeof key === "string") {

                    var upperCaseKey = key.toUpperCase();
                    var replacedDateValue;

                    // Do not surround date fields with Date() if skipDates flag is set to 1
                    if (skipDates !== 1 && typeof value === "string" && value !== "" && upperCaseKey.indexOf("_DT_TM") > -1) {

                        if (isUTC) {
                            replacedDateValue = "XXX_REPLACE_DT_START_XXX" + value.replace("Z", "+00:00XXX_REPLACE_DT_END_XXX");
                        }
                        else {
                            replacedDateValue = "XXX_REPLACE_DT_START_XXX" + value + "XXX_REPLACE_DT_END_XXX";
                        }
                        return replacedDateValue;
                    }
                    // Treat ID and CD fields as float type fields when applicable
                    if ((skipIDAndCDFields !== 1) && (typeof value === "number")
                        && (upperCaseKey.indexOf("_ID") > -1 || upperCaseKey.indexOf("_CD") > -1)) {

                        var hasKey = floatTypeFields.some(function(field) {
                            return field === key;
                        });
                        // Field names cannot be duplicated
                        if (!hasKey) {
                            floatTypeFields.push(key);
                        }
                    }
                }

                return value;
            };

            /**
             * Append the given string with ".0" when it dose not contain a decimal point.
             * @param {string} str - A string which contains a number.
             * @returns {string} Returns a string
             * @private
             */
            var numberMatchReplacer = function(str) {
                if (str.indexOf(".") === -1) {
                    return str + ".0";
                }

                return str;
            };

            replacedJSONStr = JSON.stringify(obj, dateAndIdReplacer)
                .replace(/XXX_REPLACE_DT_START_XXX/g, "\\/Date(")
                .replace(/XXX_REPLACE_DT_END_XXX/g, ")\\/");

            // Stringify float type fields to decimal values
            for (var i = floatTypeFields.length; i--;) {
                // Create a regular expression which captures the field along with it's value
                // Ignore those which do not have a non-negative number value
                findString = "(\"" + floatTypeFields[ i ] + "\"" + ":" + "\\d+\\.?\\d*)";
                regExpObject = new RegExp(findString, "gi");
                // Append ".0" to integers
                replacedJSONStr = replacedJSONStr.replace(regExpObject, numberMatchReplacer);
            }
            return replacedJSONStr;
        }
    };
    /**
     * Calculates difference between two dates given and returns string with appropriate units
     * If no endDate is given it is assumed the endDate is the current date/time
     *
     * @param beginDate  Begin <code>Date</code> for Calculation
     * @param endDate  End <code>Date</code> for Calculation
     * @param mathFlag  <code>Integer</code> Flag to determine if Math.Ceil or Math.Floor is used defaults to Math.floor 1 =
     * Floor, 0 = Ceil
     * @param abbreviateFlag  <code>Boolean</code> to determine if shortened versions of Month,Year,Weeks,Days should be used
     * such as in the case of a within string
     */
    function GetDateDiffString(beginDate, endDate, mathFlag, abbreviateFlag) {
        var i18nCore = i18n.discernabu;
        var timeDiff = 0;
        var returnVal = "";
        //Set endDate to current time if it's not passed in
        endDate = (!endDate) ? new Date() : endDate;
        mathFlag = (!mathFlag) ? 0 : mathFlag;
        var one_minute = 1000 * 60;
        var one_hour = one_minute * 60;
        var one_day = one_hour * 24;
        var one_week = one_day * 7;

        var valMinutes = 0;
        var valHours = 0;
        var valDays = 0;
        var valWeeks = 0;
        var valMonths = 0;
        var valYears = 0;
        //time diff in milliseconds
        timeDiff = (endDate.getTime() - beginDate.getTime());

        //Choose if ceiling or floor should be applied
        var mathFunc = null;
        var comparisonFunc = null;
        if (mathFlag == 0) {  //eslint-disable-line eqeqeq
            mathFunc = function(val) {
                return Math.ceil(val);
            };
            comparisonFunc = function(lowerVal, upperVal) {
                return (lowerVal <= upperVal);
            };
        }
        else {
            mathFunc = function(val) {
                return Math.floor(val);
            };
            comparisonFunc = function(lowerVal, upperVal) {
                return (lowerVal < upperVal);
            };
        }

        var calcMonths = function() {
            var removeCurYr = 0;
            var removeCurMon = 0;
            var yearDiff = 0;
            var monthDiff = 0;
            var dayDiff = endDate.getDate();
            if (endDate.getMonth() > beginDate.getMonth()) {
                monthDiff = endDate.getMonth() - beginDate.getMonth();
                if (endDate.getDate() < beginDate.getDate()) {
                    removeCurMon = 1;
                }
            }
            else if (endDate.getMonth() < beginDate.getMonth()) {
                monthDiff = 12 - beginDate.getMonth() + endDate.getMonth();
                removeCurYr = 1;
                if (endDate.getDate() < beginDate.getDate()) {
                    removeCurMon = 1;
                }
            }
            else if (endDate.getDate() < beginDate.getDate()) {
                removeCurYr = 1;
                monthDiff = 11;
            }

            if (endDate.getDate() >= beginDate.getDate()) {
                dayDiff = endDate.getDate() - beginDate.getDate();
            }

            yearDiff = (endDate.getFullYear() - beginDate.getFullYear()) - removeCurYr;
            //days are divided by 32 to ensure the number will always be less than zero
            monthDiff += (yearDiff * 12) + (dayDiff / 32) - removeCurMon;

            return monthDiff;
        };

        valMinutes = mathFunc(timeDiff / one_minute);
        valHours = mathFunc(timeDiff / one_hour);
        valDays = mathFunc(timeDiff / one_day);
        valWeeks = mathFunc(timeDiff / one_week);
        valMonths = calcMonths();
        valMonths = mathFunc(valMonths);
        valYears = mathFunc(valMonths / 12);

        if (comparisonFunc(valHours, 2))//Less than 2 hours, display number of minutes. Use abbreviation of "mins".
            returnVal = abbreviateFlag ? (i18nCore.WITHIN_MINS.replace("{0}", valMinutes)) : (i18nCore.X_MINUTES.replace("{0}", valMinutes));
        else if (comparisonFunc(valDays, 2))//Less than 2 days, display number of hours. Use abbreviation of "hrs".
            returnVal = abbreviateFlag ? (i18nCore.WITHIN_HOURS.replace("{0}", valHours)) : (i18nCore.X_HOURS.replace("{0}", valHours));
        else if (comparisonFunc(valWeeks, 2))//Less than 2 weeks, display number of days. Use "days".
            returnVal = abbreviateFlag ? (i18nCore.WITHIN_DAYS.replace("{0}", valDays)) : (i18nCore.X_DAYS.replace("{0}", valDays));
        else if (comparisonFunc(valMonths, 2))//Less than 2 months, display number of weeks. Use abbreviation of "wks".
            returnVal = abbreviateFlag ? (i18nCore.WITHIN_WEEKS.replace("{0}", valWeeks)) : (i18nCore.X_WEEKS.replace("{0}", valWeeks));
        else if (comparisonFunc(valYears, 2))//Less than 2 years, display number of months. Use abbreviation of "mos".
            returnVal = abbreviateFlag ? (i18nCore.WITHIN_MONTHS.replace("{0}", valMonths)) : (i18nCore.X_MONTHS.replace("{0}", valMonths));
        else//Over 2 years, display number of years.  Use abbreviation of "yrs".
            returnVal = abbreviateFlag ? (i18nCore.WITHIN_YEARS.replace("{0}", valYears)) : (i18nCore.X_YEARS.replace("{0}", valYears));

        return (returnVal);
    }

}();

/**
 * @namespace
 */
MP_Util.Doc = function() {
    var openAccordion = "";
    var compMenuTimeout = null;
    var compMenuDelay = 250;

    return {
        SetupExpandCollapse: function(categoryMeaning) {
            var i18nCore = i18n.discernabu;
            //set up expand collapse for all components
            var body = null;
            var toggleArray = null;
            if (categoryMeaning) {
                body = _g(categoryMeaning);
                toggleArray = Util.Style.g("sec-hd-tgl", body, "span");
            }
            else {
                toggleArray = Util.Style.g("sec-hd-tgl");
            }
            for (var k = 0; k < toggleArray.length; k++) {
                Util.addEvent(toggleArray[ k ], "click", MP_Util.Doc.ExpandCollapse);
                var checkClosed = Util.gp(Util.gp(toggleArray[ k ]));
                if (Util.Style.ccss(checkClosed, "closed")) {
                    toggleArray[ k ].innerHTML = "+";
                    toggleArray[ k ].title = i18nCore.SHOW_SECTION;
                    toggleArray[ k ].setAttribute("aria-label",i18nCore.SHOW_SECTION);
                }
            }
        },
        SetupCompFilters: function(compArray) {
            var comp = null;
            var compArrayLen = compArray.length;
            var hasFilters = false;
            for (var x = 0; x < compArrayLen; x++) {
                comp = compArray[ x ];
                hasFilters = false;
                for (var y = 0; y < 10; y++) {
                    if (comp.getGrouperLabel(y) || comp.getGrouperCatLabel(y)) {
                        hasFilters = true;
                        break;
                    }
                }
                comp.setCompFilters(hasFilters);
                if (comp.hasCompFilters() && comp.isDisplayable()) {
                    comp.renderAccordion(comp);
                }
            }
        },
        /**
         * Create Component Menus
         * @param {mpComps} mpage components for current view
         * @param {bool} disablePrsnl boolean to disable personalize section
         * @param
         */
        CreateCompMenus: function(mpComps, disablePrsnl) {
            var setupCustCompMenu = function(curComp, compId, fullId, ns) {
                curComp.createMainMenu();
                var compMenu = curComp.getMenu();
                if (compMenu) {
                    var themeSelectorId = "themeSelector" + compId;
                    var themeSelector = new ThemeSelector(themeSelectorId, compId, fullId, ns);
                    compMenu.addMenuItem(themeSelector);
                    var defaultExpandedSelection = new MenuSelection("defaultExpandedSelection" + compId);
                    defaultExpandedSelection.setLabel(i18n.discernabu.DEFAULT_EXPANDED);
                    defaultExpandedSelection.setIsSelected(curComp.isExpanded() === 1);
                    defaultExpandedSelection.setCloseOnClick(false);
                    defaultExpandedSelection.setClickFunction(function() {
                        var isFinalStateExpanded = !curComp.isExpanded();
                        curComp.setExpandCollapseState(isFinalStateExpanded);
                        curComp.setExpanded(isFinalStateExpanded ? 1 : 0);
                        MP_Core.AppUserPreferenceManager.UpdateSingleCompPreferences(curComp, true); //eslint-disable-line new-cap
                    });
                    compMenu.addMenuItem(defaultExpandedSelection);
                    MP_MenuManager.updateMenuObject(compMenu);
                    var secId = fullId.replace("mainCompMenu", "");
                    Util.addEvent(_g("mainCompMenu" + secId), "click", function() {
                        MP_MenuManager.showMenu(this.id);
                    });
                }
            };

            var setupCompMenu = function(componentId, fullId, isExp, infoInd, infoState) {
                if (_g(fullId)) {
                    var optMenu = _g("moreOptMenu" + componentId);
                    if (!optMenu) {
                        optMenu = Util.cep("div", {
                            className: "opts-menu-content menu-hide",
                            id: "moreOptMenu" + componentId
                        });
                        var i18nCore = i18n.discernabu;
                        var defExpClass = "";
                        var infoBtnMsg = i18nCore.INFO_BUTTON;
                        var infoClass = "";

                        if (isExp) {
                            defExpClass = "opts-menu-def-exp";
                        }

                        if (infoState) {
                            infoClass = "opts-menu-info-en";
                        }

                        var optMenuHtml = "<div class=\"opts-actions-sec\" id=\"optsMenuActions" + componentId + "\"></div>";

                        if (!disablePrsnl) {
                            if (infoInd) {
                                optMenuHtml += "<div class=\"opts-personalize-sec\" id=\"optsMenupersonalize" + componentId + "\"><div class=\"opts-menu-item opts-def-theme\" id=\"optsDefTheme" + componentId + "\">" + i18nCore.COLOR_THEME + "</div><div class=\"opts-menu-item opts-def-state\" id=\"optsDefState" + componentId + "\">" + i18nCore.DEFAULT_EXPANDED + "<span class=\"" + defExpClass + "\">&nbsp;</span></div><div class=\"opts-menu-item opts-personalize-sec-divider\" id=\"optsInfoState" + componentId + "\">" + infoBtnMsg + "<span class=\"" + infoClass + "\">&nbsp;</span></div></div>";
                            }
                            else {
                                optMenuHtml += "<div class=\"opts-personalize-sec\" id=\"optsMenupersonalize" + componentId + "\"><div class=\"opts-menu-item opts-def-theme\" id=\"optsDefTheme" + componentId + "\">" + i18nCore.COLOR_THEME + "</div><div class=\"opts-menu-item opts-def-state\" id=\"optsDefState" + componentId + "\">" + i18nCore.DEFAULT_EXPANDED + "<span class=\"" + defExpClass + "\">&nbsp;</span></div></div>";
                            }
                        }

                        optMenu.innerHTML = optMenuHtml;

                        Util.ac(optMenu, document.body);
                    }
                    InitCompOptMenu(optMenu, componentId, false); //eslint-disable-line new-cap

                    var themeTimeout = null;
                    var themeOut = function(e) {
                        if (!e) {
                            e = window.event;
                        }
                        var relTarg = e.relatedTarget || e.toElement;
                        if (relTarg) {
                            themeTimeout = window.setTimeout(function() {
                                if (_g("optMenuConfig" + componentId)) {
                                    Util.Style.acss(_g("optMenuConfig" + componentId), "menu-hide");
                                }
                            }, compMenuDelay);
                        }
                        else {
                            if (_g("optMenuConfig" + componentId)) {
                                Util.Style.acss(_g("optMenuConfig" + componentId), "menu-hide");
                            }
                            return;
                        }
                    };
                    var secId = fullId.replace("mainCompMenu", "");
                    Util.addEvent(_g("mainCompMenu" + secId), "click", function() {
                        OpenCompOptMenu(optMenu, secId); //eslint-disable-line new-cap
                    });

                    if (!disablePrsnl) {
                        var optDefThemeMenuItem = _g("optsDefTheme" + componentId);

                        // when entering the "Color Theme" menu  item...
                        // we launch the color theme menu + clear the "close menu" timer
                        Util.addEvent(optDefThemeMenuItem, "mouseenter", function() {
                            window.clearTimeout(themeTimeout);
                            var configMenu = _g("optMenuConfig" + componentId);
                            if (!configMenu) {
                                launchThemeMenu(componentId, fullId, secId, this);
                            }
                            else {
                                if (Util.Style.ccss(configMenu, "menu-hide")) {
                                    OpenCompOptMenu(configMenu, fullId, this); //eslint-disable-line new-cap
                                }
                            }
                        });
                        // When entering the component menu container...
                        // if we aren't moving into the "Color Theme" menu item, trigger the "close menu" timer
                        Util.addEvent(optMenu, "mouseenter", function(e) {
                            if (!e) {
                                e = window.event;
                            }
                            var target = e.target || e.srcElement;
                            if (!Util.Style.ccss(target, "opts-def-theme")) {
                                themeOut(e);
                            }
                        });
                        // When leaving the "Color Theme" menu item...
                        // if we aren't moving into the component menu container or moving into the color themes menu, trigger the "close menu" timer
                        Util.addEvent(optDefThemeMenuItem, "mouseleave", function(e) {
                            if (!e) {
                                e = window.event;
                            }
                            window.clearTimeout(themeTimeout);
                            var relTarg = e.relatedTarget || e.toElement;
                            if (relTarg && !Util.Style.ccss(relTarg, "opts-menu-content") && !Util.Style.ccss(relTarg, "opts-menu-config-content")) {
                                themeOut(e);
                            }
                        });

                        $(_g("optsDefState" + componentId)).unbind("click");
                        $(_g("optsDefState" + componentId)).bind("click",function() {
                            launchSetState(componentId, this);
                        });
                        if(MP_Util.GetCompObjById(componentId).isExpanded()){
                            $(_g("optsDefState" + componentId).getElementsByTagName('span')).addClass("opts-menu-def-exp");
                        }

                        if (infoInd) {
                            Util.addEvent(_g("optsInfoState" + componentId), "click", function() {
                                launchInfoSetState(componentId, this);
                            });
                        }
                    }
                }
            };
            var mns = mpComps;
            var mLen = mns.length;
            for (var i = 0; i < mLen; i++) {
                var curComp = mns[ i ];
                var ns = curComp.m_styles.m_nameSpace;
                var compId = curComp.m_styles.m_componentId;
                var fullId = "mainCompMenu" + ns + compId;
                var isExp = curComp.isExpanded();
                var infoInd = curComp.hasInfoButton();
                var infoState = curComp.isInfoButtonEnabled();
                if (ns !== "cust") {
                    setupCompMenu(compId, fullId, isExp, infoInd, infoState);
                } else {
                    setupCustCompMenu(curComp, compId, fullId, ns);
                }
            }
        },
        /**
         * Hide all Component Menus
         */
        HideAllCompMenus: function() {
            var mnus = Util.Style.g("opts-menu-content", null, "div");
            var mnLen = mnus.length;
            for (var m = mnLen; m--;) {
                if (!Util.Style.ccss(mnus[ m ], "menu-hide")) {
                    Util.Style.acss(mnus[ m ], "menu-hide");
                }
            }
        },
        GetComments: function(par, personnelArray) {
            var com = "",
                recDate = "";
            var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
            for (var j = 0, m = par.COMMENTS.length; j < m; j++) {
                if (personnelArray.length != null) {  //eslint-disable-line eqeqeq
                    if (par.COMMENTS[ j ].RECORDED_DT_TM != "") {  //eslint-disable-line eqeqeq
                        recDate = df.formatISO8601(par.COMMENTS[ j ].RECORDED_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
                    }
                    if (j > 0) {
                        com += "<br />";
                    }
                    if (par.COMMENTS[ j ].RECORDED_BY > 0) {
                        com += recDate + " - " + MP_Util.GetValueFromArray(par.COMMENTS[ j ].RECORDED_BY, personnelArray).fullName + "<br />" + par.COMMENTS[ j ].COMMENT_TEXT; //eslint-disable-line new-cap
                    }
                    else {
                        com += recDate + "<br />" + par.COMMENTS[ j ].COMMENT_TEXT;
                    }
                }
            }
            return com;
        },
        FinalizeComponent: function(contentHTML, component, countText) {
            var styles = component.getStyles();

            //replace count text
            var rootComponentNode = component.getRootComponentNode();
            //There are certain circumstances where a components DOM element will have been removed.
            //ie. selecting a view from the viewpoint drop down and then selecting another.
            if (rootComponentNode) {
                var totalCount = Util.Style.g("sec-total", rootComponentNode, "span");
                if (countText && totalCount && totalCount.length) {
                    //sets the result count of the specific component to get it in component load details timer
                    component.setResultCount(countText);
                    //Make sure the count text is not hidden.
                    $(totalCount).removeClass("hidden");
                    totalCount[ 0 ].innerHTML = countText;
                }
                else if (totalCount && totalCount.length) {
                    //If there is no count text to show then hide the element so it doesn't take up space.
                    $(totalCount).addClass("hidden");
                }

                //replace content with HTML
                var node = component.getSectionContentNode();
                node.innerHTML = contentHTML;

                //init hovers
                MP_Util.Doc.InitHovers(styles.getInfo(), node, component); //eslint-disable-line new-cap

                //init subsection toggles
                MP_Util.Doc.InitSubToggles(node, "sub-sec-hd-tgl"); //eslint-disable-line new-cap

                //init scrolling
                //Wrap in timeout to momentarly break the JS processing up and allow the browswer to render.
                setTimeout(function() {
                    MP_Util.Doc.InitScrolling(Util.Style.g("scrollable", node, "div"), component.getScrollNumber(), "1.6"); //eslint-disable-line new-cap
                }, 0);

                //Check to see if the component has an error message displayed
                var errorElement = $(rootComponentNode).find(".error-message");
                if (errorElement.length) {
                    //Add an error icon to the component title
                    $(rootComponentNode).find(".sec-title>span:first-child").addClass("error-icon-component");
                    //Ensure the bottom border on the error message is red and the padding is consistent
                    $(errorElement).css("border", "1px solid #C00").css("padding", "2px 4px");
                    //Fire and event to inform any listener that the component has errored
                    CERN_EventListener.fireEvent(component, component, EventListener.EVENT_ERROR_UPDATE, {
                        "error": true
                    });
                }
                else {
                    //Remove the error icon in the component title
                    $(rootComponentNode).find(".sec-title>span:first-child").removeClass("error-icon-component");
                    //Fire and event to inform any listener that the component has not errored
                    CERN_EventListener.fireEvent(component, component, EventListener.EVENT_ERROR_UPDATE, {
                        "error": false
                    });
                }
            }

            //notify the aggregate timer that the component has finished loading
            component.notifyAggregateTimer();

            if (component.getOnFinalizeComponent && component.getOnFinalizeComponent()) {
                component.getOnFinalizeComponent()();
            }
        },
        /**
         * Formats the content to the appropriate height and enables scrolling
         * @param {node} content : The content to be formatted
         * @param {int} num : The approximate number of items to display face up
         * @param {float} ht : The total line height of an item
         */
        InitScrolling: function(content, num, ht) {
            for (var k = 0; k < content.length; k++) {
                MP_Util.Doc.InitSectionScrolling(content[ k ], num, ht); //eslint-disable-line new-cap
            }
        },
        /**
         * Formats the section to the appropriate height and enables scrolling
         * @param {node} sec : The section to be formatted
         * @param {int} num : The approximate number of items to display face up
         * @param {float} ht : The total line height of an item
         */
        InitSectionScrolling: function(sec, num, ht) {
            var th = num * ht;
            var totalHeight = th + "em";

            sec.style.maxHeight = totalHeight;
            sec.style.overflowY = "auto";
            sec.style.overflowX = "hidden";
        },
        InitHovers: function(trg, par, component) {
            var gen = Util.Style.g(trg, par, "DL");

            for (var i = 0, l = gen.length; i < l; i++) {
                var m = gen[ i ];
                if (m) {
                    var nm = Util.gns(Util.gns(m));
                    if (nm) {
                        if (Util.Style.ccss(nm, "hvr")) {
                            hs(m, nm, component);
                        }
                    }
                }
            }
        },
        InitSubToggles: function(par, tog) {
            var i18nCore = i18n.discernabu;
            var toggleArray = Util.Style.g(tog, par, "span");
            for (var k = 0; k < toggleArray.length; k++) {
                Util.addEvent(toggleArray[ k ], "click", MP_Util.Doc.ExpandCollapse);
                var checkClosed = Util.gp(Util.gp(toggleArray[ k ]));
                if (Util.Style.ccss(checkClosed, "closed")) {
                    toggleArray[ k ].innerHTML = "+";
                    toggleArray[ k ].title = i18nCore.SHOW_SECTION;
                }
            }
        },


        /**
         * Adds the title to the page.
         * @param {String} title The title of the page to display
         * @param {Object} bodyTag The body tag associated to the HTML document
         * @param {Boolean} debugInd Indicator denoting if the mpage should run in debug mode.
         * @param {Boolean} custInd Indicator denoting if the 'customize' option should be made available to the user for the given layout
         * @param {String} helpFile The string name of the help file to associate to the page.
         * @param {String} helpURL The String name of the help file URL to associate to the page.
         * @param {Object} criterion The object associated to the criterion data
         * @param {String} categoryMeaning The String name of the MPages View
         */
        AddPageTitle: function(title, bodyTag, debugInd, custInd, anchorArray, helpFile, helpURL, criterion, categoryMeaning) {
            var i18nCore = i18n.discernabu;
            var ar = [];
            if (categoryMeaning) {
                title = "";
                bodyTag = _g(categoryMeaning);
                bodyTag.innerHTML = "";
            }
            else {
                if (bodyTag) {
                    bodyTag = document.body;
                }
            }
            ar.push("<div class='pg-hd'>");
            ar.push("<h1><span class='pg-title'>", title, "</span></h1><span id='pageCtrl", criterion.category_mean, "' class='page-ctrl'>");

            //'as of' date is always to the far left of items
            if (categoryMeaning) {
                var df = MP_Util.GetDateFormatter(); //eslint-disable-line new-cap
                ar.push("<span class='other-anchors'>", i18nCore.AS_OF_TIME.replace("{0}", df.format(new Date(), mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS)), "</span>");
            }
            if (anchorArray) {
                for (var x = 0, xl = anchorArray.length; x < xl; x++) {
                    ar.push("<span class='other-anchors'>" + anchorArray[ x ] + "</span>");
                }
            }

            if (custInd || categoryMeaning) {//customizable single view or in a view point
                var pageMenuId = "pageMenu" + criterion.category_mean;
                ar.push("<span id='", pageMenuId, "' class='page-menu'>&nbsp;</span>");
            }
            ar.push("</span></div>");
            bodyTag.innerHTML += ar.join("");
            return;
        },
        /**
         * Launches the help file in a new modal window
         * @param {String} HelpURL The String name of the help file  to associate to the page.
         */
        LaunchHelpWindow: function(helpURL) {
            var wParams = "left=0,top=0,width=1200,height=700,toolbar=no";
            logger.logCCLNewSessionWindowInfo(null, helpURL, "mp_core.js", "LaunchHelpWindow");
            CCLNEWSESSIONWINDOW(helpURL, "_self", wParams, 0, 1); //eslint-disable-line new-cap
            Util.preventDefault();
        },
        /**
         * @deprecated - This function is no longer valid and should not be used
         */
        AddCustomizeLink: function(criterion) {
            var custNode = _g("custView" + criterion.category_mean);
            if (custNode) {
                //The code below has been removed since the customize option is no longer in use.  Work still needs to be done
                //To remove this function from all locations where AddCustomLink is called.
                logger.logWarn("AddCustomizeLink is a deprecated function and should not be utilized");
            }
        },
        ExpandCollapse: function() {
            var i18nCore = i18n.discernabu;
            var gpp = Util.gp(Util.gp(this));
            if (Util.Style.ccss(gpp, "closed")) {
                Util.Style.rcss(gpp, "closed");
                this.innerHTML = "-";
                this.title = i18nCore.HIDE_SECTION;
                this.setAttribute("aria-label",i18nCore.HIDE_SECTION);
            }
            else {
                Util.Style.acss(gpp, "closed");
                this.innerHTML = "+";
                this.title = i18nCore.SHOW_SECTION;
                this.setAttribute("aria-label",i18nCore.SHOW_SECTION);
            }
        },
        HideHovers: function() {
            var hovers = Util.Style.g("hover", document.body, "DIV");
            for (var i = hovers.length; i--;) {
                if (Util.gp(hovers[ i ]).nodeName == "BODY") {  //eslint-disable-line eqeqeq
                    hovers[ i ].style.display = "none";
                    Util.de(hovers[ i ]);
                }
            }
        },
        ReplaceSubTitleText: function(component, text) {
            var lookbackDisplay = $("#lookbackDisplay" + component.getStyles().getId());
            if (lookbackDisplay.length) {
                lookbackDisplay.html(text);
            }
        },
        ReInitSubTitleText: function(component) {
            if (component.getScope() > 0) {
                var lookbackDisplay = $("#lookbackDisplay" + component.getStyles().getId());
                if (lookbackDisplay.length) {
                    lookbackDisplay.html(CreateSubTitleText(component)); //eslint-disable-line new-cap
                }
            }
        },
        /*Copyright (c) 2006-2010 Paranoid Ferret Productions.  All rights reserved.

         Developed by: Paranoid Ferret Productions
         http://www.paranoidferret.com

         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
         CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
         FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
         WITH THE SOFTWARE.*/

        RunAccordion: function(index) {
            var nID = "Accordion" + index + "Content";
            var TimeToSlide = 100.0;
            var titleDiv = _g("Accordion" + index + "Title");
            var containerDiv = _g("AccordionContainer" + index);

            //Adjust the pull tab image
            if (Util.Style.ccss(titleDiv, "Expanded")) {
                Util.Style.rcss(titleDiv, "Expanded");
                Util.Style.rcss(containerDiv, "Expanded");
            }
            else {
                Util.Style.acss(titleDiv, "Expanded");
                Util.Style.acss(containerDiv, "Expanded");
            }

            if (openAccordion == nID) { //eslint-disable-line eqeqeq
                nID = "";
            }

            setTimeout("MP_Util.Doc.Animate(" + new Date().getTime() + "," + TimeToSlide + ",'" + openAccordion + "','" + nID + "'," + index + ")", 33);
            openAccordion = nID;
        },
        Animate: function(lastTick, timeLeft, closingId, openingId, compID) {
            var TimeToSlide = timeLeft;
            var curTick = new Date().getTime();
            var elapsedTicks = curTick - lastTick;
            var ContentHeight = 275.0;

            var opening = (openingId == "") ? null : _g(openingId);  //eslint-disable-line eqeqeq
            var closing = (closingId == "") ? null : _g(closingId);  //eslint-disable-line eqeqeq

            if (timeLeft <= elapsedTicks) {
                if (opening) {
                    opening.style.display = "block";
                    opening.style.height = ContentHeight + "px";
                }

                if (closing) {
                    closing.style.display = "none";
                    closing.style.height = "0px";
                }
                return;
            }

            timeLeft -= elapsedTicks;
            var newClosedHeight = Math.round((timeLeft / TimeToSlide) * ContentHeight);

            if (opening) {
                if (opening.style.display != "block") {  //eslint-disable-line eqeqeq
                    opening.style.display = "block";
                    opening.style.height = (ContentHeight - newClosedHeight) + "px";
                }
            }
            if (closing) {
                closing.style.height = newClosedHeight + "px";
            }

            setTimeout("MP_Util.Doc.Animate(" + curTick + "," + timeLeft + ",'" + closingId + "','" + openingId + "'," + compID + ")", 33);
        },
        GetSelected: function(opt) {
            var selected = [];
            var index = 0;
            var optLen = opt.length;
            for (var intLoop = 0; intLoop < optLen; intLoop++) {
                if (opt[ intLoop ].selected) {
                    index = selected.length;
                    selected[ index ] = {};
                    selected[ index ].value = opt[ intLoop ].value;
                    selected[ index ].index = intLoop;
                }
            }
            return selected;
        },
        /* Reset Layout functionality*/
        ResetLayoutSettings: function(mPageObj) {
            var componentSettings = mPageObj.getViewSettings().BR_SET.CS; //BR_SET is shorthand for Bedrock Settings and CS is shorthand for Component Settings
            var components = mPageObj.getComponents();
            var tempComp = null;
            var tempCompSettings = {};
            var x = 0;
            //Create a map so we dont have to search the componentSettings more than once
            var componentMap = {};
            for (x = componentSettings.length; x--;) {
                componentMap[ componentSettings[ x ].R_MN ] = componentSettings[ x ]; //R_MN is shorthand for Report Mean
            }

            //Grab the settings from the componentMap and reset the sequence and row to what is originally defined in bedrock
            for (x = components.length; x--;) {
                tempComp = components[ x ];
                tempCompSettings = componentMap[ tempComp.getReportMean() ];
                components[ x ].setSequence(tempCompSettings.R_SQ); //R_SQ is shorthand for Row Sequence
                components[ x ].setColumn(tempCompSettings.C_SQ); //C_SQ is shorthand for Row Sequence
            }

            //Show the cursor as busy
            $("body").css("cursor", "wait");
            //This call is used to update all of the component's settings before refreshing the page.
            MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(components); //eslint-disable-line new-cap

            //Refresh the Page or Viewpoint
            CERN_Platform.refreshMPage();
        }
    };


    function launchThemeMenu(componentId, fullId, secId, that) {
        var i18nCore = i18n.discernabu;
        var optMenu = _g("optMenuConfig" + componentId);
        if (!optMenu) {
            optMenu = Util.cep("div", {
                "className": "opts-menu-config-content menu-hide",
                "id": "optMenuConfig" + componentId
            });
            var optMenuJsHTML = [];
            optMenuJsHTML.push("<div title = '", i18nCore.COLOR_STANDARD, "' class='opts-menu-config-item opt-config-mnu-lightgrey' data-color='lightgrey' id='optConfigMnuLightGrey", componentId, "'></div>", "<div title = '", i18nCore.COLOR_BROWN, "' class='opts-menu-config-item opt-config-mnu-brown' data-color='brown' id='optConfigMnuBrown", componentId, "'></div>", "<div title = '", i18nCore.COLOR_CERNER_BLUE, "' class='opts-menu-config-item opt-config-mnu-cernerblue' data-color='cernerblue' id='optConfigMnuCernerBlue", componentId, "'></div>", "<div title = '", i18nCore.COLOR_DARK_GREEN, "' class='opts-menu-config-item opt-config-mnu-darkgreen' data-color='darkgreen' id='optConfigMnuDarkGreen", componentId, "'></div>", "<div title = '", i18nCore.COLOR_GREEN, "' class='opts-menu-config-item opt-config-mnu-green' data-color='green' id='optConfigMnuGreen", componentId, "'></div>", "<div title = '", i18nCore.COLOR_GREY, "' class='opts-menu-config-item opt-config-mnu-grey' data-color='grey' id='optConfigMnuGrey", componentId, "'></div>", "<div title = '", i18nCore.COLOR_LIGHT_BLUE, "' class='opts-menu-config-item opt-config-mnu-lightblue' data-color='lightblue' id='optConfigMnuLightBlue", componentId, "'></div>", "<div title = '", i18nCore.COLOR_NAVY, "' class='opts-menu-config-item opt-config-mnu-navy' data-color='navy' id='optConfigMnuNavy", componentId, "'></div>", "<div title = '", i18nCore.COLOR_ORANGE, "' class='opts-menu-config-item opt-config-mnu-orange' data-color='orange' id='optConfigMnuOrange", componentId, "'></div>", "<div title = '", i18nCore.COLOR_PINK, "' class='opts-menu-config-item opt-config-mnu-pink' data-color='pink' id='optConfigMnuPink", componentId, "'></div>", "<div title = '", i18nCore.COLOR_PURPLE, "' class='opts-menu-config-item opt-config-mnu-purple' data-color='purple' id='optConfigMnuPurple", componentId, "'></div>", "<div title = '", i18nCore.COLOR_YELLOW, "' class='opts-menu-config-item opt-config-mnu-yellow' data-color='yellow' id='optConfigMnuYellow", componentId, "'></div>");

            optMenu.innerHTML = optMenuJsHTML.join("");

            Util.ac(optMenu, document.body);
            //actual contents of the menu are appended to body and positioned in launchOptMenu

            Util.addEvent(_g("optMenuConfig" + componentId), "click", function(e) {
                var target = e.target || e.srcElement;
                var color = target.getAttribute("data-color");
                changeThemeColor(componentId, color, secId);
            });

            InitCompOptMenu(optMenu, componentId, true); //eslint-disable-line new-cap
        }

        OpenCompOptMenu(optMenu, fullId, that); //eslint-disable-line new-cap
    }

    function changeThemeColor(componentId, color, styleId) {
        var section = _g(styleId);
        if (section) {
            var colorString = "brown|cernerblue|darkgreen|grey|green|lightblue|lightgrey|lowlight|navy|orange|pink|purple|yellow";
            //a color is found in the class name so replace it with ""
            if (colorString.indexOf(color) >= 0) {
                var colorRegExp = /brown|cernerblue|darkgreen|grey|green|lightblue|lightgrey|lowlight|navy|orange|pink|purple|yellow/;
                section.className = section.className.replace(colorRegExp, "");
            }

            //add the new color so it changes for the user
            Util.Style.acss(section, color);
            var component = MP_Util.GetCompObjById(componentId); //eslint-disable-line new-cap
            component.setCompColor(color);
            //add the color to the component properties
            setTimeout(function() {
                MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, color, null, false); //eslint-disable-line new-cap
            }, 0);
        }
    }

    function launchSetState(componentId, defStateEl) {
        var component = MP_Util.GetCompObjById(componentId); //eslint-disable-line new-cap
        var curExpColState = component.isExpanded();
        component.setExpandCollapseState(!curExpColState);
        var checkSpan = _gbt("span", defStateEl)[ 0 ];

        if (!curExpColState) {
            if (checkSpan) {
                Util.Style.acss(checkSpan, "opts-menu-def-exp");
            }
            setTimeout(function() {
                MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, "", "1", false); //eslint-disable-line new-cap
            }, 0);
        }
        else {
            if (checkSpan) {
                Util.Style.rcss(checkSpan, "opts-menu-def-exp");
            }
            setTimeout(function() {
                MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, "", "0", false); //eslint-disable-line new-cap
            }, 0);
        }
    }

    function launchInfoSetState(componentId, infoStateEl) {
        //false = Disabled, true = Enabled
        var component = MP_Util.GetCompObjById(componentId); //eslint-disable-line new-cap
        var curInfoState = component.isInfoButtonEnabled();
        var checkSpan = _gbt("span", infoStateEl)[ 0 ];
    // Get the component name from the report mean
        var componentName = "";
        if(component.m_reportMean && typeof component.m_reportMean !== "undefined"){
            componentName = component.m_reportMean.split('_').slice(3).join(' ');
        }
        var category_mean = component.getCriterion().category_mean;
        var capTimer = null;
        //component.setIsInfoButtonEnabled(!curInfoState);
        if (curInfoState) {
            component.setIsInfoButtonEnabled(0);
        }
        else {
            capTimer = new CapabilityTimer("CAP:MPG_ENABLE_INFOBUTTON", category_mean); //eslint-disable-line no-undef
            if(capTimer){
                capTimer.addMetaData("rtms.legacy.metadata.1", "InfoButton is enabled from the " + componentName + " Summary Component");
                capTimer.capture();
            }
            component.setIsInfoButtonEnabled(1);
        }

        if (!curInfoState) { //Currently disabled, turning to enabled
            if (checkSpan) {
                Util.Style.acss(checkSpan, "opts-menu-info-en");
                //Call the component function to show info button and allow click event
                component.showInfoButton(component, true);
                setTimeout(function() {
                    MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, "", "", false, "1"); //eslint-disable-line new-cap
                }, 0);
            }
        }
        else {
            if (checkSpan) {
                Util.Style.rcss(checkSpan, "opts-menu-info-en");
                //Call the component function to remove info button
                component.showInfoButton(component, false);
                setTimeout(function() {
                    MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, "", "", false, "0"); //eslint-disable-line new-cap
                }, 0);
            }
        }
    }

    function InitCompOptMenu(inMenu, componentId, isSubMenu) {
        var closeMenu = function(e) {
            if (!e) {
                e = window.event;
            }
            var relTarg = e.relatedTarget || e.toElement;
            var mainMenu = _g("moreOptMenu" + componentId);
            if (isSubMenu) {
                var target = e.target || e.srcElement;
            }
            if (relTarg) {
                if (!Util.Style.ccss(relTarg, "opts-menu-config-content")) {
                    compMenuTimeout = window.setTimeout(function() {
                        if (mainMenu) {
                            if (!Util.Style.ccss(relTarg, "opts-menu-content")) {
                                Util.Style.acss(mainMenu, "menu-hide");
                            }
                        }
                        if (isSubMenu) {
                            Util.Style.acss(inMenu, "menu-hide");
                            if (Util.Style.ccss(target, "opts-menu-content") && !Util.Style.ccss(relTarg, "opts-menu-content")) {
                                if (_g("moreOptMenu" + componentId)) {
                                    Util.Style.acss(_g("moreOptMenu" + componentId), "menu-hide");
                                }
                            }
                        }
                        if (_g("optMenuConfig" + componentId)) {
                            Util.Style.acss(_g("optMenuConfig" + componentId), "menu-hide");
                        }
                    }, compMenuDelay);

                }
            }
            else {
                if (mainMenu) {
                    Util.Style.acss(mainMenu, "menu-hide");
                }
            }
            Util.cancelBubble(e);
        };
        $(inMenu).mouseleave(closeMenu);
        $(inMenu).mouseenter(function() {
            window.clearTimeout(compMenuTimeout);
        });
    }

    /**
     * Open the options menu within the new order entry component
     * @param {node} menu : The menu node
     * @param {string} sectionId : The html id of the section containing the menu
     */
    function OpenCompOptMenu(menu, sectionId, that) {
        var verticalOffset = 30;
        var ofs;
        if (Util.Style.ccss(menu, "menu-hide")) {
            Util.preventDefault();
            Util.Style.rcss(menu, "menu-hide");

            if (that) {
                ofs = Util.goff(that);
                var thisWidth = that.offsetWidth;
                var divOfs = menu.offsetWidth;

                var vpOfs = ofs[ 0 ] - divOfs;
                if (vpOfs > 0) {
                    menu.style.left = (vpOfs - 2) + "px";
                    //  Util.Style.acss(mpDiv, 'hml-mpd-lt');
                }
                else {
                    menu.style.left = (ofs[ 0 ] + thisWidth + 6) + "px";
                    //  Util.Style.acss(mpDiv, 'hml-mpd-rt');

                }
                menu.style.top = (ofs[ 1 ] - 5) + "px";
            }
            else {
                var menuId = "#mainCompMenu" + sectionId;
                var menuElement = $(menuId);
                if (menuElement.length) {
                    //Component menu logic
                    menu.style.left = ($(menuElement).offset().left - 125) + "px";
                    menu.style.top = ($(menuElement).offset().top + 18) + "px";
                }
                else {
                    //Page level menu logic
                    var sec = _g(sectionId);
                    ofs = Util.goff(sec);
                    menu.style.left = (ofs[ 0 ] + sec.offsetWidth - menu.offsetWidth) + "px";
                    menu.style.top = (ofs[ 1 ] + verticalOffset) + "px";
                }
            }
        }
        else {
            Util.Style.acss(menu, "menu-hide");
        }
    }

    function CreateSubTitleText(component) {
        var i18nCore = i18n.discernabu;
        var subTitleText = "";
        var scope = component.getScope();
        var lookbackDays = component.getLookbackDays();
        var lookbackUnits = (lookbackDays > 0) ? lookbackDays : component.getLookbackUnits();
        var lookbackFlag = (lookbackDays > 0) ? 2 : component.getLookbackUnitTypeFlag();

        if (scope > 0) {
            if (lookbackFlag > 0 && lookbackUnits > 0) {
                var replaceText = "";
                switch (lookbackFlag) {
                    case 1:
                        replaceText = i18nCore.LAST_N_HOURS.replace("{0}", lookbackUnits);
                        break;
                    case 2:
                        replaceText = i18nCore.LAST_N_DAYS.replace("{0}", lookbackUnits);
                        break;
                    case 3:
                        replaceText = i18nCore.LAST_N_WEEKS.replace("{0}", lookbackUnits);
                        break;
                    case 4:
                        replaceText = i18nCore.LAST_N_MONTHS.replace("{0}", lookbackUnits);
                        break;
                    case 5:
                        replaceText = i18nCore.LAST_N_YEARS.replace("{0}", lookbackUnits);
                        break;
                }

                switch (scope) {
                    case 1:
                        subTitleText = i18nCore.ALL_N_VISITS.replace("{0}", replaceText);
                        break;
                    case 2:
                        subTitleText = i18nCore.SELECTED_N_VISIT.replace("{0}", replaceText);
                        break;
                }

            }
            else {
                switch (scope) {
                    case 1:
                        subTitleText = i18nCore.All_VISITS;
                        break;
                    case 2:
                        subTitleText = i18nCore.SELECTED_VISIT;
                        break;
                }
            }
        }
        return subTitleText;
    }
}();

/**
 * @namespace
 */
MP_Util.Measurement = function() {

    return {
        GetString: function(result, codeArray, dateMask, excludeUOM) {
            var obj = ( result instanceof MP_Core.Measurement) ? result.getResult() : MP_Util.Measurement.GetObject(result, codeArray); //eslint-disable-line new-cap
            if (obj instanceof MP_Core.QuantityValue) {
                if (excludeUOM) {
                    return obj.getValue();
                }
                return obj.toString();
            }
            else if (obj instanceof Date) {
                return obj.format(dateMask);
            }
            return obj;
        },
        GetObject: function(result, codeArray) {
            switch (result.CLASSIFICATION.toUpperCase()) {
                case "QUANTITY_VALUE":
                    return GetQuantityValue(result, codeArray); //eslint-disable-line new-cap
                case "STRING_VALUE":
                    return (GetStringValue(result)); //eslint-disable-line new-cap
                case "DATE_VALUE":
                    //we are currently not returning any date_value results. a common method shall be implemented if/when necessary
                    return (GetDateValue(result)); //eslint-disable-line new-cap
                case "CODIFIED_VALUES":
                case "CODE_VALUE":
                    return (GetCodedResult(result)); //eslint-disable-line new-cap
                case "ENCAPSULATED_VALUE":
                    return (GetEncapsulatedValue(result)); //eslint-disable-line new-cap
            }
        },
        /**
         * @param {Object} num Numeric to format
         * @param {Object} dec Number of decimal places to retain.
         * @deprecated Use mp_formatter.NumericFormatter.
         */
        SetPrecision: function(num, dec) {
            var nf = MP_Util.GetNumericFormatter(); //eslint-disable-line new-cap
            //'^' to not comma seperate values, and '.' for defining the precision
            return nf.format(num, "^." + dec);
        },
        GetModifiedIcon: function(result) {
            return (result.isModified()) ? "<span class='res-modified'>&nbsp;</span>" : "";
        },
        /* This calls MP_Core.GetNormalcyClass which returns the normalcy class associated with the result
         * @param oMeasurement - is the MP_Core.Measurement object.
         */
        GetNormalcyClass: function(oMeasurement) {
           return MP_Core.GetNormalcyClass(oMeasurement);//eslint-disable-line new-cap
        },
        /**
         * This function calls MP_Core.GetNormalcyResultDisplay which associates appropriate styles to the results.
         * @param oMeasurement - is the MP_Core.Measurement object.
         * @param excludeUOM - This value indicates whether to add the Unit of measurement or not.
         */
        GetNormalcyResultDisplay: function(oMeasurement, excludeUOM) {
            return MP_Core.GetNormalcyResultDisplay(oMeasurement, excludeUOM);//eslint-disable-line new-cap
        }
    };
    /**
     * This function calls MP_Core.GetEventViewerLink which links the result viewer to the respective results.
     * @param oMeasurement - is the MP_Core.Measurement object.
     * @param sResultDisplay - This contains the  value that needs to be displayed.
     */
    function GetEventViewerLink(oMeasurement, sResultDisplay) {//eslint-disable-line no-unused-vars
       return MP_Core.GetEventViewerLink(oMeasurement, sResultDisplay);//eslint-disable-line new-cap
    }

    function GetEncapsulatedValue(result) {
        var ar = [];
        var encap = result.ENCAPSULATED_VALUE;
        if (encap && encap.length > 0) {
            for (var n = 0, nl = encap.length; n < nl; n++) {
                var txt = encap[ n ].TEXT_PLAIN;
                if (txt != null && txt.length > 0)  //eslint-disable-line eqeqeq
                    ar.push(txt);
            }
        }
        return ar.join("");
    }

    function GetQuantityValue(result, codeArray) {
        var qv = new MP_Core.QuantityValue();
        qv.init(result, codeArray);
        return qv;
    }

    function GetDateValue(result) {
        for (var x = 0, xl = result.DATE_VALUE.length; x < xl; x++) {
            var date = result.DATE_VALUE[ x ];
            if (date.DATE != "") {  //eslint-disable-line eqeqeq
                var dateTime = new Date();
                dateTime.setISO8601(date.DATE);
                return dateTime;
            }
        }
        return null;
    }

    function GetCodedResult(result) {
        var cdValue = result.CODE_VALUE;
        var ar = [];
        for (var n = 0, nl = cdValue.length; n < nl; n++) {
            var values = cdValue[ n ].VALUES;
            for (var p = 0, pl = values.length; p < pl; p++) {
                ar.push(values[ p ].SOURCE_STRING);
            }
            var sOther = cdValue[ n ].OTHER_RESPONSE;
            if (sOther != "")  //eslint-disable-line eqeqeq
                ar.push(sOther);
        }
        return ar.join(", ");
    }

    function GetStringValue(result) {
        var strValue = result.STRING_VALUE;
        var ar = [];
        for (var n = 0, nl = strValue.length; n < nl; n++) {
            ar.push(strValue[ n ].VALUE);
        }
        return ar.join(", ");
    }

}();


/* Listener Event Class */
/*
 * Copyright (c) 2007 	Josh Davis ( http://joshdavis.wordpress.com )
 *
 * Licensed under the MIT License ( http://www.opensource.org/licenses/mit-license.php ) as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

/**
 * Create a new instance of Event.
 *
 * @classDescription    This class creates a new Event.
 * @returns {Object}    Returns a new Event object.
 * @constructor
 */
function EventListener() { //eslint-disable-line no-redeclare
    this.events = [];
    this.builtinEvts = [];
}

/**
 * Gets the index of the given action for the element
 *
 * @memberOf Event
 * @param {Object} obj The element attached to the action.
 * @param {String} evt The name of the event.
 * @param {Function} action The action to execute upon the event firing.
 * @param {Object} binding The object to scope the action to.
 * @returns {Number} Returns an integer.
 */
EventListener.prototype.getActionIdx = function(obj, evt, action, binding) {
    if (obj && evt) {

        var curel = this.events[ obj ][ evt ];
        if (curel) {
            var len = curel.length;
            for (var i = len - 1; i >= 0; i--) {
                if (curel[ i ].action == action && curel[ i ].binding == binding) { //eslint-disable-line eqeqeq
                    return i;
                }
            }
        }
        else {
            return -1;
        }
    }
    return -1;
};

/**
 * Adds a listener
 *
 * @memberOf Event
 * @param {Object} obj The element attached to the action.
 * @param {String} evt The name of the event.
 * @param {Function} action The action to execute upon the event firing.
 * @param {Object} binding The object to scope the action to.
 * @returns {null} Returns null.
 */
EventListener.prototype.addListener = function(obj, evt, action, binding) {
    if (this.events[ obj ]) {
        if (this.events[ obj ][ evt ]) {
            if (this.getActionIdx(obj, evt, action, binding) == -1) { //eslint-disable-line eqeqeq
                var curevt = this.events[ obj ][ evt ];
                curevt[ curevt.length ] = {
                    action: action,
                    binding: binding
                };
            }
        }
        else {
            this.events[ obj ][ evt ] = [];
            this.events[ obj ][ evt ][ 0 ] = {
                action: action,
                binding: binding
            };
        }
    }
    else {
        this.events[ obj ] = [];
        this.events[ obj ][ evt ] = [];
        this.events[ obj ][ evt ][ 0 ] = {
            action: action,
            binding: binding
        };
    }
};

/**
 * Removes a listener
 *
 * @memberOf Event
 * @param {Object} obj The element attached to the action.
 * @param {String} evt The name of the event.
 * @param {Function} action The action to execute upon the event firing.
 * @param {Object} binding The object to scope the action to.
 * @returns {null} Returns null.
 */
EventListener.prototype.removeListener = function(obj, evt, action, binding) {
    if (this.events[ obj ]) {
        if (this.events[ obj ][ evt ]) {
            var idx = this.getActionIdx(obj, evt, action, binding);
            if (idx >= 0) {
                this.events[ obj ][ evt ].splice(idx, 1);
            }
        }
    }
};
/**
 * Removes all listeners for a given object with given binding
 *
 * @memberOf Event
 * @param {Object} obj The element attached to the action.
 * @param {Object} binding The object to scope the action to.
 * @returns {null} Returns null.
 */
EventListener.prototype.removeAllListeners = function(obj, binding) {
    if (this.events[ obj ]) {
        for (var el in  this.events[ obj ]) {
            if (this.events[ obj ].hasOwnProperty(el)) {
                for (var ev = this.events[ obj ][ el ].length; ev--;) {
                    if (this.events[ obj ][ el ][ ev ].binding == binding) { //eslint-disable-line eqeqeq
                        this.events[ obj ][ el ].splice(ev, 1);
                    }
                }
            }
        }
    }
};

/**
 * Fires an event
 *
 * @memberOf Event
 * @param e A builtin event passthrough
 * @param {Object} obj The element attached to the action.
 * @param {String} evt The name of the event.
 * @param {Object} args The argument attached to the event.
 * @returns {null} Returns null.
 */
EventListener.prototype.fireEvent = function(e, obj, evt, args) {
    if (!e) {
        e = window.event;
    }

    if (obj && this.events) {
        var evtel = this.events[ obj ];
        if (evtel) {
            var curel = evtel[ evt ];
            if (curel) {
                for (var act = curel.length; act--;) {
                    var action = curel[ act ].action;
                    if (curel[ act ].binding) {
                        action = action.bind(curel[ act ].binding);
                    }
                    action(e, args);
                }
            }
        }
    }
};
CERN_EventListener = new EventListener();

//Constants for event Listener
EventListener.EVENT_CLINICAL_EVENT = 1;
EventListener.EVENT_ORDER_ACTION = 2;
EventListener.EVENT_ADD_DOC = 3;
EventListener.EVENT_PREGNANCY_EVENT = 4;
EventListener.EVENT_COMP_CUSTOMIZE = 5;
EventListener.EVENT_COUNT_UPDATE = 6;
EventListener.EVENT_CRITICAL_UPDATE = 7;
EventListener.EVENT_ERROR_UPDATE = 8;
EventListener.EVENT_SCRATCHPAD_COUNT_UPDATE = 9;
EventListener.EVENT_SCRATCHPAD_REMOVED_ORDER = 10;
EventListener.EVENT_SCRATCHPAD_REMOVED_ORDER_ACTION = 11;
EventListener.EVENT_SCRATCHPAD_RECEIVED_ORDER_ACTION = 12;
EventListener.EVENT_REMOVE_PERSONAL_FAV_FOLDER = 13;
EventListener.EVENT_QOC_VIEW_VENUE_CHANGED = 14;
EventListener.EVENT_SCROLL = 15;
EventListener.EVENT_NAVIGATOR_ERR = 16;
EventListener.EVENT_CONDITIONS_UPDATE = 17;
EventListener.HEALTH_PLANS_RETRIEVED = 18;
EventListener.EVENT_DIAGNOSIS_ADDED = 19;
//Satisfier Event for Gap Check
EventListener.EVENT_SATISFIER_UPDATE = 20;
//Event for the action in contextual view.
EventListener.EVENT_COMPONENT_MOVED_FROM_CONTEXTUAL_VIEW = 21;
//Event for components that are present in the view
EventListener.EVENT_COMPONENTS_IN_VIEW = 22;
EventListener.EVENT_SCRATCHPAD_ORDERS_SIGNED = 23;
EventListener.EVENT_PRESCRIPTION_REMOVED = 24;
EventListener.EVENT_ADMT_ORDER_PLACED = 25;
EventListener.EVENT_SOFT_REFRESH = 26;
EventListener.EVENT_DYN_DOC_COMP_CKEDITOR_STABLE = 27;
EventListener.EVENT_CARE_PATHWAYS_UPDATE = 28;
EventListener.EVENT_SCRATCHPAD_RECEIVED_ORDER = 29;
EventListener.EVENT_SEND_RATIONALE_TEXT = 30;
EventListener.CATEGORY_MEAN_CHANGE = 31;
EventListener.WORKSPACE_ACTIVE_SIZE_CHANGE = 32;
EventListener.EVENT_SAVE_DOCUMENTATION = 33;
EventListener.EVENT_DOCUMENTATION_SAVED = 34;
EventListener.EVENT_DOCUMENTATION_COMPONENTS_IN_VIEW = 35;
EventListener.EVENT_REFRESH_DYN_DOC_COMP = 36;
EventListener.EVENT_ORION_EXAMPLE = 37;
/*global Util, RTMSTimer, ComponentScriptRequest, ActiveXObject*/
if(typeof MPage === "undefined") {
	MPage = {
		ActiveComponents: [],
		Properties: {
			mine: "mine",
			personId: 0.0,
			encounter: 0.0,
			userId: 0.0,
			pprCd: 0.0,
			posCd: 0.0
		},
		Event: { //Not defined in the standard thus far, so not implemented
			/*eslint-disable no-unused-vars*/
			registerEvent: function(event, listener, component) {
				return null;
			},
			triggerEvent: function(event) {
				return null;
			},
			removeEvent: function(event, listener) {
				return null;
			}
			/*eslint-enable no-unused-vars*/
		},
		namespace: function(name) {
			var parts = name.split(".");
			var result = window;
			while(parts.length) {
				var part = parts.shift();
				result = result[part] = result[part] || {};
			}
			return result;
		},
		/**
		 * registerUnloadEvent function
		 * @deprecated as of January 2013
		 * @returns {undefined} Undefined
		 */
		registerUnloadEvent: function() {
			Util.addEvent(window, "beforeunload", MPage.fireUnload);
		},
		/**
		 * registerResizeEvent function
		 * @deprecated as of January 2013
		 * @returns {undefined} Undefined
		 */
		registerResizeEvent: function() {
			Util.addEvent(window, "resize", MPage.fireResize);
		},
		/**
		 * fireResize function
		 * @deprecated as of January 2013
		 * @returns {undefined} Undefined
		 */
		fireResize: function() {
			var compContainer = null;
			var tempComp;
			var x;

			for(x = MPage.ActiveComponents.length; x--; ) {
				tempComp = MPage.ActiveComponents[x];
				compContainer = tempComp.getTarget();
				tempComp.resize($(compContainer).width(), $(compContainer).height());
			}
		},
		/**
		 * fireUnload function
		 * @deprecated as of January 2013
		 * @returns {undefined} Undefined
		 */
		fireUnload: function() {
			var x;
			for(x = MPage.ActiveComponents.length; x--; ) {
				MPage.ActiveComponents[x].unload();
			}
		},
		addCustomComp: function(compObj) {
			MPage.ActiveComponents.push(compObj);
		},
		getCustomComp: function(compId) {
			var tempComp;
			var x;

			for(x = MPage.ActiveComponents.length; x--; ) {
				tempComp = MPage.ActiveComponents[x];
				if(tempComp.getOption("id") === compId) {
					return tempComp;
				}
			}
			return null;
		}
	};
}

MPage.Component = function() {
	this.baseclassSpecVersion = 1.1;
	this.componentMinimumSpecVersion = 1.0;
};

/* Initialize the component internal variables prior to loading data or rendering.
 * The component should NOT attempt to render during the init() subroutine as the DOM element may not exist.
 */
MPage.Component.prototype.init = function() {
	//Leave empty so component developers can override if necessary
};

/**
 * This function is for convenience. It returns the component menu for the
 * custom component. It is a workflow style menu regardless of whether the
 * component is workflow or summary and can be manipulated with the menu
 * API.
 * @returns {Menu} Component menu
 */
MPage.Component.prototype.getMenu = function() {
    var parentComp = this.getOption("parentComp");

    if (parentComp !== "undefined") {
        return parentComp.getMenu();
    }
    return "undefined";
};

MPage.Component.prototype.refresh = function() {
	var parentComp = null;
	var target = null;
	//Clear the existing target DOM element
	target = this.getTarget();
	if(target) {
		$(target).html("");
	}

	//Get the parent component and refresh from the MPageComponent
	parentComp = this.getOption("parentComp");
	if(parentComp) {
		parentComp.reloadCustomComp();
	}
};

MPage.Component.prototype.generate = function(target, callback, options) {
	var attr = null;
	var combined = null;
	var funcCallback = null;

	//Get the target if it is not already defined. (Should already be set)
	if(!target) {
		target = this.getTarget();
	}

	//Create a callback if not already defined.  (Should already be set)
	if(!callback) {
		funcCallback = function(component) {
			component.render();
		};
	}
	else {
		funcCallback = function(component) {
			component.render();
			callback(component);
		};
	}

	//If options are available, combine them with the existing options
	if(options) {
		combined = this.options;
		for(attr in options) {
			//The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.
			if(options.hasOwnProperty(attr)) {
				combined[attr] = options[attr];
			}
		}
		this.options = combined;
	}

	//Initialize the component
	this.init();
	//
	//Custom components for workflow views are created, by default, with no menu items
	//in the component menu. Test here to see if any menu items were added in the init
	//method and disable the component menu if they were not added.
	//
	if (this.getMenu().getMenuItemArray() == null || this.getMenu().getMenuItemArray().length == 0) {
		//Disable the menu for this component and unbind all click events
		$("#" + this.getMenu().getAnchorElementId())
			.addClass("opts-menu-empty")
			.unbind("click");
	}
	//Load the data for the component
	this.loadData(funcCallback);
	return this;
};

MPage.Component.prototype.loadData = function(callback) {
	//Prepare the callback for the loadCcl call
	var component = this;
	var funcCallback;
	funcCallback = function(response) {
		component.data = response;
		callback(component);
	};

	//Check dataType
	if(this.cclDataType === "undefined") {
		this.cclDataType = "JSON";
	}

	//Call the cclProgram and run it with cclParams
	if(this.cclProgram && this.cclParams && this.cclParams.length > 0) {
		this.loadCCL(this.cclProgram, this.cclParams, funcCallback, this.cclDataType);
	}
	else {
		callback(component);
	}
};

/**
 * It redirects parameters to function loadCCL, which cleans up CCL parameters and initiates a CCL call.
 * @param {string} cclProgram CCL program name
 * @param {Array} cclParams CCL program parameters
 * @param {Function} callback Call back function that handles CCL reply
 * @param {string} dataType Indicate data type of the CCL reply: "XML", "JSON", "TEXT".
 * @returns {undefined} Undefined
 */
MPage.Component.prototype.loadCcl = function(cclProgram, cclParams, callback, dataType) {
	this.loadCCL(cclProgram, cclParams, callback, dataType);
};

/**
 * It ensures all parameters are in correct formats and then initiate a CCL call. Call back function will handle CCL reply data once it's retrieved.
 * @param {string} cclProgram CCL program name
 * @param {Array} cclParams CCL program parameters
 * @param {Function} callback Call back function that handles CCL reply
 * @param {string} dataType Indicate data type of the CCL reply: "XML", "JSON", "TEXT". Data of JSON type will be parsed into JSON object before calling the callback function.
 * @returns {undefined} Undefined
 */
MPage.Component.prototype.loadCCL = function(cclProgram, cclParams, callback, dataType) {
	var self = this;
	var paramStringArr = [];

	//Ensure all parameters are in correct formats
	for(var x = 0; x < cclParams.length; x++) {
		if(typeof cclParams[x] === "string") {
			if(/^value *\(.*\) *$/.test(cclParams[x])) {
				//handle value arrays like 'value(12345.0,4567.0)'
				paramStringArr.push(cclParams[x]);
			}
			else if(!/^('.*'|".*"|\^.*\^)$/.test(cclParams[x])) {
				//check if the string is encapsulated in '',"", or ^^, otherwise put it inside ^^
				paramStringArr.push("^" + cclParams[x] + "^");
			}
			else {
				paramStringArr.push(cclParams[x]);
			}
		}
		else if(typeof cclParams[x] === "number" && cclParams[x] % 1 === 0) {
			paramStringArr.push(cclParams[x] + ".0");
		}
		else {
			paramStringArr.push(cclParams[x]);
		}
	}

	//Retrieve the parent component so the ComponentScriptRequest will successfully log the timer information
	var parentComponent = this.getOption("parentComp");

	//Create a String time stamp using the current date/time and a random number to make sure the Stop checkpoint only matches its own Start checkpoint.
	//The random number guarantees the checkpoints are matched correctly, even in the unlikely scenario
	//where multiple custom components with the same namespace and parameters are triggered at the exact same time.
	var timeStampID = (new Date()).getTime() + "" + Math.random();

	var loadTimer = new RTMSTimer(parentComponent.getComponentLoadTimerName(), parentComponent.getCriterion().category_mean);
	loadTimer.addMetaData("rtms.legacy.metadata.1", parentComponent.getComponentNamespace());
	loadTimer.addMetaData("rtms.legacy.metadata.2", parentComponent.getComponentOptionsObjectName());
	loadTimer.addMetaData("rtms.legacy.metadata.3", timeStampID);

	var renderTimer = new RTMSTimer(parentComponent.getComponentRenderTimerName(), parentComponent.getCriterion().category_mean);
	renderTimer.addMetaData("rtms.legacy.metadata.1", parentComponent.getComponentNamespace());
	renderTimer.addMetaData("rtms.legacy.metadata.2", parentComponent.getComponentOptionsObjectName());

	var request = new ComponentScriptRequest();
	request.setComponent(parentComponent);
	request.setProgramName(cclProgram);
	request.setParameterArray(paramStringArr);
	request.setRawDataIndicator(true);
	request.setLoadTimer(loadTimer);
	request.setRenderTimer(renderTimer);
	request.setResponseHandler(function(replyObj) {
		var parser = null;
		var responseData = replyObj.getResponse();
		var xmlDoc = null;

		if(responseData) {
			try {
				//Need to interpret the data here and set into this.data
				switch(dataType) {
					case "XML":
						if(window.ActiveXObject) {
							//for IE
							xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
							xmlDoc.async = "false";
							xmlDoc.loadXML(responseData);
						}
						else {
							//for Mozilla, Chrome and Safari
							parser = new DOMParser();
							xmlDoc = parser.parseFromString(responseData, "text/xml");
						}

						callback.call(self, xmlDoc);
						break;
					case "TEXT":
						callback.call(self, responseData);
						break;
					case "JSON":
						callback.call(self, JSON.parse(responseData));
						break;
					default:
						callback.call(self, JSON.parse(responseData));
						break;
				}
			}
			catch(err) {
				logger.logJSError(err, parentComponent, "mp_custom_component_core.js", "loadCCL");
				throw err;
			}
		}
		else {
			logger.logError("Script " + cclProgram + " did not return any data");
			throw new Error("Script " + cclProgram + " did not return any data");
		}
	});

	request.performRequest();
};

/*default implementation of this which is only responsible for TEXT data*/
MPage.Component.prototype.render = function() {
	var target;
	if(typeof this.data === "string") {
		target = this.getTarget();
		target.innerHTML = this.data;
	}
};

MPage.Component.prototype.getOption = function(name) {
	if(this.options && typeof this.options[name] !== "undefined") {
		return this.options[name];
	}
	else {
		return "undefined";
	}
};


MPage.Component.prototype.setOption = function(name, value) {
	if(!this.options) {
		this.options = {};
	}
	this.options[name] = value;
};

MPage.Component.prototype.getProperty = function(name) {
	if(this.properties && typeof this.properties[name] !== "undefined") {
		return this.properties[name];
	}
	else {
		return "undefined";
	}
};


MPage.Component.prototype.setProperty = function(name, value) {
	if(this.properties) {
		this.properties[name] = value;
	}
	else {
		this.properties = {};
		this.properties[name] = value;
	}

	//Take special action depending on the property
	if("headerTitle|headerSubTitle|headerShowHideState|userPreferences".indexOf(name) >= 0) {
		var parentComp = this.getOption("parentComp");
		/*eslint-disable default-case*/
		switch(name) {
			case "headerTitle":
				parentComp.updateLabel(value);
				break;
			case "headerSubTitle":
				parentComp.updateSubLabel(value);
				break;
			case "headerShowHideState":
				parentComp.setExpandCollapseState(value);
				break;
            case "userPreferences":
				try {
					parentComp.setPreferencesObj(value);
					parentComp.savePreferences(true); // save asynchronously
				}
				catch (err) {
					logger.logJSError(err, parentComp, "mp_custom_component_core.js", "savePreferences");
				}
                break;
		}
		/*eslint-enable default-case*/
	}

	return this;
};

MPage.Component.prototype.getTarget = function() {
	var target = null;
	if(this.options && this.options.target) {
		target = this.options.target;
	}
	return target;
};

MPage.Component.prototype.setTarget = function(target) {
	if(this.options) {
		this.options.target = target;
	}
	else {
		this.options = {};
		this.options.target = target;
	}
};

/*eslint-disable no-unused-vars*/
MPage.Component.prototype.resize = function(width, height) {
	return null;
};
/*eslint-enable no-unused-vars*/

MPage.Component.prototype.unload = function() {
	return null;
};

MPage.Component.prototype.getComponentUid = function() {
	return this.getOption("id");
};

MPage.Component.prototype.throwNewError = function(description, err) {
	var error = err || new Error(description);
	logger.logError("Error occurred in a custom component: " + description);
	logger.logJSError(error, null, "mp_custom_component_core.js", "MPage.Component.prototype.throwNewError");
	throw error;
};
/* global MPageEntity:true*/
/* eslint new-cap: [2, {"capIsNewExceptions": ["RefreshDiagnosisCollection", "RefreshProblemCollection"]}]*/

/**
 * The below methods define the SharedConditionResource, a child of SharedResource to be used to create
 * a shared condition list
 */

/**
 * @constructor
 * @param {String} resourceName The desired name of this instance of SharedConditionResource.
 */
function SharedConditionResource(resourceName) {
    SharedResource.call(this, resourceName);
    this.m_condPrivsRetrieved = false;
    this.m_nkpNomenclatures = [];
    this.m_cernerNKPNomenclature = 0.0;
    this.m_hasChronicProbs = false;
    // condPrivObj contains processed information about privileges and NKP details
    this.m_condPrivObj = {
        canViewNKP: false,
        canUpdtNKP: false,
        canModifyChronic: false,
        canModifyThisVisit: false,
        canAddChronicFreeText: false,
        nkpNomenclatures: [],
        cernerNKPNomenclature: 0.0,
        hasChronicProbs: false
    };
    // metaObj holds the raw metadata returned from the list reply
    this.m_metaObj = {};
    this.m_eventSource = null;
    // m_isSpecificitiesRetrieved holds boolean value to determine if specificities info is retrieved
    this.m_isSpecificitiesRetrieved = false;
}

SharedConditionResource.prototype = new SharedResource();
SharedConditionResource.prototype.constructor = SharedConditionResource;

/*
 * Getters and Setters for the privilege information
 */
SharedConditionResource.prototype.getCondPrivsRetrieved = function() {
    return (this.m_condPrivsRetrieved);
};

SharedConditionResource.prototype.setCondPrivsRetrieved = function(val) {
    this.m_condPrivsRetrieved = this.booleanTranslation(val);
};

SharedConditionResource.prototype.getCondPrivsObj = function() {
    return (this.m_condPrivObj);
};

SharedConditionResource.prototype.setViewNKPPriv = function(val) {
    this.m_condPrivObj.canViewNKP = this.booleanTranslation(val);
};
SharedConditionResource.prototype.setUpdtNKPPriv = function(val) {
    this.m_condPrivObj.canUpdtNKP = this.booleanTranslation(val);
};
SharedConditionResource.prototype.setModifyChronicPriv = function(val) {
    this.m_condPrivObj.canModifyChronic = this.booleanTranslation(val);
};
SharedConditionResource.prototype.setModifyThisVisitPriv = function(val) {
    this.m_condPrivObj.canModifyThisVisit = this.booleanTranslation(val);
};
SharedConditionResource.prototype.setChronicFreeTextPriv = function(val) {
    this.m_condPrivObj.canAddChronicFreeText = this.booleanTranslation(val);
};


/**
 * Getters and setters for NKP information
 * @param   {Array<String>} nomenclatureArr List of NKP (No Known Problems) nomenclatures as strings
 * @returns {undefined} undefined
 */
SharedConditionResource.prototype.setNKPNomenclatures = function(nomenclatureArr) { // eslint-disable-line complexity
    var nomenclatures = [];
    var nomenCnt = nomenclatureArr.length;
    var i = 0;
    var nomenclature;
    var nomenclatureId;
    if (nomenCnt) {
        for (i = 0; i < nomenCnt; i++) {
            nomenclature = nomenclatureArr[i];
            nomenclatureId = 0;
            if (nomenclature) {
                nomenclatureId = nomenclature.ID;
            }
            if (nomenclatureId) {
                nomenclatures.push(parseInt(nomenclatureId, 10));
            }
        }
    }
    this.m_condPrivObj.nkpNomenclatures = nomenclatures;
};

SharedConditionResource.prototype.getNKPNomenclatures = function() {
    return this.m_condPrivObj.nkpNomenclatures;
};
SharedConditionResource.prototype.setCernerNKPNomenclature = function(val) {
    this.m_condPrivObj.cernerNKPNomenclature = parseInt(val, 10);
};
SharedConditionResource.prototype.getCernerNKPNomenclature = function() {
    return this.m_condPrivObj.cernerNKPNomenclature;
};
SharedConditionResource.prototype.setHasChronicProbs = function(val) {
    this.m_condPrivObj.hasChronicProbs = this.booleanTranslation(val);
};
SharedConditionResource.prototype.getHasChronicProbs = function() {
    return this.m_condPrivObj.hasChronicProbs;
};
/**
 *Setter and Getter for the Meta object
 *@returns {undefined} undefined
 */
SharedConditionResource.prototype.getMetaObj = function() {
    return (this.m_metaObj);
};

SharedConditionResource.prototype.setMetaObj = function(val) {
    this.m_metaObj = val;
};

/**
 * Gets m_isSpecificitiesRetrieved
 * @returns {Boolean} returns m_isSpecificitiesRetrieved value
 */
SharedConditionResource.prototype.getIsSpecificitiesRetrieved = function() {
    return (this.m_isSpecificitiesRetrieved);
};

/**
 * Sets m_isSpecificitiesRetrieved value
 * @param {Boolean} val - boolean value either true/false
 * @returns {undefined}
 */
SharedConditionResource.prototype.setIsSpecificitiesRetrieved = function(val) {
    this.m_isSpecificitiesRetrieved = this.booleanTranslation(val);
};
/*
 * Take in a value and return a boolean
 * @param {String|Number|Boolean} value Value to return boolean representation of
 * @returns {Boolean} Boolean representation of passed value
 */
SharedConditionResource.prototype.booleanTranslation = function(value) { // eslint-disable-line complexity
    if (value === true || value === false) {
        return (value);
    }
    else if (value === "1" || value > 0) {
        return (true);
    }
    else {
        return (false);
    }
};

SharedConditionResource.prototype.notifyResourceConsumers = function(eventSource) {
    this.m_eventSource = eventSource;
    SharedResource.prototype.notifyResourceConsumers.call(this);
};

/*
 * Overwriting parent retrieveSharedResourceData to use condition entity for data retrieval
 */
SharedConditionResource.prototype.retrieveSharedResourceData = function() { // eslint-disable-line complexity
    var Condition = MPageEntity.entities.Condition;
    var probDxUtils = MPageEntity.getProbDxUtils();
    var self = this;
    var criterion = JSON.parse(m_criterionJSON).CRITERION;
    if (!this.getCondPrivsRetrieved()) {
        Condition.meta.userId = criterion.PRSNL_ID;
    }
    var listCriteria = {
        personId: criterion.PERSON_ID,
        encounterId: criterion.ENCNTRS[0].ENCNTR_ID,
        pprCd: criterion.PPR_CD
    };
    var selectedCondition = (arguments.length && arguments[0] !== undefined) ? arguments[0] : null;
    var nomenclatureId = (selectedCondition !== null) ? selectedCondition.getNomenclatureValue() : null;
    try {
        if (this.isBeingRetrieved()) {
            return;
        }
        this.setIsBeingRetrieved(true);
        if(nomenclatureId && nomenclatureId !== null){
            listCriteria.nomenclatureId = nomenclatureId;
            Condition.listByNomen(listCriteria, function(conditions){
                if(conditions.length){
                    conditions.filterDiagnoses(selectedCondition);
                }
                selectedCondition.isHistoricalDiagnosesRetrieved = true;
                self.setIsBeingRetrieved(false);
            });
        }
        else{
            if(self.getEventListenerObject() && self.getEventListenerObject().getIsDxAssistantEnabled){
                Condition.meta.isDxAssistantEnabled = self.getEventListenerObject().getIsDxAssistantEnabled() ? 1 : 0;
            }
            Condition.list(listCriteria, function(conditions, respStr) { // eslint-disable-line complexity
                self.setResourceData(conditions);
                self.setIsAvailable(true);
                self.setIsBeingRetrieved(false);
                if (respStr !== null) {
                    var metaObj = JSON.parse(respStr).RECORD_DATA.META;
                    if (metaObj) {
                        self.setMetaObj(metaObj);
                        self.setViewNKPPriv(metaObj.CANVIEWNKP);
                        self.setUpdtNKPPriv(metaObj.CANUPDTNKP);
                        self.setModifyChronicPriv(metaObj.CANMODIFYCHRONIC);
                        self.setModifyThisVisitPriv(metaObj.CANMODIFYTHISVISIT);
                        self.setChronicFreeTextPriv(metaObj.CANADDCHRONICFREETEXT);
                        self.setNKPNomenclatures(metaObj.NKPNOMENS);
                        self.setCernerNKPNomenclature(metaObj.CERNERNKPNOMENID);
                        self.setHasChronicProbs(metaObj.HASCHRONICPROBS);
                        self.setCondPrivsRetrieved(true);
                        Condition.meta.isDxAssistantEnabled === 1 ? self.setIsSpecificitiesRetrieved(true) : self.setIsSpecificitiesRetrieved(false); // eslint-disable-line no-unused-expressions
                        if(conditions.length){
                            conditions[0].getMeta().allEncounter = metaObj.ALLENCOUNTER;
                        }
                    }
                }
                self.notifyResourceConsumers();
                // Refresh the win32 problems and diagnoses component.
                if (!probDxUtils) {
                    logger.logError("Unable to create the PROBDXUTILS COM object");
                    return;
                }
                probDxUtils.RefreshDiagnosisCollection(criterion.PERSON_ID, criterion.ENCNTRS[0].ENCNTR_ID);
                probDxUtils.RefreshProblemCollection(criterion.PERSON_ID);
            });
        }
    }
    catch (err) {
        this.setIsBeingRetrieved(false);
        if (logger) {
            logger.logJSError(err, null, "mp_shared_condition_resource.js", "retrieveSharedResourceData");
        }
    }
};

/**
 * Initializes the shared resource and adds a callback to be performed when resource is retrieved
 * @param  {Function} callback The callback to be perfromed after the shared resource has been retrieved
 * @param  {Object} consumer The consumer calling to retrieve the shared resource
 * @returns {SharedConditionResource} The shared condition resource that was initialized or used by the consumer
 */
SharedConditionResource.getSharedResource = function(callback, consumer) {
    consumer = consumer || {};
    var sharedConditionResource = MP_Resources.getSharedResource("shared-condition-resource");
    if (!sharedConditionResource) {
        sharedConditionResource = new SharedConditionResource("shared-condition-resource");
        sharedConditionResource.setEventListenerFlag(EventListener.EVENT_CONDITIONS_UPDATE);
        sharedConditionResource.setEventListenerObject(consumer);
        MP_Resources.addSharedResource("shared-condition-resource", sharedConditionResource);
    }
    var wrappedCallback = function() {
        callback(sharedConditionResource.getResourceData(), sharedConditionResource.getCondPrivsObj(), sharedConditionResource.getMetaObj(), sharedConditionResource);
    };
    if (sharedConditionResource.isResourceAvailable()) {
        wrappedCallback();
    }
    else {
        sharedConditionResource.retrieveSharedResourceData();
    }
    CERN_EventListener.addListener(consumer, EventListener.EVENT_CONDITIONS_UPDATE, wrappedCallback, consumer);
    return sharedConditionResource;
};

/**
 * Returns the condition in the shared resource that matches the passed condition (based on internal data)
 * @param   {MPageEntity.Condition} conditionToMatch Condition to be found in shared resource
 * @returns {MPageEntity.Condition}                  Condition that matches passed condition
 */
SharedConditionResource.prototype.getMatchingCondition = function(conditionToMatch) {
    var data = this.getResourceData();
    // Conditions are considered matching if they reference the same data
    var matchingConditions = data.filter(function(cond) {
        return cond.getData() === conditionToMatch.getData();
    });

    if (matchingConditions.length) {
        return matchingConditions[0];
    }
    else {
        return null;
    }
};

/**
 * Removes a condition from the shared resource if empty (no diagnosis or problem driver)
 * @param   {MPageEntity.Condition} condition to remove from the shared resource
 * @returns {undefined}
 */
SharedConditionResource.prototype.removeEmptyCondition = function(condition) {
    if (condition.isEmpty()) {
        var data = this.getResourceData();
        var matchingCondition = this.getMatchingCondition(condition);
        // Remove condition from shared resource if found and notify consumers
        if (matchingCondition) {
            data.splice(data.indexOf(matchingCondition), 1);
        }
    }
};

/**
 * Copies over a condition added from any component into a condition to be stored in the shared resource.
 * Notifies consumers of addition
 * @param   {MPageEntity.Condition}  condition to add to shared resource
 * @returns {MPageEntity.Condition}  Condition Entity created in the shared resource
 */
SharedConditionResource.prototype.addCondition = function(condition) {
    var data = this.getResourceData();
    var Condition = MPageEntity.entities.Condition;
    var newCondition = new Condition();
    newCondition.setData(condition.getData());
    newCondition.setResponseMeta(condition.getResponseMeta());
    data.push(newCondition);
    return newCondition;
};

/**
 * Clears the data and entity cache for the condition is the shared resource corresponding to the passed condition
 * This is utilized to ensure that the One-To-One and One-To-Many field are reloaded after data is updated
 * @param   {MPageEntity.Condition} condition The condition to clear the entity cache of in the shared resource
 * @returns {undefined} undefined
 */
SharedConditionResource.prototype.updateCondition = function(condition) {
    var sharedCondition = this.getMatchingCondition(condition);
    if (sharedCondition) {
        sharedCondition.clearEntityCache();
    }
};
/*eslint no-redeclare: [2, { "builtinGlobals": false }]*/
/*
 * mp_shared_resources.js
 * @author Steven Lewis
 *
 * A collection of functions and objects used to manage shared resources between multiple MPages and Components.
 */

/**
 * Base implementation of a shared resource
 * @param {String} resourceName The desired name of this instance of shared resource.
 * Will be used to reference this shared resource object.
 * @constructor
 */
function BaseSharedResource(resourceName) {
  /** @private */
  var name = resourceName;
  /** @private */
  var isAvailable = false;
  /** @private */
  var isBeingRetrieved = false;
  /** @private */
  var resourceData = null;
  /** @private */
  var eventListenerFlag = null;
  /** @private */
  var eventListenerObject = null;
  /** @private */
  var options = {};

  /**
   * Get the options passed into the shared resource
   * @returns {{}} The options within the shared resource
   */
  this.getOptions = function() {
    return options || {};
  };

  /**
   * Set the options for the shared resource retrieval
   * @param {{}} value The hash of options utilized by the shared resource for retrieval
   */
  this.setOptions = function(value) {
    options = value;
  };

  /**
   * Get the name of the shared resource
   * @return {String} The name of the shared resource
   */
  this.getName = function() {
    return name;
  };

  /**
   * Set the name of the shared resource
   * @param {String} value The name to be given to the shared resource
   */
  this.setName = function(value) {
    name = value;
  };

  /**
   * Get the isAvailable indicator of the shared resource
   * @return {Boolean} A boolean which tells if the shared resource is available or not
   */
  this.isResourceAvailable = function() {
    return isAvailable;
  };

  /**
   * Set the isAvailable indicator of the shared resource
   * @param {Boolean} isAvailableInd An indicator which tells if the shared resource data is available for consumption
   */
  this.setIsAvailable = function(isAvailableInd) {
    isAvailable = (isAvailableInd) ? true : false;
  };

  /**
   * Get the isBeingRetrieved indicator of the shared resource
   * @return {Boolean} A boolean indicating whether the shared resource is currently being retrieved
   */
  this.isBeingRetrieved = function() {
    return isBeingRetrieved;
  };

  /**
   * Set the isBeingRetrieved indicator of the shared resource
   * @param {Boolean} retrieving An indicator which tells if the shared resource is currently being retrieved
   */
  this.setIsBeingRetrieved = function(retrieving) {
    isBeingRetrieved = (retrieving) ? true : false;
  };

  /**
   * Get the resourceData of the shared resource
   * @return {Object} An object which is the actual shared resource.  The type of object is dependent upon what set
   * the resourceData element and should be known to all consumers of that particular BaseSharedResource.
   */
  this.getResourceData = function() {
    return resourceData;
  };

  /**
   * Set the resourceData of the shared resource
   * @param {Object} data The data object which is the resource being shared.
   */
  this.setResourceData = function(data) {
    resourceData = data;
  };

  /**
   * Get the eventListenerFlag of the shared resource
   * @return {Number} An integer which represents the type of event to fire when the shared resource data is available.
   */
  this.getEventListenerFlag = function() {
    return eventListenerFlag;
  };

  /**
   * Set the eventListenerFlag of the shared resource
   * @param {Number} event An integer which represents the type of event to fire when the
   * shared resource data is available.
   */
  this.setEventListenerFlag = function(event) {
    eventListenerFlag = event;
  };

  /**
   * Get the eventListenerObject of the shared resource
   * @return {Object} An integer which represents the type of event to fire when the shared resource data is available.
   */
  this.getEventListenerObject = function() {
    return eventListenerObject;
  };

  /**
   * Set the eventListenerObject of the shared resource
   * @param {Object} object An integer which represents the type of event to fire when the
   * shared resource data is available.
   */
  this.setEventListenerObject = function(object) {
    eventListenerObject = object;
  };
}

/**
 * Fire the event associated to this shared resource to notify all of the consumers that the data is available.
 * @return {Boolean} An indicator telling if the event was fired successfully
 */
BaseSharedResource.prototype.notifyResourceConsumers = function(removedInd, orderId) {
  try {
    //Get the parameters to fire the event
    var eventFlag = this.getEventListenerFlag();
    var eventObj = this.getEventListenerObject();
    var resourceData = this.getResourceData();

    //Fire the event based on the eventListenerObject and eventListenerFlag
    CERN_EventListener.fireEvent(null, eventObj, eventFlag, resourceData);
    //Log debugging data
    logger.logMessage("Firing Shared Resource Event<br />" +
      "Resource Name: " + this.getName() + "<br />" +
      "Resource Data: " + JSON.stringify(resourceData) + "<br />");

    //send an event to any order profile instances that need to be updated
    if(removedInd) {
      CERN_EventListener.fireEvent(null, new MPageComponent(), EventListener.EVENT_SCRATCHPAD_RECEIVED_ORDER_ACTION, orderId);
    }
    else {
      if(resourceData.scratchpadObjArr && resourceData.scratchpadObjArr.length > 0) {
        var spArrLen = resourceData.scratchpadObjArr.length;
        //grab the most recently added order
        var curOrder = resourceData.scratchpadObjArr[spArrLen - 1];
        if(curOrder.addedFrom === "OrderProfile" && orderId) {
          //order is an order action from order profile, fire an event to any other OP component in the viewpoint
          CERN_EventListener.fireEvent(null, new MPageComponent(), EventListener.EVENT_SCRATCHPAD_RECEIVED_ORDER_ACTION, curOrder);
        }
      }
    }
    return true;
  }
  catch(err) {
    //Log error information and return
    logger.logJSError(err, null, "mp_shared_resources.js", "notifyResourceConsumers");
    return false;
  }
};

/**
 * Complete the shared resoruce and notify listening parties
 * @param {Object} data The data that is to be set on the shared resource object
 * @returns {Promise}
 */
BaseSharedResource.prototype.complete = function(data) {
  var sharedResource = this;
  return new Promise(function(resolve, reject) {
    try{
      sharedResource.setResourceData(data);
      sharedResource.setIsAvailable(true);
      sharedResource.setIsBeingRetrieved(false);
      sharedResource.notifyResourceConsumers();
      resolve();
    } catch (e) {
      reject(Error("Error received: " + e.message));
    }
  });
};

/**
 * Creates an instance of CCL based shared resource object
 * @param {String} resourceName The desired name of this instance of SharedResource.
 * Will be used to reference this SharedResource object.
 * @constructor
 */
function SharedResource(resourceName) {
  BaseSharedResource.call(this, resourceName);
  /** @private */
  var cclProgram = null;
  /** @private */
  var cclParams = [];

  /**
   * Get the ccl program of the SharedResource
   * @return {String} The name of the ccl program which retrieves the data for this SharedResouce
   */
  this.getCclProgram = function() {
    return cclProgram;
  };

  /**
   * Set the ccl program of the SharedResource
   * @param {string} cclProgram The name of the ccl program used to retrieve the data for the SharedResource
   */
  this.setCclProgram = function(cclProgramName) {
    cclProgram = cclProgramName;
  };

  /**
   * Get the ccl parameters for the script used to retrieve the data for the SharedResource
   * @return {Array} The parameter array used when call the cclProgram
   */
  this.getCclParams = function() {
    return cclParams;
  };

  /**
   * Set the ccl parameters for the script used to retrieve the data for the SharedResource
   * @param {Array} paramArray An array of mixed type parameters which will be sent to the cclProgram
   */
  this.setCclParams = function(paramArray) {
    cclParams = paramArray;
  };
}

SharedResource.prototype = new BaseSharedResource();
SharedResource.prototype.constructor = BaseSharedResource;

/* Additional helper functions */

/**
 * Retrieves the shared resource data from the script specified in the SharedResource
 * and notifies consumers when the data is available.
 */
SharedResource.prototype.retrieveSharedResourceData = function() {
  var sharedResource = this;

  //If the resource is already being retrieved just return.
  if(this.isBeingRetrieved()) {
    return;
  }

  //Set the isBeingRetrieved flag
  this.setIsBeingRetrieved(true);
  //Create and execute the script request
  var resourceRequest = new ScriptRequest();

  resourceRequest.setArtifactInfo({
    artifactId: "mpage-shared-resource",
    functionName: "retrieveSharedResourceData"
  });

  resourceRequest.setName("Shared Resources Data Retrieval");
  resourceRequest.setProgramName(this.getCclProgram());
  resourceRequest.setParameterArray(this.getCclParams());
  resourceRequest.setRawDataIndicator(true);
  resourceRequest.setResponseHandler(function(scriptReply) {
    sharedResource.setResourceData(scriptReply.getResponse());
    sharedResource.setIsAvailable(true);
    sharedResource.setIsBeingRetrieved(false);
    sharedResource.notifyResourceConsumers();
  });
  resourceRequest.performRequest();
};

/**
 * Creates an instance of a restful based shared resource object
 * @param {String} resourceName The desired name of this instance of of a shared resource
 * @constructor
 */
function RestfulSharedResource(resourceName) {
  BaseSharedResource.call(this, resourceName);
}

RestfulSharedResource.prototype = new BaseSharedResource();
RestfulSharedResource.prototype.constructor = BaseSharedResource;

/**
 * Retrieves the shared resource data from the restful endpoint for the shared resource
 * and notifies consumers when the data is available.
 */
RestfulSharedResource.prototype.retrieveSharedResourceData = function() {
  var sharedResource = this;

  //If the resource is already being retrieved just return.
  if(this.isBeingRetrieved()) {
    return;
  }
  //Set the isBeingRetrieved flag
  this.setIsBeingRetrieved(true);

  this.getRestfulSharedResource()
    .then(function(data) { return sharedResource.complete(data); });
};

/**
 * Retrieve the data at the restful endpoint
 * @returns {Promise}
 */
RestfulSharedResource.prototype.getRestfulSharedResource = function() {
  var options = this.getOptions();

  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open(options.method || 'GET', options.url, true);

    // Set request headers if provided.
    var headers = options.headers || {};
    Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, options.headers[key]);
    });

    if (headers.Accept === undefined) {
      //set default of application/json if none provided
      req.setRequestHeader('Accept', 'application/json');
    }

    if (options.withCredentials !== undefined) {
      req.withCredentials = options.withCredentials;
    }

    req.onreadystatechange = function(e) {
      if(req.readyState !== 4) {
        return;
      }

      if([200,304].indexOf(req.status) === -1) {
        reject(new Error('Server responded with a status of ' + req.status));
      } else {
        resolve(e.target.responseText);
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error("Network Error"));
    };

    // Make the request
    req.send();
  });
};

/**
 * Creates an instance of a local/function based shared resource object
 * @param {String} resourceName The desired name of this instance of of a shared resource
 * @constructor
 */
function LocalSharedResource(resourceName) {
  BaseSharedResource.call(this, resourceName);
}

LocalSharedResource.prototype = new BaseSharedResource();
LocalSharedResource.prototype.constructor = BaseSharedResource;

/**
 * Retrieves the shared resource data from the common construction or retrieval from local/client
 * and notifies consumers when the data is available.
 */
LocalSharedResource.prototype.retrieveSharedResourceData = function() {
  var sharedResource = this;

  //If the resource is already being retrieved just return.
  if(this.isBeingRetrieved()) {
    return;
  }
  //Set the isBeingRetrieved flag
  this.setIsBeingRetrieved(true);

  var options = this.getOptions();
  options.function.call(this, options)
    .then(function(data) { return sharedResource.complete(data); });
};

/**
 * A global object that contains all of the shared resources for MPages.  Also contains helper functions that can be used when dealing with SharedResource Objects.
 * @namespace
 */
var MP_Resources = function() {
  /** @private */
  var sharedResources = {};

  return {
    /**
     * Retrieves the SharedResource object if it is available.
     * @param {String} resourceName The name of the SharedResource to retrieve
     * @returns {SharedResource} If the shared resource is available it will be returned, otherwise null.
     */
    getSharedResource: function(resourceName) {
      return (sharedResources[resourceName]) ? sharedResources[resourceName] : null;
    },
    /**
     * Sets the data currently stored in the SharedResource.  There are no checks on the resourceData parameter other than  a check for 'undefined'
     * @param {String} resourceName The name of the SharedResource to update
     * @param {Object} resourceData The data object to update into the SharedResource object.
     * @return {Boolean} True if the SharedResource was updated successfully, false otherwise.
     */
    setSharedResourceData: function(resourceName, resourceData) {
      var resource = null;

      //Make sure the data passed in isn't undefined.  Undefined is the only unacceptable data.
      if(typeof resourceData === "undefined") {
        logger.logMessage("SharedResource update data is undefined. '" + resourceName + "' will not be updated.");
        return false;
      }

      //Retrieve and update the resource if it is available and not being retrieved.
      resource = MP_Resources.getSharedResource(resourceName);
      if(resource) {
        if(!resource.isBeingRetrieved()) {
          resource.setResourceData(resourceData);
          return true;
        }
        else {
          logger.logMessage("SharedResource '" + resourceName + "' is currently being retrieved and cannot be updated.");
          return false;
        }
      }
      else {
        logger.logMessage("SharedResource '" + resourceName + "' does not currently exist");
        return false;
      }
    },
    /**
     * Add a shared resource to the available resources if it hadnt already been added.  If wanting to update a SharedResource object use the
     * MP_Resources.setSharedResourceData() function.
     * @param {String} resourceName The name of the SharedResource to to add
     * @param {SharedResource} sharedResourceObj The SharedResource object to store for future use
     * @return {Boolean} True if the resource was added, false otherwise.
     */
    addSharedResource: function(resourceName, sharedResourceObj) {
      if(!sharedResources[resourceName]) {
        sharedResources[resourceName] = sharedResourceObj;
        return true;
      }
      else {
        //Log an error because we are trying to overwrite an existing shared resource
        logger.logError("Attempting to overwrite an existing shared resource: " + resourceName);
        return false;
      }
    },

    createSharedResource: function(resourceName, consumerObj, notifyEventFlag, options) {
      //If no shared resource name is given there will be no way to reference it later on.
      if(!resourceName) {
        logger.logError("Cannot create a SharedResource object without a name.");
        return null;
      }

      var sharedResource = null;

      if (options.hasOwnProperty('url')) {
        sharedResource = new RestfulSharedResource(resourceName);
      } else if (options.hasOwnProperty('function')) {
        sharedResource = new LocalSharedResource(resourceName);
      } else {
        sharedResource = new SharedResource(resourceName);
        sharedResource.setCclProgram(options.script);
        sharedResource.setCclParams(options.params);
      }

      sharedResource.setOptions(options);
      sharedResource.setEventListenerObject(consumerObj);
      sharedResource.setEventListenerFlag(notifyEventFlag);

      //Add the SharedResource object to the collection
      sharedResources[resourceName] = sharedResource;

      return sharedResource;
    },

    /**
     * Creates a new SharedResource object for use by components and mpages and adds it to the collection
     * @param {String} resourceName The name to give to the SharedResource
     * @param {Object} consumerObj The object which is creating the SharedResource.  This is used when notifying resource consumers which have to have the same Object definition.
     * @param {String} cclProgram The name of the script used to retrieve the shared resource data
     * @param {Array} cclParams An array of parameters to send to the cclProgram script
     * @param {Number} notifyEventFlag The Event flag to fire when the data is available for consumers
     */
    createSharedResourceObj: function(resourceName, consumerObj, cclProgram, cclParams, notifyEventFlag) {
      return this.createSharedResource(resourceName, consumerObj, notifyEventFlag, {script: cclProgram, params: cclParams}); // eslint-disable-line no-undef
    },

    /**
     * Creates a new SharedResource object for use by components and mpages, adds it to the collection, and associates the EventListener for callbacks.
     * @param {String} resourceName The name to give to the SharedResource
     * @param {Object} consumerObj The object which is creating the SharedResource.  This is used when notifying resource consumers which have to have the same Object definition.
     * @param {Function} processCallback The function to return to the consumer utilizing the retrieved shared data
     * @param {Struct} options A JSON representation of the options needed for executing the script utilized for the SharedResource.
     *   script - The name of the script used to retrieve the shared resource data
     *   params - An array of parameters to send to the script
     *   url - A restful endpoint to execute retrieval
     */
    sharedResource: function(resourceName, consumerObj, processCallback, options) {
      var resource = MP_Resources.getSharedResource(resourceName);
      var resourceAvailable = resourceName + "Available";

      CERN_EventListener.addListener(consumerObj, resourceAvailable, function (event, dataString) {
        processCallback(event, dataString);
      }, consumerObj);

      if (resource) {
        // set event listener
        resource.setEventListenerFlag(resourceAvailable);
        if (resource.isResourceAvailable()) {
          processCallback(null, resource.getResourceData());
        } else {
          resource.retrieveSharedResourceData();
        }
      }
      else {
        resource = MP_Resources.createSharedResource(resourceName, consumerObj, resourceAvailable, options);
        if (resource) {
          resource.retrieveSharedResourceData();
        }
      }
    }
  };
}();
/* globals ICUDashboardMPage, ReachSummaryMPage, CalculatorsSummaryMPage, ViewBuilderMPage, WorkflowRenderStrategy, SummaryRenderStrategy, CERN_COMPONENT_TYPE_SUMMARY, CERN_COMPONENT_TYPE_WORKFLOW, DummyMPage, CERN_Browser, CapabilityTimer, ComponentContainer */

/**
 * Create a new instance of an MPageView or WorkflowView object based on a category mean.
 * @param {String} categoryMean The category mean of the MPageView to initialize
 * @param {String} viewTypeMean The code value meaning of the view type
 * @returns {MPageView} An object which is either an MPageView/WorkflowView object or an extension of that.
 */
function createViewObject(categoryMean, viewTypeMean) { //eslint-disable-line no-unused-vars, no-redeclare
    try {
        if(!categoryMean || typeof categoryMean !== "string") {
            logger.logError("categoryMean parameter must be a string and not null");
            return null;
        }

        //Determine the type of MPage object to create based on the category mean of a predefined view
        switch(categoryMean) {
            case "MP_ICU_DASHBOARD":
                return new ICUDashboardMPage();
            case "MP_COMMON_ORDERS_V4":
                // It uses the dummy mpage to ensure the deprecated QOC V4 doesn't blow up
                var dummyPage = new DummyMPage();
                dummyPage.setCategoryMean(categoryMean);
                return dummyPage;
            case "MP_REACH_V5":
                return new ReachSummaryMPage();
            case "MP_CALC_SUMMARY":
                return new CalculatorsSummaryMPage(categoryMean);
        }
        var ViewDef = MP_Util.getObjectDefinitionMapping(categoryMean);
        //determine the view definition of a ViewBuilder using the view type mean
        if (!ViewDef && /^VB_.*/.test(categoryMean)) {
        	ViewDef = MP_Util.getObjectDefinitionMapping(viewTypeMean);
        	//if the view type is not found, use the generic ViewBuilderMPage
        	if (!ViewDef) {
        		ViewDef = ViewBuilderMPage;
        	}
        }
        else if (!ViewDef) {
			//Default the view definition to generic MPageView
        	ViewDef = MPageView;
        }
        //create the view and set the category mean
        var viewObj = new ViewDef();
        viewObj.setCategoryMean(categoryMean);
        return viewObj;
    }
    catch(err) {
        if(err.type === "not_defined") {
            logger.logError("No object type defined for " + categoryMean + ": " + err.message);
        }
        else {
            logger.logJSError(err, null, "mpage-driver.js", "createViewObject");
        }
        return null;
    }
}

/**
 * This function serves as the entry point for the MP_COMPONENT_DRIVER script.  It performs all necessary setup for
 * the Parent MPages View container for only showing components without any surrounding context.
 * @param {string} mpageCategoryMean The Category Mean of the parent MPages View
 * @param {number} optionsBitmask An integer value which is a bismask used to control various options within the Component Container
 * @param {object} viewSettings If provided will be used as the settings for the component container.  If not provided, the base MPageView functionality will attempt to read the settings from the global m_bedrockMpage settings object.
 * @returns {ComponentContainer} This function returns the ComponentContainer object that was rendered
 */
function renderComponentContainer(mpageCategoryMean, optionsBitmask, viewSettings) { // eslint-disable-line no-unused-vars
    try {
        // Parse the locale and make it available if
        populateMPageLocale();

        // Create the View and provide the category mean
        var componentContainer = new ComponentContainer();
        componentContainer.setCategoryMean(mpageCategoryMean);

        // Set the options bitmask provided
        componentContainer.setOptionsBitmask(optionsBitmask || 0);

        // If settings were provided, set them in the view otherwise they will be provide as a global object
        if (viewSettings) {
            componentContainer.setViewSettings(viewSettings);
        }
        else {
            parseMPageSettingsJSON();
        }

        // Generic MPages View Loading functions
        componentContainer.initializeView();
        componentContainer.loadViewSettings();
        componentContainer.initializeComponents();
        componentContainer.renderView();
        componentContainer.postProcessing();
        return componentContainer;
    }
    catch (err) {
        logger.logJSError(err, null, "mpage-driver.js", "renderComponentContainer");
        throw err;
    }
}

/**
 * A function that loads and renders a single component on a blank html page. This function is called from the MP_COMPONENT_DRIVER
 * CCL script.
 * @param {String} compSettingsJSON : The JSON string containing the settings and information necessary to load the component.
 * @returns {undefined} This function does not return a value
 */
function renderSingleComponent(compSettingsJSON) { //eslint-disable-line no-unused-vars
    populateMPageLocale();

    var componentSettings = parseComponentSettingsJSON(compSettingsJSON);
    var criterion = createPageCriterion("");
    var CompDef = MP_Util.getObjectDefinitionMapping(componentSettings.F_MN);
    var compObj = new CompDef(criterion);
    var compNS = compObj.getStyles().getNameSpace();
    var container = document.getElementById("mainContainer");
    var compType = (componentSettings.F_MN.substring(0, 2).toUpperCase() === "WF") ? CERN_COMPONENT_TYPE_WORKFLOW : CERN_COMPONENT_TYPE_SUMMARY;


    //set the component type in case it needs to be retrieved later
    compObj.getStyles().setComponentType(compType);

    compObj.initializeComponent(criterion);
    MP_Core.AppUserPreferenceManager.Initialize(criterion, CERN_driver_mean);
    MP_Core.AppUserPreferenceManager.GetPreferences(CERN_driver_mean) // For loading the component user preferences.
        .then(function(){ 
            compObj.loadComponentSettings(componentSettings);

            //Set a render strategy according to the component type
            if(compType === CERN_COMPONENT_TYPE_WORKFLOW) {
                compObj.setAlwaysExpanded(true);
                compObj.setRenderStrategy(new WorkflowRenderStrategy());
                container.className = "wf";
            }
            else {
                //Target component is a summary type. Set render strategy and remove workflow class from the container div.
                compObj.setRenderStrategy(new SummaryRenderStrategy());
                container.className = "";
            }

            //Create the view container and append set the height as window's height.
            var viewContainer = $("<div></div>").addClass("vwp-views").attr("id", "vwpBody").height($(window).height());

            // Append the component basic html to view container.
            viewContainer.append(compObj.getRenderStrategy().createComponentShell());

            //Append the view container to main container.
            $(container).append(viewContainer);

            //Add the resize event listener
            $(window).resize(function() {

                //Check to ensure a resize is actually necessary.  If not then just return.
                if(!CERN_Browser.validateWindowResize()) {
                    return;
                }
                viewContainer.height($(window).height());
                compObj.resizeComponent();
            });

            compObj.setRootComponentNode(document.getElementById(compNS + compObj.getComponentId()));
            compObj.setSectionContentNode(document.getElementById(compNS + "Content" + compObj.getComponentId()));
            compObj.retrieveComponentData();

            //hide the component menu if there are no items or if the menu has not been initialized
            var compMenu = compObj.getMenu();
            if(!compMenu || !compMenu.getMenuItemArray() || !compMenu.getMenuItemArray().length) {
                document.getElementById("mainCompMenu" + compNS + compObj.getComponentId()).style.display = "none";
            }
        });
}

/**
 * This function is used to generate the Criterion object for use in various locations within the MPages Architecture.  This object
 * is generated from the global m_criterionJSON string.
 * @param {Object} categoryMean The category mean of the MPage being loaded
 * @returns {Criterion} The Criterion object generated from the m_criteironJSON object
 */
function createPageCriterion(categoryMean) {
    var parsedCriterion = CERN_Platform.getCriterion();
    var criterion = MP_Util.GetCriterion(parsedCriterion, CERN_static_content); //eslint-disable-line new-cap
    criterion.category_mean = categoryMean;
    return criterion;
}

/**
 * A function used to launch the discharge process from various locations throughout the MPages Architecture
 * @param {number} encntrID The encounter ID which will be used when discharging the patient
 * @param {number} personID The ID of the person being discharged
 * @param {number} userID The ID of the user discharging the patient
 * @returns {undefined} This function does not return a value
 */
function OpenDischargeProcess(encntrID, personID, userID) { //eslint-disable-line no-unused-vars
    var dpObject = CERN_Platform.getDiscernObject("DISCHARGEPROCESS");
    if(dpObject) {
        dpObject.person_id = personID;
        dpObject.encounter_id = encntrID;
        dpObject.user_id = userID;
        dpObject.LaunchDischargeDialog(); //eslint-disable-line new-cap
    }
}

/**
 * This function is used to attempt to parse the component settings JSON string and return the resulting object
 * @param {String} compSettingsJSON : The JSON string containing the component settings
 * @returns {Object} : The structure object containing the necessary settings for rendering the component
 */
function parseComponentSettingsJSON(compSettingsJSON) {
    try {
        //Check if the JSON string exists
        if(typeof compSettingsJSON !== "undefined") {
            var settingsObj = JSON.parse(compSettingsJSON).CS;
            if(typeof settingsObj !== "undefined") {
                return settingsObj;
            }
            else {
                //The JSON string supplied does not contain the proper settings for the component.
                throw new Error(i18n.discernabu.mpageDriver.INCORRECT_JSON_STRING);
            }
        }
        else {
            throw new Error(i18n.discernabu.mpageDriver.NO_JSON_STRING);
        }
    }
    catch(err) {
        logger.logJSError(err, null, "mpage-driver.js", "parseComponentSettingsJSON");
        throw err;
    }
}

/**
 * This function is used to attempt to parse the m_mpageSettingsJSON global and store it in the m_bedrockMpage global for future
 * use.
 * @returns {undefined} This function does not return a value
 */
function parseMPageSettingsJSON() { //eslint-disable-line no-unused-vars, no-redeclare
    try {
        //Check to see if the settings JSON string exists
        if(typeof m_mpageSettingsJSON !== "undefined") {
            m_bedrockMpage = JSON.parse(m_mpageSettingsJSON).MP_SETTINGS; //eslint-disable-line no-undef
        }
        else {
            //m_mpageSettingsJSON is a global define by MP_UNIFIED_DRIVER and if that is not available then an incorrect driver is
            // being used
            throw new Error(i18n.discernabu.mpageDriver.INCORRECT_DRIVER);
        }

        //clean up the global JSON string to free up memory because it won't be used anywhere any more.
        m_mpageSettingsJSON = null; //eslint-disable-line no-undef
    }
    catch(err) {
        logger.logJSError(err, null, "mpage-driver.js", "parseMPageSettingsJSON");
        throw err;
    }
}

/**
 * This function will be used to prepare the MPAGE_LOCALE global parameter for consumption in other area within the MPages
 * Architecture
 * @returns {undefined} This function does not return a value
 */
function populateMPageLocale() { //eslint-disable-line no-redeclare
    try {
        var DATE_FORMATS = JSON.parse(m_dateformatJSON); //eslint-disable-line no-undef
        MPAGE_LOCALE = new mp_formatter.Locale(DATE_FORMATS.datetimeformats.formatters);
        var weekMonthNames = DATE_FORMATS.datetimeformats.weekmonthnames;
        var shortWeekNames = [];
        var fullWeekNames = [];
        var shortMonthNames = [];
        var fullMonthNames = [];

        //Split the stringified record value for Month & Week names and store in a array.
        $.each(weekMonthNames.weekabbrev.split(","), function() {
            shortWeekNames.push($.trim(this));
        });
        $.each(weekMonthNames.weekfull.split(","), function() {
            fullWeekNames.push($.trim(this));
        });
        dateFormat.i18n.dayNames = shortWeekNames.concat(fullWeekNames);

        $.each(weekMonthNames.monthabbrev.split(","), function() {
            shortMonthNames.push($.trim(this));
        });
        $.each(weekMonthNames.monthfull.split(","), function() {
            fullMonthNames.push($.trim(this));
        });
        dateFormat.i18n.monthNames = shortMonthNames.concat(fullMonthNames);

        dateFormat.masks = DATE_FORMATS.datetimeformats.dateformats;
        var locale = CERN_Platform.getCriterion().CRITERION.LOCALE_ID.toUpperCase();
        $.datepicker.setDefaults($.datepicker.regional[ locale ]);
    }
    catch(err) {
        logger.logJSError(err, null, "mpage-driver.js", "populateMPageLocale");
        throw err;
    }
}

/**
 * This function is used to gather execution information and log it to a CAP timer for investigation
 * purposes in the future.
 * @returns {undefined} This function does not return a value.
 */
function captureExecutionDetails() { //eslint-disable-line no-unused-vars
    var criterion = CERN_Platform.getCriterion().CRITERION;
    var executionDetailCap = new CapabilityTimer("CAP:MPG Framework Execution Detail", "MPageFramework");
    var screenDetails = {
        orientation: CERN_Browser.getOrientation(),
        screenResolution: CERN_Browser.getScreenResolution(),
        availableResolution: CERN_Browser.getAvailableResolution(),
        viewportResolution: CERN_Browser.getViewportResolution(),
        colorDepth: CERN_Browser.getColorDepth()
    };
    var browserDetails = {
        userAgent: CERN_Browser.getUserAgent()
    };
    var frameworkDetails = {
        releaseIdentifier: criterion.RELEASE_IDENTIFIER,
        releaseVersion: criterion.RELEASE_VERSION
    };
    executionDetailCap.addMetaData("screenDetails", JSON.stringify(screenDetails));
    executionDetailCap.addMetaData("browserDetails", JSON.stringify(browserDetails));
    executionDetailCap.addMetaData("frameworkDetails", JSON.stringify(frameworkDetails));
    executionDetailCap.capture();
}
/* globals m_view_content_urls, promiseMapSeries, CapabilityTimer, RTMSTimer */
/**
 * Initializes the MP_ContentLoader object to be used for loading static content on-demand
 * @returns {undefined} This function doesn't return a value
 **/
function initializeViewContentLoader() { // eslint-disable-line no-unused-vars

    // if we do not choose to load views on tab-click, we instantly resolve the loading promises since there is nothing to load
    // for example, this scenario would be executed when we are testing against master components
    // Note: m_view_content_urls is defined via a driver script configured to use deferred tab-click loading
    if (!window.m_view_content_urls){
        window.MP_ContentLoader = {
            loadViewContent: function() { },
            logDynamicTabFrameworkDetails: function() { },
            waitForContentLoaded: function() {
                return Promise.resolve();
            }
        };
    }

    // create the token loader object
    else {
        var viewContentObj = JSON.parse(m_view_content_urls).VIEW_CONTENT_URLS;
        var contentLoadTracker = {};

        /**
         * Returns the URLs for the assets necessary to load an additional view
         * @param {String} categoryMean The category_mean for the view to be loaded (expected to be upper case)
         * @returns {Array} An array of objects with keys 'JS' and 'CSS', which are each URLs
         */
        var getScriptSources = function(categoryMean) {
            var relevantCategoryObj = viewContentObj.CATEGORY.find(function(category){
                return category.CAT_MEAN.toUpperCase() === categoryMean.toUpperCase();
            });

            // if content is not needed for this view, return no scripts
            if (!relevantCategoryObj){
                return [];
            }
            return relevantCategoryObj.GROUP;
        };

        /**
         * Appends CSS to the document
         * @param {String} href The CSS URL to load
         * @returns {Promise} a promise which is resolved once the download is complete
         */
        var loadCSS = function(href) {
            return new Promise(function(resolve, reject){
                logger.logDebug("Downloading: " + href);
                var link = document.createElement("link");
                link.setAttribute("rel", "stylesheet");
                link.setAttribute("type", "text/css");
                link.setAttribute("href", href);
                link.onload = function() {
                    resolve();
                };
                link.onerror = function() {
                    logger.logError("Failed to download the following CSS file: '" + href + "'.");
                    reject();
                };
                document.getElementsByTagName("head")[0].appendChild(link);
            });
        };

        /**
         * Appends JS to the document
         * @param {String} href The JS URL to load
         * @returns {Promise} a promise which is resolved once the download is complete
         */
        var loadJS = function(href) {
            return new Promise(function(resolve, reject){
                logger.logDebug("Downloading: " + href);
                $.ajax({
                    type: "GET",
                    url: href,
                    success: function() {
                        resolve();
                    },
                    error: function(jqXHR, textStatus, errorThrown) {
                        var errorMessage = "Failed to download the following JS file: '" + href + "'. ";
                        if (textStatus) {
                            errorMessage += "Status: " + textStatus + ". ";
                        }
                        if (errorThrown){
                            errorMessage += "Error: " + errorThrown + ". ";
                        }
                        logger.logError(errorMessage);
                        reject();
                    },
                    dataType: "script",
                    cache: true
                });
            });
        };

        window.MP_ContentLoader = {
            /**
             * Loads the necessary static content needed to load the specified view
             * @param {String} categoryMean The category_mean of the view to load
             * @returns {Promise} a promise resolved once both JS and CSS downlaods for every group is complete
             **/
            loadViewContent: function(categoryMean) {
                categoryMean = categoryMean.toUpperCase();
                var scriptsToLoad = getScriptSources(categoryMean);

                var loadResourcesTimer = new RTMSTimer("ENG:MPG.LOAD_VIEW_RESOURCES", categoryMean);
                loadResourcesTimer.start();
                // note: promiseMapSeries returns Promise.resolve() for an empty array
                contentLoadTracker[categoryMean] = promiseMapSeries(scriptsToLoad, function(groupScripts){
                    return Promise.all([
                        loadCSS(groupScripts.CSS_URL),
                        loadJS(groupScripts.JS_URL)
                    ]);
                }).then(function(){
                    loadResourcesTimer.stop();
                });
                // if a script fails to download, an unhandled promise rejection will occur,
                // causing the standard page-level error

                // return the promise resolved once download is complete
                return contentLoadTracker[categoryMean];
            },
            /**
             * Returns a promise which is resolved once the view's necessary content has been loaded.
             * @param {String} categoryMean The category_mean of the view to load
             * @returns {Promise} a promise resolved once both JS and CSS downlaods for every group is complete
             **/
            waitForContentLoaded: function(categoryMean) {
                var contentPromise = contentLoadTracker[categoryMean.toUpperCase()];
                if (!contentPromise){
                    logger.logWarning("no content loaded for view '" + categoryMean + "'.");
                    return Promise.resolve();
                }
                return contentPromise;
            },
            /**
             * Creates a CAP timer for roughly detailing the impact of deferred content loading
             * @param {string} defaultCategoryMean The default categoryMean when the viewpoint is loaded
             * @param {number} viewCount The number of views defined for this viewpoint
             * @returns {undefined} This function does not return a value
             **/
            logDynamicTabFrameworkDetails: function(defaultCategoryMean, viewCount){ // eslint-disable-line no-unused-vars
                if(typeof defaultCategoryMean !== "string") {
                    logger.logError("defaultCategoryMean parameter must be a string and not null for function 'logDynamicTabFrameworkDetails'");
                    return;
                }
                if (viewContentObj && viewContentObj.CATEGORY){
                    try {
                        defaultCategoryMean = defaultCategoryMean.toUpperCase();
                        var dynamicTabCapTimer = new CapabilityTimer("CAP:MPG.DYNAMIC_TAB_FRAMEWORK_DETAILS", "MPAGEFRAMEWORK");

                        var timerMetadata = {
                            "VIEW_CNT": viewCount, // the number of actual views defined to load in the viewpoint
                            "TOTAL_TOKEN_CNT": 0, // the count of tokens shared across all views
                            "INITIAL_TOKEN_CNT": 0, // token count needed prior to loading first view (includes unassociated)
                            "UNASSOCIATED_TOKEN_CNT": 0 // the count of tokens in the unassociated category
                        };

                        // finds the total count of tokens for a group
                        // used as param to array.prototype.reduce below
                        var getTokenCount = function(totalCount, groupObject){
                            // this will match the token array of an mpages dynamic content url
                            // e.g., for the url: http://url/js/group?[{"g_id":"MP,"a_id":"stuff","t":["1gXHzO","7dGufo"]}],
                            //      regexTokenMatch[1] will be ["1gXHzO","7dGufo"]
                            var regexTokenMatch = groupObject.JS_URL.match(/"t":(\[.*?\])/);
                            if (!regexTokenMatch || !regexTokenMatch[1]){
                                return totalCount;
                            }
                            return totalCount + JSON.parse(regexTokenMatch[1]).length;
                        };

                        viewContentObj.CATEGORY.forEach(function(singleViewContentObject){
                            var categoryMean = singleViewContentObject.CAT_MEAN.toUpperCase();

                            // get the total token count across all groups for only this category_mean
                            var tokenCount = singleViewContentObject.GROUP.reduce(getTokenCount, 0);

                            // increment count fields
                            timerMetadata.TOTAL_TOKEN_CNT += tokenCount;
                            if (categoryMean === defaultCategoryMean){
                                timerMetadata.INITIAL_TOKEN_CNT += tokenCount;
                            }
                            else if (categoryMean === "__UNSPECIFIED_CATEGORY"){
                                timerMetadata.INITIAL_TOKEN_CNT += tokenCount;
                                timerMetadata.UNASSOCIATED_TOKEN_CNT += tokenCount;
                            }
                        });
                        dynamicTabCapTimer.addMetaData("dynamicTabFrameworkDetails", JSON.stringify(timerMetadata));
                        dynamicTabCapTimer.capture();
                    }
                    catch (error) {
                        logger.logJSError(error, null, "view-content-driver.js", "logDynamicTabFrameworkDetails");
                    }
                }
            }
        };
    }
}
/**
 * @class
 * This MP_EventAudit object is the main entry point of the Mpage Audit API for MPages.
 * It creates the JSON object that will be passed to the CCL wrapper that calls the CCLAUDIT script.
 * This API will also allow for multiple audit events to be submit at the same time.
 */

var MP_EventAudit = function(){
	this.auditevents = {};
	this.auditevents.EVENTS = {};
	this.auditevents.EVENTS.EVENT = [];
	this.m_iAuditMode = 0;
	this.m_sAuditEventName = "";
	this.m_sAuditEventType = "";
	this.m_sAuditParticipantType = "";
	this.m_sAuditParticipantRoleCd = "";
	this.m_sAuditParticipantIDType = "";
	this.m_sAuditDataLifeCycle = "";
	this.m_dAuditParticipantID = 0.0;
	this.m_sAuditParticipantName = "";
	this.m_iAuditOutcomeInd = 4;
};
/**
 * Sets the Audit Mode value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditMode
 * @param {number} modeValue The audit mode
 * Possible Values: 0 - one-part, 1 - open multi-part, 2 - continue multi-part, 3 - close multi-part, 4 - close multi-part no entry
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditMode = function(modeValue) {
	if ( typeof modeValue !== "number" || modeValue < 0 || modeValue > 4) {
        throw new Error("EventAudit: Invalid Audit Mode");
    }
	this.m_iAuditMode = modeValue;
};

/**
 * Retrieves the audit mode
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditMode
 * @return {number} m_iAuditMode The Audit Mode value
 */
MP_EventAudit.prototype.getAuditMode = function() {
	return this.m_iAuditMode;
};

/**
 * Sets the Event Name value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditEventName
 * @param {string} auditEventName The audit event name
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditEventName = function(auditEventName) {
	this.m_sAuditEventName = auditEventName;
};

/**
 * Retrieves the audit event name
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditEventName
 * @return {string} m_sAuditEventName The Audit Event Name value
 */
MP_EventAudit.prototype.getAuditEventName = function() {
	return this.m_sAuditEventName;
};

/**
 * Sets the Event Type value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditEventType
 * @param {string} auditEventType The audit event type
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditEventType = function(auditEventType) {
	this.m_sAuditEventType = auditEventType;
};

/**
 * Retrieves the audit event type
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditEventType
 * @return {string} m_sAuditEventType The Audit Event Type value
 */
MP_EventAudit.prototype.getAuditEventType = function() {
	return this.m_sAuditEventType;
};

/**
 * Sets the Participant Type value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantType
 * @param {string} auditParticipantType The audit Participant Type
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantType = function(auditParticipantType) {
	this.m_sAuditParticipantType = auditParticipantType;
};

/**
 * Retrieves the audit Participant Type
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantType
 * @return {string} m_sAuditParticipantType The Audit Participant Type value
 */
MP_EventAudit.prototype.getAuditParticipantType = function() {
	return this.m_sAuditParticipantType;
};

/**
 * Sets the Participant Role Code value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantRoleCd
 * @param {string} auditParticipantRoleCd The audit Participant Role Code
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantRoleCd = function(auditParticipantRoleCd) {
	this.m_sAuditParticipantRoleCd = auditParticipantRoleCd;
};

/**
 * Retrieves the audit Participant Role Code
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantRoleCd
 * @return {string} m_sAuditParticipantRoleCd The Audit Participant Role Code value
 */
MP_EventAudit.prototype.getAuditParticipantRoleCd = function() {
	return this.m_sAuditParticipantRoleCd;
};

/**
 * Sets the Participant ID Type value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantIDType
 * @param {string} auditParticipantIDType The audit Participant ID Type
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantIDType = function(auditParticipantIDType){
	this.m_sAuditParticipantIDType = auditParticipantIDType;
};

/**
 * Retrieves the audit Participant ID Type
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantIDType
 * @return {string} m_sAuditParticipantIDType The Audit Participant ID Type value
 */
MP_EventAudit.prototype.getAuditParticipantIDType = function() {
	return this.m_sAuditParticipantIDType;
};

/**
 * Sets the Data Life Cycle value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditDataLifeCycle
 * @param {string} auditDataLifeCycle The audit Data Life Cycle
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditDataLifeCycle = function(auditDataLifeCycle) {
	this.m_sAuditDataLifeCycle = auditDataLifeCycle;
};

/**
 * Retrieves the audit Data Life Cycle
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditDataLifeCycle
 * @return {string} m_sAuditDataLifeCycle The Audit DataLife Cycle value
 */
MP_EventAudit.prototype.getAuditDataLifeCycle = function() {
	return this.m_sAuditDataLifeCycle;
};

/**
 * Sets the Participant ID value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantID
 * @param {double} auditParticipantID The audit Participant ID
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantID = function(auditParticipantID) {
	this.m_dAuditParticipantID = auditParticipantID;
};

/**
 * Retrieves the audit Participant ID
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantID
 * @return {double} m_dAuditParticipantID The Audit Participant ID value
 */
MP_EventAudit.prototype.getAuditParticipantID = function() {
	return this.m_dAuditParticipantID;
};

/**
 * Sets the Participant Name value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditParticipantName
 * @param {string} auditParticipantName The audit Participant Name
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditParticipantName = function(auditParticipantName) {
	this.m_sAuditParticipantName = auditParticipantName;
	var OutcomeInd = auditParticipantName.substring(7,8);
	this.m_iAuditOutcomeInd = parseInt(OutcomeInd, 10);
};

/**
 * Retrieves the audit Participant Name
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditParticipantName
 * @return {string} m_sAuditParticipantName The Audit Participant Name value
 */
MP_EventAudit.prototype.getAuditParticipantName = function() {
	return this.m_sAuditParticipantName;
};

/**
 * Sets the Outcome_Ind value
 *
 * @function
 * @memberof MP_EventAudit
 * @name setAuditOutcomeInd
 * @param {number} setAuditOutcomeInd The audit Outcome_Ind
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.setAuditOutcomeInd = function(auditOutcomeInd) {
	this.m_iAuditOutcomeInd = auditOutcomeInd;
};

/**
 * Retrieves the audit Outcome_Ind value
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditOutcomeInd
 * @return {number} m_iAuditOutcomeind The Audit Outcome_Ind value
 */
MP_EventAudit.prototype.getAuditOutcomeInd = function() {
	return this.m_iAuditOutcomeInd;
};

/**
 * Return the JSON string representation of the MP_EventAudit.auditevents object
 *
 * @function
 * @memberof MP_EventAudit
 * @name toJSON
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.toJSON = function() {
		return JSON.stringify(this.auditevents);
};

/**
 * Add a new audit event to the auditevents object.
 *
 * @function
 * @memberof MP_EventAudit
 * @name addAuditEvent
 *  @return {undefined} Nothing
 */
MP_EventAudit.prototype.addAuditEvent = function(){
	var tAEvent = {};
	tAEvent.AUDIT_MODE = this.m_iAuditMode || 0;
	tAEvent.EVENT_NAME = this.m_sAuditEventName || "";
	tAEvent.EVENT_TYPE = this.m_sAuditEventType || "";
	tAEvent.PARTICIPANT_TYPE = this.m_sAuditParticipantType || "";
	tAEvent.PARTICIPANT_ROLE_CD = this.m_sAuditParticipantRoleCd || "";
	tAEvent.PARTICIPANT_ID_TYPE = this.m_sAuditParticipantIDType || "";
	tAEvent.DATA_LIFE_CYCLE = this.m_sAuditDataLifeCycle || "";
	tAEvent.PARTICIPANT_ID = this.m_dAuditParticipantID || 0.0;
	tAEvent.PARTICIPANT_NAME = this.m_sAuditParticipantName || "";
	tAEvent.OUTCOME_IND = this.m_iAuditOutcomeInd;
	this.auditevents.EVENTS.EVENT.push(tAEvent);
};

/**
 * Return the collection of audit event objects
 *
 * @function
 * @memberof MP_EventAudit
 * @name getAuditEvents
 * @return {object} The audit events as JSON
 */
MP_EventAudit.prototype.getAuditEvents = function() {
	var arrObject = this.toJSON();
	return arrObject;
};

/**
 * Reset the collection of audit event objects
 *
 * @function
 * @memberof MP_EventAudit
 * @name resetAuditEvents
 */
MP_EventAudit.prototype.resetAuditEvents = function() {
	this.auditevents.EVENTS.EVENT = [];
};

/**
 * Submit array of Audit Events through the call to mp_submit_audit_events.prg
 *
 * @static
 * @function
 * @memberof MP_EventAudit
 * @name submit
 * @return {undefined} Nothing
 */
MP_EventAudit.prototype.submit = function() {
	try {
		if(this.auditevents.EVENTS.EVENT && this.auditevents.EVENTS.EVENT.length === 0){
			logger.logJSError("The Audit Events array submitted for processing is empty.");
			throw new Error("EVENTAUDIT: Audit Events array is empty.");
		} else {
            //Call the toJson method to stringify the auditevents object
            var aeObj = this.toJSON();
            //Create instance of script request api
            var request = new ScriptRequest();

            request.setArtifactInfo({
                artifactId: "mpage-event-audit",
                functionName: "submit"
            });

            var programName = "mp_submit_audit_events";
            var params = ['^MINE^', '^' + aeObj + '^'];
            request.setProgramName(programName);
            request.setParameterArray(params);
            request.setResponseHandler(function(replyObj) {
				if (replyObj.getStatus() === "S") {
					logger.logDebug("All events have been successfully submitted.");
					
				} else {
					logger.logJSError("An error occurred during the submission of events.");
					throw new Error("EVENTAUDIT: Error submitting events.");
				}
			});
            request.performRequest();

            //Clear audit events after successful submission
            this.resetAuditEvents();
        }
	} catch(e){
		logger.logJSError("Error encountered trying to submit audit events: <br />Message: " + e.description + "<br />Name: " + e.name + "<br />Number: " + e.number);
	}
};

/* global DDClipDragDrop, UtilitiesMenu, TemplateBuilder, TaggingDao, OrionTaggingDao, MP_FEATURE_TOGGLE */
/**
 * A collection of functions which can be used to save and delete tagged results.
 * @constructor
 */
var TaggingHandler = function() {

    // The user id which will be used when tagging and querying for tagged results
    this.m_userId = 0.0;

    // The encounter id to use when tagging and querying for tagged results
    this.m_encounterId = 0.0;

    // The patient id to use when tagging and querying for tagged results
    this.m_patientId = 0.0;

    // The person position code to use when tagging and querying for tagged results
    this.m_pprCode = 0.0;

    // A flag used to determine if tagging is available or not
    this.m_taggingAvailable = false;

    // This field will hold the actual contents for the Tagged Results Utility menu
    this.m_taggedResultsContent = "";

    // The element id for the icon of the utilities menu
    this.m_taggingMenuEleId = "";

    //  The user time zone to use when querying for tagged results
    this.m_userTz = 0;

    this.m_draggingAvailable = false;
    this.m_draggingCallback = $.Callbacks(); // eslint-disable-line new-cap

    this.m_contentTypes = [];
    this.m_contentTypesCallback = $.Callbacks(); // eslint-disable-line new-cap

    // Use OrionTagging API if it exists otherwise use CCL version
    if (window.OrionWebTagging) {
        // Call check feature toggle function that return Promise
        var featureToggle = this.checkWebTaggingEnabled();

        // Bind context Resove and Reject functions to current object TaggingHandler
        featureToggle
            .then(this.resolveFeatureToggle.bind(this))
            .catch(this.rejectFeatureToggle.bind(this));
    }
    else {
        this.m_taggingDataAccess = new TaggingDao();
    }
};

/* Feature toggle */

/**
 * Get the status of Orion Tagging feature.
 * @returns {Promise<object|Error>} status of the feature enable/disable.
 */
TaggingHandler.prototype.checkWebTaggingEnabled = function() {
    var ORION_TAGGING_ENABLED_TOGGLE = "urn:cerner:millennium:mpages:enable-web-tagging";

    try {
        return MP_FEATURE_TOGGLE.getToggleStatus(ORION_TAGGING_ENABLED_TOGGLE);
    } catch (err) {
        return Promise.reject(err);
    }
};

/**
 * Resolve Promise and log result with flag value or use CCL version.
 */
TaggingHandler.prototype.resolveFeatureToggle = function(response) {
    // If feature enabled then use OrionTagging API  otherwise use CCL version
    if (response.isEnabled) {
        this.m_taggingDataAccess = new OrionTaggingDao();
        MP_Util.LogInfo("Orion Tagging - enabled: " + response.isEnabled);
    }
    else {
        this.m_taggingDataAccess = new TaggingDao();
    }
};

/**
 * Reject Promise, log error and use CCL version.
 */
TaggingHandler.prototype.rejectFeatureToggle = function(error) {
    // If feature toggle fails then use CCL version
    this.m_taggingDataAccess = new TaggingDao();
    MP_Util.LogJSError(error, null, "TaggingHandler.js", "rejectFeatureToggle"); // eslint-disable-line new-cap
};

/* Checkers */

/**
 * Checks to see if tagging is available
 * @returns {boolean} True if tagging is available, false otherwise
 */
TaggingHandler.prototype.isTaggingAvailable = function() {
    return this.m_taggingAvailable;
};

/**
 * Calls a function when dragging services are available
 * @param {Function} func the function to call
 * @returns {undefined}
 */
TaggingHandler.prototype.draggingAvailableCallback = function(func) {

    if (this.m_draggingCallback.fired()) {
        func(this.m_draggingAvailable);
    }
    else {
        this.m_draggingCallback.add(func);
    }
};

/**
 * Calls a function when tagging content types are available.
 * @param {string} type the content type to query - this corresponds to a CDF_MEANING on code set 32000, i.e. LABS_V2, TAGTEXT
 * @param {Function} func the function to call - will return a single argument that will be true if the requested content type is available
 * @returns {undefined}
 */
TaggingHandler.prototype.taggingContentAvailableCallback = function(type, func) {
    var self = this;
    if (this.m_contentTypesCallback.fired()) {
        func(self.isContentTypeAvailable(type));
    }
    else {
        this.m_contentTypesCallback.add(function() {
            func(self.isContentTypeAvailable(type));
        });
    }
};

/**
 * Checks to see if a content type is currently marked as available. Consumers should generally call
 * taggingContentAvailableCallback instead.
 * @param {string} type the content type to query - this corresponds to a CDF_MEANING on code set 32000, i.e. LABS_V2, TAGTEXT
 * @returns {boolean} true if content specified by type is available, false otherwise
 */
TaggingHandler.prototype.isContentTypeAvailable = function(type) {
    return this.m_contentTypes.indexOf(type) !== -1;
};

/* Getters */

/**
 * Retrieves the id of the encounter that will be used when tagging a result or querying for tagged results
 * @returns {number} The id of the current encounter
 */
TaggingHandler.prototype.getEncounterId = function() {
    return this.m_encounterId;
};

/**
 * Gets the id of the patient that will be used when handling tagging queries.
 * @returns {number} The id of the patient.
 */
TaggingHandler.prototype.getPatientId = function() {
    return this.m_patientId;
};

/**
 * Get the PPR code that will be used when tagging a result
 * @returns {number} the PPR code
 */
TaggingHandler.prototype.getPPRCode = function() {
    return this.m_pprCode;
};

/**
 * Retrieves the contents of the tagged results container
 * @returns {string} The HTML markup for the tagged results container
 */
TaggingHandler.prototype.getTaggedResultsContent = function() {
    return this.m_taggedResultsContent;
};

/**
 * Gets the id of the tagged results menu element
 * @returns {String} elementId The id of the tagged results menu element
 */
TaggingHandler.prototype.getTaggingMenuElementId = function() {
    return this.m_taggingMenuEleId;
};


/**
 * Retrieves the id of the user that will be used when tagging a result or querying for tagged results
 * @returns {number} The id of the user who tagged the result
 */
TaggingHandler.prototype.getUserId = function() {
    return this.m_userId;
};

/**
 * Gets the time zone of the user that will be used when handling tagging queries.
 * @returns {number} The time zone of the user.
 */
TaggingHandler.prototype.getUserTz = function() {
    return this.m_userTz;
};


/* Setters */

/**
 * Sets the id of the encounter to use for this tagging and querying for tagged results.  This should be the id of the encounter
 * currently being viewed by the user and not the encounter when the result was documented.
 * @param {number} encounterId The id of the encounter currently being viewed
 * @returns {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setEncounterId = function(encounterId) {
    if (typeof encounterId !== "number") {
        throw new Error("Called setEncounterId on TaggingHandler with non number type for encounterId parameter");
    }
    this.m_encounterId = encounterId;
    return this;
};

/**
 * Sets the patient id to use for tagging. This should be the patient id as returned in the criterion.
 * @param {number} patientId the id of the patient.
 * @returns {TaggingHandler} returns self.
 */
TaggingHandler.prototype.setPatientId = function(patientId) {
    if (typeof patientId !== "number") {
        throw new Error("Called setPatientId on TaggingHandler with non number type for patientId parameter");
    }
    this.m_patientId = patientId;
    return this;
};

/**
 * Sets the PPR code to use for tagging. This should be the ppr code as returned in the criterion.
 * @param {number} pprCode the ppr code.
 * @returns {TaggingHandler} returns self.
 */
TaggingHandler.prototype.setPPRCode = function(pprCode) {
    if (typeof pprCode !== "number") {
        throw new Error("Called setPPRCode on TaggingHandler with non number type for pprCode parameter");
    }
    this.m_pprCode = pprCode;
    return this;
};

/**
 * Sets the contents of the tagged results list
 * @param {String} taggedContents The contents that will be shown in the tagged results container
 * @returns {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setTaggedResultsContent = function(taggedContents) {
    if (typeof taggedContents !== "string") {
        throw new Error("Called setTaggedResultsContent with non string type for taggedContents parameter");
    }
    this.m_taggedResultsContent = taggedContents;
    return this;
};

/**
 * Sets the id of the tagged results menu element
 * @param {String} elementId The id of the tagged results menu element
 * @returns {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setTaggingMenuElementId = function(elementId) {
    if (typeof elementId === "string") {
        this.m_taggingMenuEleId = elementId;
    }
    return this;
};

/**
 * Sets the flag which indicates if tagging is available or not
 * @param {taggingAvailable} taggingAvailable The flag used to determine if tagging is available or not
 * @returns {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setTaggingAvailable = function(taggingAvailable) {
    if (typeof taggingAvailable === "boolean") {
        this.m_taggingAvailable = taggingAvailable;
    }
    return this;
};

/**
 * Sets the id of the user tagging the result.
 * @param {number} userId The id of the user tagging the result
 * @returns {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setUserId = function(userId) {
    if (typeof userId === "number") {
        this.m_userId = userId;
    }
    return this;
};

/**
 * Sets the user time zone
 * @param {number} userTz The time zone of the user tagging the result
 * @returns {TaggingHandler} The TaggingHandler object calling this function so chaining can be used
 */
TaggingHandler.prototype.setUserTz = function(userTz) {
    if (typeof userTz === "number") {
        this.m_userTz = userTz;
    }
    return this;
};

/* Actions */
/**
 * Initializes the tagging utility within the viewpoint framework.  This includes settings the user and encounter id which are used later when tagging and querying results
 * and creating the UtilitiesMenu for the user interface.
 * @param {string} utilIconElementId The HTML id for the icon that will be used for the viewpoint utility
 * @param {Criterion} criterion The criterion object used to extract the user id and encounter id
 * @returns {string} Initial body of tag text menu
 */
TaggingHandler.prototype.initTaggingUtility = function(utilIconElementId, criterion) {
    var self = this;
    var rti18n = i18n.discernabu.mpageResultTagging;
    var vwpHeaderHeight = 38;
    // Save off the userId and encounter Id for future use
    this.setUserId(criterion.provider_id);
    this.setPatientId(criterion.person_id);
    this.setEncounterId(criterion.encntr_id);
    this.setPPRCode(criterion.ppr_cd);
    this.setUserTz(criterion.client_tz);

    // Update the taggingAvailable indicator so components know that they can tag results
    this.setTaggingAvailable(true);
    this.setTaggingMenuElementId(utilIconElementId);

    // Add the necessary click event to the utilities menu
    var taggingIcon = $("#" + utilIconElementId);
    if (taggingIcon.length) {
        $(taggingIcon).addClass("tagging-util-icon").attr({"title": rti18n.TAGGED_ITEMS, "aria-label": rti18n.TAGGED_ITEMS});
    }

    // Get the tagging util anchor
    var taggingUtilAnchor = taggingIcon;
    if (taggingUtilAnchor.length) {
        // Create the UtilitiesMenu and attach click events
        var taggingMenu = new UtilitiesMenu("resultTagging");
        taggingMenu.setLabel(rti18n.TAGGED_ITEMS + "<span id='taggingRemoveAll' class='tagging-remove-all'>" + rti18n.REMOVE_ALL + "</span>");
        taggingMenu.setWidth(400);
        // Determine the maxHeight for the contents
        taggingMenu.setAnchorElementId($(taggingUtilAnchor).attr("id"));
        taggingMenu.setAnchorActiveClass("vwp-util-active");
        taggingMenu.setAnchorConnectionCorner([ "bottom", "right" ]);
        taggingMenu.setContentConnectionCorner([ "top", "right" ]);
        taggingMenu.setUtilitiesContentCreationFunction(function() {
            self.queryTaggedResults();

            // If the menu is open show the loading indicator
            return "<div class='tagging-loading'>&nbsp;</div>";
        });
        MP_MenuManager.addMenuObject(taggingMenu);

        //  make loaded clipboard contents draggable
        CERN_EventListener.addListener(document.body, "tagMenuLoaded", function(e, eventData) {
            if (typeof DDClipDragDrop !== "undefined") {
                DDClipDragDrop.initMPageTagClipboardDragDrop(eventData.draggingAvailable);
            }

            if (eventData.draggingAvailable) {
                if (typeof DDClipDragDrop !== "undefined") {
                    DDClipDragDrop.initDragBehavior(true);
                }
            }
        }, this);

        // close the menu when the last item is dropped
        CERN_EventListener.addListener(document.body, "lastItemDropped", function() {
            MP_MenuManager.closeMenuStack();
        }, this);

        // Add the click event to the viewpoint Utilities control
        $(taggingUtilAnchor).click(function() {
            if (taggingMenu.isVisible()) {
                MP_MenuManager.closeMenuStack();
            }
            else {
                taggingMenu.setMaxHeight($("#vwpBody").height() - vwpHeaderHeight);
                MP_MenuManager.showMenu("resultTagging");
            }
        });
    }

    // Kick off a script call to populate the Result Tagging menu after a timeout to allow the components to load first
    setTimeout(function() {
        self.queryTaggedResults();
    }, 3000);
};

/**
 * Performs a call to the CCL script MP_DELETE_TAGGED_RESULTS with the ids of all of the tagged results to delete.  The MP_DELETE_TAGGED_RESULTS script
 * calls the same service as MP_QUERY_TAGGED_RESULTS and returns the contents in order to keep the contents in the Tagged Results utilities menu updated.
 * @param {[number]} deleteList A JSON list of tagged entities to be removed. The format MUST be as follows: [{"contentType":"EMR_MEANING", "entityId" : "ENTITY_ID},{},...,{}]
 * where EMR_MEANING is the emr meaning that will be looked up in codeset 32000 and ENTITY_ID is the tagged entity id.
 * @returns {Promise<object|Error>} status and xhtml result representing the new contents of the clipboard
 */
TaggingHandler.prototype.deleteTaggedResults = function(deleteList) {
    var self = this;
    try {
        // If there is nothing to delete, just return.
        if (!deleteList.DELETE_TAG.TAG_LIST) {
            return Promise.resolve({ status: "S" });
        }

        return this.m_taggingDataAccess.deleteTaggedResults(this.getUserId(), this.getPatientId(), this.getEncounterId(), this.getPPRCode(), deleteList)
            .then(function(reply) {
                self.deleteTaggedResultsHandler();
                return reply;
            }, function(error) {
                self.handleError(i18n.discernabu.mpageResultTagging.REMOVE_ERROR_MESSAGE, i18n.discernabu.mpageResultTagging.REMOVE_ERROR_TITLE);
                throw error;
            });
    }
    catch (error) {
        MP_Util.LogJSError(error, null, "TaggingHandler.js", "deleteTaggedResults"); // eslint-disable-line new-cap
        return Promise.reject(Error("Failed to call delete tagged results"));
    }
};

/**
 * Performs a call to request 969595 - GenerateDragText. The service will return a list of EMR content and footnotes if the tags passed are TAGTEXT.
 * @param {Array<TaggedResult>} taggedResults A list of TaggedResult objects to be converted to text/annotations
 * @returns {Promise<String>} resulting xhtml for drag rendering call
 */
TaggingHandler.prototype.retrieveDragResults = function(taggedResults) {

    try {
        return this.m_taggingDataAccess.retrieveDragResults(this.getUserId(), this.getPatientId(), this.getEncounterId(), this.getPPRCode(), this.getUserTz(), taggedResults);
    }
    catch (error) {
        MP_Util.LogJSError(error, null, "TaggingHandler.js", "retrieveDragResults"); // eslint-disable-line new-cap
        return Promise.reject(error);
    }
};

/**
 * Attempts to save tagged results. Expects a list of TaggedResult objects. For each of the provided TaggedResult objects,
 * the necessary fields are validated. If they are not provided, an exception is thrown.
 * @param {Array<TaggedResult>} taggedResults A list of TaggedResult objects to be saved.
 * @returns {Promise<object|Error>} status and tag list, with entityId, contentType, and blobHandle (images only)
 */
TaggingHandler.prototype.saveTaggedResults = function(taggedResults) {
    var self = this;
    try {
        return this.m_taggingDataAccess.saveTaggedResults(this.getUserId(), this.getEncounterId(), taggedResults)
            .then(function(reply) {
                self.saveTaggedResultsHandler(reply);
                return reply;
            }, function(error) {
                self.handleError(i18n.discernabu.mpageResultTagging.SAVE_ERROR_MESSAGE, i18n.discernabu.mpageResultTagging.SAVE_ERROR_TITLE);
                throw error;
            });
    }
    catch (error) {
        MP_Util.LogJSError(error, null, "TaggingHandler.js", "saveTaggedResults"); // eslint-disable-line new-cap
        return Promise.reject(error);
    }
};

/**
 * Attempts to save a list of tagged result based on the TaggedResult object list passed into the function.  Before making the call to the MP_SAVE_TAGGED_RESULTS CCL
 * script, all of the required fields are validated.  If all of the required fields are not valid then no call is made.  The MP_SAVE_TAGGED_RESULTS script
 * calls the same service as MP_QUERY_TAGGED_RESULTS and returns the contents in order to keep the contents in the Tagged Results utilities menu updated.
 * @param {TaggedResult} taggedResult A list of a TaggedResult object which contains all of the necessary information for tagging a result.
 * @returns {Promise<object|Error>} status and tag list, with entityId, contentType, and blobHandle (images only)
 */
TaggingHandler.prototype.saveTaggedResult = function(taggedResult) {
    return this.saveTaggedResults([ taggedResult ]);
};

/**
 * Retrieves tagged details for all of the currently tagged results.
 * Populates the tag clipboard menu display with XHTML markup if open.
 * @returns {Promise<object|Error>} status and tag list, with entityId, contentType, tagTextEntityId, and blobHandle (images only)
 */
TaggingHandler.prototype.queryTaggedResults = function() {
    var self = this;
    try {
        var promise = this.m_taggingDataAccess.queryTaggedResults(this.getUserId(), this.getPatientId(), this.getEncounterId(), this.getPPRCode())
            .then(function(reply) {
                self.queryTaggedResultsHandler(reply);
                return reply;
            }, function(error) {
                self.handleError(i18n.discernabu.mpageResultTagging.QUERY_ERROR_MESSAGE, i18n.discernabu.mpageResultTagging.QUERY_ERROR_TITLE);
                throw error;
            });

        return promise;
    }
    catch (error) {
        MP_Util.LogJSError(error, null, "TaggingHandler.js", "queryTaggedResults"); // eslint-disable-line new-cap
        return Promise.reject(error);
    }
};

/**
 * Callback for queryTaggedResults - updates tag menu and fires drag/content callbacks
 * @param {object} reply queryTaggedResults reply
 * @returns {undefined}
 */
TaggingHandler.prototype.queryTaggedResultsHandler = function(reply) {
    this.updateTaggingIcon(!!reply.xhtml);
    this.taggingCallback(reply.xhtml);

    if (!this.m_draggingCallback.fired()) {
        this.m_draggingAvailable = reply.dragVersion > 0;
        this.m_draggingCallback.fire(this.m_draggingAvailable);
    }

    if (!this.m_contentTypesCallback.fired()) {
        if (reply.contentTypes) {
            this.m_contentTypes = reply.contentTypes;
        }
        this.m_contentTypesCallback.fire(this.m_contentTypes);
    }
};

/**
 * Callback for saveTaggedResults - closes tag menu if open
 * @param {object} reply saveTaggedResults reply
 * @returns {undefined}
 */
TaggingHandler.prototype.saveTaggedResultsHandler = function(reply) {
    this.updateTaggingIcon(reply.tags && reply.tags.length > 0);
    this.taggingCallback();
    MP_MenuManager.closeMenuStack();
};

/**
 * Callback for removeTaggedResults - updates tag menu and fires drag/content callbacks
 * @param {object} reply removeTaggedResults reply
 * @returns {undefined}
 */
TaggingHandler.prototype.deleteTaggedResultsHandler = function() {

    var menu = MP_MenuManager.getMenuObject("resultTagging");
    var menuContent = $("#" + menu.getContentElementId() + " .utilities-menu-custom-content");
    var ddemrcontentitems = menuContent.find(".ddemrcontentitem").not(".ddemrcontentitem.removed");
    this.updateTaggingIcon(ddemrcontentitems && ddemrcontentitems.length > 0);

    if(ddemrcontentitems && ddemrcontentitems.length === 0) {
        var taggedContents = "<p class='tagging-no-tags'>" + i18n.discernabu.mpageResultTagging.NO_TAGGED_ITEMS_FOUND + "</p>";
        this.setTaggedResultsContent(taggedContents);
        if (menu && menu.isVisible()) {
            $("#" + menu.getContentElementId() + " .utilities-menu-custom-content").html(taggedContents);

            //  fire event when content is loaded
            CERN_EventListener.fireEvent(null, document.body, "tagMenuLoaded", { draggingAvailable: this.m_draggingAvailable });
        }
    }
};

/**
 * Sets the tag icon to indicate whether or not any tags are currently available.
 * @param {boolean} hasTags true if the user has tags on their tag clipboard, false otherwise
 * @returns {undefined}
 */
TaggingHandler.prototype.updateTaggingIcon = function(hasTags) {

    var taggingIcon = $("#" + this.getTaggingMenuElementId());
    if (taggingIcon.length) {
        if (hasTags) {
            $(taggingIcon).addClass("tagging-util-icon-active");
        }
        else {
            $(taggingIcon).removeClass("tagging-util-icon-active");
        }
    }
};

/**
 * Error handler - clears the tag menu if open and displays an error dialog.
 * @param {String} errorMessage Error message to display in error dialog
 * @param {String} errorTitle Error title to display in error dialog
 * @returns {undefined}
 */
TaggingHandler.prototype.handleError = function(errorMessage, errorTitle) {

    this.updateTaggingIcon(false);

    var menu = MP_MenuManager.getMenuObject("resultTagging");
    if (menu && menu.isVisible()) {
        $("#menuContentresultTagging").find("#taggingRemoveAll").css("display", "");

        var taggedContents = "<p class='tagging-no-tags'>" + i18n.discernabu.mpageResultTagging.NO_TAGGED_ITEMS_FOUND + "</p>";
        this.setTaggedResultsContent(taggedContents);
        $("#" + menu.getContentElementId() + " .utilities-menu-custom-content").html(taggedContents);

        //  fire event when content is loaded
        CERN_EventListener.fireEvent(null, document.body, "tagMenuLoaded", { draggingAvailable: this.m_draggingAvailable });
    }

    var errorModal = MP_ModalDialog.retrieveModalDialogObject("resultTaggingErrorModal");
    if (!errorModal) {
        errorModal = new ModalDialog("resultTaggingErrorModal");
        // Create and add the close button
        var closeButton = new ModalButton("closeButton");
        closeButton.setText(i18n.discernabu.CONFIRM_OK).setCloseOnClick(true);
        errorModal.addFooterButton(closeButton);
        MP_ModalDialog.addModalDialogObject(errorModal);
    }

    errorModal = MP_Util.generateModalDialogBody("resultTaggingErrorModal", "error", errorMessage, i18n.discernabu.mpageResultTagging.ERROR_ACTION);
    errorModal.setHeaderTitle(errorTitle);
    MP_ModalDialog.updateModalDialogObject(errorModal);
    MP_ModalDialog.showModalDialog("resultTaggingErrorModal");
};

/**
 * Handles tag menu UI for tag queries
 * @param {String} xhtml XHTML to display in tag menu. Optional.
 * @returns {undefined}
 */
TaggingHandler.prototype.taggingCallback = function(xhtml) { // eslint-disable-line complexity
    var self = this;
    var rti18n = i18n.discernabu.mpageResultTagging;
    var menu = MP_MenuManager.getMenuObject("resultTagging");
    var taggedContents = "";

    // Tagging selector info
    var categoryClass = ".ddcategory";
    var individualResultSelector = ".ddemrcontentitem";
    var deleteIconSelector = ".tagging-delete";

    // Add the click event to the remove all option
    if (menu && menu.isVisible()) {
        var menuElement = $("#menuContentresultTagging");
        // Unbind the result tagging events. There is a race condition in which multiple events can be bound, causing the event to fire
        // twice.
        menuElement.unbind(".resultTagging");

        // we cannot use the menu in DDClipDragDrop if it is unavailable
        if (typeof DDClipDragDrop === "undefined") {
            var groupResultSelector = ".ddcategorytitle";
            // Create a template for the delete icon, so we can create new ones on the fly.
            var deleteTemplate = TemplateBuilder.buildTemplate("<div class=\"tagging-delete\" dd:settype=\"${setType}\" dd:contenttype=\"${contentType}\" dd:entityid=\"${entityId}\"></div>");
            // Hover over individual result
            menuElement.on("mouseenter.resultTagging", individualResultSelector, function(event) {
                var item = $(event.currentTarget);
                // Append a delete button to the element. Go ahead and give it the content type and entity id so we can do trivial operations
                // when the icon is clicked.
                item.append(deleteTemplate.render({
                    setType: "SINGLE_RESULT",
                    contentType: item.attr("dd:contenttype"),
                    entityId: item.attr("dd:entityid")
                }));
                event.stopPropagation();
            });
            // Mouse out of an individual result
            menuElement.on("mouseleave.resultTagging", individualResultSelector, function(event) {
                var item = $(event.currentTarget);
                item.find(deleteIconSelector).remove();
                event.stopPropagation();
            });
            // Mouse over a grouping of results
            menuElement.on("mouseenter.resultTagging", groupResultSelector, function(event) {
                var item = $(event.currentTarget);
                // Append a delete icon to the category header, allowing us to delete the group of results
                item.append(deleteTemplate.render({ setType: "RESULT_GROUP", contentType: "", entityId: "" }));
                event.stopPropagation();
            });
            // Mouse leave a grouping of results
            menuElement.on("mouseleave.resultTagging", groupResultSelector, function(event) {
                $(event.currentTarget).find(deleteIconSelector).remove();
                event.stopPropagation();
            });
        }

        // Click on a delete icon
        menuElement.on("click.resultTagging", deleteIconSelector, function(event) {
            var item = $(event.currentTarget);
            var type = item.attr("dd:settype");
            var deleteList = { "DELETE_TAG": { "TAG_LIST": [] } };
            // If this is a single result, we only push the one item into the array to be removed.
            if (type === "SINGLE_RESULT") {
                // Push the tagged info into a JSON object
                deleteList.DELETE_TAG.TAG_LIST.push({
                    "contentType": item.attr("dd:contenttype"),
                    "entityId": item.attr("dd:entityid") + ".0"
                });
            }
            else if (type === "RESULT_GROUP") {
                // Must find all ddemrcontentitems that belong to this grouping and push their tagging information
                // into the array to be deleted
                item.parents(categoryClass).find(individualResultSelector).each(function(index, element) {
                    element = $(element);
                    deleteList.DELETE_TAG.TAG_LIST.push({
                        "contentType": element.attr("dd:contenttype"),
                        "entityId": element.attr("dd:entityid") + ".0"
                    });
                });
            }
            // Make the call to delete the tagged results
            self.deleteTaggedResults(deleteList);
            var categoryElement = item.parents(categoryClass).find(individualResultSelector).not('.ddemrcontentitem.removed');
            var currentTag = $(event.currentTarget).closest('.ddcategory,.ddemrcontentitem');
            //If this is last tag in this category. remove parent 
            if(categoryElement && categoryElement.length === 1) {
                item.parents(categoryClass).remove();
            } else {
                //else just remove this tag 
                currentTag.remove();
            }
            event.stopPropagation();
        });

        var menuContent = $("#" + menu.getContentElementId() + " .utilities-menu-custom-content");
        // Show and create the click action for the Remove All link
        $("#menuContentresultTagging").find("#taggingRemoveAll").css("display", "inline").click(function() {
            // Show the confirm dialog and add the click event
            var removeDialog = menuContent.find(".tagging-remove-dialog");
            removeDialog.css("display", "block");
            removeDialog.find("#taggingRemoveAllCancel").click(function() {
                removeDialog.css("display", "none");
            });
            removeDialog.find("#taggingRemoveAllRemove").click(function() {
                var deleteList = { "DELETE_TAG": { "TAG_LIST": [] } };
                // Grab all of the results
                menuContent.find(".ddemrcontentitem").each(function(index, element) {
                    element = $(element);
                    // Push the tag information to be deleted into a JSON structure to be sent off to mp_delete_tagged_results
                    deleteList.DELETE_TAG.TAG_LIST.push({
                        "contentType": element.attr("dd:contenttype"),
                        "entityId": element.attr("dd:entityid") + ".0"
                    });
                });
                // Perform the call to remove the tags
                self.deleteTaggedResults(deleteList);
                // Close the dialog
                MP_MenuManager.closeMenuStack();
            });
        });
    }
    // Save tagged result only returns the newly created tag id so we should try to update the HTML
    if (xhtml) {
        taggedContents += "<div class='tagging-remove-dialog'><div><span class='tagging-remove-warn'>&nbsp;</span><span>" + rti18n.REMOVE_ALL_TAGS + "</span></div><div><input id='taggingRemoveAllCancel' class='tagging-remove-button' type='button' value='" + i18n.CANCEL + "' /><input id='taggingRemoveAllRemove' class='tagging-remove-button' type='button' value='" + rti18n.REMOVE + "' /></div></div>";
        taggedContents += xhtml;
    }
    else {
        taggedContents = "<p class='tagging-no-tags'>" + i18n.discernabu.mpageResultTagging.NO_TAGGED_ITEMS_FOUND + "</p>";
    }

    // Extract the updated HTML from the reply and save it for the next time the user opens the utility
    this.setTaggedResultsContent(taggedContents);


    // Check to see if the menu is open and update the contents if it is
    if (menu && menu.isVisible()) {
        $("#" + menu.getContentElementId() + " .utilities-menu-custom-content").html(taggedContents);

        //  fire event when content is loaded
        CERN_EventListener.fireEvent(null, document.body, "tagMenuLoaded", { draggingAvailable: this.m_draggingAvailable });
    }
};

var MP_TaggingHandler = new TaggingHandler(); // eslint-disable-line no-redeclare, no-unused-vars
/**
 * The TaggedResult class is used as a base class for all types of tagged results.  For each type of result that can be tagged
 * a new implementation of the TaggedResult needs to be created and the EMR Type and Categorization XML set for that particular
 * implementation.
 * @constructor
 */
var TaggedResult = function() {
    // The EMR Type Code correlates to the CDF_MEANING for a value in code set 32000 and should not be modified
    this.m_emrType = "";
    //  This is the id used to look up the tagged item in the table associated with the EMR Type Code
    this.m_tagEntityId = 0.0;
    // This is the date and time when the result was last updated
    this.m_tagDateTime = "";
    // The categorization array will be used to dynamically create the categorization XML.
    // This categorization XML is used by the Dynamic Documentation team to categorize tagged results
    this.m_categorizationArray = null;
    // The categorization XML created from the categorizationArray
    this.m_categorizationXML = "";
};

/* Getters */

/**
 * Retrieves the categorization array used to create the categorization xml markup for this TaggedResult.
 * @returns {string} The categorization XML associated with a specific type of TaggedResult
 */
TaggedResult.prototype.getCategorizationArray = function() {
    if (!this.m_categorizationArray) {
        this.m_categorizationArray = [];
    }
    return this.m_categorizationArray;
};

/**
 * Retrieves the categorization xml markup for this TaggedResult.  The categorization XML is created when the caegorizationArray is
 * set.
 * @returns {string} The categorization XML associated with a specific type of TaggedResult
 */
TaggedResult.prototype.getCategorizationXML = function() {
    return this.m_categorizationXML;
};

/**
 * Retrieves the EMR Type set for this TaggedResult.  This will typically be set by the object inheriting from the TaggedResult
 * base class.
 * @returns {string} The EMR Type that is associated with this TaggedResult
 */
TaggedResult.prototype.getEMRType = function() {
    return this.m_emrType;
};

/**
 * Retrieves the last updated date and time associated with the TaggedResult.  The date and time will be in iso8601 format (YYYY-MM-DDTHH:MM:SSZ)
 * @returns {string} The iso8601 representation of the last updated date and time set for the tagger result.
 */
TaggedResult.prototype.getTagDateTime = function() {
    return this.m_tagDateTime;
};

/**
 * Retrieves the tagged results's entity id.  This entity id differs based on the type of result being tagged.  For instance if tagging a Clinical Event this
 * entity id would hold the Event Id of that Clinical Event.
 * @returns {number} The entity id associated with this TaggedResult
 */
TaggedResult.prototype.getTagEntityId = function() {
    return this.m_tagEntityId;
};

/* Setters */

/**
 * Sets the categorization array for this TaggedResult.  This array is used to create the cateogrization xml for this
 * particular tagged result.
 * @param {[string]} categorizationArray An array of strings which represents categories and sub categories.  For each element past the first,
 * a new sub category will be created.
 * @returns {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedResult.prototype.setCategorizationArray = function(categorizationArray) {
    if (categorizationArray && categorizationArray.length) {
        // Store the array as a separate reference
        this.m_categorizationArray = categorizationArray.slice(0);

        // Examine the contents and create the categorizationXML
        var catLength = categorizationArray.length;
        var lastIndex = catLength - 1;
        var catInject = "{0}";
        for (var x = 0; x < catLength; x++) {
            if (x < lastIndex) {
                catInject = catInject.replace("{0}", "<category display='" + categorizationArray[ x ] + "'>{0}</category>");
            }
            else {
                catInject = catInject.replace("{0}", "<category display='" + categorizationArray[ x ] + "' />");
            }
        }
        this.m_categorizationXML = "<?xml version='1.0' encoding='UTF-8'?><category-data xmlns:xsi='http:// www.w3.org/2001/XMLSchema-instance' xsi:noNamespaceSchemaLocation='categorization.xsd'>" + catInject + "</category-data>";
    }
    return this;
};


/**
 * Sets the EMR Type for this TaggedResult.  The EMR Type is used to indicate which table the TaggedResult's information can be found on.  This fields is typically
 * set by the object inheriting from the TaggedResult and shouldn't be manually set by developers.  This field correlates to a CDF_MEANING of a event code in event
 * set 32000.
 * @param {string} emrType The CDF_MEANING of the EMR Type that is associated with object inheriting from TaggedResult
 * @returns {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedResult.prototype.setEMRType = function(emrType) {
    if (typeof emrType === "string") {
        this.m_emrType = emrType;
    }
    return this;
};

/**
 * Sets the date and time for the result being tagged.  This Date should be the last updated date for the result and should be in the iso8601 format sent from the back end.
 * @param {Date | string} tagDateTime If a string, just set it. If a date, then convert it to the desired format and set it.
 * @returns {TaggedResult} The TaggedResult object calling this function so chaining can be used.
 */
TaggedResult.prototype.setTagDateTime = function(tagDateTime) {
    // Just a little helper function to formate date values to add leading 0s (if necessary)
    function formatDateValue(value) {
        return value < 10 ? "0" + value : value;
    }

    if (typeof tagDateTime === "string") {
        this.m_tagDateTime = tagDateTime;
    }
    else if (Date.prototype.isPrototypeOf(tagDateTime)) {
        var currentMonth = formatDateValue(tagDateTime.getMonth() + 1);
        var currentDate = formatDateValue(tagDateTime.getDate());
        var currentHours = formatDateValue(tagDateTime.getHours());
        var currentMinutes = formatDateValue(tagDateTime.getMinutes());
        var currentSeconds = formatDateValue(tagDateTime.getSeconds());
        // Format the date to the required format.
        this.m_tagDateTime = tagDateTime.getFullYear() + "-" + currentMonth + "-" + currentDate + "T" + currentHours + ":" + currentMinutes + ":" + currentSeconds + "Z";
    }
    else {
        throw new Error("Called setTagDateTime with non string or Date type for tagDateTime parameter");
    }
    return this;
};

/**
 * Sets the entity id for this TaggedResult.  This id will be based on the type of TaggedResult being used.  For instance if tagging a Clinical Event the
 * entity id will be an Event Id.
 * @param {number} tagEntityId The entity id associated with the type of result being tagged
 * @returns {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedResult.prototype.setTagEntityId = function(tagEntityId) {
    if (typeof tagEntityId === "number") {
        this.m_tagEntityId = tagEntityId;
    }
    return this;
};

/**
 * Checks that all required fields are set. Calls errorFn with incorrect field name if a missing required field was found.
 * @param {function} errorFn Called with missing required field name if any is present
 * @returns {undefined}
 */
TaggedResult.prototype.validateRequiredFields = function(errorFn) {
    var checkField = function(field, fieldName) {
        if (!field) {
            errorFn(fieldName);
        }
    };

    checkField(this.m_emrType, "EMR type");
    checkField(this.m_tagDateTime, "date time");
    checkField(this.m_categorizationXML, "categorization XML");

    if (this.m_emrType === "LABS" || this.m_emrType === "LABS_V2" || this.m_emrType === "TAGTEXT") {
        checkField(this.m_tagEntityId, "entity id");
    }
};
/* globals TaggedResult*/

/**
 * TaggedImage is used for tagging image results. Blob handle and format meaning are required for saving.
 * @constructor
 */
function TaggedImage() {
    TaggedResult.call(this);
    this.setEMRType("IMAGES");
    this.m_blobHandle = "";
    this.m_formatCd = "";
    this.m_storageCd = "MMF";
}

TaggedImage.prototype = new TaggedResult();
TaggedImage.prototype.constructor = TaggedResult;

/**
 * Retrieves the format code meaning from code set 23 for the TaggedImage. This field is required.
 * @returns {string} The format selected by the user for this TaggedImage
 */
TaggedImage.prototype.getFormatCd = function() {
    return this.m_formatCd;
};

/**
 * Sets the format code meaning from code set 23 for the TaggedImage. This field is required.
 * @param {string} format The format code meaning selected for this tagged result
 * @returns {TaggedImage} The TaggedImage object calling this function so chaining can be used
 */
TaggedImage.prototype.setFormatCd = function(format) {
    if (typeof format === "string") {
        this.m_formatCd = format;
    }
    return this;
};

/**
 * Retrieves the blob handle for the TaggedImage. This field is required.
 * @returns {string} The blob handle selected by the user for this TaggedImage
 */
TaggedImage.prototype.getBlobHandle = function() {
    return this.m_blobHandle;
};

/**
 * Sets the blob handle for the TaggedImage. This field is required.
 * @param {string} blobHandle The blob handle selected for this tagged result
 * @returns {TaggedImage} The TaggedImage object calling this function so chaining can be used
 */
TaggedImage.prototype.setBlobHandle = function(blobHandle) {
    if (typeof blobHandle === "string") {
        this.m_blobHandle = blobHandle;
    }
    return this;
};

/**
 * Retrieves the storage code meaning from code set 25 for the TaggedImage.
 * This field is optional, if not set, MMF will be used.
 * @returns {string} The storage code meaning selected by the user for this TaggedImage
 */
TaggedImage.prototype.getStorageCd = function() {
    return this.m_storageCd;
};

/**
 * Sets the storage code meaning from code set 25 for the TaggedImage.
 * This field is optional, if not set, MMF will be used.
 * @param {string} storageCd The storage code meaning selected for this tagged result
 * @returns {TaggedImage} The TaggedImage object calling this function so chaining can be used
 */
TaggedImage.prototype.setStorageCd = function(storageCd) {
    if (typeof storageCd === "string") {
        this.m_storageCd = storageCd;
    }
    return this;
};

/**
 * Checks that all required fields are set. Calls errorFn with incorrect field name if a missing required field was found.
 * @param {function} errorFn Called with missing required field name if any is present
 * @returns {undefined}
 */
TaggedImage.prototype.validateRequiredFields = function(errorFn) {
    var checkField = function(field, fieldName) {
        if (!field) {
            errorFn(fieldName);
        }
    };

    TaggedResult.prototype.validateRequiredFields.call(this, errorFn);

    checkField(this.m_blobHandle, "blob handle");
    checkField(this.m_formatCd, "format code");
    checkField(this.m_storageCd, "storage code");
};
/* globals TaggedResult*/

/**
 * TaggedText is used for tagging and rendering tagged text. TagText and Format code meaning are required fields for
 * saving.
 * @constructor
 */
function TaggedText() {
    TaggedResult.call(this);
    this.setEMRType("TAGTEXT");

    // This is an optional parameter used when tagging text from a document
    this.m_tagText = "";
    // This is an optional parameter used when tagging text from a document. To tag larger text in document, use this field instead of tag text as this uses blob to send data to the script
    this.m_tagTextBlob = "";
    // This is a required parameter that defaults to XHTML if not set
    this.m_formatCd = "XHTML";
}

TaggedText.prototype = new TaggedResult();
TaggedText.prototype.constructor = TaggedResult;

/**
 * Retrieves the format code meaning from code set 23 for the TaggedText.
 * This field is optional, if not set, XHTML will be used.
 * @returns {string} The format selected by the user for this TaggedText
 */
TaggedText.prototype.getFormatCd = function() {
    return this.m_formatCd;
};

/**
 * Sets the format code meaning from code set 23 for the TaggedText.
 * This field is optional, if not set, XHTML will be used.
 * @param {string} format The format code meaning selected for this tagged result
 * @returns {TaggedText} The TaggedText object calling this function so chaining can be used
 */
TaggedText.prototype.setFormatCd = function(format) {
    if (typeof format === "string") {
        this.m_formatCd = format;
    }
    return this;
};

/**
 * Retrieves the text that has been selected by the user for this TaggedResult.  This field is optional and only applies in certain scenarios.
 * @returns {string} The text selected by the user for this TaggedResult
 */
TaggedText.prototype.getTagText = function() {
    return this.m_tagText;
};

/**
 * @deprecated
 * This method has been deprecated. Use setTagTextBlob instead.
 * Sets the text to be used for the TaggedResult.  This field is optional and is only used in certain types of tags
 * @param {string} tagText The text selected for this tagged result
 * @returns {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedText.prototype.setTagText = function(tagText) {
    if (typeof tagText === "string") {
        this.m_tagText = tagText;
    }
    return this;
};

/**
 * Retrieves the text that has been selected by the user for this TaggedResult.
 * TagTextBlob will take precendence over TagText(deprecated in the service) and if tagTextBlob exists tagText will be ignored.
 * @returns {string} The text selected by the user for this TaggedResult.
 */
TaggedText.prototype.getTagTextBlob = function() {
    return this.m_tagTextBlob;
};

/**
 * Sets the text to be used for the TaggedResult. This field is optional and takes precendence over this.m_tagText.
 * This is recommended since tag text is being deprecated and going forward it is ideal to switch to tag text blob.
 * @param {string} tagTextBlob The text selected for this tagged result
 * @returns {TaggedResult} The TaggedResult object calling this function so chaining can be used
 */
TaggedText.prototype.setTagTextBlob = function(tagTextBlob) {
    if(typeof tagTextBlob === "string") {
        this.m_tagTextBlob = tagTextBlob;
    }
    return this;
};

/**
 * Checks that all required fields are set. Calls errorFn with incorrect field name if a missing required field was found.
 * @param {function} errorFn Called with missing required field name if any is present
 * @returns {undefined}
 */
TaggedText.prototype.validateRequiredFields = function(errorFn) {
    var checkField = function(field, fieldName) {
        if (!field) {
            errorFn(fieldName);
        }
    };

    TaggedResult.prototype.validateRequiredFields.call(this, errorFn);

    checkField(this.m_tagText, "tag text");
    checkField(this.m_formatCd, "format code");
};
/* global DDCOMMON, SERVICE_TASK */

/**
 * Tagging data access implementation relying on CCL, save for text drag which goes through a CKEDITOR data access layer
 * @constructor
 */
function TaggingDao() {
}

/**
 * Performs a CCL script call to MP_QUERY_TAGGED_RESULTS which returns the HTMl markup for all of the currently tagged results.
 * @param {number} userId user ID to tag result
 * @param {number} patientId patient ID tagged
 * @param {number} encounterId encounter ID tagged
 * @param {number} pprCode PPR tagged
 * @returns {Promise<object|Error>} status and tag list, with entityId, contentType, tagTextEntityId, and blobHandle (images only)
 */
TaggingDao.prototype.queryTaggedResults = function(userId, patientId, encounterId, pprCode) { //  eslint-disable-line complexity
    var handleQueryTaggedResults = function(reply) { //  eslint-disable-line complexity

        var response = reply.getResponse();
        var status = reply.getStatus();

        var tags = [];
        if (response && response.XHTML_TEXT) {
            var $html = $(response.XHTML_TEXT);
            tags = $.map($html.find(".ddemrcontentitem"), function(val) {
                return {
                    entityId: parseInt($(val).attr("dd:entityid"), 10),
                    contentType: $(val).attr("dd:contenttype"),
                    tagTextEntityId: parseInt($(val).attr("dd:tagtextentityid"), 10),
                    blobHandle: $(val).attr("dd:blobhandle")
                };
            });
        }

        var replyObject = {
            status: status,
            xhtml: response.XHTML_TEXT,
            dragVersion: response.DRAG_SUPPORT_VERSION,
            tags: tags
        };
        if (response.CONTENT_TYPES) {

            try {
                var contentTypes = JSON.parse(response.CONTENT_TYPES);
                if (contentTypes.contentImported && contentTypes.contentImported instanceof Array) {
                    replyObject.contentTypes = contentTypes.contentImported;
                }
            }
            catch (error) {
                MP_Util.LogJSError(error, null, "TaggingDao.js", "handleQueryTaggedResults"); //  eslint-disable-line new-cap
            }
        }
        return replyObject;
    };

    if (!userId) {
        throw new Error("Cannot retrieve tagged results without the User Id populated");
    }
    if (!patientId) {
        throw new Error("Cannot retrieve tagged results without the patient id populated");
    }
    if (!encounterId) {
        throw new Error("Cannot retrieve tagged results without the Encounter Id populated");
    }
    if (!pprCode) {
        throw new Error("Cannot retrieve tagged results without the PPR Code populated");
    }

    // Create the param array to send to the CCL Script
    var params = [ "^MINE^", userId + ".0", patientId + ".0", encounterId + ".0", pprCode + ".0" ];
    var tagRequest = new MP_Core.ScriptRequest();

    tagRequest.setArtifactInfo({
        artifactId: "mpage-result-tagging",
        functionName: "queryTaggedResults"
    });

    tagRequest.setName("queryTaggedResult");
    tagRequest.setProgramName("MP_QUERY_TAGGED_RESULTS");
    tagRequest.setParameters(params);

    return new Promise(function(resolve, reject) {
        MP_Core.XMLCCLRequestCallBack(null, tagRequest, function(reply) { // eslint-disable-line new-cap
            var replyObj = handleQueryTaggedResults(reply);
            if (replyObj.status !== "F") {
                resolve(replyObj);
            }
            else {
                reject(Error("QueryTaggedResults failed"));
            }
        });
    });
};

/**
 * Attempts to save tagged results via the MP_SAVE_TAGGED_RESULTS ccl script. It expects a list of TaggedResult objects. For each of the
 * provided TaggedResult objects, the necessary fields are validated. If they are not provided, an exception is thrown.
 * @param {number} userId user ID to tag result
 * @param {number} encounterId encounter ID tagged
 * @param {Array<TaggedResult>} taggedResults A list of TaggedResult objects to be saved.
 * @returns {Promise<object|Error>} status and tag list, with entityId, contentType, and blobHandle (images only)
 */
TaggingDao.prototype.saveTaggedResults = function(userId, encounterId, taggedResults) {
    var self = this;
    return new Promise(function(resolve, reject) { // eslint-disable-line complexity
        var handleSaveTaggedResults = function(reply, inputTags) {
            var response = reply.getResponse();
            var status = reply.getStatus();

            var tags = [];
            if (status === "S" && response.TAGGED_ITEMS) {

                tags = $.map(inputTags, function(tag, i) {
                    var tagObj = {
                        contentType: tag.getEMRType(),
                        entityId: response.TAGGED_ITEMS[ i ].TAG_ENTITY_ID
                    };
                    if (tag.getEMRType() === "IMAGES") {
                        tagObj.blobHandle = tag.getBlobHandle();
                    }
                    return tagObj;
                });
            }

            return {
                tags: tags,
                status: status
            };
        };

        if (!Array.prototype.isPrototypeOf(taggedResults)) {
            reject(new Error("Called saveTaggedResults on TaggingHandler with non Array type for taggedResults parameter"));
            return; // to return the control immediately.
        }
        // If there are no items to tag, just return
        if (!taggedResults.length) {
            resolve({ status: "S", tags: [] });
            return;
        }
        if (!userId) {
            reject(new Error("Cannot tag a result without the User Id populated"));
            return;
        }
        // Verify the Encounter Id is populated
        if (!encounterId) {
            reject(new Error("Cannot tag a result without the Encounter Id populated"));
            return;
        }
        //  //Define the record structure required by mp_save_tagged_results
        var saveTagJSON = {
            "SAVE_TAGS": {
                "TAG_LIST": []
            }
        };
        // Grab a reference to the list that we're storing the tags in
        self.pushTaggedResult(saveTagJSON.SAVE_TAGS.TAG_LIST, taggedResults, true);
        // If we have tags to delete, perform the request. Must use tilde to prevent browser development from breaking.
        var params = [ "^MINE^", userId + ".0", encounterId + ".0", CERN_Platform.encoding.encodeAndConvertStringToLengthFormat(JSON.stringify(saveTagJSON)) ];
        var saveTagsRequest = new ScriptRequest();

        //  If taggedResults exists and if the tagTextBlob function exists in the TaggedResult then set the Data blob with the tagged
        if (taggedResults.length > 0 && typeof taggedResults[0].getTagTextBlob === "function" && taggedResults[0].getTagTextBlob() !== "") {
            saveTagsRequest.setDataBlob(taggedResults[0].getTagTextBlob());
        }
        saveTagsRequest
            .setArtifactInfo({
                artifactId: "mpage-result-tagging",
                functionName: "saveTaggedResults"
            })
            .setName("saveTaggedResult")
            .setProgramName("MP_SAVE_TAGGED_RESULTS")
            .setParameterArray(params)
            .setResponseHandler(function(scriptReply){
                var replyObj = handleSaveTaggedResults(scriptReply, taggedResults);
                if (replyObj.status !== "F") {
                    resolve(replyObj);
                }
                else {
                    reject(Error("saveTaggedResults failed"));
                }
            })
            .performRequest();
    });
};

/**
 Performs a call to the CCL script MP_DELETE_TAGGED_RESULTS with the ids of all of the tagged results to delete.  The MP_DELETE_TAGGED_RESULTS script
 * calls the same service as MP_QUERY_TAGGED_RESULTS and returns the contents in order to keep the contents in the Tagged Results utilities menu updated.
 * @param {number} userId user ID to tag result
 * @param {number} patientId patient ID tagged
 * @param {number} encounterId encounter ID tagged
 * @param {number} pprCode PPR tagged
 * @param {[number]} deleteList A JSON list of tagged entities to be removed. The format MUST be as follows: [{"contentType":"EMR_MEANING", "entityId" : "ENTITY_ID},{},...,{}]
 * where EMR_MEANING is the emr meaning that will be looked up in codeset 32000 and ENTITY_ID is the tagged entity id.
 * @returns {Promise<object|Error>} status and xhtml result representing the new contents of the clipboard
 */
TaggingDao.prototype.deleteTaggedResults = function(userId, patientId, encounterId, pprCode, deleteList) { // eslint-disable-line complexity
    var handleDeleteTaggedResults = function(reply) {
        var response = reply.getResponse();
        var status = reply.getStatus();

        return {
            status: status,
            xhtml: response.XHTML_TEXT
        };
    };

    if (!userId) {
        throw new Error("Cannot delete a tag result without the User Id populated");
    }
    if (!patientId) {
        throw new Error("Cannot retrieve tagged results without the patient id populated");
    }
    if (!encounterId) {
        throw new Error("Cannot delete a tag result without the Encounter Id populated");
    }
    if (!pprCode) {
        throw new Error("Cannot delete a tagged result without the user PPR code populated");
    }

    // If we have tags to delete, perform the request. Must use tilde to prevent browser development from breaking.
    var params = [ "^MINE^", userId + ".0", patientId + ".0", encounterId + ".0", pprCode + ".0", "~" + JSON.stringify(deleteList) + "~" ];
    var deleteTagsRequest = new MP_Core.ScriptRequest();

    deleteTagsRequest.setArtifactInfo({
        artifactId: "mpage-result-tagging",
        functionName: "deleteTaggedResults"
    });

    deleteTagsRequest.setName("removeTaggedResult");
    deleteTagsRequest.setProgramName("MP_DELETE_TAGGED_RESULTS");
    deleteTagsRequest.setParameters(params);
    return new Promise(function(resolve, reject) {
        MP_Core.XMLCCLRequestCallBack(null, deleteTagsRequest, function(scriptReply) { // eslint-disable-line new-cap
            var replyObj = handleDeleteTaggedResults(scriptReply);
            if (replyObj.status !== "F") {
                resolve(replyObj);
            }
            else {
                reject(Error("deleteTaggedResults failed"));
            }
        });
    });
};

/**
 * Append tagging request objects to a list for calling save tag or generate dragging text services.
 * @param {Array} saveTagList List to push tag request objects to
 * @param {Array<TaggedResult>} taggedResults Tagging result objects to queue for request
 * @returns {undefined}
 */
TaggingDao.prototype.pushTaggedResult = function(saveTagList, taggedResults, legacy) { // eslint-disable-line complexity

    // Helper function to check the necessary tag fields
    function checkTagField(errorMessage, fieldName) {
        throw new Error(errorMessage + " - " + fieldName);
    }

    // Loop through the tag items and add create their corresponding JSON object
    var foundTextTag = false;
    for (var i = 0; i < taggedResults.length; i++) {
        var tag = taggedResults[ i ];

        //  Verify all required fields for the current tag
        tag.validateRequiredFields(function(fieldName) { // eslint-disable-line no-loop-func
            checkTagField("Cannot tag a result without required field", fieldName);
        });

        //  Retrieve fields for particular tag types
        var taggedText = "";

        // Push an individual JSON(ified) version of the tagging object into the list to be saved
        var tagObj = {
            EMR_TYPE: tag.getEMRType(), //  MPages CCL requires the field set as this name
            EMR_TYPE_CD: tag.getEMRType(),
            TAG_ENTITY_ID: tag.getTagEntityId() + ".0",
            TAG_DT_TM: tag.getTagDateTime(),
            CATEGORIZATION_XML: tag.getCategorizationXML(),
            FORMAT_CD: "", //  The save tag script requires the following keys to be present even if unused
            STORAGE_CD: "",
            BLOB_HANDLE: "",
            TAG_TEXT: "",
            TEXT_ENCODING: "UTF-8"
        };

        if (tag.getEMRType() === "TAGTEXT") {
            tagObj.FORMAT_CD = tag.getFormatCd();
            taggedText = tag.getTagText();
            //  when legacy is true, the tagtext is added on the blob before calling the script.
            if (legacy) {
                if (!foundTextTag) {
                  foundTextTag = true;
                } else {
                  throw new Error("Saving multiple text tags is not supported");
                }
            }
            else {
                tagObj.TAG_TEXT_BLOB = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><html><body>" + taggedText + "</body></html>";
                tagObj.TEXT_ENCODING = "UTF-8";
            }
        }
        else if (tag.getEMRType() === "IMAGES") {
            tagObj.BLOB_HANDLE = tag.getBlobHandle();
            tagObj.FORMAT_CD = tag.getFormatCd();
            tagObj.STORAGE_CD = tag.getStorageCd();
        }

        saveTagList.push(tagObj);
    }
};
/**
 * Performs a call to request 969595 - GenerateDragText. The service will return a list of EMR content and footnotes if the tags passed are TAGTEXT.
 * @param {number} userId user ID to tag result
 * @param {number} patientId patient ID tagged
 * @param {number} encounterId encounter ID tagged
 * @param {number} pprCd PPR tagged
 * @param {number} userTz timezone to use for tag result
 * @param {Array<TaggedResult>} taggedResults A list of TaggedResult objects to be converted to text/annotations
 * @returns {Promise<String>} resulting xhtml for drag rendering call
 */
TaggingDao.prototype.retrieveDragResults = function(userId, patientId, encounterId, pprCd, userTz, taggedResults) {
    // Grab a reference to the list that we're storing the tags in
    var saveTagListJSON = [];
    this.pushTaggedResult(saveTagListJSON, taggedResults);

    var DocUtilsHelper = CERN_Platform.getWrappedDiscernObject("DOCUTILSHELPER");
    DocUtilsHelper.isAvailable().then(function(helperIsAvailable) {
        if (helperIsAvailable) {
            var req = DDCOMMON.valueifyObject({
                user_id: userId,
                patient_id: patientId,
                encntr_id: encounterId,
                ppr_cd: pprCd,
                user_tz: userTz,
                tags: saveTagListJSON
            });
            var requestOptions = {
                tags: {
                    tag_text_blob: {
                        charset: "en_US.UTF-8",
                        content_type: "text/plain"
                    },
                    format_cd: {
                        content_type: "text/cdf-meaning",
                        codeset: 23
                    },
                    storage_cd: {
                        content_type: "text/cdf-meaning",
                        codeset: 25
                    },
                    emr_type_cd: {
                        content_type: "text/cdf-meaning",
                        codeset: 32000
                    }
                }
            };
            var replyOptions = {
                tags: {
                    xhtml_text: {
                        charset: "en_US.UTF-8",
                        content_type: "text/plain"
                    },
                    xhtml_annotation: {
                        charset: "en_US.UTF-8",
                        content_type: "text/plain"
                    }
                }
            };
            DocUtilsHelper.supports("CallCRMAsync").then(function(crmAsyncSupported) {
                if (crmAsyncSupported) {
                    return new Promise(function(resolve, reject) {
                        DocUtilsHelper.invoke("CallCRMAsync", [SERVICE_TASK, 969595, JSON.stringify(req), { // eslint-disable-line new-cap
                            requestOptions: JSON.stringify(requestOptions),
                            replyOptions: JSON.stringify(replyOptions),
                            complete: function(reply) {
                                reply = JSON.parse(reply);

                                if (DDCOMMON.isStepSuccessful(reply)) {
                                    var tag = reply.tags[0];
                                    var $xhtmlText = $("<div>").html(tag.xhtml_text);
                                    var $xhtmlAnnotation = $("<div>").html(tag.xhtml_annotation);
                                    var $formattedText = $xhtmlText.find(".ddformattedtext");
                                    $formattedText.attr("dd:footnotetext", $xhtmlAnnotation.find(".ddtagged")[0].outerHTML);
                                    resolve($formattedText[0].outerHTML);
                                } else {
                                    reject(Error("Unable to retrieve note data"));
                                }
                            },
                            callError: function() {
                                reject(Error("Unable to call step; check task access"));
                            }
                        }]);
                    });
                }
            }).catch(function(error) {
                MP_Util.LogJSError(error, null, "TaggingDao.js", "retrieveDragResults"); //  eslint-disable-line new-cap
            });
        }
    }).catch(function(error) {
        MP_Util.LogJSError(error, null, "TaggingDao.js", "retrieveDragResults"); //  eslint-disable-line new-cap
    });
};
/**
 * Obtains application name from executable name supplied through CERN_Platform object
 * @returns {string} Application name
 */
function getApplicationName() {
    try {
        return window.CERN_Platform.getCriterion().CRITERION.EXECUTABLE.replace(/\.[^/.]+$/, "");
    } catch (error) {
        return "";
    }
}

/**
 * Tagging data access implementation relying on OrionTagging API, save for text drag which goes through a CKEDITOR data access layer
 * @constructor
 */
function OrionTaggingDao() {
    var params = {
        applicationName: getApplicationName(),
        auth: window.MillenniumOAuthUtil.authenticate,
        baseUrl: window.WORKFLOW_BASE_URL
    };

    this.tagging = new window.OrionWebTagging(params);
}

/**
 * Performs a replacement of HTTP status code with CCL status
 * @param {request} request promise
 * @returns {Promise<object|Error>} response with the converted status wrapped in Promise
 */
OrionTaggingDao.prototype.parseResponseToConvertHTTPStatus = function(request) {
    /**
     * The identifier of the response status
     */
    var RESPONSE_STATUS = Object.freeze({
        Z: "Z",
        S: "S",
        F: "F"
    });

    /**
     * Converts HTTP response status to CCL response status.
     * Converts statuses by the following rules:
     204 -> Z
     200-299 -> S (except 204)
     anything else -> F
     *
     * @param {number} status - HTTP response status
     * @returns {string} - CCL response status. Can be one of: "Z", "S" or "F"
     */
    var convertResponseStatus = function(status) {
        if (status === 204) {
            return RESPONSE_STATUS.Z;
        }

        if (status >= 200 && status <= 299) {
            return RESPONSE_STATUS.S;
        }

        return RESPONSE_STATUS.F;
    };

    /**
     * Handles status convert in the response
     *
     * @param {Promise<object|Error>} requestInner - Request promise
     * @returns {object|Error} - Response with the converted status
     */
    var handleResponseConverting = function(requestInner) {
        return requestInner
            .then(function(response) {
                response.status = convertResponseStatus(response.status);
                return response;
            })
            .catch(function(error) {
                throw error;
            });
    };

    return new Promise(function(resolve, reject) {
        try {
            resolve(handleResponseConverting(request));
        } catch (error) {
            reject(Error("Unable to perform response status converting"));
        }
    });
};

/**
 * Performs a call to OrionTagging API which returns the HTMl markup for all of the currently tagged results.
 * @param {number} userId user ID to tag result
 * @param {number} patientId patient ID tagged
 * @param {number} encounterId encounter ID tagged
 * @param {number} pprCode PPR tagged
 * @returns {Promise<object|Error>} status and tag list, with entityId, contentType, tagTextEntityId, and blobHandle (images only)
 */
OrionTaggingDao.prototype.queryTaggedResults = function(userId, patientId, encounterId, pprCode) { // eslint-disable-line no-unused-vars
    return this.parseResponseToConvertHTTPStatus(this.tagging.retrieveClipboard(encounterId, patientId));
};

/**
 * Attempts to save tagged results via the OrionTagging API. It expects a list of TaggedResult objects. For each of the
 * provided TaggedResult objects, the necessary fields are validated. If they are not provided, an exception is thrown.
 * @param {number} userId user ID to tag result
 * @param {number} encounterId encounter ID tagged
 * @param {Array<TaggedResult>} taggedResults A list of TaggedResult objects to be saved.
 * @returns {Promise<object|Error>} status and tag list, with entityId, contentType, and blobHandle (images only)
 */
OrionTaggingDao.prototype.saveTaggedResults = function(userId, encounterId, taggedResults) { // eslint-disable-line no-unused-vars
    return this.parseResponseToConvertHTTPStatus(this.tagging.saveTaggedResults(encounterId, taggedResults));
};

/**
 * Performs a call to the OrionTagging API with the ids of all of the tagged results to delete.
 * @param {number} userId user ID to tag result
 * @param {number} patientId patient ID tagged
 * @param {number} encounterId encounter ID tagged
 * @param {number} pprCode PPR tagged
 * @param {[number]} deleteList A JSON list of tagged entities to be removed. The format MUST be as follows: [{"contentType":"EMR_MEANING", "entityId" : "ENTITY_ID},{},...,{}]
 * where EMR_MEANING is the emr meaning that will be looked up in codeset 32000 and ENTITY_ID is the tagged entity id.
 * @returns {Promise<object|Error>} status and xhtml result representing the new contents of the clipboard
 */
OrionTaggingDao.prototype.deleteTaggedResults = function(userId, patientId, encounterId, pprCode, deleteList) { // eslint-disable-line no-unused-vars
    return this.parseResponseToConvertHTTPStatus(this.tagging.removeTaggedResults(encounterId, patientId, deleteList));
};

/**
 * Performs a call to OrionTagging API. The service will return a list of EMR content and footnotes if the tags passed are TAGTEXT.
 * @param {number} userId user ID to tag result
 * @param {number} patientId patient ID tagged
 * @param {number} encounterId encounter ID tagged
 * @param {number} pprCd PPR tagged
 * @param {number} userTz timezone to use for tag result
 * @param {Array<TaggedResult>} taggedResults A list of TaggedResult objects to be converted to text/annotations
 * @returns {Promise<String>} resulting xhtml for drag rendering call
 */
OrionTaggingDao.prototype.retrieveDragResults = function(userId, patientId, encounterId, pprCd, userTz, taggedResults) { // eslint-disable-line no-unused-vars
    return this.tagging.retrieveTaggedContent(encounterId, patientId, taggedResults);
};

/**
 * The TextControl class. This API allows simple creation of input controls and handles all necessary interactions
 * such as required state, invalid state, etc.
 * @constructor
 */
function TextControl() {
	this.m_currentValue = "";
	this.m_delegateId = "";
	this.m_disabled = false;
	this.m_extensions = null;
	this.m_id = "";
	this.m_label = "";
	this.m_labelPosition = TextControl.label_position.TOP;
	this.m_placeholderText = "";
	this.m_requiredInd = false;
	this.m_strictWhitespace = false;
	this.m_valid = true;
	this.m_validator = null;

	//Element cache
	this.m_$extensionElement = null;
	this.m_$inputElement = null;
	this.m_$inputGroupElement = null;
	this.m_$stageElement = null;
	this.m_$validationElement = null;

	//Dimensions
	this.m_width = null;
	this.m_predefinedWidth = TextControl.width.MEDIUM;
	this.m_labelWidth = null;

	//Callbacks
	this.m_onChangeCallback = null;
	this.m_onValidChangeCallback = null;
}

/**
 * A registry for keeping track of global information related to TextControl objects.
 * @type {{m_controlMapping: {}, m_delegateMapping: {}}}
 */
TextControl.Registry = {
	"m_controlMapping" : {},
	"m_delegateMapping" : {}
};

/**
 * Registers a TextControl object into the control mapping. The control mapping is a mapping of TextControl ids to the
 * instance of the same object.
 * @param {TextControl} control - The TextControl being registered to the system.
 */
TextControl.Registry.registerControl = function(control){
	if(TextControl.Registry.m_controlMapping[control.getId()]) {
		logger.logWarning("TextControl.Registry.registerControl: attempting to register control with non-unique id " + control.getId());
	}
	TextControl.Registry.m_controlMapping[control.getId()] = control;
};

/**
 * Retrieves a TextControl instance from the registry that matches the specified id.
 * @param {String} id - The id of the TextControl being retrieved.
 * @returns {TextControl|null} The TextControl registered with the specified id, or null if no TextControl object
 * was found.
 */
TextControl.Registry.getControlById = function(id) {
	return TextControl.Registry.m_controlMapping[id] || null;
};

/**
 * An enumeration for the label position of a TextControl.
 * @type {{LEFT: number, TOP: number}}
 */
TextControl.label_position = {
	"LEFT" : 0,
	"TOP" : 1
};

/**
 * An enumeration for predefined text control widths.
 * @type {{SMALL: string, MEDIUM: string, LARGE: string, SUPER: string, FILL: string}}
 */
TextControl.width = {
	"SMALL": "te-small",
	"MEDIUM": "te-medium",
	"LARGE" : "te-large",
	"SUPER" : "te-super",
	"FILL" : "te-fill"
};

/**
 * Retrieves the current value of the TextControl. This is the value currently in the input element.
 * @returns {string} The current value of the TextControl.
 */
TextControl.prototype.getCurrentValue = function() {
	return this.m_currentValue;
};

/**
 * Sets the current value that is in the input element.
 * @param {String} value - The value currently in the input element.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setCurrentValue = function(value) {
	if(typeof value !== "string") {
		throw new Error("TextControl.prototype.setCurrentValue expects a string.");
	}
	//If the element has been rendered, update the value.
	this.getInputElement().val(value);
	this.m_currentValue = value;
	//Update the state since the value has changed
	this.updateState();
	return this;
};

/**
 * Sets the delegate id for the TextControl. The delegate id is the id of the element to which the event
 * delegates will be attached.
 * @param {String} delegateId - The id of the element to which the event delegates will be attached.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setDelegateId = function(delegateId) {
	if(typeof delegateId !== "string") {
		throw new Error("TextControl.prototype.setDelegateId expects a string");
	}
	this.m_delegateId = delegateId;
	return this;
};

/**
 * Retrieves whether the TextControl object is disabled or not.
 * @returns {boolean} Whether the TextControl is disabled or not.
 */
TextControl.prototype.isDisabled = function() {
	return this.m_disabled;
};

/**
 * Sets the disabled state of the TextControl. True is disabled, false is not disabled (or enabled).
 * @param {Boolean} disabled - The disabled state of the TextControl.
 */
TextControl.prototype.setDisabled = function(disabled) {
	if(typeof disabled !== "boolean") {
		throw new Error("TextControl.prototype.setDisabled expects a boolean.");
	}
	this.m_disabled = disabled;
	//If the control has been rendered, go ahead and update the disabled state.
	this.getInputElement().prop("disabled", disabled);
	return this;
};

/**
 * Retrieves the list of TextControlExtension associated with this TextControl. This defaults to an empty array.
 * @returns {Array<TextControlExtension>} The list of TextControlExtension objects.
 */
TextControl.prototype.getExtensions = function() {
	if(!this.m_extensions) {
		this.m_extensions = [];
	}
	return this.m_extensions;
};

/**
 * Adds a TextControlExtension to the TextControl.
 * @param {TextControlExtension} extension - The TextControlExtension to be added.
 */
TextControl.prototype.addExtension = function(extension) {
	if(!TextControlExtension.prototype.isPrototypeOf(extension)) {
		throw new Error("TextControl.prototype.addExtension expects a TextControlExtension object");
	}
	extension.setOwnerControl(this);
	this.getExtensions().push(extension);
	return this;
};

/**
 * Retrieves the unique id for the TextControl.
 * @returns {string} The unique id for the TextControl.
 */
TextControl.prototype.getId = function() {
	return this.m_id;
};

/**
 * Sets the unique id for the TextControl.
 * @param {String} id - The unique id for the TextControl.
 */
TextControl.prototype.setId = function(id) {
	if(typeof id !== "string") {
		throw new Error("TextControl.prototype.setId expects a string.");
	}
	this.m_id = id;
	return this;
};

/**
 * Retrieves the label for the input.
 * @returns {string} The label for the input.
 */
TextControl.prototype.getLabel = function() {
	return this.m_label;
};

/**
 * Sets the label to be displayed with the input.
 * @param {String} label - The label to be displayed with the input.
 */
TextControl.prototype.setLabel = function(label) {
	if(typeof label !== "string") {
		throw new Error("TextControl.prototype.setLabel expects a string.");
	}
	this.m_label = label;
	return this;
};

/**
 * Retrieves the enumeration for the input label position.
 * @returns {number} The enumerated location for the input label position.
 */
TextControl.prototype.getLabelPosition = function() {
	return this.m_labelPosition;
};

/**
 * Sets the label position for the input.
 * @param {Number} labelPosition - The position for the input.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setLabelPosition = function(labelPosition) {
	if(typeof labelPosition !== "number") {
		throw new Error("TextControl.prototype.setLabelPosition expects a number.");
	}
	this.m_labelPosition = labelPosition;
	return this;
};

/**
 * Retrieves the placeholder text for the TextControl.
 * @returns {string} The placeholder text for the input.
 */
TextControl.prototype.getPlaceholderText = function() {
	return this.m_placeholderText;
};

/**
 * Sets the placeholder text for the TextControl. This is the text that appears in the element when no value is
 * present.
 * @param {String} placeholderText - The placeholder text for the TextControl.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setPlaceholderText = function(placeholderText) {
	if(typeof placeholderText !== "string") {
		throw new Error("TextControl.prototype.setPlaceholderText expects a string.");
	}
	this.m_placeholderText = placeholderText;
	this.getInputElement().attr("placeholder", placeholderText);
	return this;
};

/**
 * Retrieves whether the text control is required or not.
 * @returns {boolean} Whether the text control is required or not.
 */
TextControl.prototype.isRequired = function() {
	return this.m_requiredInd;
};

/**
 * Sets whether the text control is required or not.
 * @param {Boolean} required - Whether the text control is required or not.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setRequired = function(required) {
	if(typeof required !== "boolean") {
		throw new Error("TextControl.prototype.setRequired expects a boolean.");
	}
	this.m_requiredInd = required;
	//Update the UI
	var $labelElement = this.getStageElement().children(".te-label");
	var $requiredInd = $labelElement.children(".te-required-ind");
	var $input = this.getInputElement();
	if(required) {
		$labelElement.addClass("te-required-label");
		//Make sure we do not append multiple required indicators
		if(!$requiredInd.length) {
			$labelElement.prepend("<span class='te-required-ind'>*</span>");
		}
		//Ensure the actual input element is updated if it is empty
		if(this.isEmpty()) {
			$input.addClass("te-required");
		}
	} else {
		$labelElement.removeClass("te-required-label");
		$requiredInd.remove();
		$input.removeClass("te-required");
	}
	return this;
};

/**
 * A quick helper function to determine if the control is considered empty.
 * @returns {Boolean} A boolean indicating if the control is empty.
 */
TextControl.prototype.isEmpty = function() {
	var currentValue = this.m_currentValue;
	return this.m_strictWhitespace ? CERN_Validate.string.isBlank(currentValue) : CERN_Validate.string.isEmpty(currentValue);
};

/**
 * Retrieves whether the TextControl is strict about whitespace.
 * @returns {boolean} Whether the TextControl is strict about whitespace.
 */
TextControl.prototype.isStrictWhitespace = function() {
	return this.m_strictWhitespace;
};

/**
 * Sets whether the TextControl is strict about whitespace.
 * @param {Boolean} strictWhitespace - Whether the TextControl is strict about whitespace.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setStrictWhitespace = function(strictWhitespace) {
	if(typeof strictWhitespace !== "boolean") {
		throw new Error("TextControl.prototype.setIsStrictWhitespace expects a boolean.");
	}
	this.m_strictWhitespace = strictWhitespace;
	return this;
};

/**
 * Retrieves whether the TextControl is considered valid or not.
 * @returns {boolean}
 */
TextControl.prototype.isValid = function() {
	return this.m_valid;
};

/**
 * Sets the validator object for the TextControl. This is a validator instance that will be used to validate
 * the value of the input element of the TextControl. If no validator is provided, it is assumed the
 * TextControl is always valid.
 * @param {InputValidator} validator - A validator instance that will perform a validation function on the
 * value of the TextControl input element.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setValidator = function(validator) {
	if(!InputValidator.prototype.isPrototypeOf(validator)) {
		throw new Error("TextControl.prototype.setValidator expects an InputValidator object.");
	}
	this.m_validator = validator;
	return this;
};

/**
 * Retrieves the extensions wrapper element. If the element is null, it will be queried from the DOM.
 * @returns {jQuery} The extensions wrapper element.
 */
TextControl.prototype.getExtensionElement = function() {
	if(!this.m_$extensionElement) {
		this.m_$extensionElement = $("#" + this.getId() + "Extensions");
	}
	return this.m_$extensionElement;
};

/**
 * @private
 * Sets the extension wrapper. This is the element that encapsulates all of the TextControl HTML.
 * This function is private and should not be called externally.
 * @param {jQuery} extensionElement - The extension wrapper element in which all extensions are encapsulated.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setExtensionElement = function(extensionElement) {
	if(typeof extensionElement !== "object") {
		throw new Error("TextControl.prototype.setExtensionElement expects a jQuery object.");
	}
	this.m_$extensionElement = extensionElement;
	return this;
};

/**
 * Retrieves the input element. If the element is null, it will be queried from the DOM.
 * @returns {jQuery} The input element.
 */
TextControl.prototype.getInputElement = function() {
	if(!this.m_$inputElement || !this.m_$inputElement.length) {
		this.m_$inputElement = $("#" + this.getId());
	}
	return this.m_$inputElement;
};

/**
 * @private
 * Sets the input element. This is the actual input control element (<input>)
 * @param {jQuery} inputElement - The input element.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setInputElement = function(inputElement) {
	if(typeof inputElement !== "object") {
		throw new Error("TextControl.prototype.setInputElement expects a jQuery object.");
	}
	this.m_$inputElement = inputElement;
	return this;
};

/**
 * Retrieves the input group element. If the element is null, it will be queried from the DOM.
 * @returns {jQuery} The input group element.
 */
TextControl.prototype.getInputGroupElement = function() {
	if(!this.m_$inputGroupElement || !this.m_$inputGroupElement.length) {
		this.m_$inputGroupElement = $("#" + this.m_id + "InputGroup");
	}
	return this.m_$inputGroupElement;
};

/**
 * @private
 * Sets the input group element.
 * @param {jQuery} inputGroupElement - The input group element.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setInputGroupElement = function(inputGroupElement) {
	if(typeof inputGroupElement !== "object") {
		throw new Error("TextControl.prototype.setInputGroupElement expects a jQuery object.");
	}
	this.m_$inputGroupElement = inputGroupElement;
	return this;
};

/**
 * Retrieves the stage element. This is the element that encapsulates all of the TextControl HTML. If the element
 * is null, it will be queried from the DOM.
 * @returns {jQuery} The stage wrapper element.
 */
TextControl.prototype.getStageElement = function() {
	if(!this.m_$stageElement || !this.m_$stageElement.length) {
		this.m_$stageElement = $("#" + this.getId() + "Stage");
	}
	return this.m_$stageElement;
};

/**
 * @private
 * Sets the stage element. This is the element that encapsulates all of the TextControl HTML.
 * @param {jQuery} stageElement - The stage (or wrapper) element in which all of the TextControl elements are
 * encapsulated.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setStageElement = function(stageElement) {
	if(typeof stageElement !== "object") {
		throw new Error("TextControl.prototype.setStageElement expects a jQuery object.");
	}
	this.m_$stageElement = stageElement;
	return this;
};

/**
 * Retrieves the validation element.
 * @returns {jQuery} The validation element.
 */
TextControl.prototype.getValidationElement = function() {
	if(!this.m_$validationElement || !this.m_$validationElement.length) {
		this.m_$validationElement = $("#" + this.getId() + "Validation");
	}
	return this.m_$validationElement;
};

/**
 * @proviate
 * Sets the validation element. This is the element that encapsulates the validation message (if any).
 * @param {jQuery} validationElement - The validation element in which the validation message will be shown.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setValidationElement = function(validationElement) {
	if(typeof validationElement !== "object") {
		throw new Error("TextControl.prototype.setValidationElement expects a jQuery object.");
	}
	this.m_$validationElement = validationElement;
	return this;
};

/**
 * Sets the width of the <input> element in pixels.
 * @param {Number} width - The width of the <input> element in pixels.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setWidthInPixels = function(width) {
	if(!CERN_Validate.number.isPositive(width)) {
		throw new Error("TextControl.prototype.setWidthInPixels expects a number > 0");
	}
	this.m_width = width;
	if(this.getInputElement().length) {
		this.getInputElement()[0].style.width = width + "px";
	}
	return this;
};

/**
 * Sets a predefined width class for the <input> element.
 * @param {String} predefinedWidth - The class to apply to the <input> element which has
 * width styling.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setPredefinedWidth = function(predefinedWidth) {
	if(!CERN_Validate.string.isString(predefinedWidth)) {
		throw new Error("TextControl.prototype.setPredefinedWidth expects a string.");
	}
	var previousPredefinedWidth = this.m_predefinedWidth;
	this.m_predefinedWidth = predefinedWidth;
	var $input = this.getInputElement();
	var $inputGroup = this.getInputGroupElement();
	var $stageElement = this.getStageElement();

	//Remove the previous pre-defined width stylings.
	$input.removeClass(previousPredefinedWidth);
	$inputGroup.removeClass(previousPredefinedWidth);
	$stageElement.removeClass(previousPredefinedWidth);
	//Fill must be handled with special care
	if(predefinedWidth === TextControl.width.FILL) {
		$stageElement.addClass(TextControl.width.FILL);
		$stageElement.removeClass("te-label-left");
		$stageElement.addClass("te-label-top");
	}
	//Now update the necessary elements with the new predefined widths.
	$input.addClass(predefinedWidth);
	$inputGroup.addClass(predefinedWidth);
	return this;
};

/**
 * Sets the width of the label in pixels.
 * @param {Number} labelWidth - The width of the label in pixels. This value must be greater than 0.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setLabelWidthInPixels = function(labelWidth) {
	if(!CERN_Validate.number.isPositive(labelWidth)) {
		throw new Error("TextControl.prototype.setLabelWidthInPixels expects a number > 0.");
	}
	this.m_labelWidth = labelWidth;
	return this;
};

/**
 * Sets the callback function that is called when the content of the input element changes.
 * @param {Function} onChangeCallback - The callback function to be called when the content of the input element
 * changes. The callback function must specify a content parameter as such:
 * ex: control.setOnChangeCallback(function(content){ ... });
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setOnChangeCallback = function(onChangeCallback) {
	if(typeof onChangeCallback !== "function") {
		throw new Error("TextControl.prototype.setOnChangeCallback expects a function");
	}
	this.m_onChangeCallback = onChangeCallback;
	return this;
};

/**
 * Sets the callback function that is called when the state of the TextControl changes from valid to invalid or
 * invalid to valid.
 * @param {Function} onValidChangeCallback - The callback function to be called when the state of the TextControl
 * changes from valid to invalid or invalid to valid. The callback function must specify a parameter as such:
 * ex: control.setOnValidChangeCallback(function(isValid){ ... });
 * @returns {TextControl} Returns self to allow chaining.
 */
TextControl.prototype.setOnValidChangeCallback = function(onValidChangeCallback) {
	if(typeof onValidChangeCallback !== "function") {
		throw new Error("TextControl.prototype.setOnValidChangeCallback expects a function");
	}
	this.m_onValidChangeCallback = onValidChangeCallback;
	return this;
};

/**
 * @private
 * This attaches a delegate to the element with the specified delegate id. This will ensure that controls rendered
 * via the renderRaw function still have events attached.
 */
TextControl.prototype.attachDelegate = function() {
	if(!this.m_delegateId) {
		throw new Error("TextControl.prototype.attachDelegate requires a delegate id be provided via TextControl.prototype.setDelegateId(...)");
	}
	//If a delegate has already been attached to the element with the specified delegate id.
	if(TextControl.Registry.m_delegateMapping[this.m_delegateId]) {
		logger.logMessage("TextControl.prototype.attachDelegate: " + this.m_delegateId + " already has events bound.");
		return;
	}
	//Attach the keyup delegate.
	$("#" + this.m_delegateId).on("keyup", ".te-textbox, .te-textarea", function(event){
		var control = TextControl.Registry.getControlById($(this).attr("id"));
		if(!control) {
			return;
		}
		control.onUpdate(this.value);
	});
	//Attach the blur delegate.
	$("#" + this.m_delegateId).on("blur", ".te-textbox, .te-textarea", function(){
		var control = TextControl.Registry.getControlById($(this).attr("id"));
		if(!control) {
			return;
		}
		control.onBlur();
	});
	//Attach the paste delegate.
	$("#" + this.m_delegateId).on("paste", ".te-textbox, .te-textarea", function(){
		var control = TextControl.Registry.getControlById($(this).attr("id"));
		if(!control) {
			return;
		}
		var pasteSource = this;
		setTimeout(function(){
			control.onUpdate(pasteSource.value);
		}, 100);
	});
	//The element with the delegate id now has the delegate attached. Remember this to prevent attaching multiple
	//delegate to the same element.
	TextControl.Registry.m_delegateMapping[this.m_delegateId] = true;
};

/**
 * @private
 * Renders the set of extensions associated to the TextControl. Does nothing if there are no extensions.
 */
TextControl.prototype.renderExtensions = function() {
	var extensions = this.getExtensions();
	var extensionCount = extensions.length;
	for(var i = 0; i < extensionCount; i++) {
		extensions[i].render();
	}
};

/**
 * Handles updating the UI state of the TextControl.
 */
TextControl.prototype.updateState = function() {
	var currentValue = this.getCurrentValue();
	var isValid = this.checkValid();
	this.m_valid = isValid;
	//If the control is strict about whitespace, it will consider nothing but whitespace as empty.
	var isEmpty = this.isStrictWhitespace() ? CERN_Validate.string.isBlank(currentValue) : CERN_Validate.string.isEmpty(currentValue);
	//Handle validity
	if(isValid) {
		this.getInputElement().removeClass("te-invalid");
		this.getValidationElement().hide();
	}
	//Handle required status
	if(this.isRequired() && isEmpty) {
		this.getInputElement().addClass("te-required");
	} else if(this.isRequired() && !isEmpty) {
		this.getInputElement().removeClass("te-required");
	}
};

/**
 * Validates the TextControl. If there is a validator, use that for validation, otherwise assume
 * the TextControl is valid.
 * @returns {Boolean} whether the TextControl is in a valid state or not.
 */
TextControl.prototype.checkValid = function() {
	if(this.m_validator) {
		return this.m_validator.validate(this.getCurrentValue());
	} else {
		return true;
	}
};

/**
 * Handles the input update. This function is called on the keyup event of the text entry field.
 * @param {String} currentValue - The current value in the TextControl UI (input)
 */
TextControl.prototype.onUpdate = function(currentValue) {
	var wasValid = this.m_valid;
	this.setCurrentValue(currentValue);
	this.updateState();
	this.updateExtensions();
	//Notify that the content has changed.
	if(this.m_onChangeCallback) {
		this.m_onChangeCallback(currentValue);
	}
	//Notify of a valid state change.
	if(wasValid !== this.m_valid && this.m_onValidChangeCallback) {
		this.m_onValidChangeCallback(this.m_valid);
	}
	//Call a post update function in case controls need to do some extra logic after updating.
	this.postUpdate();
};

/**
 * Handles the blur event for the text control. Currently this will show the validation element (if there is one).
 */
TextControl.prototype.onBlur = function() {
	if (!this.m_valid) {
		this.getValidationElement().show();
		this.getInputElement().addClass("te-invalid");
	}
};

/**
 * A base function that is always called at the end of the onUpdate function. The base TextControl
 * object does not implement this function, but some sub-classes of TextControl may need to perform
 * additional operations after update.
 */
TextControl.prototype.postUpdate = function() {
};

/**
 * Runs through the list of extensions associated with the TextControl and calls the onUpdate function,
 * passing this instance of the TextControl so the extension can handle the update appropriately.
 */
TextControl.prototype.updateExtensions = function() {
	var extensions = this.getExtensions();
	var extensionCount = extensions.length;
	for(var i = 0; i < extensionCount; i++) {
		extensions[i].onUpdate();
	}
};

/**
 * @private
 * Performs necessary validation prior to rendering the text control.
 * @param {Boolean} renderRaw - If rendering as raw HTML.
 */
TextControl.prototype.preRenderValidate = function(renderRaw) {
	//An id is required for a unique DOM existence.
	if(!this.m_id) {
		throw new Error("TextControl requires a unique id to render");
	}
	//If rendering raw, you must provide a delegate id.
	if(renderRaw && !this.m_delegateId) {
		throw new Error("TextControl requires a delegate id when calling TextControl.prototype.renderRaw");
	}
};

/**
 * @private
 * This function renders the entire control as an HTML string. This function should only be called from
 * TextControl.prototype.render and TextControl.prototype.renderRaw.
 * @returns {string} The entire text control rendered as an HTML string.
 */
TextControl.prototype.renderHtml = function() {
	//Start the control off with the correct valid state.
	this.m_valid = this.checkValid();
	//Start rendering
	var label = this.m_label;
	var labelPosition = this.m_labelPosition;
	var labelClasses = ["te-label"];
	var stageClasses = ["te-stage"];
	var inputGroupClasses = ["te-input-group", this.m_predefinedWidth];
	var labelHtml = "";
	var labelInnerHtml = "";
	var labelText = label;
	var extensions = this.getExtensions();
	var extensionCount = extensions.length;
	var controlId = this.m_id;

	//If the control uses the fill style, some special care must be taken for other elements as well.
	if(this.m_predefinedWidth === TextControl.width.FILL) {
		//If fill is specified, the label position is forced above.
		labelPosition = TextControl.label_position.TOP;
		stageClasses.push("te-fill");
	}

	if(label) {
		var labelStyle = "";
		if(this.m_labelWidth) {
			labelStyle = "style='width:" + this.m_labelWidth + "px;'";
		}
		if(labelPosition === TextControl.label_position.LEFT) {
			stageClasses.push("te-label-left");
			labelText += ":&nbsp;";
		} else {
			stageClasses.push("te-label-top");
		}
		if(this.m_requiredInd) {
			labelClasses.push("te-required-label");
			labelInnerHtml += "<span class='te-required-ind'>*</span>";
		}
		labelHtml = "<div class='"+labelClasses.join(" ")+"' "+labelStyle+">";
		labelInnerHtml += "<span class='te-label-text'>"+labelText+"</span>";
		labelHtml += labelInnerHtml;
		labelHtml += "</div>";
	}
	var html = "<div id='"+controlId+"Stage' class='" + stageClasses.join(" ") + "'>";
	html += labelHtml;
	html += "<div id='"+controlId+"InputGroup' class='" + inputGroupClasses.join(" ") + "'>";
	html += this.renderInputElementRaw();
	//Render any extensions as raw html as well.
	if (extensionCount) {
		html += "<div id='" + controlId + "Extensions' class='te-extensions'>";
		//Render any extensions
		for (var i = 0; i < extensionCount; i++) {
			html += extensions[i].renderRaw();
		}
		html += "</div>";
	}
	//Validation
	if (this.m_validator) {
		html += "<div id='" + controlId + "Validation' class='te-validation' style='display: none;'>";
		html += this.m_validator.getValidationMessage() || "";
		html += "</div>";
	}
	html += "</div></div>";
	return html;
};

/**
 * Renders as a jQuery element and attaches all necessary events.
 * @returns {*|jQuery|HTMLElement}
 */
TextControl.prototype.render = function() {
	//Validate prior to rendering. This is not rendering raw, so pass false indicating as such.
	this.preRenderValidate(false);
	var self = this;
	//Resuse the renderHtml function to generate the entire control markup.
	var $element = $(this.renderHtml());
	var controlId = this.getId();

	//Cache the most commonly used elements
	this.setInputElement($element.find("#" + controlId));
	this.setInputGroupElement($element.find("#" + controlId + "InputGroup"));
	this.setStageElement($element.find("#" + controlId + "Stage"));
	this.setExtensionElement($element.find("#" + controlId + "Extensions"));
	this.setValidationElement($element.find("#" + controlId + "Validation"));

	//Attach all necessary events to the input element.
	this.getInputElement().on("keyup", function(event){
		self.onUpdate(this.value);
	}).on("blur", function(){
		self.onBlur();
	}).on("paste", function(){
		var pasteSource = this;
		setTimeout(function(){
			self.onUpdate(pasteSource.value);
		}, 100);
	});
	return $element;
};

/**
 * Renders the TextControl as a raw HTML string. This will produce flat HTML. Thus, a delegate must
 * be applied to a parent element to this TextControl element.
 * @returns {string} The TextControl object rendered as flat HTML.
 */
TextControl.prototype.renderRaw = function() {
	//Perform rendering validation, passing true to indicate raw HTML
	this.preRenderValidate(true);
	//Register the control to the system so it can be found later
	TextControl.Registry.registerControl(this);
	//Attach the delegates
	this.attachDelegate();
	//Make the call to render tha plain HTML
	return this.renderHtml();
};

/**
 * @private
 * Renders the actual input element as a raw HTML string. This is the <input> tag of the entire
 * TextControl.
 * @returns {string} The <input> tag for the TextControl, rendered as an HTML string.
 */
TextControl.prototype.renderInputElementRaw = function() {
	var currentValue = this.m_currentValue;
	var isValid = this.m_valid;
	var isEmpty = this.isEmpty();
	var disabled = this.m_disabled ? " disabled" : "";
	var placeholder = this.m_placeholderText ? " placeholder='" + this.m_placeholderText + "'" : "";
	var inputClasses = ["te-textbox"];
	var defaultValue = currentValue ? (" value='" + currentValue + "'") : "";
	var style = "style='";
	style += this.m_width ? ("width:" + this.m_width + "px;") : "";
	style += "'";
	if(!isValid) {
		inputClasses.push("te-invalid");
	}
	if(this.m_requiredInd && isEmpty) {
		inputClasses.push("te-required");
	}
	inputClasses.push(this.m_predefinedWidth);
	return "<input id='" + this.m_id + "' class='" + inputClasses.join(" ") + "' type='text'" + defaultValue + placeholder + style + disabled + ">";
};

/**
 * The TextAreaControl class.
 * This overrides the base TextControl class, extending it to provide text area support.
 * @constructor
 */
function TextAreaControl() {
	this.m_height = null;
	this.m_isResizeable = false;
	this.m_rows = 1;
}

TextAreaControl.prototype = new TextControl();
TextAreaControl.prototype.constructor = TextControl;

/**
 * Sets the height of the <textarea> element in pixels. This value can be null if the
 * developer has not explicitly provided a height. In such a case, the <textarea> element will
 * be styled natively via the "rows" attribute which defaults to 1.
 * @param {Number} height - The height of the <textarea> element in pixels.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextAreaControl.prototype.setHeightInPixels = function(height) {
	if(!CERN_Validate.number.isPositive(height)) {
		throw new Error("TextAreaControl.prototype.setHeightInPixels expects a number > 0.");
	}
	this.m_height = height;
	//If the text area has already been rendered, go ahead and update the element.
	if(this.getInputElement().length) {
		this.getInputElement()[0].style.height = height + "px";
	}
	return this;
};

/**
 * Sets whether the <textarea> element is allowed to be resized.
 * @param {Boolean} isResizeable - True if the <textarea> element is resizeable, otherwise false.
 * @returns {TextControl} Returns self to allow chaining.
 */
TextAreaControl.prototype.setIsResizeable = function(isResizeable) {
	if(typeof isResizeable !== "boolean") {
		throw new Error("TextAreaControl.prototype.setIsResizeable expects a boolean.");
	}
	this.m_isResizeable = isResizeable;
	var $inputElement = this.getInputElement();
	//If the text area has already been rendered, go ahead and update the element.
	if(isResizeable) {
		$inputElement.removeClass("te-no-resize");
	} else {
		$inputElement.addClass("te-no-resize");
	}
	return this;
};

/**
 * Sets the number of rows for the text area. This refers to the native "rows" attribute
 * on the <textarea> element. For example: <textarea rows="1"></textarea>
 * @param {Number} rows - The number of native rows for the <textarea> element.
 * @returns {TextAreaControl} returns self to allows chaining.
 */
TextAreaControl.prototype.setHeightInRows = function(rows) {
	if(!CERN_Validate.number.isGreaterThanOrEqualTo(1)) {
		throw new Error("TextAreaControl.prototype.setHeightInRows expects an integer >= 1");
	}
	this.m_rows = rows;
	//If the text area has already been rendered, go ahead and update the element.
	this.getInputElement().attr("rows", rows);
	return this;
};

/**
 * @private
 * Overrides the base renderInputElementRaw function. The TextAreaControl uses a <textarea> element rather than an
 * <input> element.
 * @returns {String} The <textarea> element for the TextAreaControl rendered as an HTML string.
 */
TextAreaControl.prototype.renderInputElementRaw = function() {
	var currentValue = this.m_currentValue;
	var isValid = this.m_valid;
	var isEmpty = this.m_strictWhitespace ? CERN_Validate.string.isBlank(currentValue) : CERN_Validate.string.isEmpty(currentValue);
	var disabled = this.m_disabled ? " disabled" : "";
	var rows = this.m_rows;
	var placeholder = this.m_placeholderText ? " placeholder='" + this.m_placeholderText + "'" : "";
	var inputClasses = ["te-textarea"];
	inputClasses.push(this.m_predefinedWidth);
	var style = "style='";
	style += this.m_width ? ("width:" + this.m_width + "px;") : "";
	style += this.m_height ? ("height:" + this.m_height + "px;") : "";
	style += "'";
	if(!isValid) {
		inputClasses.push("te-invalid");
	}
	if(this.m_requiredInd && isEmpty) {
		inputClasses.push("te-required");
	}
	if(!this.m_isResizeable) {
		inputClasses.push("te-no-resize");
	}
	return "<textarea id='" + this.m_id + "' class='" + inputClasses.join(" ") + "' rows='" + rows + "' type='text'" + placeholder + style + disabled + ">" + currentValue + "</textarea>";
};
/**
 * The AutosizeTextAreaControl class.
 * This class extends the TextAreaControl and allows the text area to automatically
 * grow based on a min and max height.
 * @constructor
 */
function AutosizeTextAreaControl() {
	this.m_maxHeight = Number.MAX_VALUE;
	this.m_minHeight = 24;
	return this;
}

AutosizeTextAreaControl.prototype = new TextAreaControl();
AutosizeTextAreaControl.prototype.constructor = TextAreaControl;

/**
 * Sets the minimum height of the text area control.
 * @param {Number} minHeight - The minimum height of the text area element. This number must
 * be positive.
 * @returns {AutosizeTextAreaControl} Returns self to allow chaining.
 */
AutosizeTextAreaControl.prototype.setMinHeightInPixels = function(minHeight) {
	if(!CERN_Validate.number.isPositive(minHeight)) {
		throw new Error("AutosizeTextAreaControl.prototype.setMinHeightInPixels expects a number > 0.");
	}
	if(minHeight > this.m_maxHeight) {
		throw new Error("AutosizeTextAreaControl.prototype.setMinHeightInPixels: the min value must be less than or equal to the max value.");
	}
	this.m_minHeight = minHeight;
	return this;
};

/**
 * Sets the maximum height of the text area control.
 * @param {Number} maxHeight - The maximum height of the text area element. This number
 * must be positive.
 * @returns {AutosizeTextAreaControl} Returns self to allow chaining.
 */
AutosizeTextAreaControl.prototype.setMaxHeightInPixels = function(maxHeight) {
	if(!CERN_Validate.number.isPositive(maxHeight)) {
		throw new Error("TextAreaControl.prototype.setMaxHeight: expecting a value greater than 0");
	}
	if(maxHeight < this.m_minHeight) {
		throw new Error("TextAreaControl.prototype.setMaxHeight: the max value must be greater than or equal to the min value");
	}
	this.m_maxHeight = maxHeight;
	return this;
};

/**
 * Overrides the base postUpdate function. This simply calls the handleAutoGrow to ensure that when the control has
 * finished updating, the size of the control will be updated correctly.
 */
AutosizeTextAreaControl.prototype.postUpdate = function() {
	this.handleAutoGrow();
};

/**
 * An exposed resize function for developers to forcefully resize the control. Right now this simply calls
 * handleAutoGrow. This is useful if the developer has chosen to render the control as raw html and wants to ensure
 * the height is adjusted correctly post-render.
 */
AutosizeTextAreaControl.prototype.resize = function() {
	this.handleAutoGrow();
};

/**
 * This handles the height adjustment of the control. This works by forcing the height of the text area to equal
 * the scroll-height of the area. This occurs up to a maximum height at which point the overflow of the text area is
 * shown and we force the height to the max height. We must also account for Internet Explorer changing the width of the
 * text area when overflow is shown/hidden.
 */
AutosizeTextAreaControl.prototype.handleAutoGrow = function() {
	var $input = this.getInputElement();
	//This can occur if the element does not truly exist on the DOM.
	if(!$input.length) {
		return;
	}
	var rawInput = $input[0];
	var previousWidth = rawInput.offsetWidth;
	var currentWidth = null;
	var scrollHeight;
	rawInput.style.height = 'auto';
	scrollHeight = rawInput.scrollHeight;
	//Adjust the size of the text area.
	if(scrollHeight <= this.m_maxHeight) {
		rawInput.style.height = Math.max(this.m_minHeight,scrollHeight) + "px";
	} else {
		rawInput.style.height = this.m_maxHeight + "px";
	}
	//Determine if the scrollbar needs to be visible or not.
	if(scrollHeight > this.m_maxHeight) {
		$input.css({"overflow-y" : "auto"});
	} else {
		$input.css({"overflow-y" : "hidden"});
	}
	currentWidth = rawInput.offsetWidth;
	//In some browsers (IE), altering the overflow can alter the width.
	if(previousWidth !== currentWidth) {
		rawInput.style.width = previousWidth + "px";
	}
};
/**
 * The base TextControlExtension interface.
 * This class represents the interface for creating extensions for a TextControl object.
 * @constructor
 */
function TextControlExtension() {
	this.m_ownerControl = null;
}

/**
 * The base onUpdate function. This function should be implemented by subclasses. This function
 * is called when the TextControl updates (on user input).
 */
TextControlExtension.prototype.onUpdate = function () {
};

/**
 * This function renders the extension as raw HTML. This function should be implemented by subclasses.
 * @returns {String} The markup rendered as an HTML string.
 */
TextControlExtension.prototype.renderRaw = function() {
	return "";
};

/**
 * Sets the TextControl that owns this extension. This is called when you use the TextControl.prototype.addExtension
 * function.
 * @param {TextControl} control - The owner of this extension.
 * @returns {TextControlExtension} Returns self to allow chaining.
 */
TextControlExtension.prototype.setOwnerControl = function(control) {
	if(!TextControl.prototype.isPrototypeOf(control)) {
		throw new Error("TextControlExtension.prototype.setOwnerControl expects an object of type TextControl.");
	}
	this.m_ownerControl = control;
	return this;
};

/**
 * The CharacterLimitExtension class.
 * This class extends the TextControlExtension interface. This extension provides the ability to display a character
 * limit beneath the input. You can specify the character limit and whether the extension will automatically truncate
 * the text.
 * @returns {CharacterLimitExtension} Returns self to allow chaining.
 * @constructor
 */
function CharacterLimitExtension() {
	this.m_autoTruncate = false;
	this.m_characterLimit = Number.MAX_VALUE;
	this.m_$charRemaining = null;
	return this;
}

CharacterLimitExtension.prototype = new TextControlExtension();
CharacterLimitExtension.prototype.constructor = TextControlExtension;

/**
 * Sets whether the extension will automatically truncate the text in the input when the character limit is reached.
 * @param {Boolean} autoTruncate - A boolean indicating whether the extension will automatically truncate the text.
 * @returns {CharacterLimitExtension} Returns self to allow chaining.
 */
CharacterLimitExtension.prototype.setAutoTruncate = function (autoTruncate) {
	if(typeof autoTruncate !== "boolean") {
		throw new Error("CharacterLimitExtension.prototype.setAutoTruncate expects a boolean.");
	}
	this.m_autoTruncate = autoTruncate;
	return this;
};

/**
 * Sets the character limit of the extension. This is the number of characters within the input element.
 * @param {Number} characterLimit - The character limit of the extension. This must be a number greater than 0.
 * @returns {CharacterLimitExtension} Returns self.
 */
CharacterLimitExtension.prototype.setCharacterLimit = function (characterLimit) {
	if(!CERN_Validate.number.isPositive(characterLimit)) {
		throw new Error("CharacterLimitExtension.prototype.setCharacterLimit expects a number > 0.");
	}
	if(!CERN_Validate.number.isInteger(characterLimit)) {
		throw new Error("CharacterLimitExtension.prototype.setCharacterLimit only accepts integers.");
	}
	this.m_characterLimit = characterLimit;
	return this;
};

/**
 * Retrieves the character limit jQuery element.
 * @returns {jQuery} The jQuery character remaining element.
 */
CharacterLimitExtension.prototype.getCharRemainingElement = function() {
	if(!this.m_$charRemaining || !this.m_$charRemaining.length) {
		this.m_$charRemaining = $("#" + this.m_ownerControl.getId() + "CharRemaining");
	}
	return this.m_$charRemaining;
};

/**
 * Overrides the onUpdate function. This will obtain the current value from the owner
 * control and check to see if the input value exceeds the character limit. If the limit is exceeded, the visual will
 * update to indicate as such. Otherwise, the remaining character count is updated.
 */
CharacterLimitExtension.prototype.onUpdate = function () {
	var control = this.m_ownerControl;
	var currentValue = control.getCurrentValue();
	var currentValueLength = currentValue.length;
	var remainingCharacters = this.m_characterLimit - currentValueLength;
	var $charRemaining = this.getCharRemainingElement();
	//If the character limit has been reached.
	if(remainingCharacters < 0) {
		$charRemaining.addClass("te-char-limit-reached");
		//If we are over the limit and auto-truncate is enabled, process the input
		if (this.m_autoTruncate) {
			control.setCurrentValue(currentValue.substring(0, this.m_characterLimit));
			control.updateState();
		}
	} else {
		$charRemaining.removeClass("te-char-limit-reached");
	}
	//Update the character count message.
	$charRemaining.html(this.getCharRemainingMessage());
};

/**
 * Retrieves a string indicating how many characters remaining or how many characters over.
 * @returns {string} A string indicating how many characters remaining or how many characters over.
 */
CharacterLimitExtension.prototype.getCharRemainingMessage = function() {
	var control = this.m_ownerControl;
	var currentValue = control.getCurrentValue();
	var currentValueLength = currentValue.length;
	var remainingCharacters = this.m_characterLimit - currentValueLength;
	var message = Math.max(0, remainingCharacters) + "&nbsp;characters left";
	//If auto-truncating, you can never dip below 0.
	if(this.m_autoTruncate) {
		remainingCharacters = 0;
	}
	//If below 0, change the message to indicate how many you are over.
	if(remainingCharacters < 0) {
		message = Math.abs(remainingCharacters) + "&nbsp;over";
	}
	return message;
};

/**
 * Renders the extension as raw HTML.
 * @returns {string} The extension rendered as raw html.
 */
CharacterLimitExtension.prototype.renderRaw = function() {
	var control = this.m_ownerControl;
	var currentValue = control.getCurrentValue();
	var currentValueLength = currentValue.length;
	var remainingCharacters = this.m_characterLimit - currentValueLength;
	var extensionClasses = ["te-char-remaining"];
	if(remainingCharacters < 0) {
		extensionClasses.push("te-char-limit-reached");
	}
	var charLimitHtml = "<div class='te-char-limit'>";
	charLimitHtml += "<span id='"+control.getId()+"CharRemaining' class='"+extensionClasses.join(" ")+"'>" + this.getCharRemainingMessage() + "</span>";
	charLimitHtml += "</div>";
	return charLimitHtml;
};
/**
 * The InputValidator interface.
 * This interface defines the behavior of an input validator. The interface
 * is expected to be inherited to provide real implementation.
 * @constructor
 */
function InputValidator(){
}

/**
 * The base validate function. It returns true. This function should be overridden by
 * sub-classes of the InputValidator.
 * @param {String} value - The input value.
 * @returns {boolean} A boolean indicating if the value is valid or not.
 */
InputValidator.prototype.validate = function(value) {
	return true;
};

/**
 * The base getValidationMessage function. It returns an empty string. This function should be overridden by a subclass
 * of the InputValidator interface.
 * @returns {string} A message indicating the requirements for the validator to equate to true.
 */
InputValidator.prototype.getValidationMessage = function() {
	return "";
};

/**
 * The NumericValidator class.
 * This subclass of InputValidator requires the input be a number.
 * @returns {NumericValidator} Returns self to allow chaining.
 * @constructor
 */
function NumericValidator(){
	return this;
}

NumericValidator.prototype = new InputValidator();
NumericValidator.prototype.constructor = InputValidator;

/**
 * Overrides the base getValidationMessage function. It returns a message indicating that input must be of numeric
 * format in order for the validator to equate to true.
 * @returns {string} The validation message.
 */
NumericValidator.prototype.getValidationMessage = function() {
	return "A number is required";
};

/**
 * Overrides the base validate function. It uses the CERN_Validate utility to ensure that the input value is of numeric
 * format.
 * @param {String} value - The input value to be validated.
 * @returns {boolean} A boolean indicating if the provided input value is valid or not.
 */
NumericValidator.prototype.validate = function(value) {
	return CERN_Validate.string.isNumeric(value);
};

/**
 * The NumericRangeValidator class.
 * This subclass of NumericValidator (and subsequently InputValidator) requires the input be a number between a
 * specified range.
 * @returns {NumericRangeValidator} Returns self to allow chaining.
 * @constructor
 */
function NumericRangeValidator(){
	this.m_inclusive = false;
	this.m_minValue = -Number.MAX_VALUE;
	this.m_maxValue = Number.MAX_VALUE;
	return this;
}
NumericRangeValidator.prototype = new NumericValidator();
NumericRangeValidator.prototype.constructor = NumericValidator;

/**
 * Overrides the base getValidationMessage function. It returns a message indicating that the input must be of numeric
 * format and within a specified range in order for the validator to equate to true.
 * @returns {string}
 */
NumericRangeValidator.prototype.getValidationMessage = function() {
	return "A number between " + this.m_minValue + " and " + this.m_maxValue + " is required";
};

/**
 * Sets whether the numeric range provided is inclusive or not (exclusive).
 * @param {Boolean} inclusive - A boolean indicating if the numeric range is inclusive or not.
 * @returns {NumericRangeValidator} Returns self to allow chaining.
 */
NumericRangeValidator.prototype.setIsInclusive = function(inclusive) {
	if(typeof inclusive !== "boolean") {
		throw new Error("NumericRangeValidator.prototype.setIsInclusive expects a boolean.");
	}
	this.m_inclusive = inclusive;
	return this;
};

/**
 * Sets the minimum value of the accepted range of inputs.
 * @param {Number} minValue - The minimum value of the accepted range of inputs.
 * @returns {NumericRangeValidator} Returns self to allow chaining.
 */
NumericRangeValidator.prototype.setMinValue = function(minValue) {
	if(!CERN_Validate.number.isNumber(minValue)) {
		throw new Error("NumericRangeValidator.prototype.setMinValue expects a number.");
	}
	if(minValue > this.m_maxValue) {
		throw new Error("NumericRangeValidator.prototype.setMinValue - min value cannot be greater than max value.");
	}
	this.m_minValue = minValue;
	return this;
};

/**
 * Sets the maximum value of the accepted range of inputs.
 * @param {Number} maxValue - The maximum value of the accepted range of inputs.
 * @returns {NumericRangeValidator} Returns self to allow chaining.
 */
NumericRangeValidator.prototype.setMaxValue = function(maxValue) {
	if(!CERN_Validate.number.isNumber(maxValue)) {
		throw new Error("NumericRangeValidator.prototype.setMaxValue expects a number.");
	}
	if(maxValue < this.m_minValue) {
		throw new Error("NumericRangeValidator.prototype.setMaxValue - max value cannot be less than the min value.");
	}
	this.m_maxValue = maxValue;
	return this;
};

/**
 * Overrides the base validate function. The first uses the validate function from the inherited NumericValidator
 * class to ensure the value is even of numeric format. If so, the value is parsed and checked once more to ensure
 * the parsed value is indeed a number. If this is true, check if the value is within the specified range using the
 * inclusive flag.
 * @param {String} value - The input value to be validated.
 * @returns {boolean} A boolean indicating if the provided input value is valid.
 */
NumericRangeValidator.prototype.validate = function(value) {
	//Only bother validating this control if it passes the NumericValidator.
	if(NumericValidator.prototype.validate.call(this, value)) {
		var numericValue = parseFloat(value);
		//If for some reason the parsed value is not a number
		if(!CERN_Validate.number.isNumber(numericValue)) {
			return false;
		}
		return CERN_Validate.number.isWithinRange(numericValue, this.m_minValue, this.m_maxValue, this.m_inclusive);
	} else {
		return false;
	}
};

MPage_Core_User_Prefs = {}; // eslint-disable-line no-undef, mp-camelcase
/**
 * This singleton encapsulates all utility methods for storing and retrieving session specific and persistent data items.
 * @namespace UserPrefManager
 * @static
 * @global
 */
MPage_Core_User_Prefs.UserPrefManager = function() { // eslint-disable-line no-undef, mp-camelcase
    var cache = null; // eslint-disable-line no-unused-vars
    var appNumber = 3202020;
    var generatePrefKey = function(key){
        return "MPAGESPREF_" + key;
    };
    return {
        /**
         * Method for retrieving both session specific and persistent stored items by key
         * @param {String} key identifier for the stored item
         * @param {Boolean} dataIsPersisted (optional) indicator set to true if the stored item is persisted
         * @param {integer} userId identifier for the user who the prefernece is being stored for
         * @param {Boolean} async (optional) indicator set to true if preferences should be retrieved asynchronously
         * @param {function} callback (optional) indicator set to true if preferences should be retrieved asynchronously
         *
         * @returns {String} String containing the value realted to the key
         *
         * @description
         * The key is used in combination with a MPAGES prefix
         * <p>Example: A key called "FAVORITES" will be identified as "MPAGES_FAVORITES"</p>
         *
         * @static
         * @function
         * @memberof UserPrefManager
         * @name GetPreference
         */
        GetPreference: function(key, dataIsPersisted, userId, async, callback) { // eslint-disable-line complexity
            if (dataIsPersisted) {
                var prefRequest = new ScriptRequest();
                prefRequest.setProgramName("MP_GET_USER_PREFS");
                prefRequest.setParameterArray([ "^mine^", userId + ".0", "^" + generatePrefKey(key) + "^", appNumber ]);
                prefRequest.setAsyncIndicator(async === undefined ? true : async);
                prefRequest.setResponseHandler(function(scriptReply){
                    var status = scriptReply.getStatus();
                    var prefsResponse = scriptReply.getResponse();
                    if(status === "Z" || status === "S"){
                        if(callback && typeof callback === "function"){
                            callback(prefsResponse.PREF_STRING);
                        }
                        else{
                            return prefsResponse.PREF_STRING;
                        }
                    }
                    else {
                        logger.logError(scriptReply.getError());
                    }
                });
                prefRequest.performRequest();
            }
            else if(this.cache.hasOwnProperty(key)){
                if(callback && typeof callback === "function"){
                    callback(this.cache[key]);
                }
            }
        },
        /**
         * Method for saving both session specific and persistent stored items by key
         * @param {String} key  identifier for the stored item
         * @param {String} value data for the stored item
         * @param {Boolean} persistData (optional) indicator set to true if the stored item is persisted
         * @param {integer} userid identifier for the user who the prefernece is being stored for
         * @param {Boolean} async (optional) indicator set to true if preferences should be saved asynchronously
         *
         * @returns {undefined}
         *
         * @description
         * The key is used in combination with a MPAGES prefix
         * <p>Example: A key called "_FAVORITES" will be identified as "MPAGES_FAVORITES"</p>
         *
         *
         * @static
         * @function
         * @memberof UserPrefManager
         * @name SavePreference
         */
        SavePreference: function(key, value, persistData, userid, async) {
            if (persistData) {
                // Ajax Request to store
                // Create the script request and perform it
                var prefRequest = new ScriptRequest();
                prefRequest.setProgramName("MP_MAINTAIN_USER_PREFS");
                prefRequest.setParameterArray([ "^mine^", userid + ".0", "^" + generatePrefKey(key) + "^", "@" + value.toString().length + ":" + value + "@", appNumber ]);
                prefRequest.setAsyncIndicator(async === undefined ? true : async);
                prefRequest.setResponseHandler(function(scriptReply){
                    if(scriptReply.getStatus() === "F"){
                        logger.logError(scriptReply.getError());
                    }
                });
                prefRequest.performRequest();
            }
            else if ( typeof key !== "undefined" && typeof value !== "undefined"){
                this.cache[prefKey] = value; // eslint-disable-line no-undef
            }
        },
         /**
         * Method for clearing both session specific and persistent stored items by key
         * @param {String} key  identifier for the stored item
         * @param {Boolean} dataIsPersisted (optional) indicator set to true if the stored item is persisted
         * @param {integer} userid identifier for the user who the prefernece is being stored for
         * @param {Boolean} async (optional) indicator set to true if preferences should be saved asynchronously
         *
         * @returns {undefined}
         *
         * @description
         * The key is used in combination with a MPAGES prefix
         * <p>Example: A key called "_FAVORITES" will be identified as "MPAGES_FAVORITES"</p>
         *
         * @static
         * @function
         * @memberof UserPrefManager
         * @name ClearPreference
         */
        ClearPreference: function(key, dataIsPersisted, userid, async) { // eslint-disable-line complexity
            if (dataIsPersisted) {
                var criterion = CERN_Platform.getCriterion();
                // Create the script request and perform it
                var prefRequest = new ScriptRequest();
                prefRequest.setProgramName("MP_MAINTAIN_USER_PREFS");
                prefRequest.setParameterArray([ "^mine^", userid ? userid : criterion.CRITERION.PRSNL_ID + ".0", "^" + generatePrefKey(key) + "^", "^^", appNumber ]);
                prefRequest.setAsyncIndicator(async === undefined ? true : async);
                prefRequest.setResponseHandler(function(scriptReply){
                    if(scriptReply.getStatus() === "F"){
                        logger.logError(scriptReply.getError());
                    }
                });
                prefRequest.performRequest();
            }
            else if(this.cache.hasOwnProperty(prefKey)){ // eslint-disable-line no-undef
                delete this.cache[prefKey]; // eslint-disable-line no-undef
            }
        }
    };
}();
/* globals MenuSeparator*/

/**
 * The RenderStrategy base object
 * This object replaces the old CreateCompDiv function. This object facilitates the
 * creation of component html structure. This base RenderStrategy performs all
 * common html generation between summaries.
 * @constructor
 * @author Will Reynolds
 */
function RenderStrategy() {
	this.component = null;
	this.componentId = null;
	this.componentNamespace = null;
	this.componentStyle = null;
	this.i18nCore = i18n.discernabu;
}

RenderStrategy.prototype.getLookbackMenuId = function() {
    return "lookback-menu" + this.componentId;
};

RenderStrategy.prototype.getFilterMenuId = function() {
    return "filter-menu" + this.componentId;
};

/**
 * This function gets the component we are rendering
 * @returns {MPageComponent} the component we are rendering
 */
RenderStrategy.prototype.getComponentToRender = function() {
	return this.component;
};

/**
 * This function sets the component to render
 * @param {MPageComponent} component The component we are going to render
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.setComponentToRender = function(component) {
	if(component && MPageComponent.prototype.isPrototypeOf(component)) {
		this.component = component;
		this.setComponentStyle(component.getStyles());
		this.setComponentNamespace(component.getStyles().getNameSpace());
		this.setComponentId(component.getStyles().getId());
	}
};

/**
 * Gets the id of the component we are rendering
 * @returns {String} the id of the component we are rendering
 */
RenderStrategy.prototype.getComponentId = function() {
	return this.componentId;
};

/**
 * Sets the id of the component we are rendering
 * @param {String} id The id of the component we are rendering
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.setComponentId = function(id) {
    if(id && typeof id === "string") {
		this.componentId = id;
	}
};

/**
 * Gets the style of the component we are rendering
 * @returns {ComponentStyle} the style of the component we are rendering
 */
RenderStrategy.prototype.getComponentStyle = function() {
	return this.componentStyle;
};

/**
 * Sets the style of the component we are rendering
 * @param {ComponentStyle} style The style of the component we are rendering
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.setComponentStyle = function(style) {
	if(style && ComponentStyle.prototype.isPrototypeOf(style)) {
		this.componentStyle = style;
	}
};

/**
 * Gets the namespace of the component we are rendering
 * @returns {String} the namespace of the component we are rendering
 */
RenderStrategy.prototype.getComponentNamespace = function() {
	return this.componentNamespace;
};

/**
 * Sets the namespace of the component we are rendering
 * @param {String} namespace The namespace of the component we are rendering
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.setComponentNamespace = function(namespace) {
    if(namespace && typeof namespace === "string") {
		this.componentNamespace = namespace;
	}
};

/**
 * This function handles creation of the main component container
 * @param {MPageComponent} component the component for which we are creating the container
 * @returns {Object} The DOM element for the component div container (contains all component html)
 */
RenderStrategy.prototype.createComponentContainer = function() {
    var container = $("<div></div>").attr("id", this.componentId)
		.addClass(this.componentStyle.getClassName())
		// mpageui-hide-non-responsive-content css class hides all content except header and the banner.
		.addClass(!CERN_Platform.inMillenniumContext() && !this.component.isFusionComponent ? "mpageui-hide-non-responsive-content" : "");
	// Handle if the component is closed
	if(!this.component.isExpanded() && !this.component.isAlwaysExpanded()) {
        $(container).addClass("closed");
	}
	return container[ 0 ];
};

/**
 * Handles creation of the + add control in the component header
 * @param {MPageComponent} component the component for which we are creating the + add control
 * @returns {Object} creates the plus-add control for the component
 */
RenderStrategy.prototype.createPlusAddControl = function() {

	if(!this.component.isPlusAddEnabled()) {
		return null;
	}
	var component = this.component;

	// Create the plus add html structure
	var addLabel = i18n.discernabu.render_strategy.ADD.replace("{0}",this.component.getLabel());
	var plusAddControl = $("<a role='button'></a>").attr({id: this.componentNamespace + "Add", href: "#", "aria-label": addLabel, title: addLabel}).addClass("add-plus");
    var plusAddIcon = $("<span></span>").addClass("add-icon").html("&nbsp;");
    var plusAddText = $("<span></span>").addClass("add-text").html(this.i18nCore.ADD);

	// Append the structure
	plusAddControl.append(plusAddIcon);
	plusAddControl.append(plusAddText);

	// Assign click events to the plus add
	/* WARNING: This logic does not make sense and is a defect.  The existing implementation uses an iViewAdd
	 * false value to indicate that the IView functions should be utilized.
	 */
	if(this.component.isIViewAdd() === false) {
		plusAddControl.click(function() {
			component.openIView();
		});
	}
	else {
		plusAddControl.click(function() {
			component.openTab();
		});
	}
	return plusAddControl[ 0 ];
};

/**
 * Creates the component loading section of the component (added in the header)
 * @param {MPageComponent} component the component for which we are creating the loading section
 * @returns {Object} The DOM element for the component loading section
 */
RenderStrategy.prototype.createComponentSubTitleSection = function() {
    return $("<span></span>").addClass(this.componentStyle.getTotal()).html(this.i18nCore.LOADING_DATA + "...")[ 0 ];
};

/**
 * Creates the component filter applied section
 * @returns {Object} The DOM element for the component filter applied section
 */
RenderStrategy.prototype.createFilterAppliedSection = function() {
	var uniqueComponentId = this.getComponentId();
	var rComponent = this.component;
	var facilityDefinedDisplay = this.i18nCore.FACILITY_DEFINED_VIEW;
    var filterAppliedText = "";
    var filterHoverTitle = "";
	if(rComponent.getGrouperFilterCriteria() && rComponent.getGrouperFilterLabel() !== facilityDefinedDisplay) {
		filterAppliedText = this.i18nCore.FILTER_APPLIED;
		filterHoverTitle = rComponent.getGrouperFilterLabel().toString();
	}
	if(rComponent.getGrouperFilterCatalogCodes() && rComponent.getGrouperFilterCatLabel() !== facilityDefinedDisplay) {
		filterAppliedText = this.i18nCore.FILTER_APPLIED;
		filterHoverTitle = rComponent.getGrouperFilterCatLabel().toString();
	}
    return $("<span></span>").addClass("filter-applied-message").attr({
        "id": "filterAppliedMessage" + uniqueComponentId,
        "title": filterHoverTitle
	}).html(filterAppliedText)[ 0 ];
};

/**
 * Creates the component title section for a component
 * @param {MPageComponent} component the component for which we are creating the title (either just the label or an
 *     anchor)
 * @returns {Object} The DOM element for the component title
 */
RenderStrategy.prototype.createComponentTitle = function() {
    var componentTitleContainer = $("<span></span>").addClass(this.componentStyle.getTitle());

	// Create the component anchor
	this.addComponentSection(componentTitleContainer, this.createComponentAnchor());

	// Create the component loading section
	this.addComponentSection(componentTitleContainer, this.createComponentSubTitleSection());

	// Try adding the plus add control
	this.addComponentSection(componentTitleContainer, this.createPlusAddControl());

	// Try adding the header dropdown menu
	this.addComponentSection(componentTitleContainer, this.createHeaderDropdown());

	return componentTitleContainer[ 0 ];
};

/**
 * Creates the basic component header
 * @param {MPageComponent} component the component for which we are creating the header
 * @returns {Object} A DOM element for the component header
 */
RenderStrategy.prototype.createComponentHeader = function() {
	// Create the header shell
    var header = $("<h2></h2>").addClass(this.componentStyle.getHeaderClass());

	// Add the title to the header
	this.addComponentSection(header, this.createComponentTitle());

	return header[ 0 ];
};

/**
 * Creates the component lookback menu. They are vastly different between
 * summary and workflow views and are located in different areas, so we just
 * return nothing in the base class
 * @returns {null} This function returns null
 */
RenderStrategy.prototype.createComponentLookback = function() {
	return null;
};

/**
 * Creates the component options control found in the header.
 * the component
 * @param {MPageComponent} component the component for which we are creating menu option control
 * @returns {Object} the DOM element for the component options menu
 */
RenderStrategy.prototype.createComponentOptionsMenu = function() {
    return $("<span></span>").addClass("opts-menu menu-hide").attr("id", "mainCompMenu" + this.componentId).html("&nbsp")[ 0 ];
};

/**
 * Creates the header drop down controls
 * @param {Object} appendTo the DOM element we are appending the menu to (should be header)
 * @param {MPageComponent} component the component we are using to build the menu
 * @returns {Array<Object>} the DOM elements for the component header drop-down menu
 */
RenderStrategy.prototype.createHeaderDropdown = function() {
	var component = this.component;
	var headerMenuItem = null;
	var iViewItems = this.component.getIViewMenuItems();
	var menu = null;
	var menuItems = this.component.getMenuItems();
	var uniqueComponentId = this.getComponentId();
	var x = 0;
	var xl = 0;
	var item;

	// Disable the drop down arrow for the time being, if the MPage opened outside of PowerChart.
	if(!CERN_Platform.inMillenniumContext() || ((!menuItems || !menuItems.length) && (!iViewItems || !iViewItems.length))) {
		return null;
	}

	// Create the header menu
    var headerMenu = new Menu("headerMenu" + uniqueComponentId);
    headerMenu.setTypeClass("header-dropdown-menu");
    headerMenu.setLabel("Header Menu");
    headerMenu.setAnchorElementId("headerMenu" + uniqueComponentId);
    headerMenu.setAnchorConnectionCorner([ "bottom", "left" ]);
    headerMenu.setContentConnectionCorner([ "top", "left" ]);
	headerMenu.setIsRootMenu(true);

	// Helper function to launch menu and prevent closure
	function launchMenuSelection(itemId) {
		return function() {
			component.openDropDown(itemId);
		};
	}

	// Helper function to launch an IView Menu selection and prevent closure
	function launchIViewMenuSelection(sBandName, sSectionName, sItemName) {
		return function() {
			var criterion = component.getCriterion();
			var taskDocLink = new TaskDocLink(); // eslint-disable-line
			taskDocLink.isAvailable().then(function(isAvailable){
				if(!isAvailable){
					logger.logWarning("TASKDOC is not available");
					return null;
				}
				return taskDocLink.launchIView(sBandName, sSectionName, sItemName, criterion.person_id, criterion.encntr_id); // eslint-disable-line new-cap
			}).catch(function(error) {
				logger.logJSError(error, this, "render-strategy.js", "launchIViewMenuSelection");
			});
		};
	}

	var addOptionsLabel = i18n.discernabu.render_strategy.ADD_OPTIONS.replace("{0}", this.component.getLabel());
	menu = $("<a role='button'></a>").attr({ "id": "headerMenu" + uniqueComponentId, "aria-label": addOptionsLabel, title: addOptionsLabel }).addClass("drop-Down");
	var menuDropDownIcon = $("<span></span>").addClass("drop-down-ctrl");
	menu.append(menuDropDownIcon);
	$(menuDropDownIcon).click(function() {
		if(!headerMenu.isActive()) {
			MP_MenuManager.showMenu("headerMenu" + uniqueComponentId);
		}
		else {
			MP_MenuManager.closeMenuStack(true);
		}
	});

	// Create the regular menu items
	if(menuItems && menuItems.length) {
		for(x = 0, xl = menuItems.length; x < xl; x++) {
			item = menuItems[ x ];

			// Create a menu item and add it to the header menu
            headerMenuItem = new MenuSelection("headerMenuItem" + uniqueComponentId + "-" + x);
			headerMenuItem.setCloseOnClick(true);
			headerMenuItem.setLabel(item.getDescription());
			headerMenuItem.setClickFunction(launchMenuSelection(item.getId()));
			headerMenu.addMenuItem(headerMenuItem);
		}
	}
	// Create the IView Menu Items
	if(iViewItems && iViewItems.length) {
		if(menuItems && menuItems.length) {
            headerMenu.addMenuItem(new MenuSeparator("headerMenuSeparator" + uniqueComponentId));
		}
		var sDisplayName;
		var sBandName;
		var sSectionName;
		var sItemName;
		// Iterate over each Band and associate IView Sections and Items
		for(x = 0, xl = iViewItems.length; x < xl; x++) {
			item = iViewItems[ x ];
			var itemValTypeFlag = item.getValTypeFlag();
			// If this IView item is a Band
			if(itemValTypeFlag === 1) {
				sDisplayName = item.getDescription();
				sBandName = sDisplayName.toLowerCase();
                sDisplayName = sDisplayName.replace(/'/g, "");
                sSectionName = "";
                sItemName = "";
				// Iterate back over the items, finding Sections and Items belonging to the Band
				for(var y = 0, yl = iViewItems.length; y < yl; y++) {
					var secItem = iViewItems[ y ];
					// If the values returned by getValueSequence match, the secItem belongs to the Band
					// If valTypeFlag = 2, the secItem is an IView Section. If valTypeFlag = 3, the secItem is an IView
					// Item
					if(secItem.getValSequence() === item.getValSequence()) {
						if(secItem.getValTypeFlag() === 2) {
							sSectionName = secItem.getDescription();
						}
						else if(secItem.getValTypeFlag() === 3) {
							sItemName = secItem.getDescription();
						}
					}
				}

                headerMenuItem = new MenuSelection("iViewHeaderMenuItem" + uniqueComponentId + "-" + x);
				headerMenuItem.setCloseOnClick(true);
				headerMenuItem.setLabel(sDisplayName);
				headerMenuItem.setClickFunction(launchIViewMenuSelection(sBandName, sSectionName, sItemName));
				headerMenu.addMenuItem(headerMenuItem);
			}
		}
	}

	MP_MenuManager.updateMenuObject(headerMenu);

	return menu;
};

/**
 * Creates the component anchor
 * @param {MPageComponent} component the component we are using to build an anchor
 * @returns {Object} the DOM element for the component title text: either an anchor or just plain label
 */
RenderStrategy.prototype.createComponentAnchor = function() {
	var tabLink = this.component.getLink();
    var componentTitle = $("<span class='comp-title'></span>");
	if(!tabLink || !CERN_Platform.inMillenniumContext()) {
		componentTitle.html(this.component.getLabel());
		return componentTitle;
	}
	else {
        var linkTitle = this.i18nCore.GO_TO_TAB.replace("{0}", tabLink);
        linkTitle = linkTitle.replace(/'/g, "&#39");
        var sAnchor = $("<a id=" + this.componentStyle.getLink() + " title='" + linkTitle.replace(/'/g, "&#96") + "' href='#'>" + this.component.getLabel() + "</a>");
		sAnchor.click(function() {
			// Calls the onTitleClick function which specifies the tab to navigate to on click.
			// The header link can now be overwritten at the component level with component.setLink.
			this.component.onTitleClick();
		}.bind(this));
		componentTitle.html(sAnchor);
		return componentTitle;
	}
};

/**
 * Creates the component body (or content) section, also on web view component body hides on smaller screens.
 * @param {MPageComponent} component the component for which we are building the body
 * @returns {Object} the DOM element for the component content section (body)
 */
RenderStrategy.prototype.createComponentBody = function() {
	var sectionContent = $("<div></div>")
		.attr("id", this.componentStyle.getContentId())
		.addClass(this.componentStyle.getContentClass());
	return sectionContent[ 0 ];
};

/**
 * Creates the component DIV structure. This used to be done via CreateCompDiv
 * @param {MPageComponent} component the component for which we are creating the DIV
 * @returns {Object} the entire component shell, formerly built by CreateCompDiv
 */
RenderStrategy.prototype.createComponentShell = function() {
	// Store the component that we're working on, so we don't have to keep passing it?
	// this.setComponent(component);
	// Attempt to create and add all of the component sections
	try {
		if(!this.component || !MPageComponent.prototype.isPrototypeOf(this.component)) {
            throw new Error("Passed something other than MPageComponent to createComponentShell");
		}

		// Create the base component container
		var container = this.createComponentContainer();
		// Add component header
		this.addComponentSection(container, this.createComponentHeader());
		// Add the component-sub header (if there is one)
		this.addComponentSection(container, this.createComponentSubHeader());
		// Add the component accordion (if there is one)
		this.addComponentSection(container, this.createComponentAccordion());
		// Add the component notifications section
		this.addComponentSection(container, this.createComponentNotificationsSection());
		// Add component body
		this.addComponentSection(container, this.createComponentBody());
		// Add component footer
		this.addComponentSection(container, this.createComponentFooter());
		// Return the generated component container
		return container;
	}
	catch(err) {
        logger.logJSError(err, null, "render_strategy.js", "createComponentShell");
		return null;
	}
};

RenderStrategy.prototype.createComponentSubHeader = function() {
	return null;
};

/**
 * Utility function to help append component sections. componentSection can either be an array of
 * DOM elements, or just a single item
 * @param {Object} container the element we are appending componentSection to
 * @param {Object} componentSection the content we are adding to the container element
 * @returns {undefines} This function does not return a value
 */
RenderStrategy.prototype.addComponentSection = function(container, componentSection) {
	var section = $(componentSection);
	if(container && $(container).length && section && section.length) {
		section.each(function(index, element) {
			$(element).appendTo(container);
		});
	}
};

/**
 * This function creates a component filter (found in the accordion)
 * @returns {Object} An HTMl DOM element for the component filter
 */
RenderStrategy.prototype.createComponentFilter = function() {
	var rComponent = this.getComponentToRender();
	var uniqueComponentId = this.getComponentId();
	var self = this;
	var namespace = this.componentNamespace;
	var facilityDefinedDisplay = this.i18nCore.FACILITY_DEFINED_VIEW;
	var selectedFilterDisplay = facilityDefinedDisplay;
	var esIndex;

	function createFilterMenuItem(eventSetIndex, label) {
        var menuItem = new MenuSelection("filterMenuItem" + uniqueComponentId + "-" + eventSetIndex);
		menuItem.setLabel(label);
		menuItem.setCloseOnClick(true);
		menuItem.setClickFunction(handleFilterClick(menuItem, eventSetIndex, label));
		if(label === selectedFilterDisplay) {
			menuItem.setIsSelected(true);
		}
		return menuItem;
	}

	function updateFilterAppliedSection(filterHoverTitle) {
        var filterAppliedSection = $("#filterAppliedMessage" + uniqueComponentId);
        filterAppliedSection.attr("title", filterHoverTitle);
        filterAppliedSection.html((filterHoverTitle === facilityDefinedDisplay) ? "" : self.i18nCore.FILTER_APPLIED);
	}

	function handleFilterClick(selectedMenuItem, eventSetIndex, label) {
		return function() {
			if(selectedMenuItem.isSelected()) {
				return;
			}
			var codeList = null;
			var catCodeList = null;
			var eventSetList = null;

			var menuItems = filterMenu.getMenuItemArray();
			for(var i = 0; i < menuItems.length; i++) {
				menuItems[ i ].setIsSelected(false);
			}
			selectedMenuItem.setIsSelected(true);


			// Replace the text of the menu to reflect the selected filter
            $("#selectedFilter" + uniqueComponentId).html(label);
			updateFilterAppliedSection(label);

			// Handle the grouper filter/category depending on the namespace
            if(namespace === "ohx" || namespace === "ohx2") {
				catCodeList = rComponent.getGrouperCatalogCodes(eventSetIndex);
				rComponent.setGrouperFilterCatLabel(label);
				rComponent.setGrouperFilterCatalogCodes(catCodeList);
				codeList = catCodeList;
			}
			else {
				eventSetList = rComponent.getGrouperCriteria(eventSetIndex);
				rComponent.setGrouperFilterLabel(label);
				rComponent.setGrouperFilterCriteria(eventSetList);
				codeList = eventSetList;
			}
			// If this is the facility defined display, reset both to null and handle component refresh, otherwise call
			// the filter refresh
			if(label === facilityDefinedDisplay) {
				rComponent.setGrouperFilterCriteria(null);
				rComponent.setGrouperFilterCatalogCodes(null);
				// Tell the component to fetch its data again
				rComponent.startComponentDataRetrieval();
			}
			else {
				rComponent.FilterRefresh(label, codeList); // eslint-disable-line new-cap
			}
		};
	}

	rComponent.sortGrouperArrayByLabel();

	if(rComponent.getGrouperFilterCriteria()) {
		selectedFilterDisplay = rComponent.getGrouperFilterLabel();
	}
	if(rComponent.getGrouperFilterCatalogCodes()) {
		selectedFilterDisplay = rComponent.getGrouperFilterCatLabel();
	}

	// Create the drop-down for component filter
    var filterDropDownMenu = $("<div></div>").addClass("acc-mnu").attr("id", "filterDropDownMenu" + uniqueComponentId);

    var filterLabel = $("<span></span>").addClass("filter-label").html(this.i18nCore.FILTER_LABEL);
    var selectedFilterText = $("<span></span>").addClass("selected-filter").attr("id", "selectedFilter" + uniqueComponentId).html(selectedFilterDisplay);
    var filterDropDownArrow = $("<div></div>").addClass("filter-arrow").attr("id", "filterMenu" + uniqueComponentId);


	// Append the dom elements to create the menu structure
	filterDropDownMenu.append(filterLabel);
	filterDropDownMenu.append(selectedFilterText);
	filterDropDownMenu.append(filterDropDownArrow);

    var filterMenu = new Menu("filterMenu" + uniqueComponentId);
    filterMenu.setTypeClass("filter-menu");
    filterMenu.setAnchorElementId("filterMenu" + uniqueComponentId);
    filterMenu.setAnchorConnectionCorner([ "bottom", "left" ]);
    filterMenu.setContentConnectionCorner([ "top", "left" ]);
	filterMenu.setIsRootMenu(true);

	// Add the facility defined display item into the filter menu
    filterMenu.addMenuItem(createFilterMenuItem("", facilityDefinedDisplay));

	// Append the additional filters to the menu content box
	var groupLength = rComponent.m_grouper_arr.length;
	for(var z = 0, c = 0; c < groupLength && z < 10; z++) {
		if(rComponent.getGrouperLabel(z)) {
			c++;
			esIndex = z;
			filterMenu.addMenuItem(createFilterMenuItem(esIndex, rComponent.getGrouperLabel(z)));
		}
		if(rComponent.getGrouperCatLabel(z)) {
			c++;
			esIndex = z;
			filterMenu.addMenuItem(createFilterMenuItem(esIndex, rComponent.getGrouperCatLabel(z)));
		}
	}
	// Handle clicking the drop-down arrow to toggle the menu content-box
	filterDropDownArrow.click(function() {
		if(!filterMenu.isActive()) {
            MP_MenuManager.showMenu("filterMenu" + uniqueComponentId);
		}
		else {
			MP_MenuManager.closeMenuStack(true);
		}
	});
	MP_MenuManager.updateMenuObject(filterMenu);
	return filterDropDownMenu;
};

/**
 * This function creates the component accordion and renders any necessary
 * elements within.
 * @returns {Object} The DOM element representing the component accordion
 */
RenderStrategy.prototype.createComponentAccordion = function() {
	var rComponent = this.getComponentToRender();
	var mnuCompId = rComponent.getComponentId();
	var uniqueComponentId = this.getComponentId();

	// Check if the component has any grouper filters
	function hasFilters() {
		for(var y = 0; y < 10; y++) {
			// If we find any groups, return true
			if(rComponent.getGrouperLabel(y) || rComponent.getGrouperCatLabel(y)) {
				return true;
			}
		}
		// We have reached the end, and have found no groups, then return false
		return false;
	}

	// If we have no filters, return nothing
	if(!hasFilters()) {
		return null;
	}

	// Create the accordion container
    var accordionContainer = $("<div></div>").addClass("accordion-container").attr("id", "AccordionContainer" + mnuCompId);
    var accordionContent = $("<div></div>").addClass("accordion-content").attr("id", "Accordion" + mnuCompId + "Content");
    var accordionContentDiv = $("<div></div>").addClass("acc-content-div").attr("id", "accordion-content-div-" + uniqueComponentId);
    var accordionTitle = $("<div></div>").addClass("accordion-title").attr("id", "Accordion" + mnuCompId + "Title");

	// Call to create the component filter
	// accordionContentDiv.append(this.createComponentFilter());
	this.addComponentSection(accordionContentDiv, rComponent.createAccordionContent());
	this.addComponentSection(accordionContentDiv, rComponent.createAccordionControls());

	accordionTitle.click(function() {
		MP_Util.Doc.RunAccordion(mnuCompId); // eslint-disable-line new-cap
	}); // eslint-disable-line new-cap

	// Create the structure by appending the elements created above
	accordionContainer.append(accordionContent);
	accordionContainer.append(accordionTitle);

	accordionContent.append(accordionContentDiv);

	return accordionContainer;
};

/**
 * Creates the component footer (if available), otherwise returns false
 * @param {MPageComponent} component the component for which we are creating the footer
 * @returns {Object} If the component has a footer, returns the DOM element for the footer, otherwise
 * returns false.
 */
RenderStrategy.prototype.createComponentFooter = function() {
	var footerText = this.component.getFooterText();
    if(footerText && footerText !== "") {
        return $("<div></div>").addClass("sec-footer").html(footerText)[ 0 ];
	}
	return null;
};

/**
 * This function acts as a placeholder which is overridden in WorkflowRenderStrategy
 * @returns {null} null
 */
RenderStrategy.prototype.createComponentNotificationsSection = function() {
	return null;
};
/* globals CapabilityTimer*/

/**
 * A static helper class for performing resultRangeSelection operations
 * @constructor
 */
function ResultRangeSelectionUtility() {

}

/**
 * Enumeration items for ResultRangeDirection.
 * Direction for result range, BACKWARD for lookback in the result range and FORWARD for lookahead in the result range
 */

ResultRangeSelectionUtility.direction = {
    BACKWARD: 0,
    FORWARD: 1
};

/**
 * ResultRangeSelection type for custom items
 * A custom type has a value 6. It is a special lookback option that doesn't refer to a time frame.
 */
ResultRangeSelectionUtility.CustomType = 6;

/**
 * This function is used to capture the result range selection
 * @param {MPageComponent} component The component whose lookback selection was chosen
 * @param {ResultRangeSelection} resultRangeSelection The result range value selection made
 * @param {boolean} defaultSelection An indicator to determine if this result range selection was the default or chosen by the user
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelectionUtility.captureResultRangeSelectionDetails = function(component, resultRangeSelection, defaultSelection) {
    var rangeDetails;
    var rangeInfo;

    // Create the rangeDetails JSON to add as meta data
    rangeInfo = {
        defaultSelection: defaultSelection,
        scope: this.getScopeString(component.getScope()),
        selection: this.getDisplayText(resultRangeSelection)
    };

    // Create the capability timer to capture all of these details
    rangeDetails = new CapabilityTimer("CAP:MPG Component Lookback Selection", component.getReportMean());
    rangeDetails.addMetaData("rangeDetails", JSON.stringify(rangeInfo));
    rangeDetails.capture();
};

/**
 * This function determines if the component should refresh
 * @param {MPageComponent} component Component that we're determining if it should refresh
 * @param {ResultRangeSelection} resultRangeSelection ResultRangeSelection we're comparing with the component's current
 *     resultRangeSelection to determine if refresh is necessary
 * @returns {Boolean} True if the component needs to refresh, false otherwise
 */
ResultRangeSelectionUtility.shouldComponentRefresh = function(component, resultRangeSelection) {
    return (component.getLookbackUnits() !== resultRangeSelection.getUnits() || component.getLookbackUnitTypeFlag() !== resultRangeSelection.getType());
};

/**
 * Refreshes a component with a new resultRangeSelection
 * @param {MPageComponent} component Component we're refreshing
 * @param {ResultRangeSelection} resultRangeSelection ResultRangeSelection item that is clicked
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelectionUtility.refreshComponentWithNewResultRangeSelection = function(component, resultRangeSelection) {
    component.setLookbackUnits(resultRangeSelection.getUnits());
    component.setLookbackUnitTypeFlag(resultRangeSelection.getType());
    component.setResultRangeDirection(resultRangeSelection.getDirection());
    component.showLoading();
    // Notifies whoever is listening that we need to remove the count
    CERN_EventListener.fireEvent(component, component, EventListener.EVENT_COUNT_UPDATE, {
        "count": null
    });

    // Tell the component to fetch its data again
    component.startComponentDataRetrieval();

    // Capture the lookback selection information since the selection has changed
    this.captureResultRangeSelectionDetails(component, resultRangeSelection, false);
};

/**
 * Gets a display text based on the scope
 * @param {Number} scope 1 for All Visits - Across all encoutners or 2 for Selected Visit - a specific single encounter.
 * @returns {String} a display text based upon the scope passed in
 */
ResultRangeSelectionUtility.getScopeString = function(scope) {
    switch(scope) {
        case 1:
            return i18n.discernabu.All_VISITS;
        case 2:
            return i18n.discernabu.SELECTED_VISIT;
        default:
            return "";
    }
};

/**
 * Gets a display text based on the resultRangeSelectionType and resultRangeSelectionUnits for custom
 * ResultRangeSelection. if display text has resultRangeSelectionUnits>0(e.g. LAST 50 REPORTS) input
 * resultRangeSelectionType should be in LAST {0} REPORTS if resultRangeSelectionUnits are 0, provided string will be
 * displayed as it is.
 * @param {String} resultRangeSelectionType ResultRangeSelection display string for a component (LATEST, LAST {0}
 *     REPORTS, any custom string)
 * @param {Number} resultRangeSelectionUnits ResultRangeSelection units for a component
 * @returns {String} the display text based on the resultRangeSelection type and units
 */
ResultRangeSelectionUtility.getCustomDisplayString = function(resultRangeSelectionType, resultRangeSelectionUnits) {
    if(resultRangeSelectionUnits > 0) {
        return resultRangeSelectionType.replace("{0}", resultRangeSelectionUnits);
    }
    else {
        return resultRangeSelectionType;
    }
};
/**
 * Gets a display text based on the resultRangeSelectionType and resultRangeSelectionUnits
 * @param {Number} resultRangeSelectionType ResultRangeSelection type for a component (months, days, etc)
 * @param {Number} resultRangeSelectionUnits ResultRangeSelection units for a component
 * @returns {String} the display text based on the resultRangeSelection type and units
 */
ResultRangeSelectionUtility.getDisplayString = function(resultRangeSelectionType, resultRangeSelectionUnits) {
    switch(resultRangeSelectionType) {
        case 1:
            return i18n.discernabu.LAST_N_HOURS.replace("{0}", resultRangeSelectionUnits);
        case 2:
            return i18n.discernabu.LAST_N_DAYS.replace("{0}", resultRangeSelectionUnits);
        case 3:
            return i18n.discernabu.LAST_N_WEEKS.replace("{0}", resultRangeSelectionUnits);
        case 4:
            return i18n.discernabu.LAST_N_MONTHS.replace("{0}", resultRangeSelectionUnits);
        case 5:
            return i18n.discernabu.LAST_N_YEARS.replace("{0}", resultRangeSelectionUnits);
        default:
            return i18n.discernabu.LAST_N_DAYS.replace("{0}", resultRangeSelectionUnits);
    }
};

/**
 * Gets a full display text based on the scope, resultRangeSelection type, and resultRangeSelection units
 * @param {Number} scope 1 for All Visits - Across all encoutners or 2 for Selected Visit - a specific single
 *     encounter.
 * @param {Number} resultRangeSelectionType ResultRangeSelection type of the component
 * @param {Number} resultRangeSelectionUnits ResultRangeSelection units of the component
 * @returns {String} the full display text of the component resultRangeSelection based on scope, resultRangeSelection
 *     type, and resultRangeSelection units
 */
ResultRangeSelectionUtility.getFullDisplayString = function(scope, resultRangeSelectionType, resultRangeSelectionUnits) {
    var resultRangeSelectionText = "";
    var i18nCore = i18n.discernabu;
    if(resultRangeSelectionType > 0 && resultRangeSelectionUnits > 0) {
        resultRangeSelectionText = ResultRangeSelectionUtility.getDisplayString(resultRangeSelectionType, resultRangeSelectionUnits);
        switch(scope) {
            case 1:
                resultRangeSelectionText = i18nCore.ALL_N_VISITS.replace("{0}", resultRangeSelectionText);
                break;
            case 2:
                resultRangeSelectionText = i18nCore.SELECTED_N_VISIT.replace("{0}", resultRangeSelectionText);
                break;
        }
    }
    else {
        resultRangeSelectionText = ResultRangeSelectionUtility.getScopeString(scope);
    }
    return resultRangeSelectionText;
};


/**
 * Gets a full display text based for provided resultRangeSelectionItem
 * @param {ResultRangeSelection} resultRangeSelectionItem Items for which display text is needed
 * @returns {String} the display text of the component
 */
ResultRangeSelectionUtility.getDisplayText = function(resultRangeSelectionItem) {
    var lookbackType = resultRangeSelectionItem.getType();
    var lookbackValue = resultRangeSelectionItem.getUnits();
    var scope = resultRangeSelectionItem.getScope();
    if(lookbackType === ResultRangeSelectionUtility.CustomType) {
        return ResultRangeSelectionUtility.getCustomDisplayString(resultRangeSelectionItem.getDisplay(), lookbackValue);
    }
    else {
        // it's something else
        if(lookbackValue > 0 && lookbackType > 0) {
            return ResultRangeSelectionUtility.getDisplayString(lookbackType, lookbackValue);
        }
        else {
            return ResultRangeSelectionUtility.getScopeString(scope);
        }
    }
};

/**
 * This function creates custom ResultRangeSelection and adds it to the
 * look back menu items of the provided component. Function should be called from
 * the preProcessing function of the component so that when component is rendered, newly added
 * custom ResultRangeSelection will be displayed. While rendering of ResultRangeSelection,
 * result range direction will be set in component and can be accessed via getResultRangeDirection()
 * of the component. This function handles the display part of the the ResultRangeSelection and
 * then by using getLookbackUnits(), getLookbackUnitTypeFlag() and getResultRangeDirection() you can
 * retrieve required information in retrieveComponentData function of the component.
 *
 * @param {MPageComponent} component Component on which custom result range selection item needs to be added
 * @param {ResultRangeSelection} customResultRangeSelectionItem Custom ResultRangeSelection item which needs to be added
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelectionUtility.addCustomResultRangeSelectionItem = function(component, customResultRangeSelectionItem) {
    var resultRangeSelectionItems = component.getLookbackMenuItems() || [];
    var resultRangeSlectionItem = null;
    customResultRangeSelectionItem.setDisplay(ResultRangeSelectionUtility.getDisplayText(customResultRangeSelectionItem));
    if(resultRangeSelectionItems.length) {
        // Take the default and push it to the front and then add customResultRangeSelectionItem item
        resultRangeSelectionItems.unshift(resultRangeSelectionItems.pop());
        resultRangeSelectionItems.push(customResultRangeSelectionItem);
    }
    else {
        resultRangeSlectionItem = new ResultRangeSelection();
        // No lookback options defined so we need to act like there are
        if(component.getBrLookbackUnits() === 0 && component.getBrLookbackUnitTypeFlag() === 0) {
            // If neither the br lookback units or type are selected we are
            // looking across all of the current encounter or across all encounters
            resultRangeSlectionItem.setUnits(0);
            resultRangeSlectionItem.setScope(component.getScope());
            resultRangeSlectionItem.setType(component.getScope());
        }
        else {
            resultRangeSlectionItem.setUnits(component.getBrLookbackUnits());
            resultRangeSlectionItem.setScope(component.getScope());
            resultRangeSlectionItem.setType(component.getBrLookbackUnitTypeFlag());
        }
        resultRangeSlectionItem.setDisplay(ResultRangeSelectionUtility.getDisplayText(resultRangeSlectionItem));
        resultRangeSelectionItems.push(resultRangeSlectionItem, customResultRangeSelectionItem);
    }
    // Replace the existing menu item list with the new one
    component.setLookbackMenuItems(resultRangeSelectionItems);
};


/**
 * A container object for component reresultRangeSlectionItemeSelection items
 * Following points should be considered while creating custom ResultRangeSelection objects
 * type of the custom object should be 6 (ResultRangeSelectionUtility.CustomType)
 * units can be number >= 0
 * display if you want to include units in the display string such as LAST 50 NOTES,
 * in this case display should be in format LAST {0} NOTES and provide units using setUnits. It will replace
 * {0} with provided units.Notice here,if you want to add multiplier any where in the string you just need to
 * provide string consisting of {0} in place of count. If you want to display your string as it is(without any change
 * or replacement), provide set display with string you want and set units as 0.It is assumed here that provided string
 * is already internationalized. Scope would be generally the scope of the component Direction can
 * 0(ResultRangeSelectionUtility.direction.BACKWARD) for lookback and 1(ResultRangeSelectionUtility.direction.FORWARD)
 * for lookahead
 * @returns {undefined} This function does not return a value
 */
function ResultRangeSelection() {
    this.type = null;
    this.units = null;
    this.display = "";
    this.scope = null;
    this.direction = 0;
}

/**
 * Gets the resultRangeSelection unit type for the resultRangeSelection item
 * @returns {Number} the resultRangeSelection unit type flag
 */
ResultRangeSelection.prototype.getType = function() {
    return this.type;
};

/**
 * Sets the resultRangeSelection unit type for the resultRangeSelection item
 * @param {Number} type ResultRangeSelection unit type
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setType = function(type) {
    this.type = type;
};

/**
 * Gets the resultRangeSelection units for the resultRangeSelection item
 * @returns {Number} the resultRangeSelection units for the resultRangeSelection item
 */
ResultRangeSelection.prototype.getUnits = function() {
    return this.units;
};

/**
 * Sets the resultRangeSelection units for the resultRangeSelection item if the value is greater than or equal to zero
 * @param {Number} units ResultRangeSelection units for the resultRangeSelection item
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setUnits = function(units) {
    if(units >= 0) {
        this.units = units;
    }
};

/**
 * Gets the display for the resultRangeSelection item
 * @returns {String} the display for the resultRangeSelection item
 */
ResultRangeSelection.prototype.getDisplay = function() {
    return this.display;
};

/**
 * Sets the display for the resultRangeSelection item
 * @param {String} display Display for the resultRangeSelection item
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setDisplay = function(display) {
    this.display = display;
};

/**
 * Gets the scope of the resultRangeSelection item
 * @returns {Number} the scope of the resultRangeSelection item
 */
ResultRangeSelection.prototype.getScope = function() {
    return this.scope;
};

/**
 * Sets the scope of the resultRangeSelection item
 * @param {Number} scope Scope of the resultRangeSelection item
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setScope = function(scope) {
    this.scope = scope;
};

/**
 * Gets the direction of the resultRangeSelection item
 * @returns {Number} the direction of the resultRangeSelection item
 */
ResultRangeSelection.prototype.getDirection = function() {
    return this.direction;
};

/**
 * Sets the direction of the resultRangeSelection item
 * @param {Number} direction Direction of the resultRangeSelection item
 * @returns {undefined} This function does not return a value
 */
ResultRangeSelection.prototype.setDirection = function(direction) {
    this.direction = direction;
};
/* globals RenderStrategy, ResultRangeSelectionUtility */

/**
 * The SummaryRenderStrategy object
 * This object is used to create standard summary component html structures. It inherits from the base
 * RenderStrategy object. Please see that artifact for available methods to override.
 * @constructor
 * @author Will Reynolds
 */
function SummaryRenderStrategy() {
}

SummaryRenderStrategy.prototype = new RenderStrategy();
SummaryRenderStrategy.prototype.constructor = RenderStrategy;

/**
 * Overrides the RenderStrategy createComponentHeader method to add additional summary specific content to the header
 * Note that some controls appear to be added in the wrong order, but this is necessary, as the component
 * styling requires that they be added in this order.
 * @returns {Object} the DOM element for the component header.
 */
SummaryRenderStrategy.prototype.createComponentHeader = function() {
    //Create the header shell
    var header = $("<h2></h2>").addClass(this.componentStyle.getHeaderClass());

    //Add the toggle control
    this.addComponentSection(header, this.createComponentToggleControl());

    //Add the component options menu (color / default expanded / etc)
    this.addComponentSection(header, this.createComponentOptionsMenu());

    //Add the title to the header
    this.addComponentSection(header, this.createComponentTitle());

    return header[ 0 ];
};

/**
 * Overrides the RenderStrategy method for creating the component sub-header. Note
 * that this method uses the createComponentLookback function, as the component's lookback
 * exists in the sub-header in summary pages.
 * @returns {Object} The DOM object representing the component's sub-header.
 */
SummaryRenderStrategy.prototype.createComponentSubHeader = function() {
    var rComponent = this.component;
    var scope = rComponent.getScope();
    var uniqueComponentId = this.getComponentId();
    //If the scope is 3, we have a custom component subheader, otherwise, we add the lookback menu
    if(scope === 3) {
        return rComponent.getScopeHTML();
    }
    else if(scope > 0) {
        //Create html elements
        var subHeaderMenu = $("<div></div>").attr("id", "lb" + uniqueComponentId + "Mnu");
        var subHeader = $("<div></div>").addClass("sub-title-disp").attr("id", "stt" + uniqueComponentId);
        subHeaderMenu.append(subHeader);
        subHeader.append(this.createComponentLookback());
        return subHeaderMenu;
    }
};

/**
 * Creates the component toggle control found in the header. This control handles expanding/collapsing
 * the component
 * @param {MPageComponent} component the component for which we are creating the toggle control
 * @returns {Object} the DOM element for the component toggle control
 */
SummaryRenderStrategy.prototype.createComponentToggleControl = function() {
    //If component is always expanded, we do not create the toggle control
    if(this.component.isAlwaysExpanded()) {
        return null;
    }
    var hideLabel = i18n.discernabu.render_strategy.HIDE_SECTION.replace("{0}",this.component.getLabel()); 
    return $("<span role='button'></span>").addClass(this.componentStyle.getHeaderToggle()).attr({"title": hideLabel, "aria-label": hideLabel})[ 0 ];
};

/**
 * Creates the component options control found in the header.
 * the component
 * @param {MPageComponent} component the component for which we are creating menu option control
 * @returns {Object} the DOM element for the component options menu
 */
SummaryRenderStrategy.prototype.createComponentOptionsMenu = function() {
    var menuLabel = i18n.discernabu.render_strategy.MENU.replace("{0}", this.component.getLabel()); 
    return $("<span role='button'></span>").addClass("opts-menu menu-hide").attr({"id": "mainCompMenu" + this.componentId, "aria-label": menuLabel, title: menuLabel }).html("&nbsp")[ 0 ];
};

/**
 * This function overrides the RenderStrategy method for creating the component lookback controls.
 * @returns {Object} the DOM object representing the component's lookback controls
 */
SummaryRenderStrategy.prototype.createComponentLookback = function() {
    var rComponent = this.getComponentToRender();
    var lookbackItems = rComponent.getLookbackMenuItems();
    var uniqueComponentId = this.getComponentId();
    var scope = rComponent.getScope();
    var staticContentLocation = rComponent.getCriterion().static_content;
    var foundDefault = false;

    //Helper function to handle clicking a lookback item in the lookback menu
    function handleLookbackClick(menuItem, lookbackItem) {
        return function() {
            if(!ResultRangeSelectionUtility.shouldComponentRefresh(rComponent, lookbackItem)) {
                return;
            }
            //Uncheck all menu items
            var menuItems = lookbackMenu.getMenuItemArray();
            for(var i = 0; i < menuItems.length; i++) {
                menuItems[ i ].setIsSelected(false);
            }
            //Check the menu item you selected
            menuItem.setIsSelected(true);
            //Make the call to refresh the component with the new lookback
            ResultRangeSelectionUtility.refreshComponentWithNewResultRangeSelection(rComponent, lookbackItem);
            //Toggle the lookback display
            $("#lookbackDisplay" + uniqueComponentId).html(lookbackItem.getDisplay());
        };
    }

    var lookbackDays = rComponent.getLookbackDays();
    var lookbackUnits = (lookbackDays > 0) ? lookbackDays : rComponent.getLookbackUnits();
    var lookbackFlag = (lookbackDays > 0) ? 2 : rComponent.getLookbackUnitTypeFlag();

    var lookbackDisplayText = ResultRangeSelectionUtility.getFullDisplayString(scope, lookbackFlag, lookbackUnits);

    var lookbackContainer = $("<div></div>").attr("id", "lookbackContainer" + uniqueComponentId);
    lookbackContainer.append($("<span></span>").attr("id", "lookbackDisplay" + uniqueComponentId).html(lookbackDisplayText));
    //If we have no lookback items, just add the filter applied section and return what we have
    if(!lookbackItems || !lookbackItems.length) {
        lookbackContainer.append(this.createFilterAppliedSection());
        return lookbackContainer;
    }

    //Create the lookback menu
    var lookbackMenu = new Menu("lookbackMenu" + uniqueComponentId);
    lookbackMenu.setAnchorElementId("lookbackMenu" + uniqueComponentId);
    lookbackMenu.setAnchorConnectionCorner([ "bottom", "left" ]);
    lookbackMenu.setContentConnectionCorner([ "top", "left" ]);
    lookbackMenu.setIsRootMenu(true);

    //Iterate over the lookback menu items and create menu items for them
    var numberOfLookbackItems = lookbackItems.length;
    for(var x = 0; x < numberOfLookbackItems; x++) {
        var lookbackItem = lookbackItems[ x ];
        var lookbackMenuSelector = new MenuSelection("lookbackMenuItem" + uniqueComponentId + "-" + x);
        lookbackMenuSelector.setCloseOnClick(true);
        //If this lookback item is the default, set it to selected
        if(!foundDefault && lookbackItem.getUnits() === lookbackUnits && lookbackItem.getType() === lookbackFlag) {
            foundDefault = true;
            lookbackMenuSelector.setIsSelected(true);

            //Capture the default lookback selection for this component
            ResultRangeSelectionUtility.captureResultRangeSelectionDetails(rComponent, lookbackItem, true);
        }
        lookbackMenuSelector.setLabel(lookbackItem.getDisplay());
        lookbackMenuSelector.setClickFunction(handleLookbackClick(lookbackMenuSelector, lookbackItem));
        lookbackMenu.addMenuItem(lookbackMenuSelector);
    }
    MP_MenuManager.updateMenuObject(lookbackMenu);
    var lookbackDropDown = $("<a></a>").append($("<img>").attr({
        "id": "lookbackMenu" + uniqueComponentId,
        "src": staticContentLocation + "/images/3943_16.gif"
    }));
    lookbackDropDown.click(function() {
        if(!lookbackMenu.isActive()) {
            MP_MenuManager.showMenu("lookbackMenu" + uniqueComponentId);
        }
        else {
            MP_MenuManager.closeMenuStack(true);
        }
    });
    lookbackDropDown.appendTo(lookbackContainer);
    lookbackContainer.append(this.createFilterAppliedSection());
    return lookbackContainer;
};
/* global RenderStrategy, ResultRangeSelectionUtility, ResultRangeSelection, CapabilityTimer, MPageUI */
/**
 * The WorkflowRenderStrategy object
 * This object is used to create workflow component html structures. It inherits from the base
 * RenderStrategy object. Please see that artifact for available methods to override.
 * @constructor
 * @author Will Reynolds
 */
function WorkflowRenderStrategy() {

}

WorkflowRenderStrategy.prototype = new RenderStrategy();
WorkflowRenderStrategy.prototype.constructor = RenderStrategy;

/**
 * Overrides the RenderStrategy method for creating the component header.
 * This function creates the base header, and adds the lookback section.
 * @returns {Object} The DOM object representing the component header
 */
WorkflowRenderStrategy.prototype.createComponentHeader = function() {
    // override the RenderStrategy method to add Requried Indicator besides the component label
    var header = $("<h2></h2>").addClass(this.componentStyle.getHeaderClass());
    if(this.component.getGapCheckCriteria()) {
        this.addComponentSection(header, this.createComponentRequiredIndicator());
    }
    this.addComponentSection(header, this.createComponentTitle());
    var componentHeaderElementsContainer = $("<div></div>").addClass("header-elements-container");
    // Add the component options menu (color / default expanded / etc)
    this.addComponentSection(componentHeaderElementsContainer, this.createComponentOptionsMenu());
    // Add the component refresh button
    this.addComponentSection(componentHeaderElementsContainer, this.createComponentRefreshButton());
    // Add the control that would enable the SplitView in the current Workflow View.
    this.addComponentSection(componentHeaderElementsContainer, this.createComponentContextualViewControl());
    // Add toggle buttons (for switching views and other purposes)
    this.addComponentSection(componentHeaderElementsContainer, this.createHeaderToggles());
    this.addComponentSection(componentHeaderElementsContainer, this.createComponentLookback());

    this.addComponentSection(header, componentHeaderElementsContainer);
    return header[ 0 ];
};

/**
 * This function creates the Required Indicator controls for Gap check functionality
 * @returns {jQuery|string} jQuery object or HTML string of the required Indicator.
 */
WorkflowRenderStrategy.prototype.createComponentRequiredIndicator = function() {
    var requiredIndContainer = null;
    var component = this.component;
    var componentId = component.getComponentId();
    var gapCheckInd = component.getGapCheckRequiredInd();
    var spanClass = (component.getGapCheckBannerDismiss() && gapCheckInd) ? "component-required-ind" : "component-required-ind hidden";
    requiredIndContainer = $("<span class='" + spanClass + "'></span>").attr("id", "reqInd" + componentId).html("&nbsp;");
    var componentRequiredHandler = function() {
        // disable clicks
        requiredIndContainer.off("click");
        // re-enable clicks
        requiredIndContainer.click(componentRequiredHandler);
        requiredIndContainer.addClass("hidden");
        var contentNode = component.getRootComponentNode();
        if(contentNode) {
            component.displayComponentDisclaimerContainer();
            component.setGapCheckBannerDismiss(false);
            component.savePreferences(true);
        }
    };
    requiredIndContainer.click(componentRequiredHandler);
    return requiredIndContainer[ 0 ];
};

/**
 * This function handles the workflow component's section toggles.
 * @returns {jQuery|string} jQuery object or HTML string of the toggles' container.
 */
WorkflowRenderStrategy.prototype.createHeaderToggles = function() {
    return this.component.createHeaderToggles();
};

/**
 * This function handles the workflow sub-header logic.
 * @returns {Object} if the component has a scope of 3, it returns the component's
 * scope html, otherwise returns null.
 */
WorkflowRenderStrategy.prototype.createComponentSubHeader = function() {
    var rComponent = this.component;
    return (rComponent.getScope() === 3) ? rComponent.getScopeHTML() : null;
};

/**
 * This function overrides the RenderStrategy method for creating the component lookback
 * controls.
 * @returns {Object} The DOM object representing the component's lookback controls.
 */
/* eslint-disable complexity*/
WorkflowRenderStrategy.prototype.createComponentLookback = function() {
    var extraLookbackMenu = null;
    var rComponent = this.getComponentToRender();
    var uniqueComponentId = this.getComponentId();
    var hasSelectedMoreOption = false;
    var scope = rComponent.getScope();
    var maxItemsFaceUp = 3;
    var lookbackItems = rComponent.getLookbackMenuItems();
    var lookbackItem;
    var x = 0;

    // Helper function to handle showing/hiding the extra lookback options
    function toggleExtraOptions() {
        if(!extraLookbackMenu.isActive()) {
            MP_MenuManager.showMenu("extraLookbackMenu" + uniqueComponentId);
        }
        else {
            MP_MenuManager.closeMenuStack(true);
        }
    }

    // Helper function to handle when the user clicks one of the face-up lookback buttons
    function handleLookbackClick(lookbackItemSelected) {
        return function() {
            if(!ResultRangeSelectionUtility.shouldComponentRefresh(rComponent, lookbackItemSelected)) {
                return;
            }
            ResultRangeSelectionUtility.refreshComponentWithNewResultRangeSelection(rComponent, lookbackItemSelected);
            $("#lookbackContainer" + uniqueComponentId).find(".lookback-button-active").removeClass("lookback-button-active");
            $(this).addClass("lookback-button-active");
        };
    }

    // Helper function to handle when the user clicks one of the extra lookback options
    function handleExtraLookbackClick(lookbackItemSelected, extraLookbackMenuItem) {
        return function() {
            if(!ResultRangeSelectionUtility.shouldComponentRefresh(rComponent, lookbackItemSelected)) {
                return;
            }
            ResultRangeSelectionUtility.refreshComponentWithNewResultRangeSelection(rComponent, lookbackItemSelected);

            // Store off the values of the lookback item you clicked into the extra button, that way you can click it
            extraLookbackMenuItem.setDisplay(lookbackItemSelected.getDisplay());
            extraLookbackMenuItem.setUnits(lookbackItemSelected.getUnits());
            extraLookbackMenuItem.setType(lookbackItemSelected.getType());

            // If we haven't previously selected a "More" option, then we need to unbind the click event for showing the extra
            // options and bind the click event for handling the lookback
            if(!hasSelectedMoreOption) {
                $("#lookbackMoreOptions" + uniqueComponentId).unbind("click", toggleExtraOptions);
                $("#lookbackMoreOptions" + uniqueComponentId).click(handleLookbackClick(extraLookbackMenuItem));
                hasSelectedMoreOption = true;
            }
            $("#lookbackContainer" + uniqueComponentId).find(".lookback-button-active").removeClass("lookback-button-active");
            $("#lookbackMoreOptions" + uniqueComponentId).html(lookbackItemSelected.getDisplay()).addClass("lookback-button-active");
        };
    }

    // Create a lookback button element
    function createLookbackMenuItemElement(lookbackMenuItem) {
        return $("<div></div>").addClass("lookback-button").html(lookbackMenuItem.getDisplay());
    }

    // Create the container to house the lookback items
    var lookbackContainer = $("<div></div>").attr("id", "lookbackContainer" + uniqueComponentId).addClass("lookback-container");
    // If there are no lookback items, then we just have the default one
    if(!lookbackItems || !lookbackItems.length) {
        var lookbackDays = rComponent.getLookbackDays();
        var lookbackUnits = (lookbackDays > 0) ? lookbackDays : rComponent.getLookbackUnits();
        var lookbackFlag = (lookbackDays > 0) ? 2 : rComponent.getLookbackUnitTypeFlag();

        lookbackContainer.append($("<div></div>").addClass("lookback-spec-period").attr("id", "lookbackDisplay" + uniqueComponentId).html(ResultRangeSelectionUtility.getFullDisplayString(scope, lookbackFlag, lookbackUnits)));
        return lookbackContainer;
    }
    // Make a copy of the array, so we don't alter the original
    lookbackItems = lookbackItems.slice(0);
    // Get the number of lookback items (should always be at least 1)
    var numberOfLookbackItems = lookbackItems.length;
    // Move the default item to the front of the array, so we can perform more trivial operations
    lookbackItems.unshift(lookbackItems.pop());

    // If the default lookback item is either "All encounters - Specified time period" or "Current encounter - Specified time
    // period", we add some text
    if(lookbackItems[ 0 ].getType() !== 0) {
        lookbackContainer.append($("<div></div>").addClass("lookback-spec-period").attr("id", "lookbackDisplay" + uniqueComponentId).html(ResultRangeSelectionUtility.getScopeString(scope) + ":"));
    }

    // Determine the loop control (number of items to add face up)
    var numberItems = Math.min(maxItemsFaceUp, numberOfLookbackItems);

    // Add the face-up menu items
    for(x = 0; x < numberItems; x++) {
        // Create a lookback item container with necessary lookback information (see the LookbackItem class)
        lookbackItem = lookbackItems[ x ];
        var lookbackMenuItem = createLookbackMenuItemElement(lookbackItem);
        // Determine the styling for the lookback item
        lookbackMenuItem.addClass((x === 0) ? "lookback-button-active" : "lookback-button-no-left-border lookback-button-inactive");
        lookbackMenuItem.click(handleLookbackClick(lookbackItem));
        lookbackContainer.append(lookbackMenuItem);
    }
    // There are menu items that must be placed in the "more" drop-down
    if(numberOfLookbackItems > maxItemsFaceUp) {

        // Create the lookback menu
        extraLookbackMenu = new Menu("extraLookbackMenu" + uniqueComponentId);
        extraLookbackMenu.setTypeClass("more-lookback-menu");
        extraLookbackMenu.setAnchorElementId("extraLookbackMenu" + uniqueComponentId);
        extraLookbackMenu.setAnchorConnectionCorner([ "bottom", "right" ]);
        extraLookbackMenu.setContentConnectionCorner([ "top", "right" ]);
        extraLookbackMenu.setIsRootMenu(true);

        // Create the placeholder "More" lookback item.
        var extraLookbackMenuItem = new ResultRangeSelection();
        extraLookbackMenuItem.setDisplay(this.i18nCore.MORE);
        var extraLookbackMenuItemElement = createLookbackMenuItemElement(extraLookbackMenuItem).attr("id", "lookbackMoreOptions" + uniqueComponentId).addClass("lookback-button-no-left-border lookback-button-more");
        extraLookbackMenuItemElement.on("click", toggleExtraOptions);

        var extraLookbackDropDown = $("<div></div>").addClass("lookback-button lookback-button-arrow lookback-button-no-left-border").attr("id", "extraLookbackMenu" + uniqueComponentId);
        var extraLookbackArrow = $("<span></span>").addClass("wrkflw-selectArrow");

        extraLookbackArrow.click(function() {
            toggleExtraOptions();
        });

        extraLookbackDropDown.append(extraLookbackArrow);
        lookbackContainer.append(extraLookbackMenuItemElement);
        lookbackContainer.append(extraLookbackDropDown);
        for(x = maxItemsFaceUp; x < numberOfLookbackItems; x++) {
            // Use the lookback utility to create a lookback item
            lookbackItem = lookbackItems[ x ];

            // Create a standard menu selection for the "More" lookback menu
            var extraLookbackMenuSelector = new MenuSelection("extraLookbackMenuItem" + uniqueComponentId + "-" + x);
            extraLookbackMenuSelector.setCloseOnClick(true);
            extraLookbackMenuSelector.setLabel(lookbackItem.getDisplay());
            extraLookbackMenuSelector.setClickFunction(handleExtraLookbackClick(lookbackItem, extraLookbackMenuItem));
            extraLookbackMenu.addMenuItem(extraLookbackMenuSelector);
        }
        // Add the extra lookback menu
        MP_MenuManager.updateMenuObject(extraLookbackMenu);
    }

    // Capture the default lookback selection for this component
    ResultRangeSelectionUtility.captureResultRangeSelectionDetails(rComponent, lookbackItems[ 0 ], true);

    return lookbackContainer;
};

/**
 * Creates a  Component Notifications Section with banner elements for small and medium screens.
 * @returns {Object} The DOM object representing the component's notification section.
 */
WorkflowRenderStrategy.prototype.createComponentNotificationsSection = function() {
    var notificationsSection = $("<div></div>").attr("id", "notificationSection" + this.componentId).addClass("sec-notification");
    var banner = $("<div></div>").attr("id", "non-responsive-banner" + this.componentId).addClass("mpageui-u-show-for-sm-only"); // This gets displayed between small and medium breakpoint(@small <------> @medium).
    var bannerSmall = $("<div></div>").attr("id", "non-responsive-banner-sm" + this.componentId).addClass("mpageui-u-hide-for-sm");// This gets displayed only below the small breakpoint.
    this.addComponentSection(notificationsSection, banner);
    this.addComponentSection(notificationsSection, bannerSmall);
    return notificationsSection;
};

/**
 * The workflow components no longer use the accordion so we will return null
 * @returns {null} null
 */
WorkflowRenderStrategy.prototype.createComponentAccordion = function() {
    return null;
};
/**
 * Creates the component contextual view control based on the whether the component is allowed to be shown.
 * @returns {String} The mark up for Contextual View control
 */
WorkflowRenderStrategy.prototype.createComponentContextualViewControl = function() {
    var component = this.getComponentToRender();
    var compId = component.getComponentId();
    var contextualViewControl = component.createComponentContextualViewControl();
    if(contextualViewControl) {
        if(component.isAddedToContextualView()) {
            contextualViewControl.setIcon(MPageUI.ICONS.ICON_MOVE_LEFT);
        }
        else {
            contextualViewControl.setIcon(MPageUI.ICONS.ICON_MOVE_RIGHT);
        }
        component.setContextualViewControl(contextualViewControl);
        return "<div class = 'hdr-contextual-view-control-container' id = '" + compId + "ContextualViewControl'>" + contextualViewControl.render() + "</div>";
    }
    return "";
};

/**
 * Creates the component refresh button control found in the header of the
 * Workflow component
 * @returns {Object} the DOM element for the component refresh button
 */
WorkflowRenderStrategy.prototype.createComponentRefreshButton = function() {
    var compObj = this.getComponentToRender();
    var self = this;
    var refreshButtonContainer = null;
    var spanClass = compObj.isRefreshEnabled() ? "component-refresh-button" : "component-refresh-button-dthr";

    refreshButtonContainer = $("<span class='" + spanClass + "'></span>")
        .attr("id", "mainCompRefresh" + compObj.getComponentId())
        .attr("title", compObj.getAsOfDateString())
        .html("&nbsp;");

    if(compObj.isRefreshEnabled()) {
        var componentRefreshHandler = function() {
            // disable clicks
            refreshButtonContainer.off("click");
            // re-enable clicks one second from now
            setTimeout(function() {
                refreshButtonContainer.click(componentRefreshHandler);
            }, 1000);

            var refreshCapTimer = new CapabilityTimer("CAP:MPG Component Refresh", compObj.getCriterion().category_mean);
            refreshCapTimer.addMetaData("rtms.legacy.metadata.1", compObj.getReportMean());
            refreshCapTimer.capture();

            var rootComponentNode = compObj.getRootComponentNode();
            if(rootComponentNode) {
                var totalCount = Util.Style.g("sec-total", rootComponentNode, "span");
                // Make sure the loading text is not hidden.
                $(totalCount).removeClass("hidden");
                totalCount[ 0 ].innerHTML = self.i18nCore.LOADING_DATA + "...";
            }
            compObj.refreshComponent();
            compObj.updateComponentAsOfDisplay();
        };
        refreshButtonContainer.click(componentRefreshHandler);
    }
    return refreshButtonContainer;
};
/* globals CERN_Platform, logger, CapabilityTimer */
/**
 * The function below is used to intercept focus events when MPages are running within PowerChart.  This
 * is needed because of a defect which is deep within Millennium and Citrix code which causes a Patient's
 * chart to come into focus from the background when programmatic focus is placed on elements within an
 * HTML document.
 *
 * The example below provides details on when error can occur:
 * 1. The user has two Patient charts open; Patient A and Patient B
 * 2. The user takes an action on Patient A which requires an asynchronous CCL call
 * 3. While that call is taking place in the background, the user switches to Patient B's chart
 * 4. While the User is on Patient B's chart, the asynchronous CCL call returns for Patient A.
 * 4.1 The callback function for the CCL script displays a modal dialog and sets the 'ok' button to have default focus
 * 5. The defect occurs and Patient A's chart is brought into focus.
 * 6. The User has no indication that Patient A's chart has taken focus and may continue charting as if they were still
 *    looking at Patient B's chart.
 *
 * The logic in this code is only one of multiple safety nets to try and prevent this type of defect.
 */
(function () {
    // If we are not within Millennium we do not need to intercept the focus invocations
    if (!CERN_Platform.inMillenniumContext()) {
        return;
    }

    var maxMetaCharacters = 250 * 3; // characters split across 3 meta data fields
    var criterion = CERN_Platform.getCriterion().CRITERION;
    var escapeRegex = new RegExp("(&|<|>|\"|'|/)", "g");
    var subtimerDisplay;

    // The htmlEncode function will be used to encode HTML entity characters for logging purposes
    var htmlEncode = CERN_Platform.htmlEncode || function (str) {
        if (typeof str === "string") {
            return str.replace(escapeRegex, function (match) { return "&#" + match.charCodeAt(0) + ";"; });
        }
        return "";
    };

    // Create the sub timer display
    if (CERN_Platform.inPatientChartContext()) {
        subtimerDisplay = criterion.CATEGORY_MEAN + " (PersonId: " + criterion.PERSON_ID + ")";
    } else {
        subtimerDisplay = criterion.CATEGORY_MEAN + " (Organizer)";
    }

    // Store a reference to the browser's focus function and create our own implementation for all HTMLElement objects
    var browserFocus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function () {
        // If this document doesn't currently have focus ignore it and log details
        if (!document.hasFocus()) {
            // Attempt to extract as much informational detail as possible on the origination of this invocation
            var splitDetails = [];
            try {
                var element = this;
                var encodedOuterHTML = htmlEncode(element.outerHTML);
                while (element && htmlEncode(element.outerHTML).length < maxMetaCharacters) {
                    encodedOuterHTML = htmlEncode(element.outerHTML);
                    element = element.parentElement;
                }

                // We've found the element that will overflow our max characters, so lets use what we currently have
                splitDetails = encodedOuterHTML.match(/.{1,250}/g);
            } catch (err) {
                // Set the details indicating that an error occurred when attempting to grab additional information
                splitDetails.push("An error occurred when attempting to pull HTML from the invocation source element");
            }

            // Log details to blackbird for immediate information
            logger.logWarning(
                "A focus intercept has occurred.<br>"
                + "A CAP timer will be logged to capture the following details<br>"
                + "View and person Context: " + subtimerDisplay + "<br>"
                + "Invocation source: " + splitDetails.join("")
            );

            // Log a CAP timer for posthumous information
            var focusCapTimer = new CapabilityTimer("CAP:MPG Focus Intercept", subtimerDisplay);
            focusCapTimer.addMetaData("1of3", splitDetails[0]);
            focusCapTimer.addMetaData("2of3", splitDetails[1] || "");
            focusCapTimer.addMetaData("3of3", splitDetails[2] || "");
            focusCapTimer.capture();
            return;
        }

        // Document has focus, so we can allow the browser's focus handler to take over
        browserFocus.apply(this, arguments);
    };
})();
/* globals i18n, CERN_Platform, MP_Viewpoint */

/**
 * @module @mpages/chart-focus-intercept/chart-alert-intercept
 */

/**
 * It's not necessary to override the `window.alert` function outside of Millennium.
 * Don't even run the IIFE.
 */
if (CERN_Platform.inMillenniumContext()) {
    (function () {
        /**
         * Retrieve a reference to the the context i18n object
         * @function getI18n
         * @returns {{ PATIENT: string, ORGANIZER: string}}
         */
        function getI18n() {
            return i18n.discernabu.chartFocusIntercept.ALERT.CONTEXT
        }

        /**
         * Retrieves the patient name from the criterion object. If something happens along the way,
         * default the patient name to the empty string and log out the problem.
         * @function getPatientName
         * @returns {string}
         */
        function getPatientName() {
            var crit = null;
            var patientName = "";

            try {
                // Grab the criterion object
                crit = CERN_Platform.getCriterion().CRITERION;

                if (crit && crit.PERSON_INFO && crit.PERSON_INFO.PERSON_NAME) {
                    // If available, grab the patient name from the criterion object
                    patientName = crit.PERSON_INFO.PERSON_NAME;
                } else {
                    // Otherwise, tell viewers that there was a problem
                    logger.logMessage("Could not retrieve the patient name. Defaulting the patient name to the empty string.");
                }
            } catch (e) {
                logger.logJSError(e, null, "@mpages/chart-focus-intercept/chart-alert-intercept.js", "getPatientName()");

                // Tell any viewers what we've decided to do about it
                logger.logWarning("Could not retrieve the criterion object. Defaulting the patient name to the empty string.");
            }

            return patientName;
        }

        /**
         * Decorate a message with Patient context
         * @function addPatientContext
         * @param {string} message
         * @returns {string}
         */
        function addPatientContext(message) {
            return getI18n().PATIENT.replace("${PATIENT_NAME}", getPatientName()) + "\n" + message;
        }

        /**
         * Retrieves the view name from the MP_Viewpoint object. If something happens along the way,
         * default the view name to the empty string and log out the problem.
         * @function getViewName
         * @returns {string}
         */
        function getViewName() {
            var viewName = "";

            try {
                var viewContainer = MP_Viewpoint.getViewContainerById(MP_Viewpoint.getActiveViewId());
                viewName = viewContainer.getViewName();
            } catch (e) {
                logger.logJSError(e, null, "@mpages/chart-focus-intercept/chart-alert-intercept.js", "getViewName()");

                // Tell any viewers that we've decided to do about it
                logger.logWarning("Could not retrieve View Name. Defaulting the view name to the empty string.");
            }

            return viewName;
        }

        /**
         * Decorate a message with Organizer context
         * @function addOrganizerContext
         * @param {string} message
         * @returns {string}
         */
        function addOrganizerContext(message) {
            return getI18n().ORGANIZER.replace("${VIEW_NAME}", getViewName()) + "\n" + message;
        }

        /**
         * Decorate a function that implements `alert` as defined by the HTML Standard with contextual information.
         * @function withContext
         * @param {Function} alertFn - {@link https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-alert}
         * @returns {Function} a decorated replacement for `window.alert`
         */
        function withContext(alertFn) {
            /**
             * A stand-in for `window.alert` that notifies endusers of their current context
             * and notified developers not to use `window.alert`
             * @function alert
             * @param {string} message
             * @returns {undefined|*} Returns whatever `alertFn` returns; usually `undefined`
             */
            return function (message) {
                // Decide what context-adding function to use
                var addContext = CERN_Platform.inPatientChartContext()
                    ? addPatientContext
                    : addOrganizerContext;

                // Slap developers' wrists
                logger.logWarning("Usage of window.alert is deprecated. Please use the standard logger.");
                logger.logMessage(message);

                // Alert with contextualized message
                return alertFn(addContext(message));
            };
        }

        window.alert = withContext(window.alert);
    })();
}
MPageOO = {

	/**
	* Allows inheriting two classes without having to call the constructor.
	* Can be replaced with Object.create() once we go over supporting IE10+.
	*/
	inherits: function (clazz, parent) {
		var Dummy = function() {};
		Dummy.prototype = parent.prototype;
		clazz.prototype = new Dummy();
		
		// static methods
		var methods = Object.keys(parent);
		for (var i=methods.length;i--;) {
		    var m = methods[i];
		    clazz[m] = parent[m];
		}
	},

	attribute: function(clazz, name) {

		clazz.prototype["set" + name] = function(value) {
			this["m_"+name] = value;
		};

		clazz.prototype["get" + name] = function() {
			return this["m_" + name];
		};
	},

	/**
	 * Iterates over a list of elements, yielding each in turn to an iteratee
	 * function. The iteratee is bound to the context object, if one is passed.
	 * Each invocation of iteratee is called with three arguments: (element,
	 * index, list). If list is a JavaScript object, iteratee's arguments will
	 * be (value, key, list). Returns the list for chaining.
	 *
	 * @param list
	 * @param iteratee
	 * @returns {*}
	 */
	each: function(list, iteratee) {
		return list.isArray ? 
			MPageOO.eachOverArray(list, iteratee) : MPageOO.eachOverObject(list, iteratee);
	},

	/**
	 * The same as each(), except it only works on arrays.
	 * Use each() instead.
	 *
	 * @param list
	 * @param iteratee
	 * @returns {*}
	 */
	eachOverArray: function(list, iteratee) {
		for (var i = 0; i < list.length; i++) {
			iteratee(list[i], i, list);
		}
		return list;
	},

	/**
	 * The same as each(), except it only works on objects.
	 * Use each() instead.
	 *
	 * @param list
	 * @param iteratee
	 * @returns {*}
	 */
	eachOverObject: function(list, iteratee) {
		var keys = Object.keys(list);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			iteratee(list[key], key, list);
		}
		return list;
	},

	/**
	 * Produces a new array of values by mapping each value in list through a
	 * transformation function (iteratee). The iteratee is passed three
	 * arguments: the value, then the index (or key) of the iteration, and
	 * finally a reference to the entire list.
	 *
	 * @param list
	 * @param iteratee
	 * @returns {Array}
	 */
	map: function(list, iteratee) {
		return list.isArray ? 
			MPageOO.mapOverArray(list, iteratee) : MPageOO.mapOverObject(list, iteratee);
	},

	/**
	 * The same as map(), except that it expects list to be an array.
	 * Use map() instead.
	 *
	 * @param list
	 * @param iteratee
	 * @returns {Array}
	 */
	mapOverArray: function(list, iteratee) {
		var result = [];
		for (var i = 0; i < list.length; i++) {
			result.push(iteratee(list[i], i, list));
		}
		return result;
	},

	/**
	 * The same as map(), except that it expects list to be an object instantce.
	 * Use map() instead.
	 *
	 * @param list
	 * @param iteratee
	 * @returns {Array}
	 */
	mapOverObject: function(list, iteratee) {
		var result = [];
		var keys = Object.keys(list);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			result.push(iteratee(list[key], key, list));
		}
		return result;
	},

	/**
	 * Like map, but for objects. Transform the value of each property in turn.
	 * Iteratee shall return a tuple in the format [key,value].
	 *
	 * @param object
	 * @param iteratee
	 * @returns {{}}
	 */
	mapObject: function(object, iteratee) {
		var result = {};
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			var itResult = iteratee(key, object[key], object);
			result[itResult[0]] = itResult[1];
	}
		return result;
	},

	/**
	 * Also known as inject and foldl, reduce boils down a list of values into a
	 * single value. Memo is the initial state of the reduction, and each
	 * successive step of it should be returned by iteratee. The iteratee is
	 * passed four arguments: the memo, then the value and index (or key) of the
	 * iteration, and finally a reference to the entire list.
	 *
	 * If no memo is passed to the initial invocation of reduce, the iteratee is
	 * not invoked on the first element of the list. The first element is
	 * instead passed as the memo in the invocation of the iteratee on the next
	 * element in the list.
	 *
	 * @param list
	 * @param iteratee
	 * @param memo
	 */
	reduce: function(list, iteratee, memo) {
		var i = 0;
		if (typeof(memo) === 'undefined') {
			i = 1;
			memo = list[0];
		}
		for (; i < list.length; i++) {
			memo = iteratee(memo, list[i]);
		}
		return memo;
	},

	/**
	 * Convert an object into a list of [key, value] pairs.
	 *
	 * @param obj
	 * @returns {Array}
	 */
	pairs: function(obj) {
		return MPageOO.map(obj, function(v, k) {
			return [k, v];
		});
	},

	/**
	 * Return all of the values of the object's own properties.
	 *
	 * @param obj
	 * @returns {Array}
	 */
	values: function(obj) {
		return MPageOO.map(obj, function(v) {
			return v;
		});
	},

	/**
	 * Returns an array with only the values of the result of the merge
	 * between destination and source objects. If fields are common between both
	 * objects, it will favor the field in the source.
	 *
	 * @param destination
	 * @param source
	 * @returns {Array}
	 */
	mergeObjects: function(destination, source) {
		return MPageOO.map(destination, function(v, k) {
			return typeof(source[k]) !== 'undefined' ? source[k] : destination[k];
		});
	},

	/**
	 * Performs a shallow copy of obj, executing the same constructor that was
	 * initially used to generate the instance. Will fail if the constructor
	 * demands parameters.
	 *
	 * @param obj
	 */
	shallowClone: function(obj) {
		var NewCls = function() {}; // GOOD LUCK!
		NewCls.prototype = obj;
		var newObj = new NewCls();
		MPageOO.each(obj, function(v, k) {
			newObj[k] = v;
		});
		return newObj; // CONGRATS! YOU NOW KNOW PROTOTYPICAL INHERITANCE!
	},

	/**
	 * Creates a single object from an array by executing iteratee on each item.
	 * Iteratee shall return a [key, value] tuple for each iteration. Iteratee
	 * receives the current item as its argument.
	 *
	 * @param list
	 * @param iteratee
	 */
	objectFromList: function(list, iteratee) {
		return MPageOO.reduce(list, function(memo, v) {
			var result = iteratee(v);
			memo[result[0]] = result[1];
			return memo;
		}, {});
	},

    /**
     * Looks through each value in the list, returning an array of all the values 
     * that pass a truth test (predicate).
     */
    filter: function(list, iteratee) {
	return MPageOO.reduce(list, function(memo, item) {
	    if (iteratee(item)) {
	    	memo.push(item);
	    }
	    return memo;
	}, []);
    }

    
};
/*globals TableGroup, TemplateBuilder, TableRow, TableExtension */
/**
 * The Component Table class
 * @author Will Reynolds
 * @constructor
 */
function ComponentTable() { // eslint-disable-line no-redeclare
	this.activeRows = null;
	this.bodyTag = "div";
	this.columns = null;
	this.columnMap = null;
	this.columnTag = "dd";
	this.cssTemplate = "list-as-table";
	this.currentlySortedBy = null;
	this.currentlySortedColumn = null;
	this.customClass = "";
	this.extensions = null;
	this.groupedBy = "";
	this.groupMap = null;
	this.groupSequence = null;
	this.groupTemplate = null;
	this.headerEnabled = true;
	this.namespace = "";
	this.noResultsString = i18n.NO_RESULTS_FOUND;
	this.rows = null;
	this.rowMap = null;
	this.rowTag = "dl";
	this.sequence = null;
	this.showGroupCount = false;
	this.sortable = false;
	this.zebraStripe = true;
	this.rowHash = {name: "", value: ""};
}

/**
 * Get the active rows from the table (i.e. the rows that qualify for all filters applied to the table)
 * @return {Array} the active rows in the table
 */
ComponentTable.prototype.getActiveRows = function () {
    if (!this.activeRows) {
        this.activeRows = [];
    }
    return  this.activeRows;
};

/**
 * Sets the rows that are active on the table (used when filtering)
 * @param activeRows the rows that are active in the table (i.e. rows that pass through filtering)
 */
ComponentTable.prototype.setActiveRows = function (activeRows) {
    if (!(Array.isArray(activeRows))) {
        throw new Error("Called setActiveRows on ComponentTable with non Array type for activeRows parameter");
    }
    this.activeRows = activeRows;
    return this;
};

/**
 * Adds a column to the table
 * @param column The column you wish to add to the table
 */
ComponentTable.prototype.addColumn = function (column) {
    //If an attempt is made to add something other than a TableColumn
    if (!TableColumn.prototype.isPrototypeOf(column)) {
        throw new Error("Called addColumn on ComponentTable with non TableColumn type for column parameter");
    }
    //If a column already exists with this id
    if (this.hasColumn(column.getColumnId())) {
        throw new Error("Column with id: " + column.getColumnId() + " already exists in the ComponentTable with namespace: " + this.namespace);
    }
    if (column.getIsSortable()) {
        this.sortable = true;
    }
    this.getColumnSequence().push(column.getColumnId());
    this.getColumns().push(column);
    this.getColumnMap()[column.getColumnId()] = column;
};

/**
 * Gets a list of all columns from the table
 * @return {Array<TableColumn>} the list of columns
 */
ComponentTable.prototype.getColumns = function () {
    if (!this.columns) {
        this.columns = [];
    }
    return this.columns;
};

ComponentTable.prototype.getColumnMap = function () {
    if (!this.columnMap) {
        this.columnMap = {};
    }
    return this.columnMap;
};

/**
 * Gets a column at the specified index
 * @param index the index of the column
 * @return {TableColumn} the column at index
 */
ComponentTable.prototype.getColumnAtIndex = function (index) {
    if (index < 0 || index >= this.getColumns().length) {
        throw new Error("Index out of bounds when calling getColumnAtIndex on ComponentTable. Used index: " + index);
    }
    return this.getColumns()[index];
};

/**
 * Gets a column from the table by Id
 * @param columnId the Id of the column you wish to obtain
 * @return {TableColumn} the column as obtained by the Id, an exception is thrown if the column
 * does not exist
 */
ComponentTable.prototype.getColumnById = function (columnId) {
    if (!this.hasColumn(columnId)) {
        throw new Error("In ComponentTable method getColumnById, TableColumn with columnId: " + columnId + " does not exist");
    }
    return this.getColumnMap()[columnId];
};

/**
 * Checks to see if a column exists
 * @param columnId the column you're checking for
 */
ComponentTable.prototype.hasColumn = function (columnId) {
    return (typeof this.getColumnMap()[columnId] !== "undefined" && this.getColumnMap()[columnId] !== null);
};

/**
 * Gets the appropriate column tag that is applied to the table
 * @return {string} the name of the column tag for the table
 */
ComponentTable.prototype.getColumnTag = function() {
	return this.columnTag;
};

/**
 * Applies the appropriate column tag to the table
 * @param columnTag
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setColumnTag = function(columnTag) {
	if ( typeof columnTag !== "string") {
		throw new Error("Called setColumnTag on ComponentTable with non string type for columnTag parameter");
	}
	this.columnTag = columnTag;
	return this;
};

/**
 * Gets the appropriate CSS template that is applied to the table
 * @return {string} the name of the CSS Template to be applied to the root of the table
 */
ComponentTable.prototype.getCSSTemplate = function() {
	return this.cssTemplate;
};

/**
 * Applies the appropriate CSS template to the ComponentTable
 * @param cssTemplate : the name of the CSS Template to be applied to the root of the table.
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setCSSTemplate = function(cssTemplate) {
	if ( typeof cssTemplate !== "string") {
		throw new Error("Called setCSSTemplate on ComponentTable with non string type for cssTemplate parameter");
	}
	this.cssTemplate = cssTemplate;
	return this;
};

/**
 * Applies the appropriate body tag to the table
 * @param bodyTag: tag that needs to be applied for body of the ComponentTable
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setBodyTag = function(bodyTag) {
	if ( typeof bodyTag !== "string") {
		throw new Error("Called setBodyTag on ComponentTable with non string type for bodyTag parameter");
	}
	this.bodyTag = bodyTag;
	return this;
};

/**
 * Gets appropriate body tag that is applied to the table
 * @return {String} returns bodyTag that needs to be applied to ComponentTable
 */
ComponentTable.prototype.getBodyTag = function() {
	return this.bodyTag;
};

/**
 * Custom no results found string
 * @param noResultsString: tag that needs to be applied for body of the ComponentTable
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setNoresultsString = function(noResultsString) {
	if ( typeof noResultsString !== "string") {
		throw new Error("Called setNoresultsFound on ComponentTable with non string type for noResultsString parameter");
	}
	this.noResultsString = noResultsString;
	return this;
};

/**
 * Gets noResultsString that is applied to the table
 * @return {String} returns noResultsString that needs to be applied to ComponentTable
 */
ComponentTable.prototype.getNoResultsString = function() {
	return this.noResultsString;
};


/**
 * Gets appropriate row tag that is applied to the table
 * @return {String} returns tag that needs to be applied for each row of the ComponentTable
 */
ComponentTable.prototype.getRowTag = function() {
	return this.rowTag;
};

/**
 * Applies the appropriate row tag to the table
 * @param rowTag :  tag that needs to be applied for each row of the ComponentTable
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setRowTag = function(rowTag) {
	if ( typeof rowTag !== "string") {
		throw new Error("Called setRowTag on ComponentTable with non string type for rowTag parameter");
	}
	this.rowTag = rowTag;
	return this;
};

/**
 * Adds a hash for data attribute on the row
 * @param {String} attributeName: name of a data attribute applied for each row of the ComponentTable
 * @param {String} attributeValue: member from the result data that will be mapped as a value
 */
ComponentTable.prototype.setDataAttributeOnRow = function(attrName, attrValue){
	if (!attrName || !attrValue || typeof attrName !== "string" || typeof attrValue !== "string") {
		throw new Error("Called setDataAttributeOnRow on ComponentTable with non string type for attrName and attrValue parameter");
	}
	this.rowHash.name = attrName;
	this.rowHash.value = attrValue;
};

/**
 * Returns a row hash object
 * @returns {Object} returns a rowHash object
 */
ComponentTable.prototype.getDataAttributeOnRow = function(){
	return this.rowHash; 
};

/**
 * Returns the row satisfying the data attribute name and value specified
 * @param {String} Member from the result data that is added as a data attribute name
 * @param {String/Integer} Specific value which is essentially a key for finding a row   
 * @return {Object} returns a row object
 */
ComponentTable.prototype.getRowByHash = function(name, value){
	// Loop through the active rows
	var rowObj = null;
	var activeRowsLen = this.getActiveRows().length; 
	for(var i = 0; i < activeRowsLen ; i++){
		rowObj = this.getActiveRows()[i];
		if(rowObj.resultData[name] === value){
			return rowObj;
		}
	}
};

/**
 * Allows sorting a column in a specified direction
 * @param columnId the column to be sorted
 * @param direction the direction to sort
 */
ComponentTable.prototype.sortByColumnInDirection = function (columnId, direction) {
    if (!this.hasColumn(columnId)) {
        throw new Error("In ComponentTable method toggleColumnSort, TableColumn with columnId: " + columnId + " does not exist" +
            "\nOptions are: " + this.getColumnSequence().join(","));
    }
    if (!TableColumn.isValidSortDirection(direction)) {
        throw new Error("Called sortByColumnInDirection on ComponentTable with invalid sort direction. " +
            "Use enumeration TableColumn.SORT.ASCENDING or TableColumn.SORT.DESCENDING");
    }
    var column = this.getColumnMap()[columnId];
    if (!column.getIsSortable()) {
        return;
    }
    //Get a sort function based on the data type, column, and sort direction
    var sortFunction = ColumnSortFactory.getSortFunction(column, direction);
    this.currentlySortedBy = sortFunction;
    //Update the columns and their indicators
    this.updateSortIndicators(column, direction);

    //Perform the sort on the table rows
    this.getRows().sort(sortFunction);
    this.getActiveRows().sort(sortFunction);
    this.sortGroups(sortFunction);

    //Refresh the table body
    this.refresh();
};

/**
 * Toggles the sorting of the column specified by columnId. I.e. if the column is sorted ascending, it will
 * sort descending and vice versa.
 * @param columnId the column to be sorted. If columnId is not valid, an exception is thrown.
 */
ComponentTable.prototype.toggleColumnSort = function (columnId) {
    if (!this.hasColumn(columnId)) {
        throw new Error("In ComponentTable method toggleColumnSort, TableColumn with columnId: " + columnId + " does not exist." +
            "\nOptions are: " + this.getColumnSequence().join(","));
    }
    //Get the column by id
    var column = this.getColumnMap()[columnId];
    if (!column.getIsSortable()) {
        return;
    }
    //Get and invert the sort direction, otherwise default to ascending
    var sortDirection = (column.getColumnSortDirection() !== TableColumn.SORT.NONE ? (-1 * column.getColumnSortDirection()) : column.getDefaultSort());
    this.sortByColumnInDirection(columnId, sortDirection);
};

/**
 * Updates the sort indicators for a column.
 * @param column the column we're updating.
 * @param direction the direction the column is now sorted in.
 */
ComponentTable.prototype.updateSortIndicators = function (column, direction) {
    var ns = this.namespace;
    var sortedColumn = this.getCurrentlySortedColumn();
    //Update the previous column
    if (sortedColumn) {
        $("#" + ns + "columnHeader" + sortedColumn.getColumnId()).removeClass(this.getSortClass(sortedColumn.getColumnSortDirection()));
        sortedColumn.setColumnSortDirection(TableColumn.SORT.NONE);
    }
    $("#" + ns + "columnHeader" + column.getColumnId()).addClass(this.getSortClass(direction));
    column.setColumnSortDirection(direction);
    this.currentlySortedColumn = column;
};

/**
 * Gets a css class based on the passed in sort direction (ascending or descending)
 * @param sortDirection the direction for which we are obtaining a css class
 * @return {string} a css class string based on the sort direction
 * sortDirection = -1 (TableColumn.SORT.ASCENDING) returns sort-asc
 * sortDirection = 1 (TableColumn.SORT.DESCENDING) returns sort-desc
 */
ComponentTable.prototype.getSortClass = function (sortDirection) {
    switch (sortDirection) {
        case TableColumn.SORT.ASCENDING:
            return "sort-asc";
        case TableColumn.SORT.DESCENDING:
            return "sort-desc";
        default:
            return "";
    }
};

/**
 * Gets the function that is currently sorting the table. Null if no sorting is applied.
 * @return {Function} the function that is currently sorting the table.
 */
ComponentTable.prototype.getCurrentlySortedBy = function () {
    return this.currentlySortedBy;
};

/**
 * Sets the function that is currently sorting the table.
 * @param currentlySortedBy the function currently being used to sort the table.
 */
ComponentTable.prototype.setCurrentlySortedBy = function (currentlySortedBy) {
    if (typeof currentlySortedBy !== "function") {
        throw new Error("Called setCurrentlySortedBy on ComponentTable with non function type for currentlySortedBy parameter");
    }
    this.currentlySortedBy = currentlySortedBy;
    return this;
};

/**
 * Gets which column the table is currently sorted by
 * @return {TableColumn} the column the table is currently sorted by
 */
ComponentTable.prototype.getCurrentlySortedColumn = function () {
    return this.currentlySortedColumn;
};

/**
 * Sets which column the table is currently sorted by
 * @param currentlySortedColumn the column that the table is currently sorted by
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setCurrentlySortedColumn = function (currentlySortedColumn) {
    if (!TableColumn.prototype.isPrototypeOf(currentlySortedColumn)) {
        throw new Error("Called setCurrentlySortedColumn on ComponentTable with non TableColumn type for currentlySortedColumn parameter");
    }
    this.currentlySortedColumn = currentlySortedColumn;
    return this;
};

/**
 * Gets the custom class that is applied to the table (used for customized styling)
 * @return {string} the name of the custom class to be applied to the root of the table
 */
ComponentTable.prototype.getCustomClass = function () {
    return this.customClass;
};

/**
 * Applies a css class to the root of the table for customized styling options
 * @param customClass
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.setCustomClass = function (customClass) {
    if (typeof customClass !== "string") {
        throw new Error("Called setCustomClass on ComponentTable with non string type for customClass parameter");
    }
    this.customClass = customClass;
    return this;
};

/**
 * Adds an extension for the component table. They act as smaller modules that can help the table perform additional
 * operations
 * @param extension the extension that is to be added to the table
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.addExtension = function (extension) { //eslint-disable-line no-undef
    if (!TableExtension.prototype.isPrototypeOf(extension)) {
        throw new Error("Called addExtension on ComponentTable with non TableExtension type for extension parameter");
    }
    this.getExtensions().push(extension);
    return this;
};

/**
 * Gets a list of table extensions
 * @return {Array} the list of table extensions
 */
ComponentTable.prototype.getExtensions = function () {
    if (!this.extensions) {
        this.extensions = [];
    }
    return this.extensions;
};

/**
 * Groups the table by a key. The key should be a field in the results JSON.
 * @param key the field used to determine grouping. This key should be a field in the results JSON.
 * @param template the template used to render the grouping. This template determines what is shown
 * @param showCount whether the groups should show the counts
 * in the group subsection.
 */
ComponentTable.prototype.quickGroup = function (key, template, showCount) {
    this.groupedBy = key;
    this.groupTemplate = TemplateBuilder.buildTemplate(template);
    this.showGroupCount = showCount;
    var tableRows = this.getRows();
    var numberOfRows = tableRows.length;
    //If the data hasn't been bound, we stop here
    if (!numberOfRows) {
        return;
    }
    this.groupSequence = [];
    this.groupMap = {};
    //Iterate through the rows and add them to their respective groups
    for (var i = 0; i < numberOfRows; i++) {
        this.addRowToGroup(key, tableRows[i], showCount);
    }
};

/**
 *
 * @param groupKey the key we're qualifying the group on
 * @param row the row to be added to a group
 * @param showCount whether or not to show the counts for groups
 */
ComponentTable.prototype.addRowToGroup = function (groupKey, row, showCount) {
    var rowData = row.getResultData();
    var rowKey = (rowData[groupKey] || "UNKNOWN").replace(/[\s]/gi, "_").replace(/[\W]/gi, "").toUpperCase();
    var gMap = this.getGroupMap();
    var gSequence = this.getGroupSequence();
    if (!gMap[rowKey]) {
        gMap[rowKey] = new TableGroup().setKey(groupKey).setValue(rowKey).setDisplay(this.groupTemplate.render(rowData)).setGroupId(rowKey).setShowCount(showCount);
        gSequence.push(rowKey);
    }
    gMap[rowKey].addRow(row);
};

/**
 * Checks if grouping is applied
 * @return {boolean}
 */
ComponentTable.prototype.isGroupingApplied = function () {
    return (this.getGroupSequence().length > 0);
};

/**
 * Adds a single group to the table
 * @param group the group to be added
 * @return {ComponentTable} returns self
 */
ComponentTable.prototype.addGroup = function (group) {
    if (!TableGroup.prototype.isPrototypeOf(group)) {
        throw new Error("Called addGroup on ComponentTable with non TableGroup type for group parameter");
    }
    if (this.hasGroup(group.getGroupId())) {
        throw new Error("In addGroup on ComponentTable, TableGroup with id: " + group.getGroupId() + " already exists");
    }
    var gMap = this.getGroupMap();
    var gSequence = this.getGroupSequence();
    //If sorting is applied when we add the group, honor that sorting
    if (this.currentlySortedBy) {
        group.getRows().sort(this.currentlySortedBy);
    }
    gSequence.push(group.getGroupId());
    gMap[group.getGroupId()] = group;
    return this;
};

/**
 * Applies a set of groups to the table
 * @param groups a set of groups to be added to the table
 */
ComponentTable.prototype.applyGroups = function (groups) {
    if (!(Array.isArray(groups))) {
        throw new Error("Called applyGroups on ComponentTable with non Array type for groups parameter");
    }
    this.clearGroups();
    //Iterate over the provided groups and add them to the table
    for (var i = 0; i < groups.length; i++) {
        this.addGroup(groups[i]);
    }
};

/**
 * Sorts the table groups (if there are any) by the provided sort function
 * @param sortFunction the function to use to sort the groups
 */
ComponentTable.prototype.sortGroups = function (sortFunction) {
    var gMap = this.getGroupMap();
    var gSequence = this.getGroupSequence();
    var numberOfGroups = gSequence.length;
    for (var i = 0; i < numberOfGroups; i++) {
        gMap[gSequence[i]].getRows().sort(sortFunction);
    }
};

/**
 * Checks to see if a group with groupId exists in the Component Table
 * @param groupId the id of the TableGroup we're checking for
 * @return {boolean}
 */
ComponentTable.prototype.hasGroup = function (groupId) {
    return (typeof this.getGroupMap()[groupId] !== "undefined" && this.getGroupMap()[groupId] !== null);
};

/**
 * Obtains a table group based on the groupId
 * @param groupId the id of the group to be obtained
 * @return {TableGroup} a TableGroup based on the groupId passed in
 */
ComponentTable.prototype.getGroupById = function (groupId) {
    if (!this.hasGroup(groupId)) {
        throw new Error("In ComponentTable method getGroupById, TableGroup with groupId: " + groupId + " does not exist");
    }
    return this.getGroupMap()[groupId];
};

/**
 * Gets the group map for the ComponentTable
 * @return {Map<String, TableGroup>} the groupMap that maps group ids to their TableGroup object
 */
ComponentTable.prototype.getGroupMap = function () {
    if (!this.groupMap) {
        this.groupMap = {};
    }
    return this.groupMap;
};

/**
 * Gets the group sequence for the ComponentTable
 * @return {Array<String>} a list of group ids that forms the sequence of groups for the table
 */
ComponentTable.prototype.getGroupSequence = function () {
    if (!this.groupSequence) {
        this.groupSequence = [];
    }
    return this.groupSequence;
};

/**
 * Opens a TableGroup with the specified groupId
 * @param groupId the id of the group to be opened
 */
ComponentTable.prototype.openGroup = function (groupId) {
    if (!this.hasGroup(groupId)) {
        throw new Error("In ComponentTable method toggleGroup, TableGroup with groupId: " + groupId + " does not exist");
    }
    var tableGroup = this.getGroupMap()[groupId];
    var groupContainer = $("#" + this.namespace + "\\:" + tableGroup.getGroupId());
    //If it's already expanded, just return
    if (tableGroup.isExpanded()) {
        return;
    }
    tableGroup.setIsExpanded(true);
    groupContainer.removeClass("closed");
    groupContainer.find(".sub-sec-hd-tgl").attr("title", i18n.discernabu.HIDE_SECTION).html("-");
};

/**
 *
 * @param groupIds
 */
ComponentTable.prototype.openGroups = function (groupIds) {
    if (!(Array.isArray(groupIds))) {
        throw new Error("Called openGroups on ComponentTable with non Array type for groups parameter");
    }
    //Iterate over the provided group ids and open the groups
    for (var i = 0; i < groupIds.length; i++) {
        this.openGroup(groupIds[i]);
    }
};

/**
 * Closes a group based on a group id
 * @param groupId
 */
ComponentTable.prototype.collapseGroup = function (groupId) {
    if (!this.hasGroup(groupId)) {
        throw new Error("In ComponentTable method toggleGroup, TableGroup with groupId: " + groupId + " does not exist");
    }
    var tableGroup = this.getGroupMap()[groupId];
    var groupContainer = $("#" + this.namespace + "\\:" + tableGroup.getGroupId());
    //If it's already collapsed, just return
    if (!tableGroup.isExpanded()) {
        return;
    }
    tableGroup.setIsExpanded(false);
    groupContainer.addClass("closed");
    groupContainer.find(".sub-sec-hd-tgl").attr("title", i18n.discernabu.SHOW_SECTION).html("+");
};

/**
 * Collapses a set of groups.
 * @param groupIds the ids of the groups to be collapsed.
 */
ComponentTable.prototype.collapseGroups = function (groupIds) {
    if (!(Array.isArray(groupIds))) {
        throw new Error("Called closeGroups on ComponentTable with non Array type for groups parameter");
    }
    //Iterate over the group ids, attempting to close them
    for (var i = 0; i < groupIds.length; i++) {
        this.collapseGroup(groupIds[i]);
    }
};

/**
 * Toggles a table group with the specified groupId
 * @param groupId the id of the group to be toggled
 */
ComponentTable.prototype.toggleGroup = function (groupId) {
    var group = this.getGroupById(groupId);
    if (group.isExpanded()) {
        this.collapseGroup(groupId);
    } else {
        this.openGroup(groupId);
    }
};

/**
 * Clears the grouping information on the table
 */
ComponentTable.prototype.clearGroups = function () {
    this.groupSequence = [];
    this.groupMap = {};
    this.groupedBy = "";
};

/**
 * Handles rendering a group
 * @param group the group being rendered
 * @return {string} an html string built from the group
 */
ComponentTable.prototype.renderGroup = function (group) {
    var headId = this.namespace + ":" + group.getGroupId();
    var headToggleTitle = group.isExpanded() ? i18n.discernabu.HIDE_SECTION : i18n.discernabu.SHOW_SECTION;
    var headToggleContent = group.isExpanded() ? "-" : "+";
    var headToggleClass = group.isExpanded() ? "" : "closed";
    var groupCollapsibility = group.getCanCollapse() ? "can-collapse " : "";
    var countHtml = group.getShowCount() ? "<span class='sub-sec-total'>&nbsp;(" + group.getRows().length + ")</span>" : "";
    var toggleHtml = group.getCanCollapse() ? ("<span class='sub-sec-hd-tgl' title='" + headToggleTitle + "'>" +  headToggleContent + "</span>") : "";
    var hideHeader = group.getHideHeader() ? "hidden" : "";
    return "<div id='" + headId + "' class='" + headToggleClass + "'><h3 id='" + headId + ":header" + "' class='sub-sec-hd " + groupCollapsibility + hideHeader + "'>" + toggleHtml + "<span class='sub-sec-title'><" + this.getRowTag() + "><" + this.getColumnTag() + "><span class='sub-sec-display'>" + group.getDisplay() + "</span>" + countHtml + "</" + this.getColumnTag() + "></" + this.getRowTag() + "></span></h3>" +
        "<div id='" + headId + ":content' class='sub-sec-content'>" +
        (group.getRows().length ? this.renderRows(group.getRows(), group.getGroupId()) : this.renderNoResults()) +
        "</div>" +
        "</div>";
};

/**
 * Check to see if the header is enabled.
 * @return {boolean} flag determining if the table header is enabled.
 */
ComponentTable.prototype.isHeaderEnabled = function() {
    return this.headerEnabled;
};

/**
 * Sets whether the table header is enabled (will be rendered)
 * @param headerEnabled boolean flag determining if the table header is enabled.
 */
ComponentTable.prototype.setIsHeaderEnabled = function(headerEnabled) {
    if(typeof headerEnabled !== "boolean") {
        throw new Error("Called setIsHeaderEnabled on ComponentTable with non boolean type for headerEnabled parameter");
    }
    this.headerEnabled = headerEnabled;
    return this;
};

/**
 * Returns the namespace of the table
 * @return {string} the namespace of the table
 */
ComponentTable.prototype.getNamespace = function () {
    return this.namespace;
};

/**
 * Initialize the namespace of the component. This is necessary to distinguish tables in the DOM
 * @param namespace the namespace of the table. It is recommended to use component.getStyles().getId()
 */
ComponentTable.prototype.setNamespace = function (namespace) {
    if (typeof namespace !== "string") {
        throw new Error("Called setNamespace on ComponentTable with non string type for namespace parameter");
    }
    this.namespace = namespace;
    return this;
};

/**
 * Adds a row to the table
 * @param row the row to add to the table
 */
ComponentTable.prototype.addRow = function (row) {
    if (!TableRow.prototype.isPrototypeOf(row)) {
        throw new Error("Called addRow on ComponentTable with non TableRow type for row parameter");
    }
    this.getRows().push(row);
    return this;
};

/**
 * Gets the rows from the table
 * @return {Array} the rows in the table
 */
ComponentTable.prototype.getRows = function () {
    if (!this.rows) {
        this.rows = [];
    }
    return this.rows;
};

/**
 * Gets the row by id
 * @param rowId the id of the row to be obtained
 * @return {TableRow} the row with the specified id
 */
ComponentTable.prototype.getRowById = function (rowId) {
    if (!this.hasRow(rowId)) {
        throw new Error("In ComponentTable method getRowById, TableRow with rowId: " + rowId + " does not exist");
    }
    return this.getRowMap()[rowId];
};

/**
 * Gets the mapping of rowIds to TableRow objects.
 * @return {Map<String, TableRow>} the mapping of string rowIds to TableRow objects.
 */
ComponentTable.prototype.getRowMap = function() {
    if(!this.rowMap) {
        this.rowMap = {};
    }
    return this.rowMap;
};

/**
 * Checks to see if a row exists
 * @param rowId the id of the row you are checking for
 * @return {boolean} true if the row exists, false otherwise
 */
ComponentTable.prototype.hasRow = function (rowId) {
    return (typeof this.getRowMap()[rowId] !== "undefined" && this.getRowMap()[rowId] !== null);
};

/**
 * Gets the column sequence
 * @return {Array} an array of IDs telling the order in which columns are to be rendered
 */
ComponentTable.prototype.getColumnSequence = function () {
    if(!this.sequence) {
        this.sequence = [];
    }
    return this.sequence;
};

/**
 * Gets whether the table should zebra stripe
 * @return {boolean} true if the table should zebra-stripe, false otherwise
 */
ComponentTable.prototype.getZebraStripe = function () {
    return this.zebraStripe;
};

/**
 * Set whether the table should use zebra-striping
 * @param zebraStripe true if the table should zebra stripe, false otherwise
 */
ComponentTable.prototype.setZebraStripe = function (zebraStripe) {
    if (typeof zebraStripe === "boolean") {
        this.zebraStripe = zebraStripe;
    }
    return this;
};

/**
 * Gets the zebra stripe class based on the index
 * @param index the index for a row
 * @return {string} "even" if the index is even, "odd" if the index is odd
 */
ComponentTable.prototype.getStripeClass = function (index) {
	if(!this.zebraStripe){
		return "";
	}
    return (index % 2 === 0) ? "odd" : "even";
};

/**
 * Creates an html string for the table
 * @return {string} the html string for the table body
 */
ComponentTable.prototype.render = function () {
    var groupingClass = this.isGroupingApplied() ? " grouping-applied" : "";
	var contentBodyClass = groupingClass !== "" || this.getActiveRows().length > 0 ? "content-body" : "";
    var customClass = this.getCustomClass() ? " " + this.getCustomClass() : "";
    var cssTemplate = this.getCSSTemplate() ? " " + this.getCSSTemplate() : "";
	var endBodyTag = this.getBodyTag() ? "</" + this.getBodyTag() + ">" : "";
	var startBodyTag = this.getBodyTag() ? "<" + this.getBodyTag() + ">" : "";
	 var bodyHTML = "<div id='" + this.namespace + "table' class='component-table" + cssTemplate + customClass + groupingClass + "'>" +
        (this.isHeaderEnabled() ? this.renderHeader() : "") +
        "<div  id='" + this.namespace + "tableBody" + "' class='" + contentBodyClass + "'>" + startBodyTag + this.renderBody() + endBodyTag + "</div></div>";
    return bodyHTML;
};

/**
 * Refreshes the table body (usually done after sorting). If there are groups it will handle re-rendering each individual
 * group, otherwise it will just render the rows.
 */
ComponentTable.prototype.refresh = function () {
    var tableRoot = $("#" + this.namespace + "table");
    var startBodyTag = this.getBodyTag() ? "<" + this.getBodyTag() + ">" : "";
    var endBodyTag = this.getBodyTag() ? "</" + this.getBodyTag() + ">" : "";
    if(!tableRoot || !tableRoot.length) {
        return;
    }
    //If grouping is applied, add the grouping applied class to the root, otherwise remove it
    if(this.isGroupingApplied()) {
        tableRoot.addClass("grouping-applied");
    } else {
        tableRoot.removeClass("grouping-applied");
    }
    var tableBody = $("#" + this.namespace + "tableBody");
    //If the table body isn't found, we can't refresh
    if (!tableBody || !tableBody.length) {
        return;
    }
    tableBody[0].innerHTML = startBodyTag + this.renderBody() + endBodyTag;
    //There is a chance that sizings have changed, so we call the update method
    this.updateAfterResize();
};

/**
 * Renders the table header
 * @return {string} an html string representing the table's header
 */
ComponentTable.prototype.renderHeader = function () {
    var ns = this.namespace;
    var gSequence = this.getGroupSequence();
    var numberOfGroups = gSequence.length;
    if(this.getActiveRows().length > 0 || numberOfGroups > 0){
    	var headerWrapper = "<" + this.getBodyTag() + " id='" + ns + "headerWrapper" + "' class='content-hdr'>";
    	var headerHTML = "<" + this.getRowTag() + " id='" + ns + "header" + "' class='" + (this.sortable ? "sort-control" : "") + " hdr'>";
    	 var columnSequence = this.getColumnSequence();
    var numberColumns = columnSequence.length;
    var headerItemClass = "";
    var column = null;
    var style = "";
    for (var i = 0; i < numberColumns; i++) {
    	headerItemClass = "header-item";
		column = this.getColumnMap()[columnSequence[i]];
		style = column.getWidth() ? " style='width:" + column.getWidth() + "px;'" : "";
		headerItemClass += (column.getCustomClass() ? (" " + column.getCustomClass()) : "");
		headerItemClass += (column.getIsSortable() ? " sort-option" : "");
		if (column.getColumnSortDirection() !== TableColumn.SORT.NONE) {
			headerItemClass += (" " + this.getSortClass(column.getColumnSortDirection()));
		}
		headerHTML += ("<" + this.getColumnTag() + " id='" + ns + "columnHeader" + column.getColumnId() + "' class='" + headerItemClass + "'" + style + ">" + "<span id='" + ns + "headerItemDisplay" + column.getColumnId() + "' class='header-item-display'>" + column.getColumnDisplay() + "</span>" + "</" + this.getColumnTag() + ">");
	}
	return headerWrapper + headerHTML + "</" + this.getRowTag() + "></" + this.getBodyTag() + ">";
    }
    else{
    	return "";
    }
    
};


/**
 * Builds up an html string for the table body. If no grouping is applied, it just renders the active rows. Otherwise
 * it will render each group
 * @return {string} the html string for the table body
 */
ComponentTable.prototype.renderBody = function () {
	var tableBodyHTML = "";	//open table
	//If no grouping is applied, simply render the table rows
	var gMap = this.getGroupMap();
	var gSequence = this.getGroupSequence();
	var numberOfGroups = gSequence.length;
	if (!gSequence.length) {
		if (this.getActiveRows().length > 0) {
			$("#" + this.namespace + "tableBody").addClass('content-body');
			return this.renderRows(this.getActiveRows(), null);
		} else {
			//When refreshed and no data found then remove the content-body class and show No results found message. Only happens after the component is loaded.
			$("#" + this.namespace + "tableBody").removeClass('content-body');
			return this.renderNoResults();
		}
	} else {
		for (var i = 0; i < numberOfGroups; i++) {
			tableBodyHTML += this.renderGroup(gMap[gSequence[i]]);
		}
	}
	return tableBodyHTML;
		//close table
};

/**
 *
 * @param rows
 * @param groupId
 * @return {string}
 */
ComponentTable.prototype.renderRows = function (rows, groupId) {
    var rowsHtml = "";
    var columnSequence = this.getColumnSequence();
    var numberColumns = columnSequence.length;
    var style = "";
    groupId = groupId ? (":" + groupId) : "";
    var cellId = "";
    for (var i = 0; i < rows.length; i++) {
        var row = rows[i];
        var rowClass = "result-info " + this.getStripeClass(i);
        var rowId = this.namespace + groupId  + ":" + row.getId();
        var rowDataAttrName = row.getRowAttributeHash().attrName;
        var rowDataAttrValue = row.getResultData()[row.getRowAttributeHash().attrValue];
        if(rowDataAttrName && rowDataAttrValue){
           	rowsHtml += "<" + this.getRowTag() + " id='" + rowId + "' class='" + rowClass + "' " + rowDataAttrName + "=" + rowDataAttrValue + ">";
        }
        else{
        	rowsHtml += "<" + this.getRowTag() + " id='" + rowId + "' class='" + rowClass + "'>";	
        }
       	for (var j = 0; j < numberColumns; j++) {
            var column = this.getColumnMap()[columnSequence[j]];
            var tableCellClass = "table-cell " + column.getCustomClass();
            var columnID = column.getColumnId();
            style = column.getWidth() ? " style='width:" + column.getWidth() + "px;'" : "";
            cellId = this.namespace + groupId + ":" + row.getId() + ":" + columnID;
            rowsHtml += "<" + this.getColumnTag() + " id='" + cellId + "' class='" + tableCellClass + "'" + style + ">";		//open table-cell
            rowsHtml += (column.getRenderTemplate().render(row.getResultData()) || "<span>&nbsp;</span>");
            rowsHtml += "</" + this.getColumnTag() + ">";		//close table-cell
        }
        rowsHtml += "</" + this.getRowTag() + ">";
    }
    return rowsHtml;
};

/**
 * Helper function to render the standard no results found html
 * @return {string} html string for no results found
 */
ComponentTable.prototype.renderNoResults = function () {
    return "<span class='res-none'>" + this.getNoResultsString() + "</span>";
};

/**
 * Finalizes the table (i.e., must be called after it has rendered). It attaches the click delegate
 * for the table header for sorting. It also finalizes any extensions for the table.
 */
ComponentTable.prototype.finalize = function () {
    var self = this;
    var extensionsList = this.getExtensions();
    var numberOfExtensions = extensionsList.length;

    //Initialize click events for the sort options
    var header = $("#" + this.namespace + "header").on("click", ".sort-option", function (event) { //eslint-disable-line no-unused-vars
        var id = $(this).attr("id");
        var prefixLength = (self.namespace + "columnHeader").length;
        var columnID = id.substring(prefixLength, id.length);
        self.toggleColumnSort(columnID);
    });

    //Remove the current click events
    $("#" + this.namespace + "tableBody").find(".sub-sec-hd-tgl").each(function () {
        Util.removeEvent(this, "click", MP_Util.Doc.ExpandCollapse);
    });

	//Attach a delegate for the group toggle
    $("#" + this.namespace + "tableBody").on("click", ".sub-sec-hd.can-collapse", function (event) { //eslint-disable-line no-unused-vars
        self.toggleGroup(TableGroup.parseGroupId($(this).attr("id")));
    	self.updateAfterResize();
    });
    
    //Finalize all extensions
    for (var i = 0; i < numberOfExtensions; i++) {
        extensionsList[i].finalize(this);
    }
};

/**
 * Function to update the table after a resize event. It checks to see if scrolling is applied, and if so
 * it shifts the header over to compensate for the scrollbar in the table body.
 */
ComponentTable.prototype.updateAfterResize = function () {
    var tableBody = $("#" + this.namespace + "tableBody");
    if (!tableBody || !tableBody.length) {
        return;
    }
    //Scrolling is applied
    if (tableBody[0].scrollHeight > tableBody.outerHeight()) {
        $("#" + this.namespace + "header").addClass("shifted");
    } else {
        $("#" + this.namespace + "header").removeClass("shifted");
    }
};

/**
 * Binds JSON data to the table, setting up all necessary objects for render
 * @param data the data being bound to the table
 */
ComponentTable.prototype.bindData = function (data) {
    //Attempting to bind result data with no columns defined. This does not make sense.
    if (!this.getColumnSequence().length) {
        throw new Error("Called bindData on ComponentTable with no columns defined.");
    }
    if (typeof data !== "object" || !(Array.isArray(data))) {
        throw new Error("Called bindData on ComponentTable with non object Array type for data parameter. Please pass an Array of json results");
    }
    this.clearData();
    var dataLength = data.length;
    var tableRows = this.getRows();
    var rMap = this.getRowMap();
    if(dataLength > 0){
		for (var i = 0; i < dataLength; i++) {
			var dataItem = data[i];
			var tableRow = new TableRow().setId("row" + i).setResultData(dataItem);
			// Sets attribute on row if the consumer has set one
			if(this.getDataAttributeOnRow().name && this.getDataAttributeOnRow().value){
				tableRow.setRowAttributeHash(this.getDataAttributeOnRow().name, this.getDataAttributeOnRow().value);
			}
			tableRows.push(tableRow);
			//Store the row in a map by id, so we can access it later via a DOM id
			rMap[tableRow.getId()] = tableRow;

			//If grouping has been applied (prior to binding), push the rows into groups
			if (this.groupedBy) {
				this.addRowToGroup(this.groupedBy, tableRow, this.showGroupCount);
			}
		}
		this.activeRows = tableRows;
		//If for some reason the user called a sort function before binding any data
		if (this.currentlySortedBy) {
			this.getActiveRows().sort(this.currentlySortedBy);
			tableRows.sort(this.currentlySortedBy);
			this.sortGroups(this.currentlySortedBy);
		}
	
    }else{
    	this.activeRows = [];
    }
    
    return this;
};

/**
 * Clears out the table-level data (not groups)
 */
ComponentTable.prototype.clearData = function () {
    this.rows = [];
    this.rowMap = {};
    this.activeRows = [];
};

/**
 * A factory class that produces row sorting functions
 * @constructor
 */
function ColumnSortFactory() {
}

/**
 * Gets a sort function based on a column and the specified sort direction
 * @param column the column we're sorting
 * @param sortDirection the direction to sort (ascending or descending)
 * @return {Function} a sorting function
 */
ColumnSortFactory.getSortFunction = function (column, sortDirection) {
    if (!TableColumn.isValidSortDirection(sortDirection)) {
        throw new Error("Called ColumnSortFactory.getSortFunction with invalid sort direction. " +
            "Use enumeration TableColumn.SORT.ASCENDING or TableColumn.SORT.DESCENDING");
    }
    return function (rowA, rowB) {
        var resultDataA = rowA.getResultData();
        var resultDataB = rowB.getResultData();
        var rowAVal = resultDataA[column.getPrimarySortField()];
        var rowBVal = resultDataB[column.getPrimarySortField()];
        var comparison = ColumnSortFactory.compare(rowAVal, rowBVal);
        //If the comparison on the primary sort fields isn't 0 (not equal), return this value
        if (comparison !== 0) {
            return sortDirection * comparison;
        }
        //If the primary sort fields are equal, attempt to use any secondary sort fields
        var secondarySortFields = column.getSecondarySortFields();
        for (var i = 0; i < secondarySortFields.length; i++) {
            rowAVal = resultDataA[secondarySortFields[i].FIELD];
            rowBVal = resultDataB[secondarySortFields[i].FIELD];
            comparison = ColumnSortFactory.compare(rowAVal, rowBVal);
            if (comparison !== 0) {
                return secondarySortFields[i].DIRECTION * comparison;
            }
        }
        //If we've made it this far, all fields are equal, so return 0
        return 0;
    };
};

/**
 * Helper function to compare two values.
 * @param a the first value to compare
 * @param b the second value to compare
 * @return {number} a comparison value 1, -1, or 0, where 0 means equality
 */
ColumnSortFactory.compare = function (a, b) {
    try {
        //Perform special logic for setting up sort values for comparison
        if (typeof a === "number" || typeof b === "number") {
            a = a || 0;
            b = b || 0;
        } else if (typeof a === "string" || typeof b === "string") {
            a = (a || "").toUpperCase();
            b = (b || "").toUpperCase();
        }
        return ((a > b) ? -1 : (a < b ? 1 : 0));//eslint-disable-line no-nested-ternary
    } catch (exe) {
        MP_Util.LogError("Called ColumnSortFactory.compare(a,b) with an invalid value for a or b");//eslint-disable-line new-cap
        return 0;
    }
};
/**
 * Utility class for retrieving data from a table
 * @constructor
 */
function ComponentTableDataRetriever(){}

/**
 * Retrieves a result json object based on an element.
 * @param table the table we're getting the data from.
 * @param element the element for which we're obtaining the associated result json.
 * @return {JSON Object} the result obtained from the table.
 */
ComponentTableDataRetriever.getResultFromTable = function(table, element) {
    var identifiers = $(element).attr("id").split(":");
    //If grouping is applied, we go through the group to find the row data
    if(table.isGroupingApplied()) {
        return table.getGroupById(identifiers[1]).getRowById(identifiers[2]).getResultData();
    } else {
        return table.getRowById(identifiers[1]).getResultData();
    }
};

/**
 * Retrieves the column id from an element in a component table.
 * @param table the table object.
 * @param element the element we're grabbing the column id from.
 * @return {string} the id of the column as obtained from the element
 */
ComponentTableDataRetriever.getColumnIdFromElement = function(table, element) {
    if(!ComponentTable.prototype.isPrototypeOf(table)) {
        throw new Error("Called getColumnIdFromElement on ComponentTableDataRetriever with non ComponentTable type for table parameter");
    }
    var identifiers = $(element).attr("id").split(":");
    if(table.isGroupingApplied()) {
        return (identifiers.length > 4) ? (identifiers.slice(3).join(':')) : (identifiers[3]);
    } else {
        return (identifiers.length > 3) ? (identifiers.slice(2).join(':')) : identifiers[2];
    }
};
/**
 * The Flowsheet Table class
 * @author Nandini Parimi
 * @constructor
 */
function FlowsheetTable() {
	this.nameSpace = "";
	this.labelColumnTable = new ComponentTable();
	this.labelColumnTable.setRowTag("tr");
	this.labelColumnTable.setColumnTag("td");
	this.labelColumnTable.setBodyTag("table");
	this.setLabelTableCustomClass("fs-label-table");
	this.resultsTable = new ComponentTable();
	this.resultsTable.setRowTag("tr");
	this.resultsTable.setColumnTag("td");
	this.resultsTable.setBodyTag("table");
	this.setResultTableCustomClass("fs-results-table");
	this.setCSSTemplate("flowsheet-table");
	this.labelColumnTableBodyElement = null;
	this.labelColumnTableElement = null;
	this.resultsTableBodyElement = null;
	this.resultsTableElement = null;
	this.headerTableElement = null;
	this.outerScrollDiv = null;
	this.innerScrollContent = null;
	this.m_scrollController = null;
	//the disclaimer text when results are capped
	this.m_disclaimer = null;
	this.sidePanelWidth = 0;
}

/**
 * Set the disclaimer that will display when results are capped
 * @param {string} disclaimerText Text to display as footnote
 */
FlowsheetTable.prototype.setDisclaimer = function(disclaimerText){
	this.m_disclaimer = disclaimerText;
};

/**
 * Get the disclaimer  that will display when results are capped
 * @return {string} disclaimerText Text to display as footnote
 */
FlowsheetTable.prototype.getDisclaimer = function(){
	return this.m_disclaimer;
};

/**
 * Creates an html string for the table.This function makes a call to the render method for both the label and result component tables
 * @return {string} the html string for the entire flowsheet table structure
 */
FlowsheetTable.prototype.render = function() {
	var bodyHTML = "<div id = '" + this.nameSpace + "flowsheetContainer' class='flowsheet-container'>"+ this.labelColumnTable.render() + this.resultsTable.render();
	
	//Appending a vertical scroll when the number of result rows is more than the viewable pane.
	bodyHTML += "<div id = '" + this.nameSpace + "flowsheetScroll' class='flowsheet-vertical-scroll flowsheet-vertical-scroll-hidden'>" + "<span id='" + this.nameSpace + "flowsheetScrollContent' class='flowsheet-scroll-content'>&nbsp;</span></div>";
	
	//Create result cap message
	if(this.m_disclaimer){
		bodyHTML += "<div id='"+ this.nameSpace+"Disclaimer' class='flowsheet-disclaimer'>"+ this.m_disclaimer +"</div>";
	}

	bodyHTML+="</div>";
	return bodyHTML;
};

/**
 * Makes a call to the Finalize function in the component table for the labelColumnTable and resultsTable.
 *
 */
FlowsheetTable.prototype.finalize = function() {

	var self = this;
	this.labelColumnTable.finalize();
	this.resultsTable.finalize();

	//Attach scroll events to the scroller that will scroll the label and the results table.
	this.m_scrollController = this.m_scrollController || $("#" + this.nameSpace + "flowsheetScroll");
	self.m_scrollController.scroll(function(event) {
		
		self.scrollTables(event);
	});

};

/**
 This function is called each time the vertical scroll bar is used.
 This function scrolls the results table and label table whenever the vertical scrollbar is used.
 * @param event - Scroll Event.
 * @param self - Flowsheet Table.
 */
FlowsheetTable.prototype.scrollTables = function(event) {
	//Check to see if the scroller is visible and that the tables have been created
	var scrollerTop = 0;
	if (this.m_scrollController.hasClass("flowsheet-vertical-scroll")) {
		scrollerTop = this.m_scrollController.scrollTop();
		if (event.type === "mousewheel") {
			var delta = event.originalEvent.wheelDeltaY || event.originalEvent.wheelDelta;
			scrollerTop -= delta;
			this.m_scrollController.scrollTop(scrollerTop);
		}
		//Apply the correct scrolling to the table bodies
		this.labelColumnTableBodyElement = this.labelColumnTableBodyElement || $("#" + this.labelColumnTable.getNamespace() + "tableBody");
		this.resultsTableBodyElement = this.resultsTableBodyElement || $("#" + this.resultsTable.getNamespace() + "tableBody");
		this.labelColumnTableBodyElement.scrollTop(scrollerTop);
		this.resultsTableBodyElement.scrollTop(scrollerTop);
	}

};

/**
 * Creates an html string for the table
 * @return {string} the html string for the table body
 */
FlowsheetTable.prototype.bindData = function(data) {

	this.labelColumnTable.bindData(data);
	this.resultsTable.bindData(data);

};

/**
 * Loops through the columns and adds appropriate columns to the result table.
 *
 */
FlowsheetTable.prototype.addResultColumn = function(column) {

	this.resultsTable.addColumn(column);

};

/**
 * Loops through the columns and adds appropriate columns to the label tables.
 *
 */
FlowsheetTable.prototype.addLabelColumn = function(column) {

	this.labelColumnTable.addColumn(column);

};

/**
 * Applies the appropriate CSS template to the label and result tables
 * @param cssTemplate
 *
 */
FlowsheetTable.prototype.setCSSTemplate = function(cssTemplate) {

	this.labelColumnTable.setCSSTemplate(cssTemplate);
	this.resultsTable.setCSSTemplate(cssTemplate);

};

/**
 Applies appropriate custom class to the label table
 * @param customClass - carries appropriate custom class to be applied to the tables.
 */
FlowsheetTable.prototype.setLabelTableCustomClass = function(customClass) {
	this.labelColumnTable.setCustomClass(customClass);
};

/**
 Applies appropriate custom class to the result tables
 * @param customClass - carries appropriate custom class to be applied to the tables.
 */

FlowsheetTable.prototype.setResultTableCustomClass = function(customClass) {
	this.resultsTable.setCustomClass(customClass);
};

/**
 * Makes a call to the setNamespace function in the component table for the labelColumnTable and resultsTable.
 * @param namespace the namespace of the table.
 */
FlowsheetTable.prototype.setNamespace = function(nameSpace) {
	if ( typeof nameSpace !== "string") {
		throw new Error("Called setNamespace on ComponentTable with non string type for namespace parameter");
	}
	this.nameSpace = nameSpace;

	//assigning unique namespace to label and result tables.
	this.labelColumnTable.setNamespace(nameSpace + "labelTable");
	this.resultsTable.setNamespace(nameSpace + "resultsTable");
	return this;
};

/*
 * Sets the side panel width value which is used for calculations in the updateAfterResize function
 */
FlowsheetTable.prototype.setSidePanelWidth = function(sidePanelWidth) {
	this.sidePanelWidth = sidePanelWidth;
};

/**
 * Function to update the table after a resize event.
 */
FlowsheetTable.prototype.updateAfterResize = function() {

	//updating the css properties to display the scroll bar appropriately.
	this.labelColumnTableBodyElement = this.labelColumnTableBodyElement || $("#" + this.labelColumnTable.getNamespace() + "tableBody");
	this.labelColumnTableElement = this.labelColumnTableElement || $("#" + this.labelColumnTable.getNamespace() + "table");
	this.resultsTableBodyElement = this.resultsTableBodyElement || $("#" + this.resultsTable.getNamespace() + "tableBody");
	this.resultsTableElement = this.resultsTableElement || $("#" + this.resultsTable.getNamespace() + "table");
	this.headerTableElement = this.headerTableElement || $("#" + this.resultsTable.getNamespace() + "headerWrapper");
	this.outerScrollDiv = this.outerScrollDiv || $("#" + this.nameSpace + "flowsheetScroll");
	this.innerScrollContent = this.innerScrollContent || $("#" + this.nameSpace + "flowsheetScrollContent");
	var headerHeight = this.headerTableElement.height();
	var miscHeight = 20;
	var container = $("#vwpBody");
	var viewHeight = $(container).height();
	var compDOMObj = $("#" + this.nameSpace);
	if (!compDOMObj.length) {
		return;
	}
	var contentBodyObj = $(compDOMObj).find(".content-body");
	var secContent = $(compDOMObj).find(".sec-content");

	//set the max-height for the content tables of resultsTable and labelTable
	if (contentBodyObj.length) {
		//Get the overall component height

		//Get the height of section header
		var sectionHeight = $(compDOMObj).find(".sec-hd").outerHeight();
		//Get the height of the content-body
		var contentBodyHeight = contentBodyObj.height();

		var disclaimerHeight = 0;

		if(this.m_disclaimer){
			disclaimerHeight = $('#'+this.nameSpace+"Disclaimer").outerHeight();
		}

		//Calculate the estimated max height of the components content-body element
		var calcHeight = (viewHeight - (sectionHeight + headerHeight + miscHeight + disclaimerHeight)) + "px";
		//apply the max-height settings for label table and result table
		$(contentBodyObj).css("max-height", calcHeight).css("overflow-y", "hidden");
	}

	var resultTableMarginOffset = 2;
	var resultTableMaxWidth = secContent.width() - this.labelColumnTableElement.width() - resultTableMarginOffset - this.sidePanelWidth;
	//set result table to cover the whole viewing area
	this.resultsTableElement.css({
		"width" : resultTableMaxWidth
	});

	var self= this;
	var resultHeaderWidth = this.headerTableElement[0].scrollWidth;
	this.resultsTableBodyElement.css({
		"width" : self.headerTableElement[0].scrollWidth + "px"
	});
	
	var resultTableHeight = this.resultsTableBodyElement[0].scrollHeight;
	var resultTableMaxheight = this.resultsTableBodyElement.css("max-height");
	var adjustableHeight = parseInt(resultTableMaxheight, 10);
	var scrollBarThickness = 18;
	//Adding a scroll bar if the number of results is more than the viewable pane.

	//parseInt function is used to compare just the numerical part of the height and ignore the "px"
	if (adjustableHeight < resultTableHeight) {
		this.outerScrollDiv.removeClass("flowsheet-vertical-scroll-hidden");
		this.innerScrollContent.css("height", resultTableHeight);
		
		//Result table will be adjusted to resultHeaderWidth after the rezie update function. 
		//So whether the scroll bar exists can be found out by comparing the following variables. 
		if (resultTableMaxWidth < this.headerTableElement[0].scrollWidth) {
			this.resultsTableElement.css("height", adjustableHeight + headerHeight);
			//taking scroll bar height into account
			this.labelColumnTableElement.css("height", adjustableHeight + headerHeight - scrollBarThickness);
			//taking scroll bar height into account
			this.outerScrollDiv.css("height", adjustableHeight - scrollBarThickness);

			$(contentBodyObj).css("max-height", adjustableHeight - scrollBarThickness);
		}else{
			this.labelColumnTableElement.css("height", adjustableHeight + headerHeight);
			this.outerScrollDiv.css("height", adjustableHeight);
		}
	} else if (!(this.outerScrollDiv.hasClass("flowsheet-vertical-scroll-hidden"))) {
		this.outerScrollDiv.addClass("flowsheet-vertical-scroll-hidden");
		this.resultsTableElement.css("height", "100%");
		this.labelColumnTableElement.css("height", "100%");
	}
};

/**
 * Function to add extensions like "Hover" and "Click" to the flowsheet table.
 * @param extension - The extension to be added to a component table
 * @param tableFlag - This flag indicates which table to add the 
 * 			extension to 1 = labelColumnTable, 2 = resultsTable, null/nothing = both tables
 */
FlowsheetTable.prototype.addExtension = function(extension, tableFlag) {
	//Setting each td of a table cell as the target for the hover.
	if (HoverExtension.prototype.isPrototypeOf(extension)) {
		if (extension.target !== "td.table-cell") {
			extension.setTarget("td.table-cell");
		}
	}
	
	switch(tableFlag) {
	case 1:
		this.labelColumnTable.addExtension(extension);
		break;
	case 2:
		this.resultsTable.addExtension(extension);
		break;
	default:
		this.labelColumnTable.addExtension(extension);
		this.resultsTable.addExtension(extension);
	}
	
};
/**
 * The MPageTooltip class. This is used for dynamic hovers.
 * @return {MPageTooltip} returns self
 * @constructor
 * @author Will Reynolds
 */
function MPageTooltip() {
    this.anchor = null;                 //The element the tooltip is anchored to
    this.content = null;                //The content of the tooltip
    this.flipfit = true;                //Whether the tooltip should flip fit (fit on screen)
    this.height = 0;                    //The height of the tooltip content in the DOM
    this.offsetX = 20;                  //The X offset from the mouse position
    this.offsetY = 20;                  //The Y offset from the mouse position
    this.showDelay = 500;               //How long the tooltip should wait to show (in milliseconds)
    this.tolerance = 5;                 //How much extra space around the edge of the window before we flip
    this.stillHovered = false;          //Whether the mouse is still hovered over the anchor for this tooltip
    this.width = 0;                     //The width of the tooltip content in the DOM
    this.x = 0;                         //The x position of the tooltip content in the DOM (coincides with css 'left')
    this.y = 0;                         //The y position of the tooltip content in the DOM (coincides with css 'top')
    return this;
}

/**
 * Get the anchor that the tooltip is tied to
 * @return {Html Element}
 */
MPageTooltip.prototype.getAnchor = function () {
    return this.anchor;
};

/**
 * Set the anchor that the tooltip is tied to
 * @param anchor the DOM anchor that this tooltip is tied to
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setAnchor = function (anchor) {
    this.anchor = anchor;
    return this;
};

/**
 * Gets the content of the tooltip (the actual tooltip in the DOM)
 * @return {jQuery DOM Element} the jQuery DOM element of the tooltip
 */
MPageTooltip.prototype.getContent = function () {
    return this.content;
};

/**
 * Sets the content of the tooltip.
 * @param content the content to be placed inside the tooltip
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setContent = function (content) {
    this.content = $("<div class='mpage-tooltip'>").html(content).hide();
    return this;
};

/**
 * Gets whether the tooltip should flip to fit inside the screen space
 * @return {boolean} whether the tooltip should flip to fit inside the screen space
 */
MPageTooltip.prototype.shouldFlipfit = function () {
    return this.flipfit;
};

/**
 * Sets whether the tooltip should flip to fit inside the screen space
 * @param flipfit a boolean flag for whether the tooltip should flipfit
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setShouldFlipfit = function (flipfit) {
    if (typeof flipfit !== "boolean") {
        throw new Error("Called setShouldFlipfit on DiscernTooltip with non boolean type for flipfit parameter");
    }
    this.flipfit = flipfit;
    return this;
};

/**
 * Gets the height of the tooltip content in the DOM
 * @return {number} the height of the tooltip content in the DOM
 */
MPageTooltip.prototype.getHeight = function() {
    return this.height;
};

/**
 * Sets the height of the tooltip content in the DOM (this does not change the height of the tooltip, it is simply a means
 * of storing off the height of the tooltip content once it has been appended to the DOM).
 * @param height the height of the tooltip content in the DOM.
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setHeight = function(height) {
    if(typeof height !== "number") {
        throw new Error("Called setHeight on MPageTooltip with non number type for height parameter");
    }
    this.height = height;
    return this;
};

/**
 * Gets the x offset value for the tooltip. This is how far in the x direction the tooltip should be shown from the mouse
 * when hovering.
 * @return {number} the x offset value for the tooltip
 */
MPageTooltip.prototype.getOffsetX = function() {
    return this.offsetX;
};

/**
 * Sets the x offset value for the tooltip. This is how far in the x direction the tooltip should be shown from the mouse
 * when hovering.
 * @param offsetX the x offset value for the tooltip
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setOffsetX = function(offsetX) {
    if(typeof offsetX !== "number") {
        throw new Error("Called setOffsetX on MPageTooltip with non number type for offsetX parameter");
    }
    this.offsetX = offsetX;
    return this;
};

/**
 * Gets the y offset value for the tooltip. This is how far in the y direction the tooltip should be shown from the mouse
 * when hovering.
 * @return {number} the y offset value for the tooltip
 */
MPageTooltip.prototype.getOffsetY = function() {
    return this.offsetY;
};

/**
 * Sets the y offset value for the tooltip. This is how far in the y direction the tooltip should be shown from the mouse
 * when hovering.
 * @param offsetY the y offset value for the tooltip
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setOffsetY = function(offsetY) {
    if(typeof offsetY !== "number") {
        throw new Error("Called setOffsetY on MPageTooltip with non number type for offsetY parameter");
    }
    this.offsetY = offsetY;
    return this;
};

/**
 * Gets the delay value for the tooltip. This is how long the tooltip waits before appearing after the show
 * method has been called
 * @return {number} the delay for the tooltip in milliseconds.
 */
MPageTooltip.prototype.getShowDelay = function () {
    return this.showDelay;
};

/**
 * Sets the delay value for the tooltip. This is how long the tooltip waits before appearing after the show
 * method has been called
 * @param showDelay how long the tooltip should wait before appearing after the show method is called (in milliseconds)
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setShowDelay = function (showDelay) {
    if (typeof showDelay !== "number") {
        throw new Error("Called setShowDelay on DiscernTooltip with non number type for showDelay parameter");
    }
    if (showDelay < 0) {
        throw new Error("Called setShowDelay on DiscernTooltip with negative value, showDelay must be > 0");
    }
    this.showDelay = showDelay;
    return this;
};

/**
 * Gets a boolean flag determining whether the mouse is still hovered over the anchor.
 * @return {boolean} whether the mouse is still hovered over the tooltip's anchor.
 */
MPageTooltip.prototype.isStillHovered = function () {
    return this.stillHovered;
};

/**
 * Sets a boolean flag determining whether the mouse is still hovered over the anchor.
 * @param stillHovered the boolean flag for whether the mouse is still hovered over the anchor
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setIsStillHovered = function (stillHovered) {
    if (typeof stillHovered !== "boolean") {
        throw new Error("Called setIsStillHovered on DiscernTooltip with non boolean type for stillHovered parameter");
    }
    this.stillHovered = stillHovered;
    return this;
};


/**
 * Gets the tolerance for the tooltip (how much space around the window before flipping)
 * @return {number} contract the window size by this amount in pixels when determining tooltip flipping
 */
MPageTooltip.prototype.getTolerance = function() {
    return this.tolerance;
};

/**
 * Sets the tolerance of the tooltip (how much space to contract around the window before flipping)
 * @param tolerance how many pixels we contract the window size when determining tooltip flipping
 */
MPageTooltip.prototype.setTolerance = function(tolerance) {
    if(typeof tolerance !== "number") {
        throw new Error("Called setTolerance on MPageTooltip with non number type for tolerance parameter");
    }
    this.tolerance = tolerance;
};

/**
 * Gets the width of the tooltip content in the DOM
 * @return {number} the width of the tooltip content in the DOM
 */
MPageTooltip.prototype.getWidth = function () {
    return this.width;
};

/**
 * Sets the width of the tooltip content in the DOM (this does not change the width of the tooltip, it is simply a means
 * of storing off the width of the tooltip content once it has been appended to the DOM).
 * @param width the width of the tooltip content in the DOM.
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setWidth = function (width) {
    if(typeof width !== "number") {
        throw new Error("Called setWidth on MPageTooltip with non number type for width parameter");
    }
    this.width = width;
    return this;
};

/**
 * Gets the x position of the tooltip in the DOM.
 * @return {number} the x position of the tooltip in the DOM.
 */
MPageTooltip.prototype.getX = function () {
    return this.x;
};

/**
 * Sets the x position of the tooltip in the DOM (this does not change the x position of the tooltip, it is simply a means
 * of storing off the x position for internal use).
 * @param x the x position of the tooltip in the DOM.
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setX = function (x) {
    if(typeof x !== "number") {
        throw new Error("Called setX on MPageTooltip with non number type for x parameter");
    }
    this.x = x;
    return this;
};

/**
 * Gets the y position of the tooltip in the DOM.
 * @return {number} the y position of the tooltip in the DOM.
 */
MPageTooltip.prototype.getY = function () {
    return this.y;
};

/**
 * Sets the y position of the tooltip in the DOM (this does not change the y position of the tooltip, it is simply a means
 * of storing off the y position for internal use).
 * @param y the y position of the tooltip in the DOM.
 * @return {MPageTooltip} returns self
 */
MPageTooltip.prototype.setY = function (y) {
    if(typeof y !== "number") {
        throw new Error("Called setY on MPageTooltip with non number type for y parameter");
    }
    this.y = y;
    return this;
};

/**
 * Actually shows the MPageTooltip after it has been set up. It will wait the allotted delay time, then if the
 * mouse is still hovered, will append the tooltip content to the DOM. When the mouse leaves the anchor, the tooltip
 * is removed from the DOM.
 */
MPageTooltip.prototype.show = function () {
    var self = this;
    this.stillHovered = true;
    /**
     * Remove existing tooltips if any before constructing the new one
     */
    $(".mpage-tooltip").remove();

    //Bind the mouseleave event to the anchor
    $(this.getAnchor()).on("mouseleave.discernTooltip", function (event) {
        self.setIsStillHovered(false);
        //If there is content, remove it from the DOM
        if (self.getContent()) {
            self.getContent().remove();
        }
        //Unbind any events with the tooltip namespace (so we don't clutter the dom with events)
        $(self.getAnchor()).unbind(".discernTooltip");
    });

    //Wait the allotted time before showing the tooltip
    setTimeout(function () {
        //At this point, the hover will be shown, so we'll poll to see if the anchor ever disappears
        self.checkAnchorStillExists();
        //If we have moused out, we quit here
        if (!self.isStillHovered()) {
            return;
        }
        //Append the tooltip content to the DOM
        $(document.body).append(self.getContent());
        //Store of the dimensions of the tooltip
        self.setHeight(self.getContent().height());
        self.setWidth(self.getContent().width());
        //Initialize the position
        self.getContent().css({
            "left": self.calculatePosition(self.x, $(window).width()-self.getTolerance(), self.width, self.getOffsetX()),
            "top": self.calculatePosition(self.y, $(window).height()-self.getTolerance(), self.height, self.getOffsetY())
        });
        self.content.show();
        //Bind the mouse move event with the discernTooltip namespace
        $(self.getAnchor()).on("mousemove.discernTooltip", function (event) {
            //If no longer hovered, just returned
            if (!self.isStillHovered()) {
                return;
            }
            //Store off the position values
            self.setX(event.pageX).setY(event.pageY);
            //Calculate the position for the tooltip
            self.content.css("left", self.calculatePosition(event.pageX, $(window).width()-self.getTolerance(), self.width, self.getOffsetX()));
            self.content.css("top", self.calculatePosition(event.pageY, $(window).height()-self.getTolerance(), self.height, self.getOffsetY()));
        });
    }, this.getShowDelay());
};

/**
 * Calculates the position for the tooltip
 * @param mouseValue the position of the mouse (x or y)
 * @param windowValue the width or height of the window
 * @param tooltipValue the width or height of the tooltip
 * @param paramOffset the x or y offset of the tooltip
 * @return {number} the calculated position for the tooltip (an x or y value)
 */
MPageTooltip.prototype.calculatePosition = function (mouseValue, windowValue, tooltipValue, paramOffset) {
    //If we're using the flipfit functionality
    if (this.shouldFlipfit() && mouseValue + paramOffset > (windowValue - tooltipValue)) {
        var positionVal = mouseValue - tooltipValue - paramOffset;
        if (positionVal < 0) {
            positionVal = ((windowValue) / 2) - (tooltipValue / 2);
        }
        return positionVal;
    }
    //Otherwise, just return the mouse position + offset
    return mouseValue + paramOffset;
};

/**
 * Helper function to check that the hover's anchor still exists on the DOM. If at any point the anchor ceases to
 * exist, the tooltip will be removed.
 */
MPageTooltip.prototype.checkAnchorStillExists = function () {
    var self = this;
    function checkHoverAnchor(){
        try {
            //If the anchor has been removed from the DOM, remove the tooltip and return
            if ((!$(self.getAnchor()).is(":hover")) || (!$(document.body).find(self.getAnchor()).length)) {
                if (self.getContent()) {
                    self.getContent().remove();
                }
                self.setIsStillHovered(false);
                if ($(self.getAnchor()).length > 0) {
                    $(self.getAnchor()).unbind(".discernTooltip");
                }
                return;
            }
            //If no longer hovered, return
            if (!self.isStillHovered()) {
                return;
            }
            //At this point, we are still hovering, so continue polling
            setTimeout(checkHoverAnchor, 5000);
        } catch (exe) {
            return;
        }
    }
    checkHoverAnchor();
};
/**
 * SidePanel.js
 * @author Karoline Checkett
 *
 * SidePanel class
 * ============================================================================
 *
 * Creates generic rectangular area to display whatever is necessary for a particular component.
 * The size and ability to turn on/off hover functionality can be adjusted. If the hover is on, 
 * an expand bar will show up upon hover (if more info needs to be shown in the panel). Once clicked,
 * the panel will expand and show a collapse bar. A scroll bar will appear if more info is still outside
 * the viewable area. Click outside the panel or on the collapse bar to collapse the panel back to normal.
 */

// -----------------------------------------------------------------------
// Class Declaration
// ------------------------------------------------------------------------
/**
 * Instantiates a new SidePanel object
 * 
 * @name SidePanel
 * @namespace
 */
SidePanel = function() {
	this.m_uniqueId = null;
	this.m_panelId = null;
	this.m_containerElementId = null;

	// The consuming artifact can set this to be one of the values in the
	// expandOption enumerated types
	// at the bottom of this class. The current choices are non-expanding (NONE)
	// and expand-down (EXPAND_DOWN).
	this.m_expandOption = this.expandOption.NONE;

	// This variable is for when the expand option is set to NONE. Then this
	// variable should be set to true if
	// scrolling is wanted (if there isn't enough space on the screen) or false
	// if scrolling is not wanted.
	this.m_fullPanelScrollOn = true;

	// This variable will be used to validate any heights or widths that are
	// passed in
	this.m_regexHeightWidth = /^(\d+((px)|%){1})$/;

	// set a default side-panel size just in case the parent doesn't set them
	this.m_height = "175px";
	this.m_width = "100%";
	this.m_maxHeight = null;
	this.m_minHeight = "175px";
	this.m_previousMinHeight = null;

	// additional functions for the events on the panel
	this.m_mouseEnterFunc = null;
	this.m_mouseLeaveFunc = null;
	this.m_onExpandFunc = null;
	this.m_onCollapseFunc = null;
	//this.m_focusOutFunc = null;

	// hold cached DOM objects for panel parts
	this.m_parentContainer = null;
	this.m_sidePanelObj = null;
	this.m_sidePanelContents = null;
	this.m_sidePanelBodyContents = null;
	this.m_scrollContainer = null;
	this.m_expCollapseIconObj = null;
	this.m_expCollapseBarObj = null;
	this.m_sidePanelHeader = null;
	this.m_headerTitleObj = null;
	this.m_subtitleObj = null;
	this.m_closeButton = null;
	this.m_closeFunction = null;
	this.m_cornerCloseButton = null;
	this.m_cornerCloseFunction = null;
	this.m_usingUpdatedPanel = false;
	this.m_applyBodyContentsPadding = false;
};

// ------------------------------------------------------------------------
// Getters and Setters
// ------------------------------------------------------------------------
/**
 * Returns the unique id for the side panel
 * 
 * @returns {string|number} the unique id for the side panel
 */
SidePanel.prototype.getUniqueId = function() {
	return this.m_uniqueId;
};

/**
 * Sets the unique id for the side panel
 * 
 * @param {string|number}
 *            uniqueId The unique id for the side panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setUniqueId = function(uniqueId) {
	if (!uniqueId || (typeof uniqueId !== "string" && typeof uniqueId !== "number")) {
		logger.logError("Parameter uniqueId must be of type string or number for the SidePanel.setUniqueId function.");
		return;
	}

	this.m_uniqueId = uniqueId;
	this.m_panelId = 'sidePanel' + uniqueId;
	return this;
};

/**
 * Returns the container element id for the side panel
 * 
 * @returns {string} the container element id for the side panel
 */
SidePanel.prototype.getContainerElementId = function() {
	return this.m_containerElementId;
};

/**
 * Sets the container element id for the side panel
 * 
 * @param {string}
 *            containerElementId The container element id for the side panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setContainerElementId = function(containerElementId) {
	if (!containerElementId || typeof containerElementId !== "string") {
		logger.logError("Parameter containerElementId must be of type string for the SidePanel.setContainerElementId function.");
		return;
	}

	this.m_containerElementId = containerElementId;
	return this;
};

/**
 * Returns the function for the expand option chosen
 * 
 * @returns {SidePanel.expandOption} the option set for expanding the panel
 */
SidePanel.prototype.getExpandOption = function() {
	return this.m_expandOption;
};

/**
 * Sets the type of expand option chosen (NONE or EXPAND_DOWN)
 * 
 * @param {SidePanel.expandOption}
 *            expandOption The option set for expanding the panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setExpandOption = function(expandOption) {
	var valid = false;

	// ensure passed expandOption is one of the below types
	for (key in this.expandOption) {
		var func = this.expandOption[key];
		if (expandOption === func) {
			valid = true;
			break;
		}
	}

	// if not valid option, throw error
	if (!valid) {
		logger.logError("Parameter expandOption must be of type SidePanel.expandOption for the SidePanel.setExpandOption function.");
		return;
	}

	this.m_expandOption = expandOption;
	return this;
};

/**
 * Returns true or false which ever was set for turning on full-panel scrolling.
 * Only relevant when the expandOption is set to NONE.
 * 
 * @returns {boolean} whether full panel scrolling is on or not
 */
SidePanel.prototype.getFullPanelScrollOn = function() {
	return this.m_fullPanelScrollOn;
};

/**
 * Sets true or false for turning on full-panel scrolling. Only relevant when
 * the expandOption is set to NONE.
 * 
 * @param {boolean}
 *            scrollOn Whether full panel scrolling is on or not
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setFullPanelScrollOn = function(scrollOn) {
	if (typeof scrollOn !== "boolean") {
		logger.logError("Parameter scrollOn must be of type boolean for the SidePanel.setFullPanelScrollOn function.");
		return;
	}
	this.m_fullPanelScrollOn = scrollOn;
	return this;
};

/**
 * Returns the set width for the side panel.
 * 
 * @returns {string} the current value for width
 */
SidePanel.prototype.getWidth = function() {
	return this.m_width;
};

/**
 * Sets the width for the side panel.
 * 
 * @param {string}
 *            newWidth The new value for width in string format with "###px" or
 *            "###%" as the format
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setWidth = function(newWidth) {
	if (!this.m_regexHeightWidth.test(newWidth)) {
		logger.logError("Parameter newWidth must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.setWidth function.");
		return;
	}

	this.m_width = newWidth;
	if (this.m_sidePanelObj && this.m_sidePanelObj.length) {
		this.m_sidePanelObj.css({
			width : this.m_width
		});
	}
	return this;
};

/**
 * Returns the set height for the side panel.
 * 
 * @returns {string} the current value for height
 */
SidePanel.prototype.getHeight = function() {
	return this.m_height;
};

/**
 * Sets the height for the side panel.
 * 
 * @param {string}
 *            newHeight The new value for height in string format with "###px"
 *            or "###%" as the format
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setHeight = function(newHeight) {
	if (!this.m_regexHeightWidth.test(newHeight)) {
		logger.logError("Parameter newHeight must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.setHeight function.");
		return;
	}

	this.m_height = newHeight;
	if (this.m_sidePanelObj && this.m_sidePanelObj.length) {
		this.m_sidePanelObj.css({
			height : this.m_height
		});
	}
	return this;
};

/**
 * Returns the set max height for the side panel.
 * 
 * @returns {string} the current value for max height
 */
SidePanel.prototype.getMaxHeight = function() {
	return this.m_maxHeight;
};

/**
 * Sets the max height for the side panel.
 * 
 * @param {string}
 *            newMaxHeight The new value for max height in string format with
 *            "###px" or "###%" as the format
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setMaxHeight = function(newMaxHeight) {
	if (!this.m_regexHeightWidth.test(newMaxHeight)) {
		logger.logError("Parameter newMaxHeight must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.setMaxHeight function.");
		return;
	}

	this.m_maxHeight = newMaxHeight;
	if (this.m_sidePanelObj && this.m_sidePanelObj.length) {
		this.m_sidePanelObj.css({
			"max-height" : this.m_maxHeight
		});
	}
	return this;
};

/**
 * Returns the set min height for the side panel.
 * 
 * @returns {string} the current value for min height
 */
SidePanel.prototype.getMinHeight = function() {
	return this.m_minHeight;
};

/**
 * Sets the min height for the side panel.
 * 
 * @param {string}
 *            newMinHeight The new value for min height in string format with
 *            "###px" or "###%" as the format
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setMinHeight = function(newMinHeight) {
	if (!this.m_regexHeightWidth.test(newMinHeight)) {
		logger.logError("Parameter newMinHeight must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.setMinHeight function.");
		return;
	}

	this.m_minHeight = newMinHeight;
	if (this.m_sidePanelObj && this.m_sidePanelObj.length) {
		this.m_sidePanelObj.css({
			"min-height" : this.m_minHeight
		});
	}
	return this;
};

/**
 * Returns the users function chosen to be executed after expanding the side
 * panel
 * 
 * @returns {function} the function for expanding the panel
 */
SidePanel.prototype.getOnExpandFunction = function() {
	return this.m_onExpandFunc;
};

/**
 * Sets the users function to be executed after expanding the side panel
 * 
 * @param {function}
 *            func The function to execute after expanding the panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setOnExpandFunction = function(func) {
	if (typeof func !== "function") {
		logger.logError("Parameter func must be of type function for the SidePanel.setOnExpandFunction.");
		return;
	}

	this.m_onExpandFunc = func;
	return this;
};

/**
 * Returns the users function chosen to be executed after collapsing the side
 * panel
 * 
 * @returns {function} the function for collapsing the panel
 */
SidePanel.prototype.getOnCollapseFunction = function() {
	return this.m_onCollapseFunc;
};

/**
 * Sets the users function to be executed after collapsing the side panel
 * 
 * @param {function}
 *            func The function to execute after collapsing the panel
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
SidePanel.prototype.setOnCollapseFunction = function(func) {
	if (typeof func !== "function") {
		logger.logError("Parameter func must be of type function for the SidePanel.setOnCollapseFunction.");
		return;
	}

	this.m_onCollapseFunc = func;
	return this;
};

/**
 * Returns the users function chosen to be executed after the side panel loses
 * focus
 * 
 * @returns {function} the function for the side panel losing focus
 */
/*SidePanel.prototype.getFocusOutFunction = function() {
	return this.m_focusOutFunc;
};*/

/**
 * Sets the users function to be executed after the side panel loses focus
 * 
 * @param {function}
 *            func The function to execute after the side panel loses focus
 * @returns {SidePanel} returns the side panel object to allow chaining
 */
/*SidePanel.prototype.setFocusOutFunction = function(func) {
	if (typeof func !== "function") {
		throw new Error(
				"Parameter func must be of type function for the SidePanel.setFocusOutFunction.");
	}

	this.m_focusOutFunc = func;
	return this;
};*/

// ------------------------------------------------------------------------
// Main Functions
// ------------------------------------------------------------------------
/**
 * Renders the base HTML for an empty side-panel. Set height and width before
 * calling this if you want to use an empty panel.
 */
SidePanel.prototype.renderSidePanel = function() {
	// check if side-panel has been rendered, if so do nothing
	if (this.m_sidePanelContents) {
		return;
	}

	if (!this.m_containerElementId) {
		logger.logError("Container element id for side panel has not been set to use in the SidePanel.renderSidePanel function.");
		return;
	}

	this.m_parentContainer = $("#" + this.m_containerElementId);
	if (!this.m_parentContainer.length) {
		logger.logError("Container element object for side panel not found to use in the SidePanel.renderSidePanel function.");
		return;
	}

	if (!this.m_uniqueId) {
		logger.logError("Unique id for side panel has not been set to use in the SidePanel.renderSidePanel function.");
		return;
	}
	var uniqueId = this.m_uniqueId;
	var panelDivHTML = "<div id='"
			+ this.m_panelId
			+ "' class='side-panel'><div id='closeButton"
			+ uniqueId
			+ "' class='sp-close-btn'>&nbsp;</div><div id='sidePanelContents"
			+ uniqueId
			+ "' class='sp-all-contents'>&nbsp;</div><div id='sidePanelExpandCollapse"
			+ uniqueId
			+ "' class='sp-expand-collapse hidden'><div id='sidePanelExpandCollapseIcon"
			+ uniqueId + "'>&nbsp;</div></div></div>";
	this.m_parentContainer.html(panelDivHTML);

	// query to populate reusable DOM objects
	this.m_sidePanelObj = $("#" + this.m_panelId);
	this.m_sidePanelContents = $("#sidePanelContents" + uniqueId);
	this.m_sidePanelBodyContents = $("#sidePanelContents" + uniqueId); //set this one to be the same for passivity
	this.m_closeButton = $("#closeButton" + uniqueId);

	// adjust panel to desired height and width, the setters adjust the css
	this.setHeight(this.m_height);
	this.setWidth(this.m_width);
	if (this.m_minHeight) {
		this.m_sidePanelObj.css("min-height", this.m_minHeight);
	}
	this.m_closeButton.hide();
};

/**
 * Renders the inner HTML in the side-panel
 * 
 * @param {string|jQuery}
 *            contents A string or jQuery object with the contents for the
 *            side-panel
 */
SidePanel.prototype.setContents = function(contents) {
	// check if side-panel has been rendered, if not call renderSidePanel
	if (!this.m_sidePanelContents) {
		this.renderSidePanel();
	}

	// render panel contents based on type passed in
	if (typeof contents === "string" && contents.length) {
		// use .html to clean up any event listeners from previous content
		this.m_sidePanelContents.html(contents);
	} else if (contents instanceof jQuery) {
		// clean up event listeners and clear content
		this.m_sidePanelContents.empty();
		// append new content
		this.m_sidePanelContents.append(contents);
	} else {
		logger.logError("Parameter contents must be of type string or jQuery Object for the SidePanel.setContents function.");
		return;
	}

	this.m_scrollContainer = $("#sidePanelScrollContainer" + this.m_uniqueId);

	// if an expand option was chosen, call that function
	if (this.m_expandOption === this.expandOption.EXPAND_DOWN) {
		if (!this.m_maxHeight) {
			logger.logError("Max height must be set for use in SidePanel.setContents when an expand option is used.");
			return;
		}
		// set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight); 
		this.m_expandOption.call(this);
	} else {
		// when default or none, set height to auto so it shows all content
		this.m_sidePanelObj.css("height", "auto");
		// still need to handle resize, unless pref turned off
		if (this.m_fullPanelScrollOn) {
			if (!this.m_maxHeight) {
				logger.logError("Max height must be set for use in SidePanel.setContents when full panel scrolling is turned on.");
				return;
			}
			// set max height only if expand or scroll on
			this.setMaxHeight(this.m_maxHeight);
			this.fullPanelScroll();
		}
	}
};

/*********************** Functions for the pre-built side panel *********************************/
/**
 * Renders the base HTML for a side panel with a pre-built header. Set height and width before
 * calling this if you want to use an empty panel.
 */
SidePanel.prototype.renderPreBuiltSidePanel = function() {
	// check if side-panel has been rendered, if so do nothing
	if (this.m_sidePanelContents) {
		return;
	}

	if (!this.m_containerElementId) {
		logger.logError("Container element id for side panel has not been set to use in the SidePanel.renderSidePanel function.");
		return;
	}

	this.m_parentContainer = $("#" + this.m_containerElementId);
	if (!this.m_parentContainer.length) {
		logger.logError("Container element object for side panel not found to use in the SidePanel.renderSidePanel function.");
		return;
	} 

	if (!this.m_uniqueId) {
		logger.logError("Unique id for side panel has not been set to use in the SidePanel.renderSidePanel function.");
		return;
	}
	
	this.m_usingUpdatedPanel = true; //this flag will be used in pre-existing functions to allow for passivity


	var uniqueId = this.m_uniqueId;
	var panelDivHTML = "<div id='" + this.m_panelId + "' class='side-panel'>"
		+ "<div id='sidePanelContents" + uniqueId + "'>"
		+ "<div id='sidePanelHeader" + uniqueId + "' class='sp-header2'>"
		+ "<div id='sidePanelActionBar" + uniqueId + "' class='sp-action-bar'>"
		+ "<div id='sidePanelActions" + uniqueId + "' class='sp-actions'>&nbsp;</div><div id='cornerCloseButton" + uniqueId + "' class='sp-close-btn2'>&nbsp;</div>"
		+ "</div><div id='sidePanelHeaderText" + uniqueId + "' class='sp-header-text'>&nbsp;</div>"
		+ "<div id='sidePanelSubtitle" + uniqueId + "' class='sp-subtitle secondary-text'>&nbsp;</div><div id='sidePanelAlertBanner" + uniqueId + "' class='sp-alert-banner'>&nbsp;</div>"
		+ "</div><div class='sp-separator2'>&nbsp;</div><div id='sidePanelBodyContents" + uniqueId + "' class=''>&nbsp;</div>"
		+ "</div><div id='sidePanelExpandCollapse" + uniqueId + "' class='sp-expand-collapse2 hidden'><div id='sidePanelExpandCollapseIcon" + uniqueId + "' class='sp-expand'>&nbsp;</div></div>"
		+ "</div>";
	this.m_parentContainer.html(panelDivHTML);

	// query to populate reusable DOM objects
	this.m_sidePanelObj = $("#" + this.m_panelId);
	this.m_sidePanelBodyContents = $("#sidePanelBodyContents" + uniqueId);
	this.m_sidePanelContents = $("#sidePanelContents" + uniqueId);
	this.m_sidePanelHeader = $("#sidePanelHeader" + uniqueId);
	this.m_cornerCloseButton = $("#cornerCloseButton" + uniqueId);
	this.m_headerTitleObj = $("#sidePanelHeaderText" + uniqueId);
	this.m_subtitleObj = $("#sidePanelSubtitle" + uniqueId);
	this.m_sidePanelActionsObj = $("#sidePanelActions" + uniqueId);
	this.m_sidePanelAlertBanner = $("#sidePanelAlertBanner" + uniqueId);

	// adjust panel to desired height and width, the setters adjust the css
	this.setHeight(this.m_height);
	this.setWidth(this.m_width);
	if (this.m_minHeight) {
		this.m_sidePanelObj.css("min-height", this.m_minHeight);
	}
	this.m_cornerCloseButton.hide();
	this.m_subtitleObj.addClass("hidden");
	this.m_sidePanelAlertBanner.addClass("hidden");
};

/**
 * Sets the title text in the side panel
 * 
 * @param {string}
 *            titleString A string with the text for the side-panel header
 */
SidePanel.prototype.setTitleText = function(titleString) {
	if (!this.m_headerTitleObj) {
		logger.logError("Side panel title object cannot be found.");
		return;
	}
	
	this.m_headerTitleObj.text(titleString);
};

/**
 * Sets the sub title text in the side panel as a plain string
 * 
 * @param {string}
 *            subtitleString A string with the text for the side-panel subtitle
 */
SidePanel.prototype.setSubtitleText = function(subtitleString) {
	if (!this.m_subtitleObj) {
		logger.logError("Side panel subtitle object cannot be found.");
		return;
	}
	
	this.m_subtitleObj.text(subtitleString);
	this.m_subtitleObj.removeClass("hidden");
};

/**
 * Sets the sub title text in the side panel as an HTML string
 * 
 * @param {string}
 *            subtitleHTML An HTML string with the html build for the side-panel subtitle
 */
SidePanel.prototype.setSubtitleAsHTML = function(subtitleHTML) {
	if (!this.m_subtitleObj) {
		logger.logError("Side panel subtitle object cannot be found.");
		return;
	}
	
	this.m_subtitleObj.html(subtitleHTML);
	this.m_subtitleObj.removeClass("hidden");
};

/**
 * Hides the sub title text in the side panel
 * 
 */
SidePanel.prototype.removeSubtitle = function() {
	if (!this.m_subtitleObj) {
		logger.logError("Side panel subtitle object cannot be found.");
		return;
	}

	this.m_subtitleObj.addClass("hidden");
};

/**
 * Sets the action items in the side panel as an HTML string
 * 
 * @param {string}
 *            actionHTML An HTML string with the html build for the side-panel actions
 */
SidePanel.prototype.setActionsAsHTML = function(actionHTML) {
	if (!this.m_sidePanelActionsObj) {
		logger.logError("Side panel action bar object cannot be found.");
		return;
	}
	
	this.m_sidePanelActionsObj.html(actionHTML);
};

/**
 * Sets the alert banner in the side panel as an HTML string
 * 
 * @param {string}
 *            bannerHTML An HTML string with the html build for the side-panel alert banner
 */
SidePanel.prototype.setAlertBannerAsHTML = function(bannerHTML) {
	if (!this.m_sidePanelAlertBanner) {
		logger.logError("Side panel alert banner object cannot be found.");
		return;
	}
	
	this.m_sidePanelAlertBanner.html(bannerHTML);
	this.m_sidePanelAlertBanner.removeClass("hidden");
	this.m_sidePanelObj.addClass("sp-alert-banner-showing");
};

/**
 * Hides the alert banner in the side panel
 * 
 */
SidePanel.prototype.removeAlertBanner = function() {
	if (!this.m_sidePanelAlertBanner) {
		logger.logError("Side panel alert banner object cannot be found.");
		return;
	}

	this.m_sidePanelAlertBanner.addClass("hidden");
	this.m_sidePanelObj.removeClass("sp-alert-banner-showing");
};

/**
 * Option to display the corner close side-panel button
 */
SidePanel.prototype.showCornerCloseButton = function() {
	if(!this.m_cornerCloseButton) {
		logger.logError("Corner close button is not defined");
		return;
	}		
	this.m_cornerCloseButton.removeAttr('style'); //clears out the inline style and displays the button
};

/**
 * Returns the function to be executed when the corner close button is clicked
 * 
 * @returns {SidePanel.m_cornerCloseFunction} the function to close the side panel
 */
SidePanel.prototype.getCornerCloseFunction = function() {
	return this.m_cornerCloseFunction;
};

/**
 * Sets the close function
 * 
 * @param {closeFunction}
 *            closeFunction The function which is executed when we click on the corner close button 
 */
SidePanel.prototype.setCornerCloseFunction = function(closeFunction) {
	if(closeFunction instanceof Function) {
		this.m_cornerCloseFunction = closeFunction;
	} else {
		logger.logError("Corner close function must be of type 'Function'.");
		return;
	}
};

/**
 * Shows or hides the expand bar based on need to show more of side panel body
 */
SidePanel.prototype.showHideExpandBar = function() {
	if (this.m_usingUpdatedPanel && this.m_sidePanelObj[0].offsetHeight) {
		var sidePanelBody = document.getElementById("sidePanelBodyContents" + this.m_uniqueId);
		var visibleSidePanelHeight = this.m_sidePanelObj[0].offsetHeight;
		var titleHeight = this.m_sidePanelHeader[0].offsetHeight;
		var visibleBodyHeight = 0;
		
		if (titleHeight < visibleSidePanelHeight) {
			visibleBodyHeight = visibleSidePanelHeight - titleHeight;
		} else {
			this.m_expCollapseBarObj.removeClass("hidden");
		}
		
		if (visibleBodyHeight && sidePanelBody.scrollHeight > visibleBodyHeight) {
			this.m_expCollapseBarObj.removeClass("hidden");
		} else if (visibleBodyHeight && visibleBodyHeight >= sidePanelBody.scrollHeight) {
			this.m_expCollapseBarObj.addClass("hidden");
		}
	}
};

/**
 * Returns the value of whether or not padding should be removed from the sp-body-contents-padding div
 * 
 * @return {Boolean} whether the padding in side panel body contents should be removed
 */
SidePanel.prototype.getApplyBodyContentsPadding = function() {
	return this.m_applyBodyContentsPadding;
};

/**
 * Sets the variable that removes the body contents padding
 *
 * @param {string}
 *            this.m_applyBodyContentsPadding A boolean flag to turn the padding in the side panel on or off
 *
 * @return {Undefined}
 */
SidePanel.prototype.setApplyBodyContentsPadding = function(applyBodyContentsPadding) {
	if(typeof(applyBodyContentsPadding) === "boolean") {
		this.m_applyBodyContentsPadding = applyBodyContentsPadding;
	} else {
		logger.logError("applyBodyContentsPadding must be of type 'Boolean'.");
		return;
	}
};


/*********************** END OF Functions for the pre-built side panel *********************************/

/**
 * Calls the appropriate function to handle resizing the panel based on which
 * type of panel it is.
 * 
 * @param {string}
 *            maxHeight A string to represent the maximum height available for
 *            the side panel to expand in string format with "###px" or "###%"
 *            as the format
 */
SidePanel.prototype.resizePanel = function(maxHeight) {
	if (!this.m_regexHeightWidth.test(maxHeight)) {
		logger.logError("Parameter maxHeight must match the regex /^(\d+((px)|%){1})$/ for the SidePanel.resizePanel function.");
		return;
	}

	this.m_maxHeight = maxHeight;

	// Call resize function based on which type of panel is built
	if (this.m_expandOption === this.expandOption.EXPAND_DOWN) {
		// set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight);
		
		this.showHideExpandBar();
		
		this.collapseSidePanel();
	} else {
		// when default or none, still need to handle resize, unless pref turned
		// off
		if (this.m_fullPanelScrollOn) {
			// set max height only if expand or scroll on
			this.setMaxHeight(this.m_maxHeight);
			this.fullPanelScroll();
		}
	}
};

/**
 * This will be called if expand is turned off for the panel and full panel
 * scroll is turned on. This function will put a scroll bar on the panel if its
 * contents exceed the height of the window view.
 */
SidePanel.prototype.fullPanelScroll = function() {
	if (!this.m_scrollContainer.length) {
		logger.logError("Scroll container object for side panel not found for use in SidePanel.fullPanelScroll.");
		return;
	}
	if (!this.m_maxHeight) {
		logger.logError("Max height for side panel not set for use in SidePanel.fullPanelScroll.");
		return;
	}

	// Reset any previous max-height to allow panel to expand again
	if (this.m_scrollContainer.css("max-height") !== "none") {
		this.m_scrollContainer.css("max-height", "none");
	}
	
	var titleHeight = null;
	
	// set up for scrolling the panel if contents exceed panel height
	if (this.m_usingUpdatedPanel) {
		var bodyContentHeight = this.m_sidePanelBodyContents[0].offsetHeight;
		titleHeight = this.m_sidePanelContents.height() - bodyContentHeight;
	} else {
		var contentHeight = this.m_sidePanelContents[0].offsetHeight;
		titleHeight = contentHeight - this.m_scrollContainer.height();
	}

	// Set height to auto so it will expand to show contents
	this.m_sidePanelObj.css({
		"height" : "auto"
	});
	// Incrementing scrollMaxHeight to prevent issues when the content is the
	// same height as the max (its finicky)
	var scrollMaxHeight = (this.m_sidePanelObj.height() - titleHeight) + 1;

	// To enable the scroll bar, set the max-height. Need px here for other
	// check below to be number
	this.m_scrollContainer.css("max-height", scrollMaxHeight + "px");
	
	if (scrollMaxHeight === this.m_scrollContainer.height()) {
		this.m_scrollContainer.addClass("sp-add-scroll");
	} else {
		this.m_scrollContainer.removeClass("sp-add-scroll");
	}

};

/**
 * Register the following events: 1. side-panel mouse enter/leave 2. Side Panel
 * focus-out
 */
SidePanel.prototype.expandDownListeners = function() {
	// If the side panel object is not found, do nothing
	if (this.m_sidePanelObj === null) {
		return;
	}

	var uniqueId = this.m_uniqueId;
	var self = this;
	var expCollapseBarId = "#sidePanelExpandCollapse" + uniqueId;

	// Register the mouse enter event for side-panel to show the expand/collapse
	// bar.
	this.m_expCollapseIconObj = $("#sidePanelExpandCollapseIcon" + uniqueId);
	this.m_expCollapseBarObj = $(expCollapseBarId);
	var scrollContainer = null;
	var ppId = "#" + this.m_panelId;
	
	//remove all event handlers from sidePanelObj
	this.m_sidePanelObj.off();
	
	//only if the panel is not expanded, call showHideExpandBar
	if (!this.m_sidePanelObj.hasClass("sp-focusin")) {
		this.showHideExpandBar();
	}
	
	// When the user hovers over the side-panel, if the content exceeds the
	// height of the side-panel,
	// an expand/collapse control is presented.
	if (!this.m_usingUpdatedPanel) {
		this.m_sidePanelObj.on("mouseenter", function() {
			// if the exp/coll bar is visible, do not carry on this code
			if (!self.m_expCollapseBarObj.hasClass("hidden")) {
				return;
			}

			// Have to requery this DOM object because it could be different than
			// before (i.e. exp/clps options within content)
			scrollContainer = $("#sidePanelScrollContainer" + uniqueId);

			// If the side-panel info is overflowed or has a scroll bar, show the
			// expand icon
			if ((this.scrollHeight > this.offsetHeight) || scrollContainer.hasClass("sp-add-scroll")) {
				self.m_expCollapseIconObj.addClass("sp-expand").removeClass("sp-collapse");
				// make the section visible.
				self.m_expCollapseBarObj.removeClass("hidden");
			}

			if (self.m_mouseEnterFunc) {
				self.m_mouseEnterFunc();
			}
		});

		// Register the mouse leave event for side-panel to hide the expand/collapse
		// bar.
		this.m_sidePanelObj.on("mouseleave", function() {

			if (self.m_expCollapseIconObj.hasClass("sp-expand")) {
				// Hide the section.
				self.m_expCollapseBarObj.addClass("hidden");
			}

			if (self.m_mouseLeaveFunc) {
				self.m_mouseLeaveFunc();
			}
		});
	}

	this.m_sidePanelObj.on("click", expCollapseBarId, function(event) {
		self.expandCollapseSidePanel();
	});

	// Set the tabindex to -1 so clicking outside the component causes focusout
	// to get triggered.
	/*this.m_sidePanelObj.attr("tabindex", -1);
	this.m_sidePanelObj.on("focusout", function(event) {
		var toElem = event.relatedTarget;
		if (!($(toElem).closest(self.m_sidePanelObj).length)) {
			self.collapseSidePanel();
	
			if (self.m_focusOutFunc) {
				self.m_focusOutFunc();
			}
		}
	});*/
	
	//If the side panel is already expanded, call expandSidePanel to get a scroll bar if needed
	if (this.m_expCollapseIconObj.hasClass("sp-collapse")) {
		this.expandSidePanel();
	}
};

/**
 * This will be called on the click event of expand/collapse bar in the
 * side-panel. On expand, set max-height for scroll container and extend the
 * height to just above the bottom of page. Reset the above on collapse.
 */
SidePanel.prototype.expandCollapseSidePanel = function() {
	// If the side panel object is not found, do nothing
	if (!this.m_sidePanelObj.length) {
		return;
	}

	// Expand the side panel to show all of its contents, it more contents than
	// space, scroll
	if (this.m_expCollapseIconObj.hasClass("sp-expand")) {
		this.expandSidePanel();
	}
	// Collapse the side panel back to previous height before expanding
	else {
		this.collapseSidePanel();
	}
};

/**
 * This will be called on the click event of expand/collapse icon in the
 * side-panel. On expand, set max-height for scroll container and extend the
 * height to just above the bottom of page.
 */
SidePanel.prototype.expandSidePanel = function() {
	//if the side panel is not already expanded, then set up the missing pieces
	if (!this.m_sidePanelObj.hasClass("sp-focusin")) {
		//Add expand bar if it is not currently showing
		this.m_expCollapseBarObj.removeClass("hidden");
		
		// Upon expand, absolute positioning is applied to allow the side panel to
		// expand over other content
		this.m_parentContainer.css({
			position : "absolute"
		});
		
		// Add the styles like shadow.
		this.m_sidePanelObj.addClass("sp-focusin");
		
		// Replace the expand-collapse icon
		this.m_expCollapseIconObj.addClass("sp-collapse").removeClass("sp-expand");
	}
	
	//Set panel obj to have min-height that matches the current panel height (so it does not "expand" shorter)
	this.m_previousMinHeight = this.m_minHeight;
	
	//convert the "45px" strings to their respective int values 45
	var heightVal = parseInt(this.m_height, 10);
	var minHeightVal = parseInt(this.m_minHeight, 10);
	
	if (heightVal > minHeightVal) {
		this.setMinHeight(this.m_height);
	}

	//Get the current scroll position to scrollTo after expand
	var scrollContainer = $("#sidePanelScrollContainer" + this.m_uniqueId);
	var currScrollPositionVal = 0;
	if(scrollContainer.length){
		currScrollPositionVal = $("#sidePanelScrollContainer" + this.m_uniqueId).scrollTop();
	}

	//Remove the max-height if its already on the scroll container, otherwise it will not expand to full size
	this.m_scrollContainer.css("max-height", "");
	
	var titleHeight = null;
	
	// set up for scrolling the panel if contents exceed panel height
	if (this.m_usingUpdatedPanel) {
		var bodyContentHeight = this.m_sidePanelBodyContents[0].offsetHeight;
		titleHeight = this.m_sidePanelContents.height() - bodyContentHeight;
	} else {
		var contentHeight = this.m_sidePanelContents[0].offsetHeight;
		titleHeight = contentHeight - this.m_scrollContainer.height();
	}

	// Set height to auto so it will expand to show contents
	this.m_sidePanelObj.css({
		"height" : "auto"
	});

	// Incrementing scrollMaxHeight to prevent issues when the content is the
	// same height as the max (its finicky)
	var scrollMaxHeight = (this.m_sidePanelObj.height() - titleHeight) + 1;

	// To enable the scroll bar, set the max-height. Need px here for other
	// check below to be number
	this.m_scrollContainer.css("max-height", scrollMaxHeight + "px");
	
	if (Math.round(scrollMaxHeight) === Math.round(this.m_scrollContainer.outerHeight())) {
		this.m_scrollContainer.addClass("sp-add-scroll");
	}

	//Scroll back to the original position
	if(scrollContainer.length){
		scrollContainer.scrollTop(currScrollPositionVal);
	}

	if (this.m_onExpandFunc) {
		this.m_onExpandFunc();
	}
};

/**
 * This will be called on the click event of expand/collapse icon in the
 * side-panel. On collapse, set reset height for scroll container.
 */
SidePanel.prototype.collapseSidePanel = function() {
	// collapse panel only if it is expanded
	if (this.m_expCollapseIconObj.hasClass("sp-collapse")) {
		// Revert the positioning of the side-panel
		this.m_parentContainer.css({
			position : "relative"
		});

		// Set the height of the pane as previous height
		this.m_sidePanelObj.css("height", this.m_height);

		// To disable the scroll bar, set the overflow as hidden and remove the
		// max-height.
		this.m_scrollContainer.css("max-height", "none");
		this.m_scrollContainer.removeClass("sp-add-scroll");
		
		if (this.m_usingUpdatedPanel) {
			// Remove collapse icon, put expand back
			this.m_expCollapseIconObj.removeClass("sp-collapse").addClass("sp-expand");
		} else {
			// Remove collapse icon
			this.m_expCollapseIconObj.removeClass("sp-collapse");
			// Hide the section
			this.m_expCollapseBarObj.addClass("hidden");
		}

		// Remove the styles like shadow.
		this.m_sidePanelObj.removeClass("sp-focusin");
		
		//show/hide the exp/col bar as necessary
		this.showHideExpandBar();
		
		//reset min height back to what it was before calling expandSidePanel
		this.setMinHeight(this.m_previousMinHeight);
		
		if (this.m_onCollapseFunc) {
			this.m_onCollapseFunc();
		}
	}
};

/**
 * Type of panel being created, more can be added later
 */
SidePanel.prototype.expandOption = {
	NONE : null,
	EXPAND_DOWN : SidePanel.prototype.expandDownListeners
};


/**
 * Option to show the side panel
 */
SidePanel.prototype.showPanel = function() {
	// Show the side panel by removing the display:non property
	this.m_sidePanelObj.show();
};


/**
 * Option to hide the side panel
 */
SidePanel.prototype.hidePanel = function() {
	// hide the side panel by adding the display:non property
	this.m_sidePanelObj.hide();
};


/**
 * Option to display the Close Side Panel button
 */
SidePanel.prototype.showCloseButton = function() {
	if(!this.m_closeButton) {
		logger.logError("Close button is not defined");
		return;
	}		
	this.m_closeButton.show();	
};

/**
 * Returns the function to be executed when close button is clicked
 * 
 * @returns {SidePanel.m_closeFunction} the function to close the side panel
 */
SidePanel.prototype.getCloseFunction = function() {
	return this.m_closeFunction;
};

/**
 * Sets the close function
 * 
 * @param {closeFunction}
 *            closeFunction The function which is executed when we click on the close button 
 */
SidePanel.prototype.setCloseFunction = function(closeFunction) {
	if(closeFunction instanceof Function) {
		this.m_closeFunction = closeFunction;
	}	
};
/**
 * CompSidePanel.js
 * 
 * @author Karoline Checkett
 * 
 * CompSidePanel class
 * ============================================================================
 * 
 * Uses the base SidePanel class and makes it easier for components to
 * implement.
 */

// -----------------------------------------------------------------------
// Class Declaration
// ------------------------------------------------------------------------
/**
 * Instantiates a new component side-panel object
 * 
 * @name CompSidePanel
 * @namespace
 * @param {string}
 *            compId A unique ID for the object containing containing the
 *            side-panel. Likely the component ID.
 * @param {string}
 *            panelElementId The element id that will contain the side-panel.
 */
CompSidePanel = function(compId, panelElementId) {
	this.setUniqueId(compId);
	this.setContainerElementId(panelElementId);
	this.m_compBodyId = null;
	this.m_compBodyObj = null;
	this.m_removeOffsetFromHeight = 0;
};

CompSidePanel.prototype = new SidePanel();
CompSidePanel.prototype.constructor = SidePanel;


/**
 * Sets the offset height needed to be removed for panel height calculations
 * 
 * @param {number}
 *            offsetHeight The extra space in pixels that should be subtracted
 *            from the max height calculations for the side panel
 */
CompSidePanel.prototype.setOffsetHeight = function(offsetHeight) {
	if(isNaN(offsetHeight)) {
		logger.logError("Value passed to setOffsetHeight must be a number");
		return;
	}
	this.m_removeOffsetFromHeight = offsetHeight;
};

/**
 * Renders the inner HTML in the comp-side-panel
 * 
 * @param {string|jQuery}
 *            contents A string or jQuery object with the contents for the
 *            side-panel
 * @param {string}
 *            componentBodyId The id for the contents container in the main body
 *            in the component
 */
CompSidePanel.prototype.setContents = function(contents, componentBodyId) {
	// check if side-panel has been rendered, if not call renderSidePanel
	if (!this.m_sidePanelBodyContents) {
		this.renderSidePanel();
	}
	else{
		if(this.getApplyBodyContentsPadding()){
			this.m_sidePanelBodyContents.addClass('sp-body-contents-padding');
		}
		else{
			this.m_sidePanelBodyContents.removeClass('sp-body-contents-padding');
		}
	}

	// render panel contents based on type passed in
	if (typeof contents === "string" && contents.length) {
		// use .html to clean up any event listeners from previous content
		this.m_sidePanelBodyContents.html(contents);
	} else if (contents instanceof jQuery) {
		// clean up event listeners and clear content
		this.m_sidePanelBodyContents.empty();
		// append new content
		this.m_sidePanelBodyContents.append(contents);
	} else {
		logger.logError("Parameter contents must be of type string or jQuery Object for the SidePanel.setContents function.");
		return;
	}

	this.m_compBodyId = componentBodyId;
	this.m_scrollContainer = $("#sidePanelScrollContainer" + this.m_uniqueId);

	// check if maxHeight has been set yet, if not attempt to set using
	// createDefaultMaxHeight
	if (!this.m_maxHeight) {
		this.createDefaultMaxHeight();
	}

	// if an expand option was chosen, call that function
	if (this.m_expandOption) {
		if (!componentBodyId) {
			logger.logError("Parameter componentBodyId must be specified for the CompSidePanel.setContents function.");
			return;
		}
		this.m_compBodyObj = $("#" + componentBodyId);
		// set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight);
		this.m_expandOption.call(this);
		
	} else {
		// when default or none, set height to auto so it shows all content
		this.m_sidePanelObj.css("height", "auto");
		// still need to handle resize, unless pref turned off
		if (this.m_fullPanelScrollOn) {
			// set max height only if expand or scroll on
			this.setMaxHeight(this.m_maxHeight);
			this.fullPanelScroll();
		}
	}
};

/**
 * Register the following events: 1. side-panel mouse enter/leave 2. Component
 * focus-out Overriding this function to set the focus out on the component,
 * instead of the panel, so you can still click in the component body and the
 * panel wont close
 */
CompSidePanel.prototype.expandDownListeners = function() {
	var uniqueId = this.m_uniqueId;
	var compBodyObj = this.m_compBodyObj;
	var self = this;
	var expCollapseBarId = "#sidePanelExpandCollapse" + uniqueId;
	var closeButton = "#closeButton" + uniqueId;
	var cornerCloseButton = "#cornerCloseButton" + uniqueId;

	// Register the mouse enter event for side-panel to show the expand/collapse
	// bar.
	this.m_expCollapseIconObj = $("#sidePanelExpandCollapseIcon" + uniqueId);
	this.m_expCollapseBarObj = $(expCollapseBarId);
	var scrollContainer = null;
	var ppId = "#" + this.m_panelId;
	
	//remove all event handlers from sidePanelObj and CompBodyObj
	this.m_sidePanelObj.off();
	compBodyObj.off();
	
	//only if the panel is not expanded, call showHideExpandBar
	if (!this.m_sidePanelObj.hasClass("sp-focusin")) {
		this.showHideExpandBar();
	}
	
	// When the user hovers over the side-panel, if the content exceeds the
	// height of the side-panel,
	// an expand/collapse control is presented.
	if (!this.m_usingUpdatedPanel) {
		this.m_sidePanelObj.on("mouseenter", function() {
			// if the exp/coll bar is visible, do not carry on this code
			if (!self.m_expCollapseBarObj.hasClass("hidden")) {
				return;
			}

			// Have to requery this DOM object because it could be different than
			// before (i.e. exp/clps options within content)
			scrollContainer = $("#sidePanelScrollContainer" + uniqueId);

			// If the side-panel info is overflowed or has a scroll bar, show the
			// expand icon
			if ((this.scrollHeight > this.offsetHeight) || scrollContainer.hasClass("sp-add-scroll")) {
				self.m_expCollapseIconObj.addClass("sp-expand");
				self.m_expCollapseIconObj.removeClass("sp-collapse");
				// make the section visible.
				self.m_expCollapseBarObj.removeClass("hidden");
			}

			if (self.m_mouseEnterFunc) {
				self.m_mouseEnterFunc();
			}
		});

		// Register the mouse leave event for side-panel to hide the expand/collapse
		// bar.
		this.m_sidePanelObj.on("mouseleave", function() {

			if (self.m_expCollapseIconObj.hasClass("sp-expand")) {
				// Hide the section.
				self.m_expCollapseBarObj.addClass("hidden");
			}

			if (self.m_mouseLeaveFunc) {
				self.m_mouseLeaveFunc();
			}
		});
	}
	
	// Register the click event for the expand/collapse bar
	this.m_sidePanelObj.on("click", expCollapseBarId, function(event) {
		self.expandCollapseSidePanel();
	});
	
	// Set the tabindex to -1 so clicking outside the component causes focusout
	// to get triggered
	/*compBodyObj.attr("tabindex", -1);
	compBodyObj.on("focusout", function(event) {
		var toElem = event.relatedTarget;
		if (!($(toElem).closest(compBodyObj).length)) {
			self.collapseSidePanel();

			if (self.m_focusOutFunc) {
				self.m_focusOutFunc();
			}
		}
	});*/
	
	if (this.m_usingUpdatedPanel) {
		// Register the click event for the corner close button
		this.m_sidePanelObj.on("click", cornerCloseButton, function(event) {
			if(!self.m_cornerCloseFunction){
				logger.logError("You must set the SidePanel.cornerCloseFunction.");
				return;
			}
			self.collapseSidePanel();
			self.m_sidePanelObj.hide();
			self.getCornerCloseFunction()();
		});
	} else {
		// Register the click event for the close button
		this.m_sidePanelObj.on("click", closeButton, function(event) {
			if(!self.m_closeFunction){
				logger.logError("You must set the SidePanel.closeFunction.");
				return;
			}
			self.collapseSidePanel();
			self.m_sidePanelObj.hide();
			self.getCloseFunction()();
		});
	}
	
	//If the side panel is already expanded, call expandSidePanel to get a scroll bar if needed
	if (this.m_expCollapseIconObj.hasClass("sp-collapse")) {
		this.expandSidePanel();
	}
};

/**
 * This will be called on the click event of expand/collapse icon in the
 * side-panel. On expand, set max-height for scroll container and extend the
 * height to just above the bottom of page.
 */
CompSidePanel.prototype.expandSidePanel = function() {
	// call the base expandSidePanel function
	SidePanel.prototype.expandSidePanel.call(this, null);
};

/**
 * This will be called on the click event of expand/collapse icon in the
 * side-panel. On collapse, set reset height for scroll container.
 */
CompSidePanel.prototype.collapseSidePanel = function() {
	// call the base expandSidePanel function
	SidePanel.prototype.collapseSidePanel.call(this, null);
};

/**
 * This will be called on to attempt to set a default max height, checking to
 * see if the consuming artifact is in a viewpoint. If so, it determines the
 * appropriate maximum height that the panel can expand to.
 */
CompSidePanel.prototype.createDefaultMaxHeight = function() {
	var viewPointBodyObj = $("#vwpBody");
	// extra padding at bottom of pane between window
	var windowPadding = 70;

	// stop calculations if we are not in a viewpoint
	if (!viewPointBodyObj.length) {
		return;
	}

	var maxHeight = (viewPointBodyObj.height() - windowPadding - this.m_removeOffsetFromHeight) + "px";
	this.m_maxHeight = maxHeight;
};

/**
 * Calls the appropriate function to handle resizing the panel based on which
 * type of panel it is.
 * 
 * @param {string}
 *            [maxHeight] A string to represent the maximum height available for
 *            the side panel to expand in string format with "###px" or "###%"
 *            as the format
 */
CompSidePanel.prototype.resizePanel = function(maxHeight) {
	// reset max height to null
	this.m_maxHeight = null;

	// if maxHeight was passed in, attempt to set that as the maxHeight
	if (maxHeight && this.m_regexHeightWidth.test(maxHeight)) {
		this.m_maxHeight = maxHeight;
	}
	// if max height still not set, attempt to set using createDefaultMaxHeight
	else if (!this.m_maxHeight) {
		this.createDefaultMaxHeight();
	}
	// proper one must be passed
	if (!this.m_maxHeight) {
		logger.logError("Parameter maxHeight must match the regex /^(\d+((px)|%){1})$/ for the CompSidePanel.resizePanel function.");
		return;
	}

	// if still in here, Call resize function based on which type of panel is
	// built
	if (this.m_expandOption === this.expandOption.EXPAND_DOWN) {
		// set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight);
		
		this.showHideExpandBar();	
		
		this.collapseSidePanel();
	} else if (this.m_fullPanelScrollOn) {
		// when default or none, still need to handle resize, unless pref turned
		// off. Set max height only if expand or scroll on
		this.setMaxHeight(this.m_maxHeight); 
		this.fullPanelScroll();
	}
};

/**
 * Type of panel being created, more can be added later
 */
CompSidePanel.prototype.expandOption = {
	NONE : null,
	EXPAND_DOWN : CompSidePanel.prototype.expandDownListeners
};

StandardTemplates = {};
StandardTemplates["CLINICAL_LINK"] = [
    '<span>${ ((EVENT_CD_DISP) ? MP_Util.CreateClinNoteLink(PERSON_ID+".0",ENCNTR_ID+".0",EVENT_ID+".0",EVENT_CD_DISP,VIEWER_TYPE,PARENT_EVENT_ID+".0") : "--") }</span>'
].join('');

/* globals TableExtension, ComponentTableDataRetriever */
/**
 * The TableCellCallbackExtension class
 * This extension is meant to be used to provide a callback to the component
 * when the user clicks on a cell within the component table
 * @return {TableCellClickCallbackExtension} returns self
 * @constructor
 */
function TableCellClickCallbackExtension() {
    this.callback = function(event,data){ return; };//eslint-disable-line no-unused-vars
    return this;
}

TableCellClickCallbackExtension.prototype = new TableExtension();
TableCellClickCallbackExtension.prototype.constructor = TableExtension;


/**
 * Sets the callback that is triggered when the user clicks a cell within the component table
 * @param callback the callback function
 * @return {TableCellClickCallbackExtension} return self
 */
TableCellClickCallbackExtension.prototype.setCellClickCallback = function(callback) {
    if(typeof callback !== "function") {
        throw new Error("In TableCellCallbackExtension, attempted to setCallback() with non function type");
    }
    this.callback = callback;
    return this;
};

/**
 * Overrides the finalize method (this is called in the ComponentTable finalize method)
 * and attaches it to the table correctly
 * @param table the ComponentTable this extension belongs to
 */
TableCellClickCallbackExtension.prototype.finalize = function(table) {
    var self = this;
    var namespace = table.getNamespace();
    var resultData = null;
    var columnId = "";
    var data = {};
    $("#" + namespace + "tableBody").on("mouseup", ".table-cell", function(event){
        resultData = ComponentTableDataRetriever.getResultFromTable(table, this);
        columnId = ComponentTableDataRetriever.getColumnIdFromElement(table, this);
        //Set up the data to return via callback
        data = {
            "COLUMN_ID": columnId,
            "RESULT_DATA": resultData,
            "SOURCE": "TableCellClickCallbackExtension:CELL_CLICK"
        };
        self.callback(event, data);
    });
};
/* globals TableColumn, TemplateBuilder */
/**
 * Defines the TableColumn class
 * This class is simply a column description that tells how a column should behave
 * @constructor
 */
function TableColumn() {//eslint-disable-line no-redeclare
    this.columnDisplay = "&nbsp;";
    this.columnId = "";
    this.customClass = "";
    this.primarySortField = "";
    this.secondarySortFields = [];
    this.isSortable = false;
    this.sortDirection = TableColumn.SORT.NONE;
    this.template = TemplateBuilder.buildTemplate("<span>[Template Not Specified]</span>");       //Initialize with a default template
    this.width = null;
    this.defaultSort = TableColumn.SORT.ASCENDING;
}

/**
 * Gets the display value for the column
 * @return {string} the display for the column (as appears in the header)
 */
TableColumn.prototype.getColumnDisplay = function () {
    return this.columnDisplay;
};

/**
 * Sets the column display (what is shown in the header of the column)
 * @param columnDisplay the string that is to be displayed for the column header
 * @return {TableColumn} returns self
 */
TableColumn.prototype.setColumnDisplay = function (columnDisplay) {
    if (typeof columnDisplay !== "string") {
        throw new Error("Called setColumnDisplay on TableColumn with non string type for columnDisplay parameter");
    }
    this.columnDisplay = columnDisplay;
    return this;
};

/**
 * Gets the ID of the column
 * @return {string} the column ID
 */
TableColumn.prototype.getColumnId = function () {
    return this.columnId;
};

/**
 * Sets the id of the column
 * @param columnId the id of the column
 */
TableColumn.prototype.setColumnId = function (columnId) {
    if(typeof columnId !== "string") {
        throw new Error("Called setColumnId on TableColumn with non string type for columnId parameter");
    }
    this.columnId = columnId;
    return this;
};

/**
 * Gets the custom column class
 * @return {string} the custom column class
 */
TableColumn.prototype.getCustomClass = function () {
    return this.customClass;
};

/**
 * Sets the custom class for the column
 * @param customClass set the column custom class
 */
TableColumn.prototype.setCustomClass = function (customClass) {
    if(typeof customClass !== "string") {
        throw new Error("Called setCustomClass on TableColumn with non string type for customClass parameter");
    }
    this.customClass = customClass;
    return this;
};

/**
 * Gets the default sort order for the column
 * @return {number} the display for the column (as appears in the header)
 */
TableColumn.prototype.getDefaultSort = function () {
    return this.defaultSort;
};

/**
 * Sets the column's default sort order 
 * @param columnDisplay the string that is to be displayed for the column header
 * @return {TableColumn} returns self
 */
TableColumn.prototype.setDefaultSort = function (defaultSort) {
	if (TableColumn.isValidSortDirection(defaultSort)) {
		this.defaultSort = defaultSort;
	}
	return this;
};

/**
 * Gets the value ID used for sorting
 * @return {string} the field in the JSON that we use for sorting
 */
TableColumn.prototype.getPrimarySortField = function () {
    return this.primarySortField;
};

/**
 * Sets the field ID used for sorting
 * @param primarySortField the field ID used for sorting
 */
TableColumn.prototype.setPrimarySortField = function (primarySortField) {
    if (typeof primarySortField !== "string") {
        throw new Error("Invalid data field parameter for column, must be a string");
    }
    this.primarySortField = primarySortField;
    return this;
};

/**
 * Adds a secondary sort field to the table column
 * @param field the field on which the secondary sort will be performed
 * @param direction the direction that the secondary sort should be applied (ascending or descending)
 */
TableColumn.prototype.addSecondarySortField = function (field, direction) {
    if(typeof direction !== "number") {
        throw new Error("Called addSecondarySortField on TableColumn with non number type for direction parameter");
    }
    if (!TableColumn.isValidSortDirection(direction)) {
        throw new Error("Called addSecondarySortField on TableColumn with invalid direction. Please use TableColumn.SORT.ASCENDING or TableColumn.SORT.DESCENDING");
    }
    if (typeof field !== "string") {
        throw new Error("Called addSecondarySortField on TableColumn with non string type for field parameter.");
    }
    this.secondarySortFields.push({"FIELD": field, "DIRECTION": direction});
};

TableColumn.prototype.getSecondarySortFields = function () {
    return this.secondarySortFields;
};

/**
 * Gets whether the column is sortable
 * @return {boolean} true if sortable, false otherwise
 */
TableColumn.prototype.getIsSortable = function () {
    return this.isSortable;
};

/**
 * Sets whether or not the column sortable or not
 * @param isSortable true if sortable, false otherwise
 */
TableColumn.prototype.setIsSortable = function (isSortable) {
    if (typeof isSortable !== "boolean") {
        throw new Error("Called setIsSortable on TableColumn with non boolean type for isSortable parameter");
    }
    this.isSortable = isSortable;
    return this;
};

/**
 * Sets how the column is currently sorted (ascending/descending/none)
 * @param sortDirection how the column is sorted
 */
TableColumn.prototype.setColumnSortDirection = function (sortDirection) {
    //If user attempts to use a non-number value
    if (typeof sortDirection !== "number") {
        throw new Error("Called setColumnSortDirection on TableColumn with non number type for sortDirection parameter");
    }
    //If user attempts to set an invalid value. Valid values are defined in the TableColumn.SORT object
    if (sortDirection < -1 || sortDirection > 1) {
        throw new Error("Called setColumnSortDirection on TableColumn with invalid sortDirection: " + sortDirection + " the value must be 0, -1, or 1. It " +
            "is recommended that you use TableColumn.SORT.NONE, TableColumn.SORT.ASCENDING, or TableColumn.SORT.DESCENDING");
    }
    this.sortDirection = sortDirection;
    return this;
};

/**
 * Gets how the column is currently sorted
 * @return {number} -1 = ascending, 1 = descending, 0 = none
 */
TableColumn.prototype.getColumnSortDirection = function () {
    return this.sortDirection;
};

/**
 * Gets the render template for the column
 * @return {Template} the render template for the column
 */
TableColumn.prototype.getRenderTemplate = function () {
    return this.template;
};

/**
 * Sets the render template for the column
 * @param template the render template for the column
 * @return {TableColumn} returns self
 */
TableColumn.prototype.setRenderTemplate = function (template) {
    this.template = TemplateBuilder.buildTemplate(template);
    return this;
};

/**
 * Gets the explicit width of the column.
 * @return {number} the width of the column.
 */
TableColumn.prototype.getWidth = function() {
    return this.width;
};

/**
 * Sets the explicit width of the column (in pixels).
 * @param width the width of the column in pixels.
 * @return {TableColumn} returns self.
 */
TableColumn.prototype.setWidth = function(width) {
    if(typeof width !== "number") {
        throw new Error("Called setWidth on TableColumn with non number type for width parameter");
    }
    if(width < 0) {
        throw new Error("Cannot call setWidth on TableColumn with a negative number");
    }
    this.width = width;
    return this;
};

/**
 * Helper function to determine if a sort direction is valid
 * @param sortDirection the direction of the sort
 * @return {boolean} true if the sort direction is valid
 */
TableColumn.isValidSortDirection = function(sortDirection) {
    if(typeof sortDirection !== "number") {
        throw new Error("Called isValidSortDirection on TableColumn with non number type for sortDirection parameter");
    }
    return (Math.abs(sortDirection) === 1);
};

/**
 * Just defines some sorting values so you can do things like ColumnDefinition.SORT.ASCENDING, etc.
 * @type {{ASCENDING: number, DESCENDING: number, NONE: number}}
 */
TableColumn.SORT = {
    "ASCENDING": -1,
    "DESCENDING": 1,
    "NONE": 0
};
/**
 * A table extension class that will serve to create addons for the component table
 * @constructor
 */
function TableExtension(){
    return this;
}

/**
 * The finalize method for a TableExtension.
 * @return {boolean}
 */
TableExtension.prototype.finalize = function(table) {//eslint-disable-line no-unused-vars
    throw new Error("Error, finalize method not implemented in a base TableExtension class");
};
/*global TableRow */
/**
 * The TableGroup class. Serves as a container
 * for grouping functionality for the ComponentTable
 * @constructor
 */
function TableGroup() {
    this.canCollapse = true;
    this.display = "";
    this.expanded = true;
    this.groupId = "";
    this.key = "";
    this.rows = [];
    this.rowMap = {};
    this.showCount = false;
    this.groupValue = "";
    this.hideHeader = false;
}

/**
 * Binds a set of data to the group
 * @param data the set of data being bound to the group
 */
TableGroup.prototype.bindData = function(data) {
    for(var i = 0; i < data.length; i++) {
        var tableRow = new TableRow().setResultData(data[i]).setId("row" + i);
        this.rows.push(tableRow);
        this.rowMap[tableRow.getId()] = tableRow;
    }
    return this;
};

/**
 * Clears the data from the group
 */
TableGroup.prototype.clearData = function() {
    this.rows = [];
    this.rowMap = {};
};

/**
 * Gets whether the group can expand/collapse
 * @return {boolean} whether the group is collapsible
 */
TableGroup.prototype.getCanCollapse = function() {
    return this.canCollapse;
};

/**
 * Sets whether the group can expand/collapse
 * @param canCollapse if the group can be collapsed
 * @return {TableGroup} returns self
 */
TableGroup.prototype.setCanCollapse = function(canCollapse) {
    if(typeof canCollapse !== "boolean") {
        throw new Error("Called setCanCollapse on TableGroup with non boolean type for parameter canCollapse");
    }
    this.canCollapse = canCollapse;
    return this;
};

/**
 * Gets the display of the group
 * @return {string} the display of the group
 */
TableGroup.prototype.getDisplay = function(){
    return this.display;
};

/**
 * Sets the display of the group
 * @param display the value to be displayed in the group section
 * @return {*}
 */
TableGroup.prototype.setDisplay = function(display) {
    if(typeof display !== "string") {
        throw new Error("Called setDisplay on TableGroup with non string type for parameter display");
    }
    this.display = display;
    return this;
};

/**
 * Determines if the group is expanded or collapsed
 * @return {boolean} whether the group is expanded
 */
TableGroup.prototype.isExpanded = function() {
    return this.expanded;
};

/**
 * Sets whether the group is expanded or not
 * @param expanded
 */
TableGroup.prototype.setIsExpanded = function(expanded) {
    if(typeof expanded !== "boolean") {
        throw new Error("Called setIsExpanded on TableGroup with non boolean type for isExpanded parameter");
    }
    this.expanded = expanded;
    return this;
};

/**
 * Gets the id of the group
 * @return {string} the id of the group
 */
TableGroup.prototype.getGroupId = function() {
    return this.groupId;
};

/**
 * Sets the id of the group
 * @param groupId the id of the group
 * @return {TableGroup} returns self
 */
TableGroup.prototype.setGroupId = function(groupId) {
    if(typeof groupId !== "string" && typeof groupId !== "number") {
        throw new Error("Called setGroupId on TableGroup with non string type for groupId parameter");
    }
    this.groupId = groupId;
    return this;
};

/**
 * Gets the key of the group. The key is the field on which results are grouped, such as
 * ENCNTR_ID, etc.
 * @return {string} the key of the group
 */
TableGroup.prototype.getKey = function() {
    return this.key;
};

/**
 * Sets the key of the group
 * @param key the key of the group
 * @return {TableGroup} returns self
 */
TableGroup.prototype.setKey = function(key) {
    if(typeof key !== "string" && typeof key !== "number") {
        throw new Error("Called setKey on TableGroup with non string/number type for parameter key");
    }
    this.key = key;
    return this;
};

/**
 * Adds a row to the group
 * @param row the row being added
 * @return {TableGroup} returns self
 */
TableGroup.prototype.addRow = function(row) {
    if(!TableRow.prototype.isPrototypeOf(row)) {
        throw new Error("Called addRow on TableGroup with non TableRow type for row parameter");
    }
    this.rows.push(row);
    this.rowMap[row.getId()] = row;
    return this;
};

/**
 * Gets the rows belonging to the group
 * @return {Array} the list of rows belonging to the group
 */
TableGroup.prototype.getRows = function() {
    return this.rows;
};

/**
 * Returns the row with the specified id. If the row does not exist, an exception is thrown
 * @param rowId the id of the row being obtained
 * @return {TableRow}
 */
TableGroup.prototype.getRowById = function(rowId) {
    if(!this.hasRow(rowId)) {
        throw new Error("In getRowById on TableGroup, TableRow with id: " + rowId + " does not exist");
    }
    return this.rowMap[rowId];
};

/**
 * Checks if the group has the row with the specified id
 * @param rowId the id of the row we're checking for
 * @return {boolean} whether the row exists or not.
 */
TableGroup.prototype.hasRow = function(rowId) {
    return ((typeof this.rowMap[rowId] !== "undefined") && this.rowMap[rowId] !== null);
};

/**
 * Sets the list of rows belonging to the group
 * @param rows the list of rows to be set for the group
 * @return {TableGroup
 */
TableGroup.prototype.setRows = function(rows) {
    if(!(Array.isArray(rows))) {
        throw new Error("Called setRows on TableGroup with non Array type for rows parameter");
    }
    this.rows = rows;
    return this;
};

/**
 * Gets whether the group is to show the count in the subsection
 * @return {boolean} whether the group is to show the count in the
 */
TableGroup.prototype.getShowCount = function() {
    return this.showCount;
};

/**
 * Sets whether the group should show the count in the subsection
 * @param showCount whether the group should show the count in the subsection (true/false)
 * @return {TableGroup} return self
 */
TableGroup.prototype.setShowCount = function(showCount) {
    if(typeof showCount !== "boolean") {
        throw new Error("Called setShowCount on TableGroup with non boolean type for showCount parameter");
    }
    this.showCount = showCount;
    return this;
};

/**
 * Gets the value of the group. The value is what the key is equal to. For example, if we want to group on
 * ENCNTR_ID (group key), we may have a group whose value is, say, 125434.0.
 * @return {string} the value of the group
 */
TableGroup.prototype.getValue = function() {
    return this.groupValue;
};

/**
 * Sets the value of the group. The value is what the key is equal to. For example, if we want to group on
 * ENCNTR_ID (group key), we may have a group whose value is, say, 125434.0.
 * @param groupValue the value of the group. (what the key is equal to).
 * @return {TableGroup} returns self.
 */
TableGroup.prototype.setValue = function(groupValue) {
    if(typeof groupValue !== "string" && typeof groupValue !== "number") {
        throw new Error("Called setValue on TableGroup with non string type for parameter value");
    }
    this.groupValue = groupValue;
    return this;
};

/**
 * Gets whether the group's subsection header should be displayed/rendered or not
 * @return [boolean] whether or not the header should be displayed/rendered 
 */
TableGroup.prototype.getHideHeader = function() {
	return this.hideHeader;
};

/**
 * Sets whether the group's subsection header should be displayed/rendered or not
 * @param showHeader : Boolean value that determines if the header should be displayed/rendered
 * @return [TableGroup] return self 
 */
TableGroup.prototype.setHideHeader = function(hideHeader) {
	if(typeof hideHeader !== "boolean") {
		throw new Error("Called setShowHeader on TableGroup with non-boolean type for showHeader parameter value");
	}
	this.hideHeader = hideHeader;
	return this;
};

/**
 * Parses a group id from an element
 * @param elementId the id of the element we're parsing
 * @return {string} the id of the group parsed from the element id
 */
TableGroup.parseGroupId = function(elementId) {
    return elementId.split(":")[1];
};
/*globals TableExtension, TableGroup */
/**
 * The TableGroupToggleCallbackExtension class
 * This extension is meant to be used to provide a callback to the component
 * when the user toggles a group within the component table
 * @return {TableGroupToggleCallbackExtension} returns self
 * @constructor
 */
function TableGroupToggleCallbackExtension(){
    this.callback = function(event,data){ return; };//eslint-disable-line no-unused-vars
    return this;
}

TableGroupToggleCallbackExtension.prototype = new TableExtension();
TableGroupToggleCallbackExtension.prototype.constructor = TableExtension;

/**
 * Sets the callback that is triggered when the user toggles a table group
 * @param callback the callback function
 */
TableGroupToggleCallbackExtension.prototype.setGroupToggleCallback = function(callback) {
    if(typeof callback !== "function") {
        throw new Error("Called setGroupToggleCallback on TableGroupToggleCallbackExtension with non function type for callback parameter");
    }
    this.callback = callback;
    return this;
};

/**
 * Overrides the finalize method (this is called in the ComponentTable finalize method)
 * and attaches it to the table correctly
 * @param table the ComponentTable this extension belongs to
 */
TableGroupToggleCallbackExtension.prototype.finalize = function(table) {
    var self = this;
    var namespace = table.getNamespace();
    var data = {};
    $("#" + namespace + "tableBody").on("click", ".sub-sec-hd", function(event){
        var group = table.getGroupById(TableGroup.parseGroupId($(this).attr("id")));
        data = {
            "GROUP_DATA": {
                "KEY": group.getKey(),
                "VALUE": group.getValue(),
                "EXPANDED": group.isExpanded(),
                "GROUP_ID": group.getGroupId()
            }
            , "SOURCE": "TableGroupToggleCallbackExtension:GROUP_CLICK"
        };
        self.callback(event, data);
    });
};

/*globals MPageTooltip, TableExtension, ComponentTableDataRetriever, TemplateBuilder*/
/**
 * The HoverExtension class. It extends the TableExtension class. This class
 * provides functionality for hovers, integrating with the ComponentTable.
 * @return {HoverExtension} returns self.
 * @constructor
 */
function HoverExtension() {
    this.hoverClass = "mpage-tooltip-hover";
    this.onHover = function () {
        return;
    };
    this.onLeave = function () {
        return;
    };
    this.target = "";
    this.tooltip = new MPageTooltip().setShowDelay(0);
    return this;
}

HoverExtension.prototype = new TableExtension();
HoverExtension.prototype.constructor = TableExtension;

HoverExtension.prototype.getHoverClass = function () {
    return this.hoverClass;
};

HoverExtension.prototype.setHoverClass = function (hoverClass) {
    if (typeof hoverClass !== "string") {
        throw new Error("Called setHoverClass on HoverExtension with non string type for hoverClass parameter");
    }
    this.hoverClass = hoverClass;
    return this;
};

/**
 * Sets the callback for a hover event.
 * @param onHover the function to be triggered on the mouse enter.
 */
HoverExtension.prototype.setOnHoverCallback = function (onHover) {
    if (typeof onHover !== "function") {
        throw new Error("Called setOnHoverCallback on HoverExtension with non function type for onHover parameter");
    }
    this.onHover = onHover;
    return this;
};

/**
 * Sets the callback for a hover event.
 * @param onLeave the function to be triggered on the mouse leave.
 */
HoverExtension.prototype.setOnLeaveCallback = function (onLeave) {
    if (typeof onLeave !== "function") {
        throw new Error("Called setOnLeaveCallback on HoverExtension with non function type for onLeave parameter");
    }
    this.onLeave = onLeave;
    return this;
};

/**
 * Gets the target for the hover extension.
 * @return {string} the target for the extension.
 */
HoverExtension.prototype.getTarget = function () {
    return this.target;
};

/**
 * Sets the target for the hover extension. This ensures the delegate is attached to the correct elements.
 * @param target the identifier, telling the extension on what to attach the delegate.
 * @return {HoverExtension} returns self
 */
HoverExtension.prototype.setTarget = function (target) {
    if (typeof target !== "string") {
        throw new Error("Called setTarget on HoverExtension with non string type for target parameter");
    }
    this.target = target;
    return this;
};

/**
 * Gets the tooltip for the extension.
 * @return {MPageTooltip} the tooltip object for the extension.
 */
HoverExtension.prototype.getTooltip = function() {
    return this.tooltip;
};

/**
 * Sets the tooltip for the extension.
 * @param tooltip the tooltip object.
 * @return {HoverExtension} returns self.
 */
HoverExtension.prototype.setTooltip = function(tooltip) {
    if(!(MPageTooltip.prototype.isPrototypeOf(tooltip))) {
        throw new Error("Called setTooltip on HoverExtension with non MPageTooltip type for tooltip parameter");
    }
    this.tooltip = tooltip;
    return this;
};

/**
 * The finalize method for the HoverExtension. It overrides the finalize method in the TableExtension class.
 * This method attaches a mouseenter and mouseleave delegate for the table body. When a mouseenter occurs,
 * the target is highlighted and a hover is shown.
 * @param table the table to which this extension belongs.
 */
HoverExtension.prototype.finalize = function (table) {
    var thiz = this;
    var tableBodyTag = "#" + table.getNamespace() + "tableBody";
    var elementMap = {};
    //Bind the mouseenter event so we know when a user has hovered into an item
    $(tableBodyTag).on("mouseenter", this.getTarget(), function (event) {
        var anchor = this;
        var anchorId = $(this).attr("id");
        //If there is a hover class specified, add it to the element
        if (thiz.getHoverClass() !== "") {
            $(this).addClass(thiz.getHoverClass());
        }
        if (!elementMap[anchorId]) {
            elementMap[anchorId] = {};
        }
        thiz.onHover(event);
        //Store of a flag that we're hovered inside this element
        elementMap[anchorId].TIMEOUT = setTimeout(function () {
            thiz.showHover(event, table, anchor);
        }, 500);
    });
    //Bind the mouseleave event
    $(tableBodyTag).on("mouseleave", this.getTarget(), function (event) {
        $(this).removeClass("mpage-tooltip-hover");
        if(elementMap[$(this).attr("id")] && elementMap[$(this).attr("id")].TIMEOUT){
            clearTimeout(elementMap[$(this).attr("id")].TIMEOUT);
        }
        thiz.onLeave(event);
    });
};

/**
 * Base showHover function. Must be overwritten by subclasses of the HoverExtension class.
 * @param event the hover event.
 * @param table the table to which this extension belongs.
 * @param anchor the element that will serve as the anchor to the hover.
 */
HoverExtension.prototype.showHover = function (event, table, anchor) { //eslint-disable-line no-unused-vars
    throw new Error("showHover has not been overwritten for a HoverExtension base class");
};

/**
 * The TableRowHoverExtension class. Used when you wish to
 * have a row-level hover.
 * @return {TableRowHoverExtension} returns self
 * @constructor
 * @author Will Reynolds
 */
function TableRowHoverExtension() {
    this.setTarget("dl.result-info");                 //Set the target to result-info, or each row
    this.hoverRenderer = null;                      //The hover renderer (can be either a StringTemplateRenderer or a FunctionRenderer)
    return this;
}

TableRowHoverExtension.prototype = new HoverExtension();
TableRowHoverExtension.prototype.constructor = HoverExtension;

/**
 * Gets the hover renderer
 * @return {HoverRenderer} a HoverRenderer object
 */
TableRowHoverExtension.prototype.getHoverRenderer = function () {
    return this.hoverRenderer;
};

/**
 * Sets the hover renderer
 * @param renderer either a template string or a function used for rendering.
 * @return {TableRowHoverExtension} returns self
 */
TableRowHoverExtension.prototype.setHoverRenderer = function (renderer) {
    this.hoverRenderer = HoverRenderFactory.getHoverRenderer(renderer);
    return this;
};

/**
 * Overrides the showHover method in the HoverExtension base class.
 * @param event the hover event.
 * @param table the table to which this extension belongs.
 * @param anchor the element the anchor is being anchored to.
 */
TableRowHoverExtension.prototype.showHover = function (event, table, anchor) {
    if (!this.hoverRenderer) {
        return;
    }
    var data = {};
    data.RESULT_DATA = ComponentTableDataRetriever.getResultFromTable(table, anchor);
    data.SOURCE = "TableRowHoverExtension:ROW_HOVER";
    var content = this.hoverRenderer.render(data);
    if (!content) {
        return;
    }
    //Create a new tooltip
    var tooltip = this.getTooltip();
    tooltip.setX(event.pageX).setY(event.pageY).setAnchor(anchor).setContent(this.hoverRenderer.render(data));
    tooltip.show();
};

/**
 * The TableCellHoverExtension class. Used when you want cell level hovers.
 * @return {TableCellHoverExtension} returns self
 * @constructor
 * @author Will Reynolds
 */
function TableCellHoverExtension() {
    this.setTarget("dd.table-cell");                    //Set the target of the hovers to each table cell
    this.templateMap = {};                              //A mapping of column ids to hover renderers. Allows different hover content per column
    return this;
}

TableCellHoverExtension.prototype = new HoverExtension();
TableCellHoverExtension.prototype.constructor = HoverExtension;

/**
 * Adds a hover rendering method for the specified column
 * @param column the column for which we're specifying the hover renderer
 * @param renderer how the hover is to be rendered. Either a string or a function.
 */
TableCellHoverExtension.prototype.addHoverForColumn = function (column, renderer) {
    //If you attempt to call this on a non-column object, fail
    if (!TableColumn.prototype.isPrototypeOf(column)) {
        throw new Error("Called addTemplateForColumn on TableCellHoverExtension with non TableColumn type for column parameter");
    }
    this.templateMap[column.getColumnId()] = HoverRenderFactory.getHoverRenderer(renderer);
};

/**
 * Overrides the showHover method in the HoverExtension base class.
 * @param event the hover event
 * @param table the table to which this extension belongs
 * @param anchor the element the hover is being anchored to
 */
TableCellHoverExtension.prototype.showHover = function (event, table, anchor) {
    var data = {};
    var columnId = ComponentTableDataRetriever.getColumnIdFromElement(table, anchor);
    var hoverRenderer = this.templateMap[columnId];
    if (!hoverRenderer) {
        return;
    }
    data.RESULT_DATA = ComponentTableDataRetriever.getResultFromTable(table, anchor);
    data.COLUMN_ID = columnId;
    data.SOURCE = "TableCellHoverExtension:CELL_HOVER";
    data.EVENT = event;
    var content = hoverRenderer.render(data);
    if (!content) {
        return;
    }
    //Create a new tooltip
    var tooltip = this.getTooltip();
    tooltip.setX(event.pageX).setY(event.pageY).setAnchor(anchor).setContent(content);
    tooltip.show();
};

/**
 * A helper class used to get different HoverRenderer classes.
 * @constructor
 * @author Will Reynolds
 */
function HoverRenderFactory() {
}

/**
 * Gets a HoverRenderer object based on the object passed in. A string will return a StringTemplateRenderer, which uses
 * the string templating system. A function will return a FunctionRenderer, which uses a callback function to render the hover.
 * If neither a string nor a function are passed in, an exception is thrown.
 * @param renderObject the object that will handle rendering the hover.
 * @return {HoverRenderer} a HoverRenderer object based on the object passed in.
 */
HoverRenderFactory.getHoverRenderer = function (renderObject) {
    var renderer = null;
    //If the object is a string, we create a StringTemplateRenderer object
    if (typeof renderObject === "string") {
        renderer = new StringTemplateRenderer();
    } else if (typeof renderObject === "function") {
        renderer = new FunctionRenderer();
    } else {
        throw new Error("Called getHoverRenderer on HoverRenderFactory with invalid type for renderObject, use string or function");
    }
    //Initialize the HoverRenderer object with the object passed in
    renderer.init(renderObject);
    return renderer;
};

/**
 * An interface that will render hovers. This interface can be implemented.
 * @constructor
 * @author Will Reynolds
 */
function HoverRenderer() {
}

/**
 * The init interface method which takes in an object that will handle rendering a hover. This method
 * must be overwritten in all sub-classes.
 * @param renderObject the object that will handle rendering a hover
 */
HoverRenderer.prototype.init = function (renderObject) { //eslint-disable-line no-unused-vars
    throw new Error("HoverRenderer init method not implemented");
};

/**
 * The render method which takes in a data object. This will populate a hover with the data object. This method
 * must be overwritten in all sub-classes.
 * @param data the data object which will be injected into the hover.
 */
HoverRenderer.prototype.render = function (data) { //eslint-disable-line no-unused-vars
    throw new Error("HoverRenderer render method not implemented");
};

/**
 * The StringTemplateRenderer class. It is a sub-class of HoverRenderer. This implementation uses the string
 * templating system.
 * @constructor
 * @author Will Reynolds
 */
function StringTemplateRenderer() {
    this.template = null;
}
StringTemplateRenderer.prototype = new HoverRenderer();
StringTemplateRenderer.prototype.constructor = HoverRenderer;

/**
 * Gets the template
 * @return {Template} the renderer's template object
 */
StringTemplateRenderer.prototype.getTemplate = function () {
    return this.template;
};

/**
 * Sets the template object for the renderer
 * @param template the template object
 * @return {StringTemplateRenderer} returns self
 */
StringTemplateRenderer.prototype.setTemplate = function (template) {
    this.template = template;
    return this;
};

/**
 * Overrides the init method for the HoverRenderer interface. This init method takes the renderObject
 * and stores it as a template.
 * @param renderObject the render object which will be converted to a template. This renderObject must be a string
 * @return {StringTemplateRenderer} returns self
 */
StringTemplateRenderer.prototype.init = function (renderObject) {
    return this.setTemplate(TemplateBuilder.buildTemplate(renderObject));
};

/**
 * Overrides the render method for the HoverRenderer interface. This method simply renders the template with the
 * passed in data.
 * @param data the data to be rendered via the template.
 * @return {string} an html string rendered by the template.
 */
StringTemplateRenderer.prototype.render = function (data) {
    return this.template.render(data);
};

/**
 * The FunctionRenderer class. It is a sub-class of HoverRenderer. This implementation uses function callbacks
 * to perform rendering.
 * @constructor
 * @author Will Reynolds
 */
function FunctionRenderer() {
    this.renderFunction = function (data) {//eslint-disable-line no-unused-vars
        return "";
    };
}
FunctionRenderer.prototype = new HoverRenderer();
FunctionRenderer.prototype.constructor = HoverRenderer;

/**
 * Gets the render function
 * @return {Function} returns the function that will perform the rendering
 */
FunctionRenderer.prototype.getRenderFunction = function () {
    return this.renderFunction;
};

/**
 * Sets the render function
 * @param renderFunction the function that will handle rendering
 * @return {FunctionRenderer} returns self
 */
FunctionRenderer.prototype.setRenderFunction = function (renderFunction) {
    if (typeof renderFunction !== "function") {
        throw new Error("Called setRenderFunction on FunctionRenderer with non function type for renderFunction parameter");
    }
    this.renderFunction = renderFunction;
    return this;
};

/**
 * Overrides the init method for the HoverRenderer interface. This simply stores off the renderObject.
 * @param renderObject this will be a function that will perform rendering.
 * @return {FunctionRenderer} returns self
 */
FunctionRenderer.prototype.init = function (renderObject) {
    return this.setRenderFunction(renderObject);
};

/**
 * Overrides the render method for the HoverRenderer interface. This simply calls the renderFunction, passing
 * the data as a parameter.
 * @param data the data that is to be rendered via the renderFunction.
 * @return {string} the html string as rendered by the function.
 */
FunctionRenderer.prototype.render = function (data) {
    return this.renderFunction(data);
};

/*global TableCell */
/**
 * Class for a component table row
 * @constructor
 */
function TableRow() {
    this.rowId = "";
    this.tableCells = [];
    this.resultData = null;
    this.rowAttributeHash = {attrName: "" , attrValue: ""};
    return this;
}

/**
 * Store the JSON data that belongs to the row
 * @param resultData the JSON result that is associated with the row
 */
TableRow.prototype.setResultData = function (resultData) {
    if(typeof resultData !== "object") {
        throw new Error("Called setResultData on TableRow with non object type for the resultData parameter");
    }
    this.resultData = resultData;
    return this;
};

/**
 * Gets the result data associated with the row
 * @return {JSON Object} the result data associated with the row
 */
TableRow.prototype.getResultData = function () {
    return this.resultData;
};

/**
 * Gets the row id
 * @return {string} gets the row id
 */
TableRow.prototype.getId = function(){
    return this.rowId;
};

/**
 * Sets the row id
 * @param id the row id
 */
TableRow.prototype.setId = function(id) {
    this.rowId = id;
    return this;
};

/**
 * Return all results for the row
 * @return {Array} an array of results for the row
 */
TableRow.prototype.getTableCells = function () {
    return this.tableCells;
};

/**
 * Sets the results for the row
 * @param tableCells the results that belong to the row
 */
TableRow.prototype.setTableCells = function (tableCells) {
    if(!Array.isArray(tableCells)) {
        throw new Error("Called setTableCells on TableRow with type other than Array");
    }
    this.tableCells = tableCells;
    return this;
};

/**
 * Adds a result to the row, associated with which column it belongs in
 * @param columnId the column we're associating the result to
 * @param tableCell the result
 */
TableRow.prototype.addTableCell = function (columnId, tableCell) {
    if(typeof columnId !== "string") {
        throw new Error("Called addTableCell on TableRow and passed non string type for columnId parameter");
    }
    if(!TableCell.prototype.isPrototypeOf(tableCell)) {
        throw new Error("Called addTableCell on TableRow and passed non TableCell type for tableCell parameter");
    }
    this.tableCells[columnId] = tableCell;
};

/**
 * Gets the result in the row at the specified column
 * @param columnId the column in which we want the result
 * @return {TableCell} a result cell at the specified column
 */
TableRow.prototype.getTableCellInColumn = function (columnId) {
    if(typeof columnId !== "string") {
        throw new Error("Called getTableCellInColumn on TableRow and passed non string type for columnId parameter");
    }
    if(typeof this.tableCells[columnId] === "undefined" || this.tableCells[columnId] === null) {
        throw new Error("In method getTableCellInColumn, the columnId: " + columnId + " returned undefined or null");
    }
    return this.tableCells[columnId];
};

/**
 * Creates a hash for setting a data attribute on the row
 * @param {String} attributeName: name of a data attribute applied for each row of the ComponentTable
 * @param {String} attributeValue: member from the result data that will be mapped as an attribute value
 */
TableRow.prototype.setRowAttributeHash = function(attributeName, attributeValue){
	if(typeof attributeName !== "string" || typeof attributeValue !== "string"){ 
        throw new Error("Called setRowAttributeHash on TableRow and passed non string type for attributeName or attributeValue parameter");
	}
	this.rowAttributeHash.attrName = attributeName;
	this.rowAttributeHash.attrValue = attributeValue;
	return this;
};

/**
 * Returns the rowAttributeHash object
 * @return {object} returns the rowAttributeHash
 */
TableRow.prototype.getRowAttributeHash = function(){
	return this.rowAttributeHash;
};
/**
 * Simple template class to encapsulate an html template
 * @author Will Reynolds
 * @constructor
 */
function Template() {
    this.id = "";
    this.templateFunction = null;
}

/**
 * Sets the id of the template
 * @param id the id of the template
 */
Template.prototype.setId = function(id) {
    this.id = id;
};

/**
 * Gets the id of the template
 * @return {string} the id of the template (this can be used to find it in the template cache)
 */
Template.prototype.getId = function() {
    return this.id;
};

/**
 * Set the template rendering function
 * @param templateFunction the template rendering function
 */
Template.prototype.setTemplateFunction = function(templateFunction) {
    this.templateFunction = templateFunction;
};

/**
 * Get the template rendering function
 * @return {Function} the template rendering function
 */
Template.prototype.getTemplateFunction = function() {
    return this.templateFunction;
};

/**
 * Renders the template with provided data
 * @param data the data object you wish to provide to the template
 * @return {string} the populated template
 */
Template.prototype.render = function(data) {
    data = data || {};
    try {
        return this.templateFunction(data);
    } catch(exe) {
        throw new Error("There was an error rendering the template: " + exe.message);
    }
};
/**
 * Simple template builder class
 * @author Will Reynolds
 * @constructor
 */
function TemplateBuilder() {
}

/**
 * Builds a template from a string
 * @param template a template string
 * @return {Template} a template object based on the template string passed in
 */
TemplateBuilder.buildTemplate = function(template) {
    if(typeof template !== "string") {
        throw new Error("Called buildTemplate on TemplateBuilder with non string type for template parameter");
    }
	
	// escape double quotes
	template = template.replace(/"/g, '\\"');
	
    var newTemplate = new Template();
    //Build the template rendering function
    var templateFunction = new Function("data", "var params=[];" +
        "params.push(\"" + template.split("${").join("\");params.push(data.").split("}").join(");params.push(\"") + "\");"+
        "return params.join(\"\");");
    newTemplate.setTemplateFunction(templateFunction);
    return newTemplate;
};

/**
 * Creates a template AND caches it in the template cache
 * @param id the id by which the template can be accessed
 * @param template the template string
 * @return {Template} the template object created
 */
TemplateBuilder.buildAndCacheTemplate = function(id, template) {
    var templateObject = TemplateBuilder.buildTemplate(template);
    TemplateCache.cacheTemplate(id, templateObject);
    return templateObject;
};
/**
 * Simple template cache class to store off constructed templates
 * @author Will Reynolds
 * @constructor
 */
function TemplateCache(){
}

TemplateCache.templates = {};

/**
 * Loads all standard template into the cache to be used later (only do this if you wish to load all templates)
 */
TemplateCache.loadStandardTemplates = function() {
    for(var templateKey in StandardTemplates) {
        var template = StandardTemplates[templateKey];
        if(template && typeof template === "string") {
            TemplateCache.cacheTemplate(templateKey, TemplateBuilder.buildTemplate(template));
        }
    }
};

/**
 * Stores a template in the cache
 * @param id the id of the template that you'll use to get it later
 * @param template the template object you're caching
 */
TemplateCache.cacheTemplate = function(id, template) {
    if(typeof id !== "string") {
        throw new Error("Called cacheTemplate on TemplateCache with non string type for id parameter");
    }
    if(!Template.prototype.isPrototypeOf(template)) {
        throw new Error("Called cacheTemplate on TemplateCache with non Template type for template parameter");
    }
    if(TemplateCache.hasTemplate(id)) {
        throw new Error("Called cacheTemplate on TemplateCache. Template with id: " + id + " already exists. Please use a different identifier.");
    }
    TemplateCache.templates[id] = template;
};

/**
 * Gets a template by the id passed in
 * @param id the id of the template one wishes to obtain
 * @return {Template} if a template exists for the id, returns that Template, otherwise returns null
 */
TemplateCache.getTemplate = function(id) {
    if(!TemplateCache.hasTemplate(id)) {
        throw new Error("Template with id: " + id + " does not exist");
    }
    return TemplateCache.templates[id];
};

/**
 * Checks if a template object exists in the cache
 * @param id the id of the template
 * @return {boolean} true if the template exists, otherwise false
 */
TemplateCache.hasTemplate = function(id) {
    return (typeof TemplateCache.templates[id] !== "undefined" && TemplateCache.templates[id] !== null);
};
/*! URI.js v1.18.0 http://medialize.github.io/URI.js/ */
/* build contains: URI.js */
(function(n,v){"object"===typeof exports?module.exports=v(require("./punycode"),require("./IPv6"),require("./SecondLevelDomains")):"function"===typeof define&&define.amd?define(["./punycode","./IPv6","./SecondLevelDomains"],v):n.URI=v(n.punycode,n.IPv6,n.SecondLevelDomains,n)})(this,function(n,v,t,h){function d(a,b){var c=1<=arguments.length,f=2<=arguments.length;if(!(this instanceof d))return c?f?new d(a,b):new d(a):new d;if(void 0===a){if(c)throw new TypeError("undefined is not a valid argument for URI");
a="undefined"!==typeof location?location.href+"":""}this.href(a);return void 0!==b?this.absoluteTo(b):this}function q(a){return a.replace(/([.*+?^=!:${}()|[\]\/\\])/g,"\\$1")}function u(a){return void 0===a?"Undefined":String(Object.prototype.toString.call(a)).slice(8,-1)}function k(a){return"Array"===u(a)}function C(a,b){var c={},d,g;if("RegExp"===u(b))c=null;else if(k(b))for(d=0,g=b.length;d<g;d++)c[b[d]]=!0;else c[b]=!0;d=0;for(g=a.length;d<g;d++)if(c&&void 0!==c[a[d]]||!c&&b.test(a[d]))a.splice(d,
1),g--,d--;return a}function y(a,b){var c,d;if(k(b)){c=0;for(d=b.length;c<d;c++)if(!y(a,b[c]))return!1;return!0}var g=u(b);c=0;for(d=a.length;c<d;c++)if("RegExp"===g){if("string"===typeof a[c]&&a[c].match(b))return!0}else if(a[c]===b)return!0;return!1}function D(a,b){if(!k(a)||!k(b)||a.length!==b.length)return!1;a.sort();b.sort();for(var c=0,d=a.length;c<d;c++)if(a[c]!==b[c])return!1;return!0}function z(a){return a.replace(/^\/+|\/+$/g,"")}function F(a){return escape(a)}function A(a){return encodeURIComponent(a).replace(/[!'()*]/g,
F).replace(/\*/g,"%2A")}function w(a){return function(b,c){if(void 0===b)return this._parts[a]||"";this._parts[a]=b||null;this.build(!c);return this}}function E(a,b){return function(c,d){if(void 0===c)return this._parts[a]||"";null!==c&&(c+="",c.charAt(0)===b&&(c=c.substring(1)));this._parts[a]=c;this.build(!d);return this}}var G=h&&h.URI;d.version="1.18.0";var e=d.prototype,p=Object.prototype.hasOwnProperty;d._parts=function(){return{protocol:null,username:null,password:null,hostname:null,urn:null,
port:null,path:null,query:null,fragment:null,duplicateQueryParameters:d.duplicateQueryParameters,escapeQuerySpace:d.escapeQuerySpace}};d.duplicateQueryParameters=!1;d.escapeQuerySpace=!0;d.protocol_expression=/^[a-z][a-z0-9.+-]*$/i;d.idn_expression=/[^a-z0-9\.-]/i;d.punycode_expression=/(xn--)/i;d.ip4_expression=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;d.ip6_expression=/^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
d.find_uri_expression=/\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019]))/ig;d.findUri={start:/\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,end:/[\s\r\n]|$/,trim:/[`!()\[\]{};:'".,<>?\u00ab\u00bb\u201c\u201d\u201e\u2018\u2019]+$/};d.defaultPorts={http:"80",https:"443",ftp:"21",gopher:"70",ws:"80",wss:"443"};d.invalid_hostname_characters=
/[^a-zA-Z0-9\.-]/;d.domAttributes={a:"href",blockquote:"cite",link:"href",base:"href",script:"src",form:"action",img:"src",area:"href",iframe:"src",embed:"src",source:"src",track:"src",input:"src",audio:"src",video:"src"};d.getDomAttribute=function(a){if(a&&a.nodeName){var b=a.nodeName.toLowerCase();return"input"===b&&"image"!==a.type?void 0:d.domAttributes[b]}};d.encode=A;d.decode=decodeURIComponent;d.iso8859=function(){d.encode=escape;d.decode=unescape};d.unicode=function(){d.encode=A;d.decode=
decodeURIComponent};d.characters={pathname:{encode:{expression:/%(24|26|2B|2C|3B|3D|3A|40)/ig,map:{"%24":"$","%26":"&","%2B":"+","%2C":",","%3B":";","%3D":"=","%3A":":","%40":"@"}},decode:{expression:/[\/\?#]/g,map:{"/":"%2F","?":"%3F","#":"%23"}}},reserved:{encode:{expression:/%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,map:{"%3A":":","%2F":"/","%3F":"?","%23":"#","%5B":"[","%5D":"]","%40":"@","%21":"!","%24":"$","%26":"&","%27":"'","%28":"(","%29":")","%2A":"*","%2B":"+","%2C":",",
"%3B":";","%3D":"="}}},urnpath:{encode:{expression:/%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,map:{"%21":"!","%24":"$","%27":"'","%28":"(","%29":")","%2A":"*","%2B":"+","%2C":",","%3B":";","%3D":"=","%40":"@"}},decode:{expression:/[\/\?#:]/g,map:{"/":"%2F","?":"%3F","#":"%23",":":"%3A"}}}};d.encodeQuery=function(a,b){var c=d.encode(a+"");void 0===b&&(b=d.escapeQuerySpace);return b?c.replace(/%20/g,"+"):c};d.decodeQuery=function(a,b){a+="";void 0===b&&(b=d.escapeQuerySpace);try{return d.decode(b?a.replace(/\+/g,
"%20"):a)}catch(c){return a}};var r={encode:"encode",decode:"decode"},x,B=function(a,b){return function(c){try{return d[b](c+"").replace(d.characters[a][b].expression,function(c){return d.characters[a][b].map[c]})}catch(f){return c}}};for(x in r)d[x+"PathSegment"]=B("pathname",r[x]),d[x+"UrnPathSegment"]=B("urnpath",r[x]);r=function(a,b,c){return function(f){var g;g=c?function(a){return d[b](d[c](a))}:d[b];f=(f+"").split(a);for(var e=0,l=f.length;e<l;e++)f[e]=g(f[e]);return f.join(a)}};d.decodePath=
r("/","decodePathSegment");d.decodeUrnPath=r(":","decodeUrnPathSegment");d.recodePath=r("/","encodePathSegment","decode");d.recodeUrnPath=r(":","encodeUrnPathSegment","decode");d.encodeReserved=B("reserved","encode");d.parse=function(a,b){var c;b||(b={});c=a.indexOf("#");-1<c&&(b.fragment=a.substring(c+1)||null,a=a.substring(0,c));c=a.indexOf("?");-1<c&&(b.query=a.substring(c+1)||null,a=a.substring(0,c));"//"===a.substring(0,2)?(b.protocol=null,a=a.substring(2),a=d.parseAuthority(a,b)):(c=a.indexOf(":"),
-1<c&&(b.protocol=a.substring(0,c)||null,b.protocol&&!b.protocol.match(d.protocol_expression)?b.protocol=void 0:"//"===a.substring(c+1,c+3)?(a=a.substring(c+3),a=d.parseAuthority(a,b)):(a=a.substring(c+1),b.urn=!0)));b.path=a;return b};d.parseHost=function(a,b){a=a.replace(/\\/g,"/");var c=a.indexOf("/"),d;-1===c&&(c=a.length);if("["===a.charAt(0))d=a.indexOf("]"),b.hostname=a.substring(1,d)||null,b.port=a.substring(d+2,c)||null,"/"===b.port&&(b.port=null);else{var g=a.indexOf(":");d=a.indexOf("/");
g=a.indexOf(":",g+1);-1!==g&&(-1===d||g<d)?(b.hostname=a.substring(0,c)||null,b.port=null):(d=a.substring(0,c).split(":"),b.hostname=d[0]||null,b.port=d[1]||null)}b.hostname&&"/"!==a.substring(c).charAt(0)&&(c++,a="/"+a);return a.substring(c)||"/"};d.parseAuthority=function(a,b){a=d.parseUserinfo(a,b);return d.parseHost(a,b)};d.parseUserinfo=function(a,b){var c=a.indexOf("/"),f=a.lastIndexOf("@",-1<c?c:a.length-1);-1<f&&(-1===c||f<c)?(c=a.substring(0,f).split(":"),b.username=c[0]?d.decode(c[0]):null,
c.shift(),b.password=c[0]?d.decode(c.join(":")):null,a=a.substring(f+1)):(b.username=null,b.password=null);return a};d.parseQuery=function(a,b){if(!a)return{};a=a.replace(/&+/g,"&").replace(/^\?*&*|&+$/g,"");if(!a)return{};for(var c={},f=a.split("&"),g=f.length,e,l,m=0;m<g;m++)if(e=f[m].split("="),l=d.decodeQuery(e.shift(),b),e=e.length?d.decodeQuery(e.join("="),b):null,p.call(c,l)){if("string"===typeof c[l]||null===c[l])c[l]=[c[l]];c[l].push(e)}else c[l]=e;return c};d.build=function(a){var b="";
a.protocol&&(b+=a.protocol+":");a.urn||!b&&!a.hostname||(b+="//");b+=d.buildAuthority(a)||"";"string"===typeof a.path&&("/"!==a.path.charAt(0)&&"string"===typeof a.hostname&&(b+="/"),b+=a.path);"string"===typeof a.query&&a.query&&(b+="?"+a.query);"string"===typeof a.fragment&&a.fragment&&(b+="#"+a.fragment);return b};d.buildHost=function(a){var b="";if(a.hostname)b=d.ip6_expression.test(a.hostname)?b+("["+a.hostname+"]"):b+a.hostname;else return"";a.port&&(b+=":"+a.port);return b};d.buildAuthority=
function(a){return d.buildUserinfo(a)+d.buildHost(a)};d.buildUserinfo=function(a){var b="";a.username&&(b+=d.encode(a.username));a.password&&(b+=":"+d.encode(a.password));b&&(b+="@");return b};d.buildQuery=function(a,b,c){var f="",g,e,l,m;for(e in a)if(p.call(a,e)&&e)if(k(a[e]))for(g={},l=0,m=a[e].length;l<m;l++)void 0!==a[e][l]&&void 0===g[a[e][l]+""]&&(f+="&"+d.buildQueryParameter(e,a[e][l],c),!0!==b&&(g[a[e][l]+""]=!0));else void 0!==a[e]&&(f+="&"+d.buildQueryParameter(e,a[e],c));return f.substring(1)};
d.buildQueryParameter=function(a,b,c){return d.encodeQuery(a,c)+(null!==b?"="+d.encodeQuery(b,c):"")};d.addQuery=function(a,b,c){if("object"===typeof b)for(var f in b)p.call(b,f)&&d.addQuery(a,f,b[f]);else if("string"===typeof b)void 0===a[b]?a[b]=c:("string"===typeof a[b]&&(a[b]=[a[b]]),k(c)||(c=[c]),a[b]=(a[b]||[]).concat(c));else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");};d.removeQuery=function(a,b,c){var f;if(k(b))for(c=0,f=b.length;c<f;c++)a[b[c]]=
void 0;else if("RegExp"===u(b))for(f in a)b.test(f)&&(a[f]=void 0);else if("object"===typeof b)for(f in b)p.call(b,f)&&d.removeQuery(a,f,b[f]);else if("string"===typeof b)void 0!==c?"RegExp"===u(c)?!k(a[b])&&c.test(a[b])?a[b]=void 0:a[b]=C(a[b],c):a[b]!==String(c)||k(c)&&1!==c.length?k(a[b])&&(a[b]=C(a[b],c)):a[b]=void 0:a[b]=void 0;else throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");};d.hasQuery=function(a,b,c,f){switch(u(b)){case "String":break;
case "RegExp":for(var g in a)if(p.call(a,g)&&b.test(g)&&(void 0===c||d.hasQuery(a,g,c)))return!0;return!1;case "Object":for(var e in b)if(p.call(b,e)&&!d.hasQuery(a,e,b[e]))return!1;return!0;default:throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");}switch(u(c)){case "Undefined":return b in a;case "Boolean":return a=!(k(a[b])?!a[b].length:!a[b]),c===a;case "Function":return!!c(a[b],b,a);case "Array":return k(a[b])?(f?y:D)(a[b],c):!1;case "RegExp":return k(a[b])?
f?y(a[b],c):!1:!(!a[b]||!a[b].match(c));case "Number":c=String(c);case "String":return k(a[b])?f?y(a[b],c):!1:a[b]===c;default:throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");}};d.joinPaths=function(){for(var a=[],b=[],c=0,f=0;f<arguments.length;f++){var g=new d(arguments[f]);a.push(g);for(var g=g.segment(),e=0;e<g.length;e++)"string"===typeof g[e]&&b.push(g[e]),g[e]&&c++}if(!b.length||!c)return new d("");b=(new d("")).segment(b);
""!==a[0].path()&&"/"!==a[0].path().slice(0,1)||b.path("/"+b.path());return b.normalize()};d.commonPath=function(a,b){var c=Math.min(a.length,b.length),d;for(d=0;d<c;d++)if(a.charAt(d)!==b.charAt(d)){d--;break}if(1>d)return a.charAt(0)===b.charAt(0)&&"/"===a.charAt(0)?"/":"";if("/"!==a.charAt(d)||"/"!==b.charAt(d))d=a.substring(0,d).lastIndexOf("/");return a.substring(0,d+1)};d.withinString=function(a,b,c){c||(c={});var f=c.start||d.findUri.start,e=c.end||d.findUri.end,H=c.trim||d.findUri.trim,l=
/[a-z0-9-]=["']?$/i;for(f.lastIndex=0;;){var m=f.exec(a);if(!m)break;m=m.index;if(c.ignoreHtml){var k=a.slice(Math.max(m-3,0),m);if(k&&l.test(k))continue}var k=m+a.slice(m).search(e),h=a.slice(m,k).replace(H,"");c.ignore&&c.ignore.test(h)||(k=m+h.length,h=b(h,m,k,a),a=a.slice(0,m)+h+a.slice(k),f.lastIndex=m+h.length)}f.lastIndex=0;return a};d.ensureValidHostname=function(a){if(a.match(d.invalid_hostname_characters)){if(!n)throw new TypeError('Hostname "'+a+'" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
if(n.toASCII(a).match(d.invalid_hostname_characters))throw new TypeError('Hostname "'+a+'" contains characters other than [A-Z0-9.-]');}};d.noConflict=function(a){if(a)return a={URI:this.noConflict()},h.URITemplate&&"function"===typeof h.URITemplate.noConflict&&(a.URITemplate=h.URITemplate.noConflict()),h.IPv6&&"function"===typeof h.IPv6.noConflict&&(a.IPv6=h.IPv6.noConflict()),h.SecondLevelDomains&&"function"===typeof h.SecondLevelDomains.noConflict&&(a.SecondLevelDomains=h.SecondLevelDomains.noConflict()),
a;h.URI===this&&(h.URI=G);return this};e.build=function(a){if(!0===a)this._deferred_build=!0;else if(void 0===a||this._deferred_build)this._string=d.build(this._parts),this._deferred_build=!1;return this};e.clone=function(){return new d(this)};e.valueOf=e.toString=function(){return this.build(!1)._string};e.protocol=w("protocol");e.username=w("username");e.password=w("password");e.hostname=w("hostname");e.port=w("port");e.query=E("query","?");e.fragment=E("fragment","#");e.search=function(a,b){var c=
this.query(a,b);return"string"===typeof c&&c.length?"?"+c:c};e.hash=function(a,b){var c=this.fragment(a,b);return"string"===typeof c&&c.length?"#"+c:c};e.pathname=function(a,b){if(void 0===a||!0===a){var c=this._parts.path||(this._parts.hostname?"/":"");return a?(this._parts.urn?d.decodeUrnPath:d.decodePath)(c):c}this._parts.path=this._parts.urn?a?d.recodeUrnPath(a):"":a?d.recodePath(a):"/";this.build(!b);return this};e.path=e.pathname;e.href=function(a,b){var c;if(void 0===a)return this.toString();
this._string="";this._parts=d._parts();var f=a instanceof d,e="object"===typeof a&&(a.hostname||a.path||a.pathname);a.nodeName&&(e=d.getDomAttribute(a),a=a[e]||"",e=!1);!f&&e&&void 0!==a.pathname&&(a=a.toString());if("string"===typeof a||a instanceof String)this._parts=d.parse(String(a),this._parts);else if(f||e)for(c in f=f?a._parts:a,f)p.call(this._parts,c)&&(this._parts[c]=f[c]);else throw new TypeError("invalid input");this.build(!b);return this};e.is=function(a){var b=!1,c=!1,f=!1,e=!1,k=!1,
l=!1,m=!1,h=!this._parts.urn;this._parts.hostname&&(h=!1,c=d.ip4_expression.test(this._parts.hostname),f=d.ip6_expression.test(this._parts.hostname),b=c||f,k=(e=!b)&&t&&t.has(this._parts.hostname),l=e&&d.idn_expression.test(this._parts.hostname),m=e&&d.punycode_expression.test(this._parts.hostname));switch(a.toLowerCase()){case "relative":return h;case "absolute":return!h;case "domain":case "name":return e;case "sld":return k;case "ip":return b;case "ip4":case "ipv4":case "inet4":return c;case "ip6":case "ipv6":case "inet6":return f;
case "idn":return l;case "url":return!this._parts.urn;case "urn":return!!this._parts.urn;case "punycode":return m}return null};var I=e.protocol,J=e.port,K=e.hostname;e.protocol=function(a,b){if(void 0!==a&&a&&(a=a.replace(/:(\/\/)?$/,""),!a.match(d.protocol_expression)))throw new TypeError('Protocol "'+a+"\" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]");return I.call(this,a,b)};e.scheme=e.protocol;e.port=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0!==
a&&(0===a&&(a=null),a&&(a+="",":"===a.charAt(0)&&(a=a.substring(1)),a.match(/[^0-9]/))))throw new TypeError('Port "'+a+'" contains characters other than [0-9]');return J.call(this,a,b)};e.hostname=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0!==a){var c={};if("/"!==d.parseHost(a,c))throw new TypeError('Hostname "'+a+'" contains characters other than [A-Z0-9.-]');a=c.hostname}return K.call(this,a,b)};e.origin=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0===
a){var c=this.protocol();return this.authority()?(c?c+"://":"")+this.authority():""}c=d(a);this.protocol(c.protocol()).authority(c.authority()).build(!b);return this};e.host=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0===a)return this._parts.hostname?d.buildHost(this._parts):"";if("/"!==d.parseHost(a,this._parts))throw new TypeError('Hostname "'+a+'" contains characters other than [A-Z0-9.-]');this.build(!b);return this};e.authority=function(a,b){if(this._parts.urn)return void 0===
a?"":this;if(void 0===a)return this._parts.hostname?d.buildAuthority(this._parts):"";if("/"!==d.parseAuthority(a,this._parts))throw new TypeError('Hostname "'+a+'" contains characters other than [A-Z0-9.-]');this.build(!b);return this};e.userinfo=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0===a){var c=d.buildUserinfo(this._parts);return c?c.substring(0,c.length-1):c}"@"!==a[a.length-1]&&(a+="@");d.parseUserinfo(a,this._parts);this.build(!b);return this};e.resource=function(a,
b){var c;if(void 0===a)return this.path()+this.search()+this.hash();c=d.parse(a);this._parts.path=c.path;this._parts.query=c.query;this._parts.fragment=c.fragment;this.build(!b);return this};e.subdomain=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0===a){if(!this._parts.hostname||this.is("IP"))return"";var c=this._parts.hostname.length-this.domain().length-1;return this._parts.hostname.substring(0,c)||""}c=this._parts.hostname.length-this.domain().length;c=this._parts.hostname.substring(0,
c);c=new RegExp("^"+q(c));a&&"."!==a.charAt(a.length-1)&&(a+=".");a&&d.ensureValidHostname(a);this._parts.hostname=this._parts.hostname.replace(c,a);this.build(!b);return this};e.domain=function(a,b){if(this._parts.urn)return void 0===a?"":this;"boolean"===typeof a&&(b=a,a=void 0);if(void 0===a){if(!this._parts.hostname||this.is("IP"))return"";var c=this._parts.hostname.match(/\./g);if(c&&2>c.length)return this._parts.hostname;c=this._parts.hostname.length-this.tld(b).length-1;c=this._parts.hostname.lastIndexOf(".",
c-1)+1;return this._parts.hostname.substring(c)||""}if(!a)throw new TypeError("cannot set domain empty");d.ensureValidHostname(a);!this._parts.hostname||this.is("IP")?this._parts.hostname=a:(c=new RegExp(q(this.domain())+"$"),this._parts.hostname=this._parts.hostname.replace(c,a));this.build(!b);return this};e.tld=function(a,b){if(this._parts.urn)return void 0===a?"":this;"boolean"===typeof a&&(b=a,a=void 0);if(void 0===a){if(!this._parts.hostname||this.is("IP"))return"";var c=this._parts.hostname.lastIndexOf("."),
c=this._parts.hostname.substring(c+1);return!0!==b&&t&&t.list[c.toLowerCase()]?t.get(this._parts.hostname)||c:c}if(a)if(a.match(/[^a-zA-Z0-9-]/))if(t&&t.is(a))c=new RegExp(q(this.tld())+"$"),this._parts.hostname=this._parts.hostname.replace(c,a);else throw new TypeError('TLD "'+a+'" contains characters other than [A-Z0-9]');else{if(!this._parts.hostname||this.is("IP"))throw new ReferenceError("cannot set TLD on non-domain host");c=new RegExp(q(this.tld())+"$");this._parts.hostname=this._parts.hostname.replace(c,
a)}else throw new TypeError("cannot set TLD empty");this.build(!b);return this};e.directory=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0===a||!0===a){if(!this._parts.path&&!this._parts.hostname)return"";if("/"===this._parts.path)return"/";var c=this._parts.path.length-this.filename().length-1,c=this._parts.path.substring(0,c)||(this._parts.hostname?"/":"");return a?d.decodePath(c):c}c=this._parts.path.length-this.filename().length;c=this._parts.path.substring(0,c);c=new RegExp("^"+
q(c));this.is("relative")||(a||(a="/"),"/"!==a.charAt(0)&&(a="/"+a));a&&"/"!==a.charAt(a.length-1)&&(a+="/");a=d.recodePath(a);this._parts.path=this._parts.path.replace(c,a);this.build(!b);return this};e.filename=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0===a||!0===a){if(!this._parts.path||"/"===this._parts.path)return"";var c=this._parts.path.lastIndexOf("/"),c=this._parts.path.substring(c+1);return a?d.decodePathSegment(c):c}c=!1;"/"===a.charAt(0)&&(a=a.substring(1));a.match(/\.?\//)&&
(c=!0);var f=new RegExp(q(this.filename())+"$");a=d.recodePath(a);this._parts.path=this._parts.path.replace(f,a);c?this.normalizePath(b):this.build(!b);return this};e.suffix=function(a,b){if(this._parts.urn)return void 0===a?"":this;if(void 0===a||!0===a){if(!this._parts.path||"/"===this._parts.path)return"";var c=this.filename(),f=c.lastIndexOf(".");if(-1===f)return"";c=c.substring(f+1);c=/^[a-z0-9%]+$/i.test(c)?c:"";return a?d.decodePathSegment(c):c}"."===a.charAt(0)&&(a=a.substring(1));if(c=this.suffix())f=
a?new RegExp(q(c)+"$"):new RegExp(q("."+c)+"$");else{if(!a)return this;this._parts.path+="."+d.recodePath(a)}f&&(a=d.recodePath(a),this._parts.path=this._parts.path.replace(f,a));this.build(!b);return this};e.segment=function(a,b,c){var d=this._parts.urn?":":"/",e=this.path(),h="/"===e.substring(0,1),e=e.split(d);void 0!==a&&"number"!==typeof a&&(c=b,b=a,a=void 0);if(void 0!==a&&"number"!==typeof a)throw Error('Bad segment "'+a+'", must be 0-based integer');h&&e.shift();0>a&&(a=Math.max(e.length+
a,0));if(void 0===b)return void 0===a?e:e[a];if(null===a||void 0===e[a])if(k(b)){e=[];a=0;for(var l=b.length;a<l;a++)if(b[a].length||e.length&&e[e.length-1].length)e.length&&!e[e.length-1].length&&e.pop(),e.push(z(b[a]))}else{if(b||"string"===typeof b)b=z(b),""===e[e.length-1]?e[e.length-1]=b:e.push(b)}else b?e[a]=z(b):e.splice(a,1);h&&e.unshift("");return this.path(e.join(d),c)};e.segmentCoded=function(a,b,c){var e,g;"number"!==typeof a&&(c=b,b=a,a=void 0);if(void 0===b){a=this.segment(a,b,c);if(k(a))for(e=
0,g=a.length;e<g;e++)a[e]=d.decode(a[e]);else a=void 0!==a?d.decode(a):void 0;return a}if(k(b))for(e=0,g=b.length;e<g;e++)b[e]=d.encode(b[e]);else b="string"===typeof b||b instanceof String?d.encode(b):b;return this.segment(a,b,c)};var L=e.query;e.query=function(a,b){if(!0===a)return d.parseQuery(this._parts.query,this._parts.escapeQuerySpace);if("function"===typeof a){var c=d.parseQuery(this._parts.query,this._parts.escapeQuerySpace),e=a.call(this,c);this._parts.query=d.buildQuery(e||c,this._parts.duplicateQueryParameters,
this._parts.escapeQuerySpace);this.build(!b);return this}return void 0!==a&&"string"!==typeof a?(this._parts.query=d.buildQuery(a,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace),this.build(!b),this):L.call(this,a,b)};e.setQuery=function(a,b,c){var e=d.parseQuery(this._parts.query,this._parts.escapeQuerySpace);if("string"===typeof a||a instanceof String)e[a]=void 0!==b?b:null;else if("object"===typeof a)for(var g in a)p.call(a,g)&&(e[g]=a[g]);else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
this._parts.query=d.buildQuery(e,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace);"string"!==typeof a&&(c=b);this.build(!c);return this};e.addQuery=function(a,b,c){var e=d.parseQuery(this._parts.query,this._parts.escapeQuerySpace);d.addQuery(e,a,void 0===b?null:b);this._parts.query=d.buildQuery(e,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace);"string"!==typeof a&&(c=b);this.build(!c);return this};e.removeQuery=function(a,b,c){var e=d.parseQuery(this._parts.query,
this._parts.escapeQuerySpace);d.removeQuery(e,a,b);this._parts.query=d.buildQuery(e,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace);"string"!==typeof a&&(c=b);this.build(!c);return this};e.hasQuery=function(a,b,c){var e=d.parseQuery(this._parts.query,this._parts.escapeQuerySpace);return d.hasQuery(e,a,b,c)};e.setSearch=e.setQuery;e.addSearch=e.addQuery;e.removeSearch=e.removeQuery;e.hasSearch=e.hasQuery;e.normalize=function(){return this._parts.urn?this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build():
this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build()};e.normalizeProtocol=function(a){"string"===typeof this._parts.protocol&&(this._parts.protocol=this._parts.protocol.toLowerCase(),this.build(!a));return this};e.normalizeHostname=function(a){this._parts.hostname&&(this.is("IDN")&&n?this._parts.hostname=n.toASCII(this._parts.hostname):this.is("IPv6")&&v&&(this._parts.hostname=v.best(this._parts.hostname)),this._parts.hostname=
this._parts.hostname.toLowerCase(),this.build(!a));return this};e.normalizePort=function(a){"string"===typeof this._parts.protocol&&this._parts.port===d.defaultPorts[this._parts.protocol]&&(this._parts.port=null,this.build(!a));return this};e.normalizePath=function(a){var b=this._parts.path;if(!b)return this;if(this._parts.urn)return this._parts.path=d.recodeUrnPath(this._parts.path),this.build(!a),this;if("/"===this._parts.path)return this;var b=d.recodePath(b),c,e="",g,k;"/"!==b.charAt(0)&&(c=!0,
b="/"+b);if("/.."===b.slice(-3)||"/."===b.slice(-2))b+="/";b=b.replace(/(\/(\.\/)+)|(\/\.$)/g,"/").replace(/\/{2,}/g,"/");c&&(e=b.substring(1).match(/^(\.\.\/)+/)||"")&&(e=e[0]);for(;;){g=b.search(/\/\.\.(\/|$)/);if(-1===g)break;else if(0===g){b=b.substring(3);continue}k=b.substring(0,g).lastIndexOf("/");-1===k&&(k=g);b=b.substring(0,k)+b.substring(g+3)}c&&this.is("relative")&&(b=e+b.substring(1));this._parts.path=b;this.build(!a);return this};e.normalizePathname=e.normalizePath;e.normalizeQuery=
function(a){"string"===typeof this._parts.query&&(this._parts.query.length?this.query(d.parseQuery(this._parts.query,this._parts.escapeQuerySpace)):this._parts.query=null,this.build(!a));return this};e.normalizeFragment=function(a){this._parts.fragment||(this._parts.fragment=null,this.build(!a));return this};e.normalizeSearch=e.normalizeQuery;e.normalizeHash=e.normalizeFragment;e.iso8859=function(){var a=d.encode,b=d.decode;d.encode=escape;d.decode=decodeURIComponent;try{this.normalize()}finally{d.encode=
a,d.decode=b}return this};e.unicode=function(){var a=d.encode,b=d.decode;d.encode=A;d.decode=unescape;try{this.normalize()}finally{d.encode=a,d.decode=b}return this};e.readable=function(){var a=this.clone();a.username("").password("").normalize();var b="";a._parts.protocol&&(b+=a._parts.protocol+"://");a._parts.hostname&&(a.is("punycode")&&n?(b+=n.toUnicode(a._parts.hostname),a._parts.port&&(b+=":"+a._parts.port)):b+=a.host());a._parts.hostname&&a._parts.path&&"/"!==a._parts.path.charAt(0)&&(b+="/");
b+=a.path(!0);if(a._parts.query){for(var c="",e=0,g=a._parts.query.split("&"),k=g.length;e<k;e++){var l=(g[e]||"").split("="),c=c+("&"+d.decodeQuery(l[0],this._parts.escapeQuerySpace).replace(/&/g,"%26"));void 0!==l[1]&&(c+="="+d.decodeQuery(l[1],this._parts.escapeQuerySpace).replace(/&/g,"%26"))}b+="?"+c.substring(1)}return b+=d.decodeQuery(a.hash(),!0)};e.absoluteTo=function(a){var b=this.clone(),c=["protocol","username","password","hostname","port"],e,g;if(this._parts.urn)throw Error("URNs do not have any generally defined hierarchical components");
a instanceof d||(a=new d(a));b._parts.protocol||(b._parts.protocol=a._parts.protocol);if(this._parts.hostname)return b;for(e=0;g=c[e];e++)b._parts[g]=a._parts[g];b._parts.path?".."===b._parts.path.substring(-2)&&(b._parts.path+="/"):(b._parts.path=a._parts.path,b._parts.query||(b._parts.query=a._parts.query));"/"!==b.path().charAt(0)&&(c=(c=a.directory())?c:0===a.path().indexOf("/")?"/":"",b._parts.path=(c?c+"/":"")+b._parts.path,b.normalizePath());b.build();return b};e.relativeTo=function(a){var b=
this.clone().normalize(),c,e,g;if(b._parts.urn)throw Error("URNs do not have any generally defined hierarchical components");a=(new d(a)).normalize();c=b._parts;e=a._parts;g=b.path();a=a.path();if("/"!==g.charAt(0))throw Error("URI is already relative");if("/"!==a.charAt(0))throw Error("Cannot calculate a URI relative to another relative URI");c.protocol===e.protocol&&(c.protocol=null);if(c.username===e.username&&c.password===e.password&&null===c.protocol&&null===c.username&&null===c.password&&c.hostname===
e.hostname&&c.port===e.port)c.hostname=null,c.port=null;else return b.build();if(g===a)return c.path="",b.build();g=d.commonPath(g,a);if(!g)return b.build();e=e.path.substring(g.length).replace(/[^\/]*$/,"").replace(/.*?\//g,"../");c.path=e+c.path.substring(g.length)||"./";return b.build()};e.equals=function(a){var b=this.clone();a=new d(a);var c={},e={},g={},h;b.normalize();a.normalize();if(b.toString()===a.toString())return!0;c=b.query();e=a.query();b.query("");a.query("");if(b.toString()!==a.toString()||
c.length!==e.length)return!1;c=d.parseQuery(c,this._parts.escapeQuerySpace);e=d.parseQuery(e,this._parts.escapeQuerySpace);for(h in c)if(p.call(c,h)){if(!k(c[h])){if(c[h]!==e[h])return!1}else if(!D(c[h],e[h]))return!1;g[h]=!0}for(h in e)if(p.call(e,h)&&!g[h])return!1;return!0};e.duplicateQueryParameters=function(a){this._parts.duplicateQueryParameters=!!a;return this};e.escapeQuerySpace=function(a){this._parts.escapeQuerySpace=!!a;return this};return d});
function AutoSuggestControl(oComponent,oQueryHandler,oSelectionHandler,oSuggestionDisplayHandler,oItemId){this.cur=0;
this.layer=null;
this.component=oComponent;
this.queryHandler=oQueryHandler;
this.selectionHandler=oSelectionHandler;
this.suggestionDisplayHandler=oSuggestionDisplayHandler;
if(oItemId){this.textbox=_g(oComponent.getStyles().getNameSpace()+oItemId+oComponent.getComponentId());
}else{this.textbox=_g(oComponent.getStyles().getNameSpace()+"ContentCtrl"+oComponent.getComponentId());
}this.objArray="";
this.init();
}AutoSuggestControl.prototype.autosuggest=function(aSuggestions,defaultSelected){this.layer.style.width=this.textbox.offsetWidth;
this.objArray=aSuggestions;
if(aSuggestions&&aSuggestions.length>0){this.showSuggestions(aSuggestions,defaultSelected);
}else{this.hideSuggestions();
}};
AutoSuggestControl.prototype.createDropDown=function(){var oThis=this;
this.layer=document.createElement("div");
this.layer.className="suggestions";
this.layer.style.display="none";
this.layer.style.zIndex="9999";
this.layer.onmousedown=this.layer.onmouseup=this.layer.onmouseover=function(oEvent){oEvent=oEvent||window.event;
oTarget=oEvent.target||oEvent.srcElement;
var index;
if(oEvent.type=="mousedown"){index=AutoSuggestControl.prototype.indexOf(this,oTarget);
oThis.selectionHandler(oThis.objArray[index],oThis.textbox,oThis.component);
oThis.hideSuggestions();
}else{if(oEvent.type=="mouseover"){index=AutoSuggestControl.prototype.indexOf(this,oTarget);
oThis.cur=index;
oThis.highlightSuggestion(oTarget);
}else{oThis.textbox.focus();
}}};
Util.ia(this.layer,Util.gp(this.textbox));
};
AutoSuggestControl.prototype.handleKeyDown=function(oEvent){if(this.layer.style.display!="none"){switch(oEvent.keyCode){case 38:this.previousSuggestion();
break;
case 40:this.nextSuggestion();
break;
case 13:this.selectionHandler(this.objArray[this.cur],this.textbox,this.component);
this.hideSuggestions();
break;
}}};
AutoSuggestControl.prototype.handleKeyUp=function(oEvent){var iKeyCode=oEvent.keyCode;
if(iKeyCode==8||iKeyCode==46){if(this.textbox.value.length>0){this.queryHandler(this,this.textbox,this.component);
}else{this.hideSuggestions();
}}else{if(iKeyCode<32||(iKeyCode>=33&&iKeyCode<46)||(iKeyCode>=112&&iKeyCode<=123)){}else{this.queryHandler(this,this.textbox,this.component);
}}};
AutoSuggestControl.prototype.hideSuggestions=function(){var oNode=this.textbox;
while(oNode&&!Util.Style.ccss(oNode,"section")){oNode=Util.gp(oNode);
}if(oNode){oNode.style.position="relative";
oNode.style.zIndex="1";
}this.layer.style.zIndex="9999";
this.layer.style.display="none";
};
AutoSuggestControl.prototype.highlightSuggestion=function(oSuggestionNode){for(var i=0;
i<this.layer.childNodes.length;
i++){var oNode=this.layer.childNodes[i];
if(oNode==oSuggestionNode||oNode==oSuggestionNode.parentNode){oNode.className="current";
}else{if(oNode.className=="current"){oNode.className="";
}}}};
AutoSuggestControl.prototype.init=function(){var oThis=this;
this.textbox.onkeyup=function(oEvent){if(!oEvent){oEvent=window.event;
}oThis.handleKeyUp(oEvent);
};
this.textbox.onkeydown=function(oEvent){if(!oEvent){oEvent=window.event;
}oThis.handleKeyDown(oEvent);
};
this.textbox.onblur=function(){oThis.hideSuggestions();
};
this.createDropDown();
};
AutoSuggestControl.prototype.nextSuggestion=function(){var cSuggestionNodes=this.layer.childNodes;
if(cSuggestionNodes.length>0&&this.cur<cSuggestionNodes.length-1){var oNode=cSuggestionNodes[++this.cur];
this.highlightSuggestion(oNode);
}};
AutoSuggestControl.prototype.previousSuggestion=function(){var cSuggestionNodes=this.layer.childNodes;
if(cSuggestionNodes.length>0&&this.cur>0){var oNode=cSuggestionNodes[--this.cur];
this.highlightSuggestion(oNode);
}};
AutoSuggestControl.prototype.showSuggestions=function(aSuggestions,defaultSelected){var oDiv=null;
this.layer.innerHTML="";
for(var i=0;
i<aSuggestions.length;
i++){oDiv=document.createElement("div");
if(i===0&&!defaultSelected){oDiv.className="current";
}if(defaultSelected){this.cur=-1;
}else{this.cur=0;
}var domText=this.suggestionDisplayHandler(aSuggestions[i],this.textbox.value);
oDiv.innerHTML=domText;
oDiv.appendChild(document.createTextNode(""));
this.layer.appendChild(oDiv);
}var oNode=this.textbox;
while(oNode&&!Util.Style.ccss(oNode,"section")){oNode=Util.gp(oNode);
}if(oNode){oNode.style.position="relative";
oNode.style.zIndex="2";
}this.layer.style.zIndex="100000";
this.layer.style.display="block";
};
AutoSuggestControl.prototype.indexOf=function(parent,el){var nodeList=parent.childNodes;
for(var i=0;
i<nodeList.length;
i++){var oNode=nodeList[i];
if(oNode==el||oNode==el.parentNode){return i;
}}return -1;
};
AutoSuggestControl.prototype.highlight=function(value,term){return"<strong>"+value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)("+term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi,"\\$1").split(" ").join("|")+")(?![^<>]*>)(?![^&;]+;)","gi"),"</strong>$1<strong>")+"</strong>";
};
/*global MP_Timezone*/
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 *
 * dateFormat.masks and dateFormat.i18n are derived from m_dateformatJSON which is returned from mp_unified_driver.
 */
/**
 * Format a date based on a standard format or template. Compose the template string using MPages supported masks.
 * [Ref: MPages Date Formatter]{@link https://wiki.ucern.com/x/WbGCUw}
 * NOTE: Passing a standard format without referencing dateFormat.masks may result in misinterpreted return if it is missing.
 * @param {Date} date - A Date object
 * @param {dateFormat.masks|string} - A standard format defined in dateFormat.masks or a template string.
 * @param {boolean} utc
 * @returns {string} Returns a formatted date display.
 */
var dateFormat = function() { // eslint-disable-line no-redeclare
    var token = /d{1,4}e?|w{1,9}|m{1,4}|MAC|M{1,12}|Y{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function(val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) val = "0" + val;
            return val;
        };

    // Regexes and supporting functions are cached through closure
    return function(date, mask, utc) {
        var dF = dateFormat;

        // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
        if (arguments.length === 1 && Object.prototype.toString.call(date) === "[object String]" && !/\d/.test(date)) {
            mask = date;
            date = undefined;
        }

        // Passing date through Date applies Date.parse, if necessary
        date = date ? new Date(date) : new Date();
        if (isNaN(date)) throw new SyntaxError("invalid date");

        //Replacing text for passivity concerns.
        if (mask) {
            mask = mask.replace("HH:MM", "HH:mm");
        }
        // Locate the format string by name, otherwise use the given mask as a format string.
        // Honor the default format if mask is undefined.
        mask = String(dF.masks[ mask ] || mask || dF.masks.default);

        // Allow setting the utc argument via the mask
        if (mask.slice(0, 4) === "UTC:") {
            mask = mask.slice(4);
            utc = true;
        }

        var _ = utc ? "getUTC" : "get";
        var d = date[ _ + "Date" ]();
        var D = date[ _ + "Day" ]();
        var m = date[ _ + "Month" ]();
        var y = date[ _ + "FullYear" ]();
        var H = date[ _ + "Hours" ]();
        var M = date[ _ + "Minutes" ]();
        var s = date[ _ + "Seconds" ]();
        var L = date[ _ + "Milliseconds" ]();
        var o = utc ? 0 : date.getTimezoneOffset();
        // Capitalized Month name abbreviation of current month
        var capMonthAbbrev = dF.i18n.monthNames[ m ].slice(0, 1).toLocaleUpperCase()
            + dF.i18n.monthNames[ m ].slice(-2).toLocaleLowerCase();
        var flags = {
            d: d,
            dd: pad(d),
            de: "de",
            ddd: dF.i18n.dayNames[ D ],
            dddd: dF.i18n.dayNames[ D + 7 ],
            ww: pad(D),
            www: dF.i18n.dayNames[ D ],
            wwwwwwwww: dF.i18n.dayNames[ D + 7 ],
            m: m + 1,
            MM: pad(m + 1),//Month padded to two digits
            mmm: dF.i18n.monthNames[ m ],
            mmmm: dF.i18n.monthNames[ m + 12 ],
            yy: String(y).slice(2),
            yyyy: y,
            YYYY: y,
            h: H % 12 || 12,
            hh: pad(H % 12 || 12),
            H: H,
            HH: pad(H),
            MAC: capMonthAbbrev,
            MMM: dF.i18n.monthNames[ m ],
            MMMM: dF.i18n.monthNames[ m ],
            MMMMMMMMM: dF.i18n.monthNames[ m + 12 ],
            MMMMMMMMMMMM: dF.i18n.monthNames[ m + 12 ],
            M: M,
            mm: pad(M),//Minutes
            s: s,
            ss: pad(s),
            l: pad(L, 3),
            L: pad(L > 99 ? Math.round(L / 10) : L),
            t: H < 12 ? "a" : "p",
            tt: H < 12 ? "am" : "pm",
            T: H < 12 ? "A" : "P",
            TT: H < 12 ? "AM" : "PM",
            Z: utc ? "UTC" : (String(date).match(timezone) || [ "" ]).pop().replace(timezoneClip, ""),
            o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
            S: [ "th", "st", "nd", "rd" ][ d % 10 > 3 ? 0 : ((d % 100 - d % 10) !== 10) * d % 10 ]
        };

        return mask.replace(token, function($0) {
            return $0 in flags ? flags[ $0 ] : $0.slice(1, $0.length - 1);
        });
    };
}();

// Some common format strings
dateFormat.masks = {};

// Internationalization strings
dateFormat.i18n = {
    dayNames: [],
    monthNames: []
};

// For convenience...
Date.prototype.format = function(mask, utc) { // eslint-disable-line no-extend-native
    var timezone = MP_Timezone.getTimeZone(this, mask);
    return (dateFormat(this, mask, utc) + ((timezone) ? " " + (timezone) : ""));
};

// For i18n formatting...
/**
 * Sets <code>this</code> instance of the Date object to the value specified by the UTC date/time string.
 *
 * The setISO8601 method only accepts date/time strings in the format with a Zulu offset.
 * Examples of setISO8601 string inputs are: "2009-07-01", "2009-07-01T17:31:00Z" and "2009-07-01T17:31:00.000Z"
 * Please be aware that when "2009-07-01" is passed in, it is equivalent to "2009-07-01T00:00:00Z"
 *
 * setISO8601 method is duplicated in all the locale date.format.js files
 *
 * The year/month/date/time has to be set in a certain order to avoid inadvertent changes in the date/time.
 * The rules governing the order are:
 *        year must be set before month and date (to avoid issues with leap year)
 *        date must be set before month (to avoid issues with months not supporting the 31st on +offset tz)
 *        times should be set before date/month/year (because setting the time on certain dates can cause date adjustments)
 *
 * @param string - An ISO8601 formatted date/time string
 */
Date.prototype.setISO8601 = function(string) { // eslint-disable-line no-extend-native
    var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})" +
        "(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\.([0-9]+))?)?" +
        "Z?)?)?)?";
    var d = string.match(new RegExp(regexp));

    var date = new Date(d[ 1 ], 0, 1);

    // set the times
    if (d[ 7 ]) {
        date.setUTCHours(d[ 7 ]);
    }
    else {
        date.setUTCHours(0);
    }
    if (d[ 8 ]) {
        date.setUTCMinutes(d[ 8 ]);
    }
    else {
        date.setUTCMinutes(0);
    }
    if (d[ 10 ]) {
        date.setUTCSeconds(d[ 10 ]);
    }
    else {
        date.setUTCSeconds(0);
    }
    if (d[ 12 ]) {
        date.setUTCMilliseconds(Number("0." + d[ 12 ]) * 1000);
    }
    else {
        date.setUTCMilliseconds(0);
    }

    // set year before month/date
    if (d[ 1 ]) {
        date.setUTCFullYear(d[ 1 ]);
    }

    // set date before month
    if (d[ 5 ]) {
        date.setUTCDate(d[ 5 ]);
    }
    if (d[ 3 ]) {
        date.setUTCMonth(d[ 3 ] - 1);
    }

    this.setTime(date.getTime());
};

/* eslint eqeqeq:0, no-underscore-dangle:0 */
//http://software.dzhuvinov.com/jsworld-numeric-formatting.html

mp_formatter = {};

mp_formatter.Locale = function(properties){
    this._className = "mp_formatter.Locale";
    this._parseList = function(names, expectedItems){
        var array = [];
        if (names === null) {
            throw "Names not defined";
        }
        else if (typeof names == "object") {
            array = names;
        }
        else if (typeof names == "string") {
            array = names.split(";", expectedItems);
            for (var i = 0; i < array.length; i++) {
                if (array[i][0] == "\"" && array[i][array[i].length - 1] == "\""){
                    array[i] = array[i].slice(1, -1);
                }
                else{
                    throw "Missing double quotes";
                }
            }
        }
        else {
            throw "Names must be an array or a string";
        }
        if (array.length != expectedItems){
            throw "Expected " + expectedItems + " items, got " + array.length;
        }
        return array;
    };
    this._validateFormatString = function(formatString){
        if (typeof formatString == "string" && formatString.length > 0){
            return formatString;
        }
        else {
            throw "Empty or no string";
        }
    };
    if (properties === null || typeof properties != "object"){
        throw "Error: Invalid/missing locale properties";
    }
    if (typeof properties.decimalPoint != "string"){
        throw "Error: Invalid/missing decimalPoint property";
    }
    this.decimalPoint = properties.decimalPoint;
    if (typeof properties.thousandsSep != "string"){
        throw "Error: Invalid/missing thousandsSep property";
    }
    this.thousandsSep = properties.thousandsSep;
    if (typeof properties.grouping != "string"){
        throw "Error: Invalid/missing grouping property";
    }
    this.grouping = properties.grouping;

    if (properties === null || typeof properties != "object"){
        throw "Error: Invalid/missing time locale properties";
    }
    try {
        this.time24hr = this._validateFormatString(properties.time24hr);
    }
    catch (error) {
        throw "Error: Invalid time24hr property: " + error;
    }
    try {
        this.time24hrnosec = this._validateFormatString(properties.time24hrnosec);
    }
    catch (error) {
        throw "Error: Invalid time24hrnosec property: " + error;
    }
    try {
        this.shortdate2yr = this._validateFormatString(properties.shortdate2yr);
    }
    catch (error) {
        throw "Error: Invalid shortdate2yr property: " + error;
    }
    try {
        this.fulldate4yr = this._validateFormatString(properties.fulldate4yr);
    }
    catch (error) {
        throw "Error: Invalid fulldate4yr property: " + error;
    }
    try {
        this.fulldate2yr = this._validateFormatString(properties.fulldate2yr);
    }
    catch (error) {
        throw "Error: Invalid fulldate2yr property: " + error;
    }
    try {
        this.fullmonth4yrnodate = this._validateFormatString(properties.fullmonth4yrnodate);
    }
    catch (error) {
        throw "Error: Invalid fullmonth4yrnodate property: " + error;
    }
    try {
        this.full4yr = this._validateFormatString(properties.full4yr);
    }
    catch (error) {
        throw "Error: Invalid full4yr property: " + error;
    }
    try {
        this.fulldatetime2yr = this._validateFormatString(properties.fulldatetime2yr);
    }
    catch (error) {
        throw "Error: Invalid fulldatetime2yr property: " + error;
    }
    try {
        this.fulldatetime4yr = this._validateFormatString(properties.fulldatetime4yr);
    }
    catch (error) {
        throw "Error: Invalid fulldatetime4yr property: " + error;
    }
};

mp_formatter._getPrecision = function(optionsString){
    if (typeof optionsString != "string"){
        return -1;
    }
    var m = optionsString.match(/\.(\d)/);
    if (m){
        return parseInt(m[1], 10);
    }
    else{
        return -1;
    }
};

mp_formatter._isNumber = function(arg){
    if (typeof arg == "number"){
        return true;
    }
    if (typeof arg != "string"){
        return false;
    }
    var s = arg + "";
    return (/^-?(\d+|\d*\.\d+)$/).test(s);
};

mp_formatter._isDate = function(arg){
    if (arg.getDate){
        return true;
    }
    return false;
};

mp_formatter._trim = function(str){
    var whitespace = ' \n\r\t\f\x0b\xa0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000';
    for (var i = 0; i < str.length; i++) {
        if (whitespace.indexOf(str.charAt(i)) === -1) {
            str = str.substring(i);
            break;
        }
    }
    for (i = str.length - 1; i >= 0; i--) {
        if (whitespace.indexOf(str.charAt(i)) === -1) {
            str = str.substring(0, i + 1);
            break;
        }
    }
    return whitespace.indexOf(str.charAt(0)) === -1 ? str : '';
};

mp_formatter._splitNumber = function(amount){
    if (typeof amount == "number"){
        amount = amount + "";
    }
    var obj = {};
    if (amount.charAt(0) == "-"){
        amount = amount.substring(1);
    }
    var amountParts = amount.split(".");
    if (!amountParts[1]){
        amountParts[1] = "";
    }
    obj.integer = amountParts[0];
    obj.fraction = amountParts[1];
    return obj;
};

mp_formatter._formatIntegerPart = function(intPart, grouping, thousandsSep){
    if (thousandsSep === "" || grouping == "-1"){
        return intPart;
    }
    var groupSizes = grouping.split(";");
    var out = "";
    var pos = intPart.length;
    var size;
    while (pos > 0) {
        if (groupSizes.length > 0){
            size = parseInt(groupSizes.shift(), 10);
        }
        if (isNaN(size)){
            throw "Error: Invalid grouping";
        }
        if (size == -1) {
            out = intPart.substring(0, pos) + out;
            break;
        }
        pos -= size;
        if (pos < 1) {
            out = intPart.substring(0, pos + size) + out;
            break;
        }
        out = thousandsSep + intPart.substring(pos, pos + size) + out;
    }
    return out;
};

mp_formatter._formatFractionPart = function(fracPart, precision){
    for (var i = 0; fracPart.length < precision; i++){
        fracPart = fracPart + "0";
    }
    return fracPart;
};

mp_formatter._hasOption = function(option, optionsString){
    if (typeof option != "string" || typeof optionsString != "string"){
        return false;
    }
    if (optionsString.indexOf(option) != -1){
        return true;
    }
    else{
        return false;
    }
};

mp_formatter._validateFormatString = function(formatString){
    if (typeof formatString == "string" && formatString.length > 0){
        return true;
    }
    else{
        return false;
    }
};

mp_formatter.NumericFormatter = function(locale){
    if (typeof locale != "object" || locale._className != "mp_formatter.Locale"){
        throw "Constructor error: You must provide a valid mp_formatter.Locale instance";
    }
    this.lc = locale;
    /*
     argument to modify the output format:
     "^" suppress grouping
     ".n" specify decimal precision n
     "+" force positive sign for positive amounts
     "~" suppress positive/negative sign
     */
    this.format = function(number, options){
        if (typeof number == "string"){
            number = mp_formatter._trim(number);
        }
        if (!mp_formatter._isNumber(number)){
            throw "Error: The input is not a number";
        }
        var floatAmount = parseFloat(number, 10);
        var reqPrecision = mp_formatter._getPrecision(options);
        if (reqPrecision != -1){
            floatAmount = Math.round(floatAmount * Math.pow(10, reqPrecision)) / Math.pow(10, reqPrecision);
        }
        var parsedAmount = mp_formatter._splitNumber(String(floatAmount));
        var formattedIntegerPart;

        if (floatAmount === 0){
            formattedIntegerPart = "0";
        }
        else{
            formattedIntegerPart = mp_formatter._hasOption("^", options) ? parsedAmount.integer : mp_formatter._formatIntegerPart(parsedAmount.integer, this.lc.grouping, this.lc.thousandsSep);
        }
        var formattedFractionPart = reqPrecision != -1 ? mp_formatter._formatFractionPart(parsedAmount.fraction, reqPrecision) : parsedAmount.fraction;
        var formattedAmount = formattedFractionPart.length ? formattedIntegerPart + this.lc.decimalPoint + formattedFractionPart : formattedIntegerPart;

        if (mp_formatter._hasOption("~", options) || floatAmount === 0) {
            return formattedAmount;
        }
        else {
            if (mp_formatter._hasOption("+", options) || floatAmount < 0) {
                if (floatAmount > 0) {
                    return "+" + formattedAmount;
                }
                else if (floatAmount < 0) {
                    return "-" + formattedAmount;
                }
                else {
                    return formattedAmount;
                }
            }
            else {
                return formattedAmount;
            }
        }
    };
};
/*
 * The singleton DateTimeFormatter has a dependency on the date.format.js (http://blog.stevenlevithan.com/archives/date-time-format)
 */
mp_formatter.DateTimeFormatter = function(locale){
    if (typeof locale != "object" || locale._className != "mp_formatter.Locale") {
        throw "Constructor error: You must provide a valid mp_formatter.Locale instance";
    }
    this.lc = locale;

    this.formatISO8601 = function(dateStr, option){
        if (!mp_formatter._validateFormatString(dateStr)){
            throw "Error: The input is either empty or no string";
        }

        var date = new Date();
        date.setISO8601(dateStr);
        return this.format(date, option);
    };

    this.format = function(dateTime, option){
        if (!mp_formatter._isDate(dateTime)) {
            throw "Error: The input is not a date object";
        }
        switch (option) {
            case mp_formatter.DateTimeFormatter.TIME_24HOUR:
                return (dateTime.format(this.lc.time24hr));
            case mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS:
                return (dateTime.format(this.lc.time24hrnosec));
            case mp_formatter.DateTimeFormatter.SHORT_DATE_2YEAR:
                return dateTime.format(this.lc.shortdate2yr);
            case mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR:
                return dateTime.format(this.lc.fulldate4yr);
            case mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR:
                return dateTime.format(this.lc.fulldate2yr);
            case mp_formatter.DateTimeFormatter.FULL_MONTH_4YEAR_NO_DATE:
                return dateTime.format(this.lc.fullmonth4yrnodate);
            case mp_formatter.DateTimeFormatter.FULL_4YEAR:
                return dateTime.format(this.lc.full4yr);
            case mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR:
                return (dateTime.format(this.lc.fulldatetime2yr));
            case mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR:
                return (dateTime.format(this.lc.fulldatetime4yr));
            default:
                alert("Unhandled date time formatting option");//eslint-disable-line no-alert
        }
    };
};

//Constants for DateFormat
mp_formatter.DateTimeFormatter.TIME_24HOUR = 1;
mp_formatter.DateTimeFormatter.TIME_24HOUR_NO_SECONDS = 2;
mp_formatter.DateTimeFormatter.SHORT_DATE_2YEAR = 3;
mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR = 4;
mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR = 5;
mp_formatter.DateTimeFormatter.FULL_MONTH_4YEAR_NO_DATE = 6;
mp_formatter.DateTimeFormatter.FULL_4YEAR = 7;
mp_formatter.DateTimeFormatter.FULL_DATE_TIME_2YEAR = 8;
mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR = 9;
/*globals CapabilityTimer*/
/**
 * The GapCheck object
 * This object is used to honour Gapcheck functionality and provides the ability add override reasons
 * for the unsatisfied components to complete the discharge work flow
 * @constructor
 * @param {Object} criterion : The criterion object
 * @author Neethu Shree
 */
var GapCheck = function (criterion) {
    this.m_auditEventsList = [];
    this.m_currentAuditEventsList = [];
    this.m_encounterType = 0;
    this.m_isOrderPlaced = null;
    this.m_criterion = criterion;
    this.m_synonymArr = [];
    this.m_encntrTypeFlag = 0;
};
/**
 * Enum to be used across artifacts for representing the workflow criteria
 */
GapCheck.CRITERIA = {
    ALL: 1,
    DISCHARGE: 2,
    ADMIT: 3
};
/**
 * Holds the value of encounter type returned from mp_retrieve_audit_events
 * @param {Number} encounterType : Holds the encounter type
 * @returns {undefined} This function does not return a value
 */
GapCheck.prototype.setEncounterType = function (encounterType) {
    this.m_encounterType = encounterType;
};
/**
 * Determines the encounter type based on the value set in m_encounterType.
 * @returns {GapCheck.m_encounterType} The function returns the encounter type
 */
GapCheck.prototype.getEncounterType = function () {
    return this.m_encounterType;
};
/**
 * JSON for Audit Elements retrieved from mp_get_audit_event, this will
 * be used populate the saved override reason details
 * @returns {Object} AuditEventElementsJSON : json object for saving the audit details information obtained from getAuditEventsList method.
 */
GapCheck.prototype.AuditEventElementsJSON = function () {
    return {
        tracking_audit_element_id: 0.0,
        audit_element_name: "",
        audit_element_txt: "",
        audit_value: 0.0,
        audit_string: "",
        audit_flag: 0,
        audit_dt_tm: "",
        update_flag: 0,
        component_Id: 0.0
    };
};
/**
 * JSON for Update Audit Elements Request to mp_add_upd_audit_event, this will be one of the
 * parameters within the Audit Events Request JSON
 * @returns {Object} UpdateAuditEventElementsJSON : json object for saving the modified information of audit events
 */
GapCheck.prototype.UpdateAuditEventElementsJSON = function () {
    return {
        tracking_audit_element_id: 0.0,
        audit_element_name: "",
        audit_element_txt: "",
        audit_value: 0.0,
        audit_string: "",
        audit_flag: 0,
        audit_dt_tm: "",
        audit_element_string: ""
    };
};
/**
 * JSON for Audit Elements Request to mp_add_upd_audit_event, this will
 * be one of the parameters within the Audit Events Request JSON
 * @returns {Object} NewAuditEventElementsJSON : json object for saving the new audit event details
 */
GapCheck.prototype.NewAuditEventElementsJSON = function () {
    return {
        audit_element_name: "",
        audit_element_txt: "",
        audit_value: 0.0,
        audit_string: "",
        audit_flag: 0,
        audit_dt_tm: "",
        audit_element_string: ""
    };
};

/**
 * JSON for Audit Events request to mp_add_upd_audit_event
 * @returns {Object} AuditEventsRequestJSON : Audit Event Request to mp_add_upd_audit_event
 */
GapCheck.prototype.AuditEventsRequestJSON = function () {
    this.tracking_audit_id = 0.0;
    this.encntr_id = 0.0;
    this.tracking_group_cd = 0.0;
    this.audit_type_cd = 0.0;
    this.updt_id = 0.0;
    this.clear_audit_elements_ind = 0;
    this.audit_elements = [];
    this.upd_audit_elements = [];
};

/**
 * Triggers a capability timer that indicated that gap-check was initialized.
 * Sends meta data containing details of gap-check and override for components that have their gap-check
 * filters set.
 * @returns {undefined} This function does not return a value
**/
GapCheck.prototype.triggerInitializationTimer = function (components) {
    var reqdObj = "";
    var overRideObj = "";
    var gapCheckInd = null;
    var gapCheckOverrideInd = null;
    var capTimer = new CapabilityTimer("CAP:MPG.GAPCHECK_Initialize_GapCheck", this.m_criterion.category_mean);
    var noOfComps = components.length;
    for (var i = 0; i < noOfComps; i++) {
        gapCheckInd = components[i].getGapCheckCriteria();
        gapCheckOverrideInd = components[i].getGapCheckOverrideInd();
        if (gapCheckInd !== null) {
            reqdObj += JSON.stringify(new this.MapObject(components[i].getReportMean(), gapCheckInd));
            if (gapCheckOverrideInd !== null) {
                overRideObj += JSON.stringify(new this.MapObject(components[i].getReportMean(), gapCheckOverrideInd));
            }
        }
    }
    capTimer.addMetaData("gapCheckDetails", reqdObj);
    capTimer.addMetaData("overrideDetails", overRideObj);
    capTimer.capture();
};


/**
 * Assorts all the details needed for the saving process
 * Creates two arrays add and update based on the update_flag
 * @param {Function} clickCallback : the function actuall intended to be called on the click event.
 * @returns {undefined} This function does not return a value
 */
GapCheck.prototype.addUpdateAuditEventsList = function (clickCallback) {
    try {
        var encounterId = this.m_criterion.encntr_id;
        var self = this;
        var cclParam = [];
        var scriptRequest = new ScriptRequest();

        scriptRequest.setArtifactInfo({
            artifactId: "gap-check",
            functionName: "addUpdateAuditEventsList"
        });

        var requestJSONStr = "";
        var eventsList = this.m_currentAuditEventsList;
        var indexCnt = eventsList.length;
        var index = 0;
        var timerAddUpdAuditEvents = null;
        self.m_auditEventsList = new self.AuditEventsRequestJSON();
        self.m_auditEventsList.encntr_id = encounterId;
        timerAddUpdAuditEvents = MP_Util.CreateTimer("ENG:MPG.GAP-CHECK-ADD UPDATE AUDIT EVENTS"); //eslint-disable-line new-cap
        for (index = 0; index < indexCnt; index++) {
            var eventListObj = eventsList[index].value;
            if (eventListObj.update_flag === 0) {
                var auditElementsObj = new self.NewAuditEventElementsJSON();
                auditElementsObj.audit_element_name = eventListObj.audit_element_name;
                auditElementsObj.audit_element_txt = eventListObj.audit_element_txt;
                auditElementsObj.audit_value = parseInt(eventListObj.audit_value, 10);
                auditElementsObj.audit_string = eventListObj.audit_string;
                auditElementsObj.audit_flag = eventListObj.audit_flag;
                self.m_auditEventsList.audit_elements.push(auditElementsObj);
            }
            else if (eventListObj.update_flag === 1) {
                var updAuditElementsObj = new self.UpdateAuditEventElementsJSON();
                updAuditElementsObj.tracking_audit_element_id = eventListObj.tracking_audit_element_id;
                updAuditElementsObj.audit_element_name = eventListObj.audit_element_name;
                updAuditElementsObj.audit_element_txt = eventListObj.audit_element_txt;
                updAuditElementsObj.audit_value = parseInt(eventListObj.audit_value, 10);
                updAuditElementsObj.audit_string = eventListObj.audit_string;
                updAuditElementsObj.audit_flag = eventListObj.audit_flag;
                self.m_auditEventsList.upd_audit_elements.push(updAuditElementsObj);
            }
        }
        requestJSONStr = "{'AUDIT_LIST_REQ':" + MP_Util.enhancedStringify(self.m_auditEventsList, 0, 0, 1, ["audit_value"]) + "}";
        cclParam.push("^MINE^", encounterId + ".0");
        scriptRequest.setParameterArray(cclParam);
        scriptRequest.setProgramName("MP_ADD_UPD_AUDIT_EVENTS");
        scriptRequest.setDataBlob(requestJSONStr);
        scriptRequest.setResponseHandler(function (scriptReply) {
            if (scriptReply.getStatus() === "S") {
                clickCallback();
            }
        });
        scriptRequest.performRequest();
    }
    catch (error) {
        logger.logJSError(error, null, "gap-check.js", "addUpdateAuditEventsList");
        if (timerAddUpdAuditEvents) {
            timerAddUpdAuditEvents.Abort(); //eslint-disable-line new-cap
            timerAddUpdAuditEvents = null;
        }
        throw error;
    }
    finally {
        if (timerAddUpdAuditEvents) {
            timerAddUpdAuditEvents.Stop(); //eslint-disable-line new-cap
        }
    }
};

/**
 * Creates a Map Object using key\value pair
 * @param {string} name unique identifier
 * @param {Object} value contains audit element information
 * @returns {undefined} This function does not return a value
 */
GapCheck.prototype.MapObject = function (name, value) {
    this.name = name;
    this.value = value;
};

/**
 * Retrieves the saved override reasons details from the service
 * @returns {undefined} This function does not return a value
 */
GapCheck.prototype.getAuditEventsList = function (callBack) {
    try {
        var encounterId = this.m_criterion.encntr_id;
        var cclParam = [];
        var self = this;
        var scriptRequest = new ScriptRequest();

        scriptRequest.setArtifactInfo({
            artifactId: "gap-check",
            functionName: "getAuditEventsList"
        });

        var x = 0;
        var timerGetAuditEvents = MP_Util.CreateTimer("ENG:MPG.GAP-CHECK-RETRIEVE AUDIT EVENTS DETAILS"); //eslint-disable-line new-cap
        cclParam.push("^MINE^", encounterId + ".0", !this.m_encntrTypeFlag);
        scriptRequest.setParameterArray(cclParam);
        scriptRequest.setProgramName("MP_RETRIEVE_AUDIT_EVENTS");
        scriptRequest.setResponseHandler(function (scriptReply) {
            if (scriptReply.getStatus() === "S" || scriptReply.getStatus() === "Z") {
                var auditDetailsReply = scriptReply.getResponse();
                var encounterReply = auditDetailsReply.ENCNTR_LIST;
                var encounterCount = encounterReply.length;
                if (!self.m_encntrTypeFlag) {
                    self.setEncounterType(auditDetailsReply.ENCNTR_TYPE);
                    self.m_encntrTypeFlag = 1;
                }
                self.m_currentAuditEventsList = [];
                if (encounterCount) {
                    var auditEventsReply = encounterReply[0].AUDIT_EVENTS;
                    var auditEventsCount = auditEventsReply.length;
                    if (auditEventsCount) {
                        for (x = 0; x < auditEventsCount; x++) {
                            var auditElementsReply = auditEventsReply[x].AUDIT_ELEMENTS;
                            var auditElementsCount = auditElementsReply.length;
                            var auditElemIndex = 0;
                            for (auditElemIndex = 0; auditElemIndex < auditElementsCount; auditElemIndex++) {
                                var auditElementObj = new self.AuditEventElementsJSON();
                                auditElementObj.tracking_audit_element_id = auditElementsReply[auditElemIndex].TRACKING_AUDIT_ELEMENT_ID;
                                auditElementObj.audit_element_name = auditElementsReply[auditElemIndex].AUDIT_ELEMENT_NAME;
                                auditElementObj.audit_element_txt = auditElementsReply[auditElemIndex].AUDIT_ELEMENT_TXT;
                                auditElementObj.audit_value = auditElementsReply[auditElemIndex].AUDIT_VALUE_DOUBLE;
                                auditElementObj.audit_string = auditElementsReply[auditElemIndex].AUDIT_STRING;
                                auditElementObj.audit_flag = auditElementsReply[auditElemIndex].AUDIT_FLAG;
                                auditElementObj.update_flag = 1;
                                var mapObj = new self.MapObject(auditElementObj.audit_element_name, auditElementObj);
                                self.m_currentAuditEventsList.push(mapObj);
                            }
                        }
                    }
                }

            }
            callBack();
        });
        scriptRequest.performRequest();
    }
    catch (error) {
        logger.logJSError(error, null, "gap-check.js", "getAuditEventsList"); //eslint-disable-line new-cap
        if (timerGetAuditEvents) {
            timerGetAuditEvents.Abort(); //eslint-disable-line new-cap
            timerGetAuditEvents = null;
        }
        throw error;
    }
    finally {
        if (timerGetAuditEvents) {
            timerGetAuditEvents.Stop(); //eslint-disable-line new-cap
        }
    }
};

/**
 * This function sets the override reason based on the value selected in the combo box.
 * @param {string} comboBoxId override reasons combobox id
 * @returns {undefined}  This function does not return a value
 */
GapCheck.prototype.handleComboboxSelection = function (comboBoxId) {
    var categoryMean = this.m_criterion.category_mean;
    var overrideDivObj = $("#overrideContainer" + categoryMean);
    var comboId = "#" + comboBoxId;
    var selectedValue = $(comboId).val();
    //remove the blank option and mandatory class , if the override reason is already set.
    if (selectedValue !== "-1") {
        $(comboId + " option[value='-1']").remove();
        $(comboId).removeClass("gc-none-option");
        var unselectedOverrideObj = overrideDivObj.find(".gc-none-option");
        if (!unselectedOverrideObj.length) {
            var saveModal = MP_ModalDialog.retrieveModalDialogObject("gapCheckOverrideDialog" + categoryMean);
            if (saveModal) {
                saveModal.setFooterButtonDither("saveOverrideModal" + categoryMean, false);
            }
        }
    }
};

/*eslint-disable complexity*/
/**
 * Returns all the components which need to be displayed in override window.
 * @param {Array} compArr contains an array of components
 * @param {Number} wfCriteria flag indicating what kind of workflow the action is intended to perform.
 * @returns {Array}componentsArr This function returns array of required components
 */
GapCheck.prototype.gatherComponentsToBeOverridden = function (compArr, wfCriteria) {
    var componentsCnt = compArr.length;
    var componentsArr = [];
    var component = null;
    var gapCheckCriteriaArr = [GapCheck.CRITERIA.ALL];
    var overrideIndArr = [GapCheck.CRITERIA.ALL];
    if (wfCriteria) {
        gapCheckCriteriaArr.push(GapCheck.CRITERIA.ADMIT);
        overrideIndArr.push(GapCheck.CRITERIA.ADMIT);
    }
    else {
        gapCheckCriteriaArr.push(GapCheck.CRITERIA.DISCHARGE);
        overrideIndArr.push(GapCheck.CRITERIA.DISCHARGE);
    }
    for (var x = componentsCnt - 1; x >= 0; x--) {
        component = compArr[x];
        if (!component.getSatisfiedInd() && gapCheckCriteriaArr.indexOf(component.getGapCheckCriteria()) !== -1 && overrideIndArr.indexOf(component.getGapCheckOverrideInd()) !== -1) {
            componentsArr.push(component);
        }
    }
    return componentsArr;
};
/*eslint-enable complexity*/

/**
 * This function adds the change Listener function to the combo box
 * @param {Array} overrideComps Array of components
 * @returns {undefined}  This function does not return a value
 */
GapCheck.prototype.attachListener = function (overrideComps) {
    var overrideCompLength = overrideComps.length;
    var self = this;
    var x;
    for (x = 0; x < overrideCompLength; x++) {
        var currComp = overrideComps[x];
        var currCompId = currComp.getComponentId();
        var comboboxObj = $("#overrideReason" + currCompId);
        var comboboxChangeHandler = function () {
            var comboboxId = $(this).attr("id");
            self.handleComboboxSelection(comboboxId);
        };
        comboboxObj.change(comboboxChangeHandler);
        comboboxObj.change();
    }
};

/**
 * This function creates the override reason combo box html based on the values returned from the code set 20318.
 * @param {float} compId : contains component Id.
 * @param {Array} overrideReasonArr :  holds the override reason information returned from the code set 20318.
 * @param {string} selectedValue : holds the information of the previously stored override reason value for specific component.
 * @returns {undefined}  This function does not return a value
 */
GapCheck.prototype.createOverrideReasonCombo = function (compId, overrideReasonArr, selectedValue) {
    var overRideReasonsCount = overrideReasonArr.length;
    var html = [];
    var index;
    html.push("<select id='overrideReason" + compId + "' data-lookup='" + compId + "' class='gc-select gc-none-option'><option value='-1'></option>");
    for (index = 0; index < overRideReasonsCount; index++) {
        var overrideReasonObj = overrideReasonArr[index];
        var optionName = overrideReasonObj.name;
        var selectedInfo = (selectedValue === optionName) ? "selected=selected" : "";
        html.push("<option value='" + optionName + "' " + selectedInfo + ">" + overrideReasonObj.value.display + "</option>");
    }
    html.push("</select>");
    return html.join("");
};

/**
 * This function updates the m_currentAuditEventsList with the latest override reason value,selected in the combo box.
 * @returns {undefined}  This function does not return a value
 */
GapCheck.prototype.updateAuditEventDetails = function () {
    var auditEventsList = this.m_currentAuditEventsList;
    var auditEventsCount = auditEventsList.length;
    var selectValue = null;
    var currVal = null;
    var index = 0;
    var compId = "";
    for (index = 0; index < auditEventsCount; index++) {
        compId = auditEventsList[index].value.component_Id;
        selectValue = $("#overrideReason" + compId).val();
        currVal = this.m_currentAuditEventsList[index].value;
        //Update the value only if the reason is changed
        if (selectValue && currVal.audit_value !== selectValue) {
            currVal.audit_value = selectValue;
        }
    }
};

/**
 * Retrieves the synonyms mapped in bedrock page level filter for gap-check.
 * @returns {Array} synonymArr - An array of mapped filters.
 */
GapCheck.prototype.getMappedOrderSynonyms = function () {
    var index = null;
    var filterObj = null;
    var filterObjVals = [];
    var synonymArr = [];
    var resourceName = this.m_criterion.category_mean + "pageLevelFilters";
    var pageLevelFilters = MP_Resources.getSharedResource(resourceName); //eslint-disable-line new-cap
    if (pageLevelFilters && pageLevelFilters.isResourceAvailable()) {
        var plFilters = pageLevelFilters.getResourceData();
        if (plFilters) {
            var plFiltersLen = plFilters.length;
            for (index = 0; index < plFiltersLen; index++) {
                filterObj = plFilters[index];
                if (filterObj.F_MN === "WF_GC_ADMT_ORDER") {
                    filterObjVals = filterObj.VALS;
                    break;
                }
            }
            for (index = 0; index < filterObjVals.length; index++) {
                synonymArr[index] = filterObjVals[index].PE_ID + ".0";
            }
        }
    }
    this.m_synonymArr = synonymArr;
    return synonymArr;
};

/**
 * Makes a call to MP_CHECK_FOR_ADMT_ORDER script and fires corresponding event upon successful completion of * call.
 * If call failed, it logs error.
 * @param {object} e: The event that triggers the function
 * @param {boolean} gapCheckInitialized: Flag for detecting soft refresh
 * @returns {undefined} This function does not return a value.
 */
GapCheck.prototype.checkForOrder = function (e, gapCheckInitialized) {
    var self = this;
    var sendAr = ["^MINE^", this.m_criterion.encntr_id + ".0"];
    var dataBlob = {
        synArr: this.m_synonymArr
    };
    gapCheckInitialized = gapCheckInitialized || false;
    var scriptRequest = new ScriptRequest();

    scriptRequest.setArtifactInfo({
        artifactId: "gap-check",
        functionName: "checkForOrder"
    });

    scriptRequest.setProgramName("MP_CHECK_FOR_ADMT_ORDER");
    scriptRequest.setParameterArray(sendAr);
    scriptRequest.setDataBlob("{'REQ':" + MP_Util.enhancedStringify(dataBlob) + "}");
    scriptRequest.setResponseHandler(function (scriptReply) {
        if (scriptReply.getStatus() === "S") {
            var response = scriptReply.getResponse();
            self.fireAdmitOrderEvent(gapCheckInitialized, response.ISPLACED);
        }
        else {
            logger.logScriptCallError(self, scriptRequest, "gap-check.js", "checkForOrder");
        }
    });
    scriptRequest.performRequest();
};

/**
 * Fires the order event that will enable the subsections and flexes gap-check
 * @param {boolean} gapCheckInitialized: Flag for detecting soft refresh
 * @param {Number} isOrderPlaced: Flag representing if required admit order is placed or not.
 * @returns {undefined} This function does not return a value.
 */
GapCheck.prototype.fireAdmitOrderEvent = function (gapCheckInitialized, isOrderPlaced) {
    if (this.m_isOrderPlaced !== isOrderPlaced || gapCheckInitialized) {
        this.m_isOrderPlaced = isOrderPlaced;
        CERN_EventListener.fireEvent(this, this, EventListener.EVENT_ADMT_ORDER_PLACED + this.m_criterion.category_mean, this.m_isOrderPlaced);
    }
};
/**
 * This function checks for the components that are not satisfied and provides a provision to add the
 * override reason for the components that required override.
 * @param {Array} componentsList : Holds the array of components added to a particular view.
 * @param {Number} wfCriteria flag indicating what kind of workflow the action is intended to perform.
 * @param {function} clickCallback : the function actually intended to be called on the click event.
 * @returns {undefined}  This function does not return a value.
 */
GapCheck.prototype.performGapCheck = function (componentsList, wfCriteria, clickCallback) {
    var self = this;
    var overrideComponents = [];
    var overrideCompLength = 0;
    var capTimer = new CapabilityTimer("CAP:MPG.GAPCHECK-Render Override Reasons", this.m_criterion.category_mean);
    //Gather all the required Components
    overrideComponents = this.gatherComponentsToBeOverridden(componentsList, wfCriteria);
    overrideCompLength = overrideComponents.length;
    if (overrideCompLength > 0) {
        //Order the components by the comp_seq so we know before they are rendered what order they will be in
        overrideComponents.sort(function (a, b) {
            var aSeq = a.getSequence();
            var bSeq = b.getSequence();
            if (aSeq < bSeq) {
                return -1;
            }
            //No two sequences will be the same so we already know bSeq > aSeq at this point.
            return 1;
        });
        this.getAuditEventsList(function () {
            self.createOverrideDialog(overrideComponents, wfCriteria, clickCallback);
            capTimer.addMetaData("gapcheck.workflow.deviation", wfCriteria === self.m_isOrderPlaced);
            capTimer.capture();
        });
    }
    else {
        clickCallback();
    }
};

/**
 * Creates the override dialog and attaches all events for the dialog and its elements.
 * @param {Array} overrideComponents : Holds the array of components to be overridden.
 * @param {Number} wfCriteria flag indicating what kind of workflow the action is intended to perform.
 * @param {function} clickCallback : the function actually intended to be called on the click event.
 * @returns {undefined}  This function does not return a value.
 */
GapCheck.prototype.createOverrideDialog = function (overrideComponents, wfCriteria, clickCallback) {
    var self = this;
    return MP_Util.GetCodeSetP(20318).then(function (overRideReasons) { //eslint-disable-line new-cap
        var categoryMean = self.m_criterion.category_mean;
        var saveModal = MP_ModalDialog.retrieveModalDialogObject("gapCheckOverrideDialog" + categoryMean);
        var submitButtonId = "saveOverrideModal" + categoryMean;
        var saveModalBtn = null;
        var cancelModalBtn = null;
        var gapChecki18n = i18n.discernabu.gap_check;
        var overrideCompLength = overrideComponents.length;
        if (saveModal) {
            saveModalBtn = saveModal.getFooterButton(submitButtonId);
            saveModal.setFooterButtonDither(submitButtonId, true);
        }
        else {
            saveModal = new ModalDialog("gapCheckOverrideDialog" + categoryMean).setLeftMarginPercentage(35).setTopMarginPercentage(20).setRightMarginPercentage(35).
                setIsBodySizeFixed(false).setIsFooterAlwaysShown(true);
            saveModal.setShowCloseIcon(true);

            //Create the modal save button
            saveModalBtn = new ModalButton(submitButtonId);
            saveModalBtn.setFocusInd(true).setCloseOnClick(true).setText(gapChecki18n.SUBMIT);
            saveModalBtn.setIsDithered(true);
            saveModal.addFooterButton(saveModalBtn);

            //Create the modal cancel button
            cancelModalBtn = new ModalButton("cancelOverrideModal" + categoryMean);
            cancelModalBtn.setText(gapChecki18n.CANCEL);
            saveModal.addFooterButton(cancelModalBtn);
        }
        saveModalBtn.setOnClickFunction(function () {
            //update m_currentAuditEventsList with latest values selected
            self.updateAuditEventDetails();
            //save the Override reasons information
            self.addUpdateAuditEventsList(clickCallback);
        });
        saveModal.setBodyDataFunction(function (modalObj) {
            var dialogBodyHtml = [];
            var encounterType = self.getEncounterType();
            var dialogHeader = gapChecki18n.DISCHARGE_HEADER;
            if (encounterType === 2) {
                dialogHeader = gapChecki18n.AMBULATORY_HEADER;
            }
            var alertbannerHTML = self.createWarningBanner(wfCriteria);
            saveModal.setHeaderTitle(dialogHeader);
            dialogBodyHtml.push(alertbannerHTML + "<div class='gc-override-container'><div class='gc-override-note'>" + gapChecki18n.TITLE + "</div><div class='gc-override-subtitle'>" + gapChecki18n.SUB_TITLE + "</div><div class='gc-override-content' id='overrideContainer" + categoryMean + "'>");
            var currAuditEventList = self.m_currentAuditEventsList;
            for (var i = 0; i < overrideCompLength; i++) {
                var currComp = overrideComponents[i];
                var currCompId = currComp.getComponentId();
                var currCompReportMean = currComp.getReportMean();
                var found = false;
                var selectedValue = "";
                for (var x = 0; x < currAuditEventList.length; x++) {
                    if (currAuditEventList[x].name === currCompReportMean) {
                        found = true;
                        selectedValue = currAuditEventList[x].value.audit_value;
                        self.m_currentAuditEventsList[x].value.component_Id = currCompId;
                        self.m_currentAuditEventsList[x].value.update_flag = 1;
                        break;
                    }
                }
                if (!found) {
                    var auditElementObj = new self.AuditEventElementsJSON();
                    auditElementObj.audit_element_name = currCompReportMean;
                    auditElementObj.component_Id = currCompId;
                    auditElementObj.update_flag = 0;
                    var mapObj = new self.MapObject(currCompReportMean, auditElementObj);
                    self.m_currentAuditEventsList.push(mapObj);
                }
                dialogBodyHtml.push("<dl class='gc-override-comp'><dt id='overrideCompInfo-" + currCompId + "'><span class='gc-required-field-label'>*</span>" + currComp.getLabel() + "</dt>");
                dialogBodyHtml.push("<dd>" + self.createOverrideReasonCombo(currCompId, MP_Util.LoadCodeListJSON(overRideReasons), selectedValue) + "</dd></dl>"); //eslint-disable-line new-cap
            }
            dialogBodyHtml.push("</div>");
            modalObj.setBodyHTML(dialogBodyHtml.join(""));
        });
        //Create/launch Modal Dialog Box
        MP_ModalDialog.updateModalDialogObject(saveModal);
        MP_ModalDialog.showModalDialog("gapCheckOverrideDialog" + categoryMean);
        $("#gapCheckOverrideDialog" + categoryMean + "body").css("margin", "0");
        $("#gapCheckOverrideDialog" + categoryMean + "body .alert-msg").css("padding", "0");
        $("#gapCheckOverrideDialog" + categoryMean + "body .warning-msg").css("font-weight", "normal");
        self.attachListener(overrideComponents);
    }).catch(function (error) {
        logger.logJSError(error, null, "gap-check.js", "createOverrideDialog");
    });
};
/**
 * Creates the warning banner that will be displayed in the override window, when user clicks on a link in the end-visit section which is possibly not intended given the current workflow.
 * @param {Number} wfCriteria flag indicating what kind of workflow the action is intended to perform.
 * @returns {Object}  The alert banner object. Returns empty string if the link clicked corresponds to the
 * workflow being followed.
 */
GapCheck.prototype.createWarningBanner = function (wfCriteria) {
    if (this.m_isOrderPlaced !== wfCriteria) {
        var gapChecki18n = i18n.discernabu.gap_check;
        var alertBanner = new MPageUI.AlertBanner();	//eslint-disable-line no-undef
        alertBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.WARNING);	//eslint-disable-line no-undef
        var primaryText = this.m_isOrderPlaced ? gapChecki18n.ORDER_FOUND_WARNING : gapChecki18n.NO_ORDER_FOUND_WARNING;
        alertBanner.setPrimaryText(primaryText);
        return alertBanner.render();
    }
    else {
        return "";
    }
};
/* eslint no-unused-expressions: 0, no-shadow: 0, key-spacing: 0, yoda: 0, semi: 0, no-nested-ternary: 0, no-unused-vars:0, eqeqeq: 0, new-cap: 0, no-sequences: 0, no-return-assign: 0, no-undef: 0, eol-last: 0 */
/**
MIT License 

Copyright (c) 2012 Jon Nylander, project maintained at 
https://bitbucket.org/pellepim/jstimezonedetect

Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to 
do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE.
*/
/* jstz.min.js Version: 1.0.5 Build date: 2014-10-28 */
!function (e) {
	var a = function () {
		"use strict";
		var e = "s",
		s = {
			DAY : 864e5,
			HOUR : 36e5,
			MINUTE : 6e4,
			SECOND : 1e3,
			BASELINE_YEAR : 2014,
			MAX_SCORE : 864e6,
			AMBIGUITIES : {
				"America/Denver" : ["America/Mazatlan"],
				"America/Chicago" : ["America/Mexico_City"],
				"America/Santiago" : ["America/Asuncion", "America/Campo_Grande"],
				"America/Montevideo" : ["America/Sao_Paulo"],
				"Asia/Beirut" : ["Asia/Amman", "Asia/Jerusalem", "Europe/Helsinki", "Asia/Damascus", "Africa/Cairo", "Asia/Gaza", "Europe/Minsk"],
				"Pacific/Auckland" : ["Pacific/Fiji"],
				"America/Los_Angeles" : ["America/Santa_Isabel"],
				"America/New_York" : ["America/Havana"],
				"America/Halifax" : ["America/Goose_Bay"],
				"America/Godthab" : ["America/Miquelon"],
				"Asia/Dubai" : ["Asia/Yerevan"],
				"Asia/Jakarta" : ["Asia/Krasnoyarsk"],
				"Asia/Shanghai" : ["Asia/Irkutsk", "Australia/Perth"],
				"Australia/Sydney" : ["Australia/Lord_Howe"],
				"Asia/Tokyo" : ["Asia/Yakutsk"],
				"Asia/Dhaka" : ["Asia/Omsk"],
				"Asia/Baku" : ["Asia/Yerevan"],
				"Australia/Brisbane" : ["Asia/Vladivostok"],
				"Pacific/Noumea" : ["Asia/Vladivostok"],
				"Pacific/Majuro" : ["Asia/Kamchatka", "Pacific/Fiji"],
				"Pacific/Tongatapu" : ["Pacific/Apia"],
				"Asia/Baghdad" : ["Europe/Minsk", "Europe/Moscow"],
				"Asia/Karachi" : ["Asia/Yekaterinburg"],
				"Africa/Johannesburg" : ["Asia/Gaza", "Africa/Cairo"]
			}
		},
		i = function (e) {
			var a = -e.getTimezoneOffset();
			return null !== a ? a : 0
		},
		r = function () {
			var a = i(new Date(s.BASELINE_YEAR, 0, 2)),
			r = i(new Date(s.BASELINE_YEAR, 5, 2)),
			n = a - r;
			return 0 > n ? a + ",1" : n > 0 ? r + ",1," + e : a + ",0"
		},
		n = function () {
			if ("undefined" != typeof Intl && "undefined" != typeof Intl.DateTimeFormat) {
				var e = Intl.DateTimeFormat();
				if ("undefined" != typeof e && "undefined" != typeof e.resolvedOptions)
					return e.resolvedOptions().timeZone
			}
		},
		o = function (e) {
			for (var a = new Date(e, 0, 1, 0, 0, 1, 0).getTime(), s = new Date(e, 12, 31, 23, 59, 59).getTime(), i = a, r = new Date(i).getTimezoneOffset(), n = null, o = null; s - 864e5 > i; ) {
				var A = new Date(i),
				u = A.getTimezoneOffset();
				u !== r && (r > u && (n = A), u > r && (o = A), r = u),
				i += 864e5
			}
			return n && o ? {
				s : t(n).getTime(),
				e : t(o).getTime()
			}
			 : !1
		},
		t = function l(e, a, i) {
			"undefined" == typeof a && (a = s.DAY, i = s.HOUR);
			for (var r = new Date(e.getTime() - a).getTime(), n = e.getTime() + a, o = new Date(r).getTimezoneOffset(), t = r, A = null; n - i > t; ) {
				var u = new Date(t),
				c = u.getTimezoneOffset();
				if (c !== o) {
					A = u;
					break
				}
				t += i
			}
			return a === s.DAY ? l(A, s.HOUR, s.MINUTE) : a === s.HOUR ? l(A, s.MINUTE, s.SECOND) : A
		},
		A = function (e, a, s, i) {
			if ("N/A" !== s)
				return s;
			if ("Asia/Beirut" === a) {
				if ("Africa/Cairo" === i.name && 13983768e5 === e[6].s && 14116788e5 === e[6].e)
					return 0;
				if ("Asia/Jerusalem" === i.name && 13959648e5 === e[6].s && 14118588e5 === e[6].e)
					return 0
			} else if ("America/Santiago" === a) {
				if ("America/Asuncion" === i.name && 14124816e5 === e[6].s && 1397358e6 === e[6].e)
					return 0;
				if ("America/Campo_Grande" === i.name && 14136912e5 === e[6].s && 13925196e5 === e[6].e)
					return 0
			} else if ("America/Montevideo" === a) {
				if ("America/Sao_Paulo" === i.name && 14136876e5 === e[6].s && 1392516e6 === e[6].e)
					return 0
			} else if ("Pacific/Auckland" === a && "Pacific/Fiji" === i.name && 14142456e5 === e[6].s && 13961016e5 === e[6].e)
				return 0;
			return s
		},
		u = function (e, i) {
			for (var r = function (a) {
				for (var r = 0, n = 0; n < e.length; n++)
					if (a.rules[n] && e[n]) {
						if (!(e[n].s >= a.rules[n].s && e[n].e <= a.rules[n].e)) {
							r = "N/A";
							break
						}
						if (r = 0, r += Math.abs(e[n].s - a.rules[n].s), r += Math.abs(a.rules[n].e - e[n].e), r > s.MAX_SCORE) {
							r = "N/A";
							break
						}
					}
				return r = A(e, i, r, a)
			}, n = {}, o = a.olson.dst_rules.zones, t = o.length, u = s.AMBIGUITIES[i], c = 0; t > c; c++) {
				var m = o[c],
				l = r(o[c]);
				"N/A" !== l && (n[m.name] = l)
			}
			for (var f in n)
				if (n.hasOwnProperty(f) && -1 != u.indexOf(f))
					return f;
			return i
		},
		c = function (e) {
			var s = function () {
				for (var e = [], s = 0; s < a.olson.dst_rules.years.length; s++) {
					var i = o(a.olson.dst_rules.years[s]);
					e.push(i)
				}
				return e
			},
			i = function (e) {
				for (var a = 0; a < e.length; a++)
					if (e[a] !== !1)
						return !0;
				return !1
			},
			r = s(),
			n = i(r);
			return n ? u(r, e) : e
		},
		m = function () {
			var e = null;
			return e || (e = a.olson.timezones[r()], "undefined" != typeof s.AMBIGUITIES[e] && (e = c(e))), {
				name : function () {
					return e
				}
			}
		};
		return {
			determine : m
		}
	}
	();
	a.olson = a.olson || {},
	a.olson.timezones = {
		"-720,0" : "Etc/GMT+12",
		"-660,0" : "Pacific/Pago_Pago",
		"-660,1,s" : "Pacific/Apia",
		"-600,1" : "America/Adak",
		"-600,0" : "Pacific/Honolulu",
		"-570,0" : "Pacific/Marquesas",
		"-540,0" : "Pacific/Gambier",
		"-540,1" : "America/Anchorage",
		"-480,1" : "America/Los_Angeles",
		"-480,0" : "Pacific/Pitcairn",
		"-420,0" : "America/Phoenix",
		"-420,1" : "America/Denver",
		"-360,0" : "America/Guatemala",
		"-360,1" : "America/Chicago",
		"-360,1,s" : "Pacific/Easter",
		"-300,0" : "America/Bogota",
		"-300,1" : "America/New_York",
		"-270,0" : "America/Caracas",
		"-240,1" : "America/Halifax",
		"-240,0" : "America/Santo_Domingo",
		"-240,1,s" : "America/Santiago",
		"-210,1" : "America/St_Johns",
		"-180,1" : "America/Godthab",
		"-180,0" : "America/Argentina/Buenos_Aires",
		"-180,1,s" : "America/Montevideo",
		"-120,0" : "America/Noronha",
		"-120,1" : "America/Noronha",
		"-60,1" : "Atlantic/Azores",
		"-60,0" : "Atlantic/Cape_Verde",
		"0,0" : "UTC",
		"0,1" : "Europe/London",
		"60,1" : "Europe/Berlin",
		"60,0" : "Africa/Lagos",
		"60,1,s" : "Africa/Windhoek",
		"120,1" : "Asia/Beirut",
		"120,0" : "Africa/Johannesburg",
		"180,0" : "Asia/Baghdad",
		"180,1" : "Europe/Moscow",
		"210,1" : "Asia/Tehran",
		"240,0" : "Asia/Dubai",
		"240,1" : "Asia/Baku",
		"270,0" : "Asia/Kabul",
		"300,1" : "Asia/Yekaterinburg",
		"300,0" : "Asia/Karachi",
		"330,0" : "Asia/Kolkata",
		"345,0" : "Asia/Kathmandu",
		"360,0" : "Asia/Dhaka",
		"360,1" : "Asia/Omsk",
		"390,0" : "Asia/Rangoon",
		"420,1" : "Asia/Krasnoyarsk",
		"420,0" : "Asia/Jakarta",
		"480,0" : "Asia/Shanghai",
		"480,1" : "Asia/Irkutsk",
		"525,0" : "Australia/Eucla",
		"525,1,s" : "Australia/Eucla",
		"540,1" : "Asia/Yakutsk",
		"540,0" : "Asia/Tokyo",
		"570,0" : "Australia/Darwin",
		"570,1,s" : "Australia/Adelaide",
		"600,0" : "Australia/Brisbane",
		"600,1" : "Asia/Vladivostok",
		"600,1,s" : "Australia/Sydney",
		"630,1,s" : "Australia/Lord_Howe",
		"660,1" : "Asia/Kamchatka",
		"660,0" : "Pacific/Noumea",
		"690,0" : "Pacific/Norfolk",
		"720,1,s" : "Pacific/Auckland",
		"720,0" : "Pacific/Majuro",
		"765,1,s" : "Pacific/Chatham",
		"780,0" : "Pacific/Tongatapu",
		"780,1,s" : "Pacific/Apia",
		"840,0" : "Pacific/Kiritimati"
	},
	a.olson.dst_rules = {
		years : [2008, 2009, 2010, 2011, 2012, 2013, 2014],
		zones : [{
				name : "Africa/Cairo",
				rules : [{
						e : 12199572e5,
						s : 12090744e5
					}, {
						e : 1250802e6,
						s : 1240524e6
					}, {
						e : 12858804e5,
						s : 12840696e5
					}, !1, !1, !1, {
						e : 14116788e5,
						s : 1406844e6
					}
				]
			}, {
				name : "America/Asuncion",
				rules : [{
						e : 12050316e5,
						s : 12243888e5
					}, {
						e : 12364812e5,
						s : 12558384e5
					}, {
						e : 12709548e5,
						s : 12860784e5
					}, {
						e : 13024044e5,
						s : 1317528e6
					}, {
						e : 1333854e6,
						s : 13495824e5
					}, {
						e : 1364094e6,
						s : 1381032e6
					}, {
						e : 13955436e5,
						s : 14124816e5
					}
				]
			}, {
				name : "America/Campo_Grande",
				rules : [{
						e : 12032172e5,
						s : 12243888e5
					}, {
						e : 12346668e5,
						s : 12558384e5
					}, {
						e : 12667212e5,
						s : 1287288e6
					}, {
						e : 12981708e5,
						s : 13187376e5
					}, {
						e : 13302252e5,
						s : 1350792e6
					}, {
						e : 136107e7,
						s : 13822416e5
					}, {
						e : 13925196e5,
						s : 14136912e5
					}
				]
			}, {
				name : "America/Goose_Bay",
				rules : [{
						e : 122559486e4,
						s : 120503526e4
					}, {
						e : 125704446e4,
						s : 123648486e4
					}, {
						e : 128909886e4,
						s : 126853926e4
					}, {
						e : 13205556e5,
						s : 129998886e4
					}, {
						e : 13520052e5,
						s : 13314456e5
					}, {
						e : 13834548e5,
						s : 13628952e5
					}, {
						e : 14149044e5,
						s : 13943448e5
					}
				]
			}, {
				name : "America/Havana",
				rules : [{
						e : 12249972e5,
						s : 12056436e5
					}, {
						e : 12564468e5,
						s : 12364884e5
					}, {
						e : 12885012e5,
						s : 12685428e5
					}, {
						e : 13211604e5,
						s : 13005972e5
					}, {
						e : 13520052e5,
						s : 13332564e5
					}, {
						e : 13834548e5,
						s : 13628916e5
					}, {
						e : 14149044e5,
						s : 13943412e5
					}
				]
			}, {
				name : "America/Mazatlan",
				rules : [{
						e : 1225008e6,
						s : 12074724e5
					}, {
						e : 12564576e5,
						s : 1238922e6
					}, {
						e : 1288512e6,
						s : 12703716e5
					}, {
						e : 13199616e5,
						s : 13018212e5
					}, {
						e : 13514112e5,
						s : 13332708e5
					}, {
						e : 13828608e5,
						s : 13653252e5
					}, {
						e : 14143104e5,
						s : 13967748e5
					}
				]
			}, {
				name : "America/Mexico_City",
				rules : [{
						e : 12250044e5,
						s : 12074688e5
					}, {
						e : 1256454e6,
						s : 12389184e5
					}, {
						e : 12885084e5,
						s : 1270368e6
					}, {
						e : 1319958e6,
						s : 13018176e5
					}, {
						e : 13514076e5,
						s : 13332672e5
					}, {
						e : 13828572e5,
						s : 13653216e5
					}, {
						e : 14143068e5,
						s : 13967712e5
					}
				]
			}, {
				name : "America/Miquelon",
				rules : [{
						e : 12255984e5,
						s : 12050388e5
					}, {
						e : 1257048e6,
						s : 12364884e5
					}, {
						e : 12891024e5,
						s : 12685428e5
					}, {
						e : 1320552e6,
						s : 12999924e5
					}, {
						e : 13520016e5,
						s : 1331442e6
					}, {
						e : 13834512e5,
						s : 13628916e5
					}, {
						e : 14149008e5,
						s : 13943412e5
					}
				]
			}, {
				name : "America/Santa_Isabel",
				rules : [{
						e : 12250116e5,
						s : 1207476e6
					}, {
						e : 12564612e5,
						s : 12389256e5
					}, {
						e : 12885156e5,
						s : 12703752e5
					}, {
						e : 13199652e5,
						s : 13018248e5
					}, {
						e : 13514148e5,
						s : 13332744e5
					}, {
						e : 13828644e5,
						s : 13653288e5
					}, {
						e : 1414314e6,
						s : 13967784e5
					}
				]
			}, {
				name : "America/Sao_Paulo",
				rules : [{
						e : 12032136e5,
						s : 12243852e5
					}, {
						e : 12346632e5,
						s : 12558348e5
					}, {
						e : 12667176e5,
						s : 12872844e5
					}, {
						e : 12981672e5,
						s : 1318734e6
					}, {
						e : 13302216e5,
						s : 13507884e5
					}, {
						e : 13610664e5,
						s : 1382238e6
					}, {
						e : 1392516e6,
						s : 14136876e5
					}
				]
			}, {
				name : "Asia/Amman",
				rules : [{
						e : 1225404e6,
						s : 12066552e5
					}, {
						e : 12568536e5,
						s : 12381048e5
					}, {
						e : 12883032e5,
						s : 12695544e5
					}, {
						e : 13197528e5,
						s : 13016088e5
					}, !1, !1, {
						e : 14147064e5,
						s : 13959576e5
					}
				]
			}, {
				name : "Asia/Damascus",
				rules : [{
						e : 12254868e5,
						s : 120726e7
					}, {
						e : 125685e7,
						s : 12381048e5
					}, {
						e : 12882996e5,
						s : 12701592e5
					}, {
						e : 13197492e5,
						s : 13016088e5
					}, {
						e : 13511988e5,
						s : 13330584e5
					}, {
						e : 13826484e5,
						s : 1364508e6
					}, {
						e : 14147028e5,
						s : 13959576e5
					}
				]
			}, {
				name : "Asia/Dubai",
				rules : [!1, !1, !1, !1, !1, !1, !1]
			}, {
				name : "Asia/Gaza",
				rules : [{
						e : 12199572e5,
						s : 12066552e5
					}, {
						e : 12520152e5,
						s : 12381048e5
					}, {
						e : 1281474e6,
						s : 126964086e4
					}, {
						e : 1312146e6,
						s : 130160886e4
					}, {
						e : 13481784e5,
						s : 13330584e5
					}, {
						e : 13802292e5,
						s : 1364508e6
					}, {
						e : 14116788e5,
						s : 13959576e5
					}
				]
			}, {
				name : "Asia/Irkutsk",
				rules : [{
						e : 12249576e5,
						s : 12068136e5
					}, {
						e : 12564072e5,
						s : 12382632e5
					}, {
						e : 12884616e5,
						s : 12697128e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Jerusalem",
				rules : [{
						e : 12231612e5,
						s : 12066624e5
					}, {
						e : 1254006e6,
						s : 1238112e6
					}, {
						e : 1284246e6,
						s : 12695616e5
					}, {
						e : 131751e7,
						s : 1301616e6
					}, {
						e : 13483548e5,
						s : 13330656e5
					}, {
						e : 13828284e5,
						s : 13645152e5
					}, {
						e : 1414278e6,
						s : 13959648e5
					}
				]
			}, {
				name : "Asia/Kamchatka",
				rules : [{
						e : 12249432e5,
						s : 12067992e5
					}, {
						e : 12563928e5,
						s : 12382488e5
					}, {
						e : 12884508e5,
						s : 12696984e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Krasnoyarsk",
				rules : [{
						e : 12249612e5,
						s : 12068172e5
					}, {
						e : 12564108e5,
						s : 12382668e5
					}, {
						e : 12884652e5,
						s : 12697164e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Omsk",
				rules : [{
						e : 12249648e5,
						s : 12068208e5
					}, {
						e : 12564144e5,
						s : 12382704e5
					}, {
						e : 12884688e5,
						s : 126972e7
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Vladivostok",
				rules : [{
						e : 12249504e5,
						s : 12068064e5
					}, {
						e : 12564e8,
						s : 1238256e6
					}, {
						e : 12884544e5,
						s : 12697056e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Yakutsk",
				rules : [{
						e : 1224954e6,
						s : 120681e7
					}, {
						e : 12564036e5,
						s : 12382596e5
					}, {
						e : 1288458e6,
						s : 12697092e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Yekaterinburg",
				rules : [{
						e : 12249684e5,
						s : 12068244e5
					}, {
						e : 1256418e6,
						s : 1238274e6
					}, {
						e : 12884724e5,
						s : 12697236e5
					}, !1, !1, !1, !1]
			}, {
				name : "Asia/Yerevan",
				rules : [{
						e : 1224972e6,
						s : 1206828e6
					}, {
						e : 12564216e5,
						s : 12382776e5
					}, {
						e : 1288476e6,
						s : 12697272e5
					}, {
						e : 13199256e5,
						s : 13011768e5
					}, !1, !1, !1]
			}, {
				name : "Australia/Lord_Howe",
				rules : [{
						e : 12074076e5,
						s : 12231342e5
					}, {
						e : 12388572e5,
						s : 12545838e5
					}, {
						e : 12703068e5,
						s : 12860334e5
					}, {
						e : 13017564e5,
						s : 1317483e6
					}, {
						e : 1333206e6,
						s : 13495374e5
					}, {
						e : 13652604e5,
						s : 1380987e6
					}, {
						e : 139671e7,
						s : 14124366e5
					}
				]
			}, {
				name : "Australia/Perth",
				rules : [{
						e : 12068136e5,
						s : 12249576e5
					}, !1, !1, !1, !1, !1, !1]
			}, {
				name : "Europe/Helsinki",
				rules : [{
						e : 12249828e5,
						s : 12068388e5
					}, {
						e : 12564324e5,
						s : 12382884e5
					}, {
						e : 12884868e5,
						s : 1269738e6
					}, {
						e : 13199364e5,
						s : 13011876e5
					}, {
						e : 1351386e6,
						s : 13326372e5
					}, {
						e : 13828356e5,
						s : 13646916e5
					}, {
						e : 14142852e5,
						s : 13961412e5
					}
				]
			}, {
				name : "Europe/Minsk",
				rules : [{
						e : 12249792e5,
						s : 12068352e5
					}, {
						e : 12564288e5,
						s : 12382848e5
					}, {
						e : 12884832e5,
						s : 12697344e5
					}, !1, !1, !1, !1]
			}, {
				name : "Europe/Moscow",
				rules : [{
						e : 12249756e5,
						s : 12068316e5
					}, {
						e : 12564252e5,
						s : 12382812e5
					}, {
						e : 12884796e5,
						s : 12697308e5
					}, !1, !1, !1, !1]
			}, {
				name : "Pacific/Apia",
				rules : [!1, !1, !1, {
						e : 13017528e5,
						s : 13168728e5
					}, {
						e : 13332024e5,
						s : 13489272e5
					}, {
						e : 13652568e5,
						s : 13803768e5
					}, {
						e : 13967064e5,
						s : 14118264e5
					}
				]
			}, {
				name : "Pacific/Fiji",
				rules : [!1, !1, {
						e : 12696984e5,
						s : 12878424e5
					}, {
						e : 13271544e5,
						s : 1319292e6
					}, {
						e : 1358604e6,
						s : 13507416e5
					}, {
						e : 139005e7,
						s : 1382796e6
					}, {
						e : 14215032e5,
						s : 14148504e5
					}
				]
			}
		]
	},
	"undefined" != typeof exports ? exports.jstz = a : e.jstz = a
}
(this);
/*global logger, MP_Viewpoint*/

/**
 * A collection of functions which can be used to maintain, create, destroy and update modal dialogs.
 * The MP_ModalDialog function keeps a copy of all of the ModalDialog objects that have been created
 * for the current view.  If a ModalDialog object is updated outside of these functions, the updated
 * version of the object should replace the stale version that is stored here by using the
 * updateModalDialogObject functionality.
 * @namespace
 */
var MP_ModalDialog = {}; //eslint-disable-line no-redeclare
MP_ModalDialog.modalDialogObjects = {};
MP_ModalDialog.whiteSpacePixels = 26;

/**
 * This function will be used to add ModalDialog objects to the collection of ModalDialog objects for the current
 * View.  This list of ModalDialog objects will be the one source of this type of object and will be used when
 * showing modal dialogs.
 * @param {ModalDialog} modalObject An instance of the ModalDialog object
 * @return [boolean] true if the ModalDialog object was added successfully, false otherwise.
 */
MP_ModalDialog.addModalDialogObject = function (modalObject) {
	var modalId = "";
	//Check that he object is not null and that the object type is ModalDialog
	if (!(modalObject instanceof ModalDialog)) {
		logger.logError("MP_ModalDialog.addModalDialogObject only accepts objects of type ModalDialog");
		return false;
	}

	//Check for a valid id.
	modalId = modalObject.getId();
	if (!modalId) {
		//Modal id is not populated
		logger.logError("MP_ModalDialog.addModalDialogObject: no/invalid ModalDialog id given");
		return false;
	}
	else if(this.modalDialogObjects[modalId]) {
		//Modal id is already in use
		logger.logError("MP_ModalDialog.addModalDialogObject: modal dialog id " + modalId + " is already in use");
		return false;
	}

	//Add the ModalDialog Object to the list of ModalDialog objects
	this.modalDialogObjects[modalId] = modalObject;
	return true;
};

/**
 * Add the modal dialog icon to the viewpoint framework.  This icon will be responsible for
 * launching the correct modal dialog based on the ModalDialog object that it is associated to.
 * @param {string} modalDialogId The id of the ModalDialog object to reference when creating the modal dialog icon
 * @param {jQuery|HTMLElement}  iconElement The element to allow launching of the modal dialog on click.  If not passed, an icon element will be generated in utilities bar
 * @return {boolean} true if the dialog was added to the viewpoint, false otherwise.
 */
MP_ModalDialog.addModalDialogOptionToViewpoint = function (modalDialogId, iconElement) {
	var modalObj = null;

	//Check to see if the ModalDialog exists
	modalObj = this.modalDialogObjects[modalDialogId];
	if (!modalObj) {
		return false;
	}

	//If the MP_Viewpoint function is defined call it
	if (typeof MP_Viewpoint !== "undefined" && typeof MP_Viewpoint.addModalDialogUtility !== "undefined") {
		MP_Viewpoint.addModalDialogUtility(modalObj, iconElement);
		return true;
	}
};

/**
 * Closes all of the associated modal dialog windows
 * @param {string} modalDialogId The id of the modal dialog to close
 * @return {boolean} true if the dialog was closed, false otherwise
 */
MP_ModalDialog.closeModalDialog = function (modalDialogId) {
	var modalObj = null;

	//Check to see if the ModalDialog exists
	modalObj = this.modalDialogObjects[modalDialogId];
	if (!modalObj) {
		return false;
	}

	//destroy the modal dialog
	$("#vwpModalDialog" + modalObj.getId()).remove();
	//destroy the modal background
	$("#vwpModalBackground" + modalObj.getId()).remove();
	//Mark the modal dialog as inactive
	modalObj.setIsActive(false);
	$("body").css("overflow", "auto");
	return true;
};

/**
 * Deletes the modal dialog object with the id modalDialogId.
 * @param {string} modalDialogId The id of the modal dialog object to be deleted
 * @return {boolean} True if a ModalDialog object was deleted, false otherwise
 */
MP_ModalDialog.deleteModalDialogObject = function (modalDialogId) {
	if (this.modalDialogObjects[modalDialogId]) {
		delete this.modalDialogObjects[modalDialogId];
		return true;
	}
	return false;
};

/**
 * Retrieves the ModalDialog object with the id of modalDialogId
 * @param {string} modalDialogId The id of the modal dialog object to retrieve
 * @return {ModalDialog} Returns the modal dialog object if it exists in the collection
 */
MP_ModalDialog.retrieveModalDialogObject = function (modalDialogId) {
	if (this.modalDialogObjects[modalDialogId]) {
		return this.modalDialogObjects[modalDialogId];
	}
	return null;
};

/**
 * Resizes all of the active modal dialogs when the window itself is being resized.
 * @param {string} modalDialogId The id of the modal dialog object to resize
 * @return null
 */
MP_ModalDialog.resizeAllModalDialogs = function () {
	var dialog = null;
	var attr = "";
	//Get all of the modal dialog objects from the modalDialogObjects collection
	for (attr in MP_ModalDialog.modalDialogObjects) {
		if (MP_ModalDialog.modalDialogObjects.hasOwnProperty(attr)) {
			dialog = MP_ModalDialog.modalDialogObjects[attr];
			if (dialog.isActive()) {
				MP_ModalDialog.resizeModalDialog(dialog.getId());
			}
		}
	}
};

/**
 * Resizes the modal dialog when the window itself is being resized.
 * @param {string} modalDialogId The id of the modal dialog object to resize
 * @return null
 */
MP_ModalDialog.resizeModalDialog = function (modalDialogId) {
	var docHeight = 0;
	var docWidth = 0;
	var topMarginSize = 0;
	var leftMarginSize = 0;
	var bottomMarginSize = 0;
	var rightMarginSize = 0;
	var modalWidth = "";
	var modalHeight = "";
	var modalObj = null;

	//Get the ModalDialog object
	modalObj = this.modalDialogObjects[modalDialogId];
	if (!modalObj) {
		logger.logError("MP_ModalDialog.resizeModalDialog: No modal dialog with the id " + modalDialogId + " exists");
		return;
	}

	if (!modalObj.isActive()) {
		logger.logError("MP_ModalDialog.resizeModalDialog: this modal dialog is not active it cannot be resized");
		return;
	}

	//Determine the new margins and update accordingly
	docHeight = $(window).height();
	docWidth = $(document.body).width();
	topMarginSize = Math.floor(docHeight * (modalObj.getTopMarginPercentage() / 100));
	leftMarginSize = Math.floor(docWidth * (modalObj.getLeftMarginPercentage() / 100));
	bottomMarginSize = Math.floor(docHeight * (modalObj.getBottomMarginPercentage() / 100));
	rightMarginSize = Math.floor(docWidth * (modalObj.getRightMarginPercentage() / 100));
	modalWidth = (docWidth - leftMarginSize - rightMarginSize);
	modalHeight = (docHeight - topMarginSize - bottomMarginSize);
	$("#vwpModalDialog" + modalObj.getId()).css({
		"top": topMarginSize,
		"left": leftMarginSize,
		"width": modalWidth + "px"
	});

	//Make sure the body div fills all of the alloted space if the body is a fixed size and also make sure the modal dialog is sized correctly.
	if (modalObj.isBodySizeFixed()) {
		$("#vwpModalDialog" + modalObj.getId()).css("height", modalHeight + "px");
		$("#" + modalObj.getBodyElementId()).height(modalHeight - $("#" + modalObj.getHeaderElementId()).height() - $("#" + modalObj.getFooterElementId()).height() - this.whiteSpacePixels);
	}
	else {
		$("#vwpModalDialog" + modalObj.getId()).css("max-height", modalHeight + "px");
		$("#" + modalObj.getBodyElementId()).css("max-height", (modalHeight - $("#" + modalObj.getHeaderElementId()).height() - $("#" + modalObj.getFooterElementId()).height() - this.whiteSpacePixels) + "px");
	}

	//Make sure the modal background is resized as well
	$("#vwpModalBackground" + modalObj.getId()).css({
		"height": "100%",
		"width": "100%"
	});
};

/**
 * Render and show the modal dialog based on the settings applied in the ModalDialog object referenced by the
 * modalDialogId parameter.
 * @param {string} modalDialogId The id of the ModalDialog object to render
 * @return null
 */
MP_ModalDialog.showModalDialog = function (modalDialogId) {
	var bodyDiv = null;
	var bodyLoadFunc = null;
	var bottomMarginSize = 0;
	var button = null;
	var dialogDiv = null;
	var docHeight = 0;
	var docWidth = 0;
	var focusButtonId = "";
	var footerDiv = null;
	var footerButtons = [];
	var footerButtonsCnt = 0;
	var footerButtonContainer = null;
	var headerDiv = null;
	var leftMarginSize = 0;
	var modalDiv = null;
	var modalObj = null;
	var modalHeight = "";
	var modalWidth = "";
	var rightMarginSize = 0;
	var topMarginSize = 0;
	var x = 0;
	var footerCheckbox = null;
	var footerText = "";

	/**
	 * This function is used to create onClick functions for each button.  Using this function
	 * will prevent closures from applying the same action onClick function to all buttons.
	 */
	function createButtonClickFunc(buttonObj, dialogId) {
		var clickFunc = buttonObj.getOnClickFunction();
		var closeModal = buttonObj.closeOnClick();
		if (!clickFunc) {
			clickFunc = function () {};

		}
		return function () {
			clickFunc();
			if (closeModal) {
				MP_ModalDialog.closeModalDialog(dialogId);
			}
		};

	}

	//Get the ModalDialog object
	modalObj = this.modalDialogObjects[modalDialogId];
	if (!modalObj) {
		logger.logError("MP_ModalDialog.showModalDialog: No modal dialog with the id " + modalDialogId + " exists");
		return;
	}

	//Check to see if the modal dialog is already displayed.  If so, return
	if (modalObj.isActive()) {
		return;
	}

	//Create the modal window based on the ModalDialog object
	//Create the header div element
	headerDiv = $("<div id='" + modalObj.getHeaderElementId() + "' class='dyn-modal-hdr-container'><span class='dyn-modal-hdr-title'>" + (modalObj.getHeaderTitle() || "&nbsp;") + "</span></div>");
	if (modalObj.showCloseIcon()) {
		headerDiv.append($("<span class='dyn-modal-hdr-close'></span>").click(function () {
				var closeFunc = null;
				var closeFunctionResponse = true;
				//call the close function of the modalObj
				closeFunc = modalObj.getHeaderCloseFunction();
				if (closeFunc) {
					closeFunctionResponse = closeFunc();
				}

				//Determine if we should close the modal or not
				if (modalObj.verifyCloseFunctionResponse()) {
					//Since we need to verify the close function response only close the modal when
					//the close function returned a truthy value or no close function is executed
					if (closeFunctionResponse) {
						MP_ModalDialog.closeModalDialog(modalObj.getId());
					}
			}
			else {
					MP_ModalDialog.closeModalDialog(modalObj.getId());
				}
			}));
	}

	//Create the body div element
	bodyDiv = $("<div id='" + modalObj.getBodyElementId() + "' class='dyn-modal-body-container'></div>");

	//Create the footer element if there are any buttons available or the checkbox is available
	footerButtons = modalObj.getFooterButtons();
	footerButtonsCnt = footerButtons.length;
	footerCheckbox = modalObj.getFooterCheckbox();
	footerText = modalObj.getFooterText();
	if (footerButtonsCnt || footerCheckbox.enabled || footerText !== "") {
		//Create the footer element
		footerDiv = $("<div id='" + modalObj.getFooterElementId() + "' class='dyn-modal-footer-container'></div>");
		//If the checkbox is enabled create the necessary elements
		if (footerCheckbox.enabled) {
			var checkboxContainer = $("<label class='dyn-modal-checkbox-container' id='" + footerCheckbox.elementId + "'></label>");
			var checkboxEle = $("<input type='checkbox' class='dyn-modal-checkbox'" + ((footerCheckbox.isChecked) ? " checked" : "") + ">");
			checkboxEle.click(footerCheckbox.onClick);
			checkboxContainer.append(checkboxEle);
			checkboxContainer.append("<span class='dyn-modal-checkbox-label'>" + footerCheckbox.label + "</span>");
			footerDiv.append(checkboxContainer);
		}
		
		//If footer buttons are enabled, rendering each button and apply the necessary click events
		if (footerButtonsCnt) {
			footerButtonContainer = $("<div id='" + modalObj.getFooterElementId() + "btnCont' class='dyn-modal-button-container'></div>");
			for (x = 0; x < footerButtonsCnt; x++) {
				button = footerButtons[x];
				footerButtonContainer.append($("<button id='" + button.getId() + "' class='dyn-modal-button'" + ((button.isDithered()) ? " disabled" : "") + ">" + button.getText() + "</button>").click(createButtonClickFunc(button, modalObj.getId())));
				//Check to see the footer button has a separator.
				if (button.getSeparatorInd()) {
					footerButtonContainer.append("<span class='dyn-modal-button-separator'></span>");
				}
				//Check to see if we should focus on this button when loading the modal dialog
				if (!focusButtonId) {
					focusButtonId = (button.getFocusInd()) ? button.getId() : "";
				}
			}
			footerDiv.append(footerButtonContainer);
		}

		//Create a footer text element if there is a label
		if (footerText !== "") {
			footerDiv.append("<span id='" + modalObj.getFooterTextElementId() + "' class='dyn-modal-footer-text'>" + footerText + "</span>");
		}

	}
	else if(modalObj.isFooterAlwaysShown()) {
		footerDiv = $("<div id='" + modalObj.getFooterElementId() + "' class='dyn-modal-footer-container'></div>");
	}

	//determine the dialog size
	docHeight = $(window).height();
	docWidth = $(document.body).width();
	topMarginSize = Math.floor(docHeight * (modalObj.getTopMarginPercentage() / 100));
	leftMarginSize = Math.floor(docWidth * (modalObj.getLeftMarginPercentage() / 100));
	bottomMarginSize = Math.floor(docHeight * (modalObj.getBottomMarginPercentage() / 100));
	rightMarginSize = Math.floor(docWidth * (modalObj.getRightMarginPercentage() / 100));
	modalWidth = (docWidth - leftMarginSize - rightMarginSize);
	modalHeight = (docHeight - topMarginSize - bottomMarginSize);
	dialogDiv = $("<div id='vwpModalDialog" + modalObj.getId() + "' class='dyn-modal-dialog'></div>").css({
			"top": topMarginSize,
			"left": leftMarginSize,
			"width": modalWidth + "px"
		});
	dialogDiv.append(headerDiv).append(bodyDiv).append(footerDiv);

	//Create the modal background if set in the ModalDialog object.
	modalDiv = $("<div id='vwpModalBackground" + modalObj.getId() + "' class='" + ((modalObj.hasGrayBackground()) ? "dyn-modal-div" : "dyn-modal-div-clear") + "'></div>").height($(document).height());

	//Add the flash function to the modal if using a clear background
	if (!modalObj.hasGrayBackground()) {
		modalDiv.click(function () {
			var modal = $("#vwpModalDialog" + modalObj.getId());
			modal.fadeOut(100);
			modal.fadeIn(100);
		});

	}

	//Add all of these elements to the document body
	$(document.body).append(modalDiv).append(dialogDiv);

	//Set the focus of a button if indicated
	if (focusButtonId) {
		$("#" + focusButtonId).focus();
	}
	//disable page scrolling when modal is enabled
	$("body").css("overflow", "hidden");

	//Make sure the body div fills all of the alloted space if the body is a fixed size and also make sure the modal dialog is sized correctly.
	if (modalObj.isBodySizeFixed()) {
		$(dialogDiv).css("height", modalHeight + "px");
		$(bodyDiv).height(modalHeight - $(headerDiv).height() - $(footerDiv).height() - this.whiteSpacePixels);
	}
	else {
		$(dialogDiv).css("max-height", modalHeight + "px");
		$(bodyDiv).css("max-height", (modalHeight - $(headerDiv).height() - $(footerDiv).height() - this.whiteSpacePixels) + "px");
	}

	//This next line makes the modal draggable.  If this is commented out updates will need to be made
	//to resize functions and also updates to the ModalDialog object to save the location of the modal
	//$(dialogDiv).draggable({containment: "parent"});

	//Mark the displayed modal as active and save its id
	modalObj.setIsActive(true);

	//Call the onBodyLoadFunction of the modal dialog
	bodyLoadFunc = modalObj.getBodyDataFunction();
	if (bodyLoadFunc) {
		bodyLoadFunc(modalObj);
	}

	//Attempt to resize the window as it is being resized
	$(window).resize(this.resizeAllModalDialogs);
};

/**
 * Updates the existing ModalDialog with a new instance of the object.  If the modal objet does not exist it is added to the collection
 * @param {ModalDialog} modalObject The updated instance of the ModalDialog object.
 * @return null
 */
MP_ModalDialog.updateModalDialogObject = function (modalObject) {
	var modalDialogId = "";

	//Check to see if we were passed a ModalDialog object
	if (!modalObject || !(modalObject instanceof ModalDialog)) {
		logger.logError("MP_ModalDialog.updateModalDialogObject only accepts objects of type ModalDialog");
		return;
	}

	//Blindly update the ModalDialog object.  If it didnt previously exist, it will now.
	modalDialogId = modalObject.getId();
	this.modalDialogObjects[modalDialogId] = modalObject;
	return;
};


/**
 * The ModalButton class is used specifically for adding buttons to the footer of a modal dialog.
 * @constructor
 */
function ModalButton(buttonId) { //eslint-disable-line no-redeclare
	//The id given to the button.  This id will be used to identify individual buttons
	this.m_buttonId = buttonId;
	//The text that will be displayed in the button itself
	this.m_buttonText = "";
	//A flag to determine if the button shall be disabled or not
	this.m_dithered = false;
	//The function to call when the button is clicked
	this.m_onClickFunction = null;
	//A flag to determine if this button should be closed when clicked.
	this.m_closeOnClick = true;
	//A flag to determine if this button should be focused when the modal dialog is shown
	this.m_focusInd = false;
	//A flag to determine if this button should show a separator next to it.
	this.m_separatorInd = false;
}

/** Checkers **/
/**
 * Check to see if the button click should close the modal dialog on click
 * @return {boolean} A boolean which determines if the button click should cause the modal dialog to close
 */
ModalButton.prototype.closeOnClick = function () {
	return this.m_closeOnClick;
};

/**
 * Check to see if the Modal Button is currently dithered
 * @return {boolean} A boolean flag that indicates if the modal button is dithered or not
 */
ModalButton.prototype.isDithered = function () {
	return this.m_dithered;
};

/** Getters **/
/**
 * Retrieves the id assigned the this ModalButton object
 * @return {string} The id assigned to this ModalButton object
 */
ModalButton.prototype.getId = function () {
	return this.m_buttonId;
};

/**
 * Retrieve the close on click flag of the ModalButton object
 * @return {boolean} The close on click flag of the ModalButton object
 */
ModalButton.prototype.getCloseOnClick = function () {
	return this.m_closeOnClick;
};

/**
 * Retrieve the focus indicator flag of the ModalButton object
 * @return {boolean} The focus indicator flag of the ModalButton object
 */
ModalButton.prototype.getFocusInd = function () {
	return this.m_focusInd;
};

/**
 * Retrieves the text used for the ModalButton display
 * @return {string} The text which will be used in the button display
 */
ModalButton.prototype.getText = function () {
	return this.m_buttonText;
};

/**
 * Retrieves the onClick function associated to this Modal Button
 * @return {function} The function executed when the button is clicked
 */
ModalButton.prototype.getOnClickFunction = function () {
	return this.m_onClickFunction;
};
/**
 * Retrieve the button separator indicator flag of the ModalButton object
 * @return {boolean} The button separator indicator flag of the ModalButton object
 */
ModalButton.prototype.getSeparatorInd = function () {
	return this.m_separatorInd;
};

/** Setters **/

/**
 * Sets the id of the ModalButton object.  The id must be a string otherwise it is ignored.
 * @param {string} buttonId The id which will be assigned to the button DOM element
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setId = function (buttonId) {
	if (buttonId && typeof buttonId === "string") {
		this.m_buttonId = buttonId;
	}
	return this;
};

/**
 * Sets the close on click flag of the dialog button
 * @param {boolean} closeFlag A boolean flag which determines if the dialog should close when the
 * button is clicked
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setCloseOnClick = function (closeFlag) {
	if (typeof closeFlag === "boolean") {
		this.m_closeOnClick = closeFlag;
	}
	return this;
};

/**
 * Sets the focus indicator flag of the dialog button
 * @param {boolean} focusInd A boolean flag which determines if the button should have focus on
 * initial dialog load.
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setFocusInd = function (focusInd) {
	if (typeof focusInd === "boolean") {
		this.m_focusInd = focusInd;
	}
	return this;
};

/**
 * Sets the text which will be shown in the button
 * @param {string} buttonText The string value to display as the button text
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setText = function (buttonText) {
	if (buttonText && typeof buttonText === "string") {
		this.m_buttonText = buttonText;
	}
	return this;
};

/**
 * Sets the dithered status of the dialog button
 * @param {boolean} dithere A boolean flag which determines if the button should be dithered
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setIsDithered = function (dithered) {
	if (typeof dithered === "boolean") {
		this.m_dithered = dithered;
	}
	return this;
};

/**
 * Sets the onClick function for the ModalButton
 * @param {function} clickFunc The function to execute when this button is clicked.
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setOnClickFunction = function (clickFunc) {
	if (typeof clickFunc === "function") {
		this.m_onClickFunction = clickFunc;
	}
	return this;
};

/**
 * Sets the button separator indicator flag of the dialog button.If the separator indicator is
 * set to true then the separator is displayed to the right of the button.
 * @param {boolean} separatorFlag A boolean flag which determines if the button will have a visual
 * separator displayed to the right of the button.
 * @return {ModalButton} The modal button object calling this function so chaining can be used
 */
ModalButton.prototype.setSeparatorInd = function (separatorFlag) {
	if (typeof separatorFlag === "boolean") {
		this.m_separatorInd = separatorFlag;
	}
	return this;
};

/**
 * The ModalDialog object contains information about the aspects of how the modal dialog will be created and what actions will take
 * place.  Depending on how the variables are set, the modal can flex based on the consumers needs.  Customizable options include the following;
 * size, modal title, onClose function, modal body content, variable footer buttons with dither options and onclick events.
 * @constructor
 */
function ModalDialog(modalId) {//eslint-disable-line no-redeclare
	//The id given to the ModalDialog object.  Will be used to set/retrieve the modal dialog
	this.m_modalId = modalId;
	//A flag used to determine if the modal is active or not
	this.m_isModalActive = false;
	//A flag to determine if the modal should be fixed to the icon used to activate the modal
	this.m_isFixedToIcon = false;
	//A flag to determine if the modal dialog should grey out the background when being displayed or not.
	this.m_hasGrayBackground = true;
	//A flag to determine if the close icon should be shown or not
	this.m_showCloseIcon = true;

	//The margins object contains the margins that will be applied to the modal window.
	this.m_margins = {
		top: 5,
		right: 5,
		bottom: 5,
		left: 5
	};

	//The icon object contains information about the icon that the user will use to launch the modal dialog
	this.m_icon = {
		elementId: modalId + "icon",
		cssClass: "",
		text: "",
		hoverText: "",
		isActive: true
	};

	//The header object of the modal.  Contains all of the necessary information to render the header of the dialog
	this.m_header = {
		elementId: modalId + "header",
		title: "",
		closeFunction: null,
		verifyCloseFunctionResponse: false
	};

	//The body object of the modal.  Contains all of the necessary information to render the body of the dialog
	this.m_body = {
		elementId: modalId + "body",
		dataFunction: null,
		isBodySizeFixed: true
	};

	//The footer object of the modal.  Contains all of the necessary information to render the footer of the dialog
	this.m_footer = {
		isAlwaysShown: false,
		elementId: modalId + "footer",
		buttons: [],
		checkbox: {
			enabled: false,
			elementId: modalId + "FooterChkBox",
			isChecked: false,
			onClick: function () {
				return false;
			},
			label: ""
		},
		footerText: {
			text: "",
			elementId: modalId + "FooterText"
		}
	};
}

/** Adders **/

/**
 * Adds a ModalButton object to the list of buttons that will be used in the footer of to modal dialog.
 * Only ModalButtons will be used, no other object type will be accepted.
 * @param {ModalButton} modalButton The button to add to the footer.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.addFooterButton = function (modalButton) {
	if (!(modalButton instanceof ModalButton)) {
		logger.logError("ModalDialog.addFooterButton: Cannot add footer button which isnt a ModalButton object.\nModalButtons can be created using the ModalDialog.createModalButton function.");
		return this;
	}

	if (!modalButton.getId()) {
		logger.logError("ModalDialog.addFooterButton: All ModalButton objects must have an id assigned");
		return this;
	}

	this.m_footer.buttons.push(modalButton);
	return this;
};

/** Checkers **/

/**
 * Checks to see if the modal dialog object has a gray background or not
 * @return {boolean} True if the modal dialog is active, false otherwise
 */
ModalDialog.prototype.hasGrayBackground = function () {
	return this.m_hasGrayBackground;
};

/**
 * Checks to see if the modal dialog object is active or not
 * @return {boolean} True if the modal dialog is active, false otherwise
 */
ModalDialog.prototype.isActive = function () {
	return this.m_isModalActive;
};

/**
 * Checks to see if the modal dialog body should have a fixed size or not
 * @return {boolean} True if the modal dialog body is a fixed size, false otherwise
 */
ModalDialog.prototype.isBodySizeFixed = function () {
	return this.m_body.isBodySizeFixed;
};

/**
 * Checks to see if the modal dialog footer should always be shown or not
 * @return {boolean} True if the modal dialog footer should always be shown
 */
ModalDialog.prototype.isFooterAlwaysShown = function () {
	return this.m_footer.isAlwaysShown;
};

/**
 * Checks if the modal should be fixed to the icon used to activate the modal
 * @return {boolean} True if the modal dialog is active, false otherwise
 */
ModalDialog.prototype.isFixedToIcon = function () {
	return this.m_isFixedToIcon;
};

/**
 * Checks to see if the modal dialog icon is active or not
 * @return {boolean} True if the modal dialog icon is active, false otherwise
 */
ModalDialog.prototype.isIconActive = function () {
	return this.m_icon.isActive;
};

/**
 * Checks to see if the close icon should be shown in the modal dialog
 * @return {boolean} True if the close icon should be shown, false otherwise
 */
ModalDialog.prototype.showCloseIcon = function () {
	return this.m_showCloseIcon;
};

/**
 * Checks to see if the response of the close function associated to the Header close icon
 * should be checked before closing the dialog.  If set to true, the response of the close function will determine
 * if the dialog will be closed or not.  A true response indicates that the dialog can be closed.  A false response
 * indicates that they dialog should not be closed.
 * @return {boolean} A flag which determines if the dialog should check the response of the close function
 * before closing the dialog.
 */
ModalDialog.prototype.verifyCloseFunctionResponse = function () {
	return this.m_header.verifyCloseFunctionResponse;
};

/** Getters **/

/**
 * Retrieves the function that will be used when attempting to populate the content of the modal dialog body.
 * @return {function} The function used when loading the modal dialog body
 */
ModalDialog.prototype.getBodyDataFunction = function () {
	return this.m_body.dataFunction;
};

/**
 * Retrieves the id associated to the modal dialog body element
 * @return {string} The id associated to the modal dialog body element
 */
ModalDialog.prototype.getBodyElementId = function () {
	return this.m_body.elementId;
};

/**
 * Retrieves the percentage set for the bottom margin of the modal dialog
 * @return {number} The percentage assigned to the bottom margin for the modal dialog
 */
ModalDialog.prototype.getBottomMarginPercentage = function () {
	return this.m_margins.bottom;
};

/**
 * Retrieves the button identified by the id passed into the function
 * @param {string} buttonId The if of the ModalButton object to retrieve
 * @return {ModalButton} The modal button with the id of buttonId, else null
 */
ModalDialog.prototype.getFooterButton = function (buttonId) {
	var x = 0;
	var button = null;
	var buttons = this.getFooterButtons();
	var buttonCnt = buttons.length;
	//Get the ModalButton
	for (x = buttonCnt; x--; ) {
		button = buttons[x];
		if (button.getId() === buttonId) {
			return buttons[x];
		}
	}
	return null;
};

/**
 * Retrieves the array of buttons which will be used in the footer of the modal dialog.
 * @return {ModalButton[]} An array of ModalButton objects which will be used in the footer of the modal dialog
 */
ModalDialog.prototype.getFooterButtons = function () {
	return this.m_footer.buttons;
};

/**
 * Retrieves the id associated to the modal dialog footer element
 * @return {string} The id associated to the modal dialog footer element
 */
ModalDialog.prototype.getFooterElementId = function () {
	return this.m_footer.elementId;
};

/**
 * Retrieves the footer checkbox object associated to the modal dialog
 * @return {object} The checkbox associated to the modal dialog footer element
 */
ModalDialog.prototype.getFooterCheckbox = function () {
	return this.m_footer.checkbox;
};

/**
 * Retrieves a boolean which determines if the checkbox is enabled in the modal dialog footer.
 * @return {boolean} The flag which determines if this modal dialog should display a checkbox in the footer
 */
ModalDialog.prototype.getIsFooterCheckboxEnabled = function () {
		
	return this.m_footer.checkbox.enabled;
};

/**
 * Retrieves a boolean which determines if the checkbox is checked in the modal dialog footer.
 * @return {boolean} The flag which returns the state of the modal dialog footer checkbox
 */
ModalDialog.prototype.getFooterCheckboxIsChecked = function () {
	return this.m_footer.checkbox.isChecked;
};

/**
 * Retrieves the string label for the checkbox in the modal dialog footer.
 * @return {string} The label that appears next to the checkbox in the modal dialog footer
 */
ModalDialog.prototype.getFooterCheckboxLabel = function () {
	return this.m_footer.checkbox.label;
};

/**
 * Returns the id associated to the modal dialog footer checkbox
 * @return {String} ID of the element associated to the modal dialog footer checkbox
 */
ModalDialog.prototype.getFooterCheckboxElementId = function() {
	 return this.m_footer.checkbox.elementId;
};


/**
 * Retrieves a boolean which determines if the modal dialog should display a gray background or not
 * @return {boolean} The flag which determines if this modal dialog should display a gray background
 */
ModalDialog.prototype.getHasGrayBackground = function () {
	return this.m_hasGrayBackground;
};

/**
 * Retrieves the function that will be used when the user attempts to close the modal dialog.
 * @return {function} The function used when closing the modal dialog
 */
ModalDialog.prototype.getHeaderCloseFunction = function () {
	return this.m_header.closeFunction;
};

/**
 * Retrieves the id associated to the modal dialog header element
 * @return {string} The id associated to the modal dialog header element
 */
ModalDialog.prototype.getHeaderElementId = function () {
	return this.m_header.elementId;
};

/**
 * Retrieves the title which will be used in the header of the modal dialog
 * @return {string} The title given to the modal dialog header element
 */
ModalDialog.prototype.getHeaderTitle = function () {
	return this.m_header.title;
};

/**
 * Retrieves the css class which will be applied to the html span used to open the modal dialog
 * @return {string} The css which will be applied to the html span used ot open the modal dialog
 */
ModalDialog.prototype.getIconClass = function () {
	return this.m_icon.cssClass;
};

/**
 * Retrieves the id associated to the modal dialog icon element
 * @return {string} The id associated to the modal dialog icon element
 */
ModalDialog.prototype.getIconElementId = function () {
	return this.m_icon.elementId;
};

/**
 * Retrieves the text which will be displayed the user hovers over the modal dialog icon
 * @return {string} The text displayed when hovering over the modal dialog icon
 */
ModalDialog.prototype.getIconHoverText = function () {
	return this.m_icon.hoverText;
};

/**
 * Retrieves the text which will be displayed next to the icon used to open the modal dialog
 * @return {string} The text displayed next to the icon
 */
ModalDialog.prototype.getIconText = function () {
	return this.m_icon.text;
};

/**
 * Retrieves the id given to this modal dialog object
 * @return {string} The id given to this modal dialog object
 */
ModalDialog.prototype.getId = function () {
	return this.m_modalId;
};

/**
 * Retrieves a boolean which determines if this modal dialog object is active or not
 * @return {boolean} The flag which determines if this modal dialog object is active or not
 */
ModalDialog.prototype.getIsActive = function () {
	return this.m_isModalActive;
};

/**
 * Retrieves a boolean which determines if this body of the modal dialog object has a fixed height or not
 * @return {boolean} The flag which determines if the body of the modal dialog object is fixed or not
 */
ModalDialog.prototype.getIsBodySizeFixed = function () {
	return this.m_body.isBodySizeFixed;
};

/**
 * Retrieves a boolean which determines if this modal dialog object is fixed to the icon used to launch it.
 * @return {boolean} The flag which determines if this modal dialog object is active or not
 */
ModalDialog.prototype.getIsFixedToIcon = function () {
	return this.m_isFixedToIcon;
};

/**
 * Retrieves a boolean which determines if this modal dialog footer is always shown or not.
 * @return {boolean} The flag which determines if this modal dialog footer is always shown or not.
 */
ModalDialog.prototype.getIsFooterAlwaysShown = function () {
	return this.m_footer.isAlwaysShown;
};

/**
 * Retrieves a boolean which determines if this modal dialog icon is active or not.  If the icon is not active it should
 * not be clickable by the user and the cursor should not change when hovered over.
 * @return {boolean} The flag which determines if modal dialog icon is active or not.
 */
ModalDialog.prototype.getIsIconActive = function () {
	return this.m_icon.isActive;
};

/**
 * Retrieves the percentage set for the left margin of the modal dialog
 * @return {number} The percentage assigned to the left margin for the modal dialog
 */
ModalDialog.prototype.getLeftMarginPercentage = function () {
	return this.m_margins.left;
};

/**
 * Retrieves the percentage set for the right margin of the modal dialog
 * @return {number} The percentage assigned to the right margin for the modal dialog
 */
ModalDialog.prototype.getRightMarginPercentage = function () {
	return this.m_margins.right;
};

/**
 * Retrieves a boolean which determines if the close icon should be shown in the modal dialog.
 * @return {boolean} The flag which determines if the close icon should be shown or not.
 */
ModalDialog.prototype.getShowCloseIcon = function () {
	return this.m_showCloseIcon;
};

/**
 * Retrieves the percentage set for the top margin of the modal dialog
 * @return {number} The percentage assigned to the top margin for the modal dialog
 */
ModalDialog.prototype.getTopMarginPercentage = function () {
	return this.m_margins.top;
};
/**
 * Retrieves the footer text which will be displayed in the footer of the modal dialog
 * @return {string} The text to display in the footer of the modal dialog.
 */
ModalDialog.prototype.getFooterText = function () {
	return this.m_footer.footerText.text;
};
/**
 * Retrieves the id associated to the modal dialog footer text element
 * @return {string} The id associated to the modal dialog footer text element
 */
ModalDialog.prototype.getFooterTextElementId = function () {
	return this.m_footer.footerText.elementId;
};

/** Setters **/
/**
 * Sets the function to be called when the modal dialog is shown.  This function will be passed ModalDialog object so that
 * it can interact with the modal dialog easily while the dialog is open.
 * @param {function} dataFunc The function used to populate the body of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setBodyDataFunction = function (dataFunc) {

	//Check the proposed function
	if (!(typeof dataFunc === "function") && dataFunc !== null) {
		logger.logError("ModalDialog.setBodyDataFunction: dataFunc param must be a function or null");
		return this;
	}

	this.m_body.dataFunction = dataFunc;
	return this;
};

/**
 * Sets the html element id of the modal dialog body.  This id will be used to insert html into the body of the modal dialog.
 * @param {string} elementId The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setBodyElementId = function (elementId) {
	if (elementId && typeof elementId === "string") {
		//Update the existing element id if the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getBodyElementId()).attr("id", elementId);
		}
		this.m_body.elementId = elementId;
	}
	return this;
};

/**
 * Sets the html of the body element.
 * @param {string} html The HTML to insert into the body element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setBodyHTML = function (html) {
	if (html && typeof html === "string") {
		//Update the existing html iff the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getBodyElementId()).html(html);
		}
	}
	return this;
};

/**
 * Sets the percentage of the window size that will make up the bottom margin of the modal dialog.  The default value is 5.
 * @param {number} margin A number that determines what percentage of the window's width will make up the bottom margin of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setBottomMarginPercentage = function (margin) {
	if (typeof margin === "number") {
		this.m_margins.bottom = (margin <= 0) ? 1 : margin;
		//Resize the modal if it is active
		if (this.isActive()) {
			MP_ModalDialog.resizeModalDialog(this.getId());
		}
	}
	return this;
};

/**
 * Sets the close on click property of a specific button in the modal dialog.
 * @param {string} buttonId The id of the button to be dithered
 * @param {boolean} closeOnClick A boolean used to determine if the button should close the dialog or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterButtonCloseOnClick = function (buttonId, closeOnClick) {
	var button = null;
	var buttonElement = null;
	var onClickFunc = null;
	var modal = this;

	//check the closeOnClick type
	if (!(typeof closeOnClick === "boolean")) {
		logger.logError("ModalDialog.setFooterButtonCloseOnClick: closeOnClick param must be of type boolean");
		return this;
	}

	//Get the ModalButton
	button = this.getFooterButton(buttonId);
	if (button) {
		//Update the closeOnClick flag
		button.setCloseOnClick(closeOnClick);
		//If the modal dialog is active, update the existing class
		if (this.isActive()) {
			//Update the class of the object
			buttonElement = $("#" + buttonId);
			buttonElement.click(function () {
				onClickFunc = button.getOnClickFunction();
				if (onClickFunc && typeof onClickFunc === "function") {
					onClickFunc();
				}
				if (closeOnClick) {
					MP_ModalDialog.closeModalDialog(modal.getId());
				}
			});

		}
	}
	else {
		logger.logError("ModalDialog.setFooterButtonCloseOnClick: No button with the id of " + buttonId + " exists for this ModalDialog");
	}
	return this;
};

/**
 * Sets the dithered property of a specific button in the modal dialog
 * @param {string} buttonId The id of the button to be dithered
 * @param {boolean} dithered A boolean used to determine if the button should be dithered or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterButtonDither = function (buttonId, dithered) {
	var button = null;
	var buttonElement = null;

	//check the dithered type
	if (!(typeof dithered === "boolean")) {
		logger.logError("ModalDialog.setFooterButtonDither: Dithered param must be of type boolean");
		return this;
	}

	//Get the ModalButton
	button = this.getFooterButton(buttonId);
	if (button) {
		//Update the dithered flag
		button.setIsDithered(dithered);
		//If the modal dialog is active, update the existing class
		if (this.isActive()) {
			//Update the class of the object
			buttonElement = $("#" + buttonId);
			if (dithered) {
				buttonElement.attr("disabled", true);
			}
			else {
				buttonElement.attr("disabled", false);
			}
		}
	}
	else {
		logger.logError("ModalDialog.setFooterButtonDither: No button with the id of " + buttonId + " exists for this ModalDialog");
	}
	return this;
};

/**
 * Sets the onclick function of the footer button with the given buttonId
 * @param {string} buttonId The id of the button to be dithered
 * @param {boolean} dithered A boolean used to determine if the button should be dithered or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterButtonOnClickFunction = function (buttonId, clickFunc) {
	var button = null;
	var modal = this;

	//Check the proposed function and make sure it is a function
	if (!(typeof clickFunc === "function") && clickFunc !== null) {
		logger.logError("ModalDialog.setFooterButtonOnClickFunction: clickFunc param must be a function or null");
		return this;
	}

	//Get the modal button
	button = this.getFooterButton(buttonId);
	if (button) {
		//Set the onclick function of the button
		button.setOnClickFunction(clickFunc);
		//If the modal dialog is active, update the existing onClick function
		if (this.isActive()) {
			$("#" + buttonId).unbind("click").click(function () {
				if (clickFunc) {
					clickFunc();
				}
				if (button.closeOnClick()) {
					MP_ModalDialog.closeModalDialog(modal.getId());
				}
			});
		}
	}
	else {
		logger.logError("ModalDialog.setFooterButtonOnClickFunction: No button with the id of " + buttonId + " exists for this ModalDialog");
	}
	return this;
};

/**
 * Sets the text displayed in the footer button with the given buttonId
 * @param {string} buttonId The id of the button to be dithered
 * @param {string} buttonText the text to display in the button
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterButtonText = function (buttonId, buttonText) {
	var button = null;

	//Check the proposed text and make sure it is a string
	if (!(typeof buttonText === "string")) {
		logger.logError("ModalDialog.setFooterButtonText: buttonText param must be a string");
		return this;
	}

	//Check make sure the string is not empty
	if (!buttonText) {
		logger.logError("ModalDialog.setFooterButtonText: buttonText param must not be empty or null");
		return this;
	}

	//Get the modal button
	button = this.getFooterButton(buttonId);
	if (button) {
		//Set the onclick function of the button
		button.setText(buttonText);
		//If the modal dialog is active, update the existing onClick function
		if (this.isActive()) {
			$("#" + buttonId).html(buttonText);
		}
	}
	else {
		logger.logError("ModalDialog.setFooterButtonText: No button with the id of " + buttonId + " exists for this ModalDialog");
	}
	return this;
};

/**
 * Sets the html element id of the modal dialog footer.  This id will be used to interact with the footer of the modal dialog.
 * @param {string} elementId The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterElementId = function (elementId) {
	if (elementId && typeof elementId === "string") {
		//Update the existing element id if the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getFooterElementId()).attr("id", elementId);
		}
		this.m_footer.elementId = elementId;
	}
	return this;
};

/**
 * Sets the label that will appear next to the checkbox in the modal dialog footer
 * @param {string} label A label that will appear next to the corresponding checkbox
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterCheckboxLabel = function (label) {
	if (typeof label === "string" && label !== "") {
		this.m_footer.checkbox.label = label;
	}
	return this;
};

/**
 * Sets the flag that will determine if the checkbox in the footer of the modal dialog
 * is visible or not.
 * @param {boolean} isEnabled A flag that will determine if the footer checkbox is visible or not.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterCheckboxEnabled = function (isEnabled) {
	if (typeof isEnabled === "boolean") {
		this.m_footer.checkbox.enabled = isEnabled;
	}
	return this;
};

/**
 * Sets the flag that will determine if the checkbox in the footer of the modal dialog
 * is checked or not checked.
 * @param {boolean} isChecked A flag that will determine the state of the footer checkbox.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterCheckboxIsChecked = function (isChecked) {
	if (typeof isChecked === "boolean") {
		this.m_footer.checkbox.isChecked = isChecked;
	}
	return this;
};

/**
 * Sets the function that will be called when the footer checkbox is clicked.
 * @param {function} checkboxClickFunction A function that will be called whenever the footer
 * checkbox is clicked
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterCheckboxClickFunction = function (checkboxClickFunction) {
	if (checkboxClickFunction && (typeof checkboxClickFunction === "function")) {
		//If the user defines the checkbox click function, assume they want it enabled
		this.setFooterCheckboxEnabled(true);
		this.m_footer.checkbox.onClick = checkboxClickFunction;
	}
	return this;
};

/**
 * Sets the flag which determines if the dialog should verify the response from the close function
 * before attempting to close.  If the response is true, the dialog can be closed.  If the response is
 * false the dialog should not be closed.
 * @param {boolean} verifyResponse The flag which will indicate if verification of the close function response
 * is needed
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used.
 */
ModalDialog.prototype.setVerifyCloseFunctionResponse = function (verifyResponse) {
	if (typeof verifyResponse === "boolean") {
		this.m_header.verifyCloseFunctionResponse = verifyResponse;
	}
	return this;
};

/**
 * EventHandler for the click on the icon when it is active. This will call the showModalDialog method
 * which renders the ModalDialog. It can be overwritten by any implementations of ModalDialog.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.activeIconClickEventHandler = function () {
	MP_ModalDialog.showModalDialog(this.getId());
	return this;
};
/**
 * Sets the indicator which determines if the icon to launch the modal dialog is active or not.  When this is
 * set, the icon and its interactions are updated if it is shown on the MPage.
 * @param {boolean} activeInd An indicator which determines if the modal dialog icon is active or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsIconActive = function (activeInd) {
	var modal = this;

	if (typeof activeInd === "boolean") {
		this.m_icon.isActive = activeInd;
		//Update the icon click event based on the indicator
		//Get the icon container and remove all events if there are any
		var iconElement = $("#" + this.getIconElementId());
		if (iconElement) {
			iconElement.unbind("click");
			if (activeInd) {
				// Add the click event
				iconElement.click(function () {
					modal.activeIconClickEventHandler();
				});
			}
		}
	}
	return this;
};

/**
 * Sets the flag which determines if the modal dialog will have a gray backgound when rendered.  This property
 * will not update dynamically.
 * @param {boolean} hasGrayBackground The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setHasGrayBackground = function (hasGrayBackground) {
	if (typeof hasGrayBackground === "boolean") {
		this.m_hasGrayBackground = hasGrayBackground;
	}
	return this;
};

/**
 * Sets the function to be called upon the user choosing to close the dialog via the exit button instead of one of the available buttons.
 * @param {function} closeFunc The function to call when the user closes the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setHeaderCloseFunction = function (closeFunc) {
	var modal = this;
	//Check the proposed function and make sure it is a function
	if (!(typeof closeFunc === "function") && closeFunc !== null) {
		logger.logError("ModalDialog.setHeaderCloseFunction: closeFunc param must be a function or null");
		return this;
	}

	//Update close function since it is valid
	this.m_header.closeFunction = closeFunc;

	//Update the header close function if the modal is active
	if (this.isActive()) {
		//Get the close element
		$(".dyn-modal-hdr-close").click(function () {
			var closeFunctionResponse = true;
			if (closeFunc) {
				closeFunctionResponse = closeFunc();
			}

			//Determine if we should close the modal or not
			if (modal.verifyCloseFunctionResponse()) {
				//Since we need to verify the close function response only close the modal when
				//the close function returned a truthy value or no close function is executed
				if (closeFunctionResponse) {
					MP_ModalDialog.closeModalDialog(modal.getId());
				}
			}
			else {
				MP_ModalDialog.closeModalDialog(modal.getId());
			}
		});
	}
	return this;
};

/**
 * Sets the html element id of the modal dialog header.  This id will be used to interact with the header of the modal dialog.
 * @param {string} elementId The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setHeaderElementId = function (elementId) {
	if (elementId && typeof elementId === "string") {
		//Update the existing element id if the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getHeaderElementId()).attr("id", elementId);
		}
		this.m_header.elementId = elementId;
	}
	return this;
};

/**
 * Sets the title to be displayed in the modal dialog header.
 * @param {string} headerTitle The string to be used in the modal dialog header as the title
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setHeaderTitle = function (headerTitle) {
	if (headerTitle && typeof headerTitle === "string") {
		//Update the existing header title if the modal dialog is active
		if (this.isActive()) {
			$("#" + this.getHeaderElementId() + " .dyn-modal-hdr-title").html(headerTitle);
		}
		this.m_header.title = headerTitle;
	}
	return this;
};

/**
 * Sets the css class to be used to display the modal dialog launch icon.  This class should contain a background and proper sizing
 * as to diaply the entire icon.
 * @param {string} iconClass The css class to be applied to the html element the user will use to launch the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIconClass = function (iconClass) {
	if (iconClass && typeof iconClass === "string") {
		//Update the existing icon class
		$("#" + this.getIconElementId()).removeClass(this.m_icon.cssClass).addClass(iconClass);
		this.m_icon.cssClass = iconClass;
	}
	return this;
};

/**
 * Sets the html element id of the modal dialog icon.  This id will be used to interact with the icon of the modal dialog.
 * @param {string} elementId The id of the html element
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIconElementId = function (elementId) {
	if (elementId && typeof elementId === "string") {
		//Update the existing element id if the modal dialog is active
		$("#" + this.getIconElementId()).attr("id", elementId);
		this.m_icon.elementId = elementId;
	}
	return this;
};

/**
 * Sets the text which will be displayed to the user when hovering over the modal dialog icon.
 * @param {string} iconHoverText The text to display in the icon hover
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIconHoverText = function (iconHoverText) {
	if (iconHoverText !== null && typeof iconHoverText === "string") {
		this.m_icon.hoverText = iconHoverText;
		//Update the icon hover text
		$("#" + this.getIconElementId()).attr("title", iconHoverText);
	}
	return this;
};

/**
 * Sets the text to be displayed next to the modal dialog icon.
 * @param {string} iconText The text to display next to the modal dialog icon.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIconText = function (iconText) {
	if (iconText !== null && typeof iconText === "string") {
		this.m_icon.text = iconText;
		//Update the icon text
		$("#" + this.getIconElementId()).html(iconText);
	}
	return this;
};

/**
 * Sets the id which will be used to identify a particular ModalDialog object.
 * @param {string} id The id that will be assigned to this ModalDialog object
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setId = function (id) {
	if (id && typeof id === "string") {
		this.m_modalId = id;
	}
	return this;
};

/**
 * Sets the flag which identifies the modal dialog as being active or not
 * @param {boolean} activeInd A boolean that can be used to determine if the modal is active or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsActive = function (activeInd) {
	if (typeof activeInd === "boolean") {
		this.m_isModalActive = activeInd;
	}
	return this;
};

/**
 * Sets the flag which identifies if the modal dialog body is a fixed height or not.
 * @param {boolean} bodyFixed A boolean that can be used to determine if the modal dialog has a fixed size body or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsBodySizeFixed = function (bodyFixed) {
	if (typeof bodyFixed === "boolean") {
		this.m_body.isBodySizeFixed = bodyFixed;
	}
	return this;
};

/**
 * Sets the flag which identifies if the modal dialog is fixed to the icon or not.  If this flag is set
 * the modal dialog will be displayed as an extension of the icon used to launch the dialog, much like a popup window.
 * In this case the Top and Right margins are ignored and the location of the icon will determine those margins.  If this
 * flag is set to false the modal dialog window will be displayed according to all of the margin settings.
 * @param {boolean} fixedToIcon A boolean that can be used to determine if the modal is fixed to the launch icon or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsFixedToIcon = function (fixedToIcon) {
	if (typeof fixedToIcon === "boolean") {
		this.m_isFixedToIcon = fixedToIcon;
	}
	return this;
};

/**
 * Sets the flag which identifies if the modal dialog footer is always shown or not
 * @param {boolean} footerAlwaysShown A boolean used to determine if the modal dialog footer is always shown or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setIsFooterAlwaysShown = function (footerAlwaysShown) {
	if (typeof footerAlwaysShown === "boolean") {
		this.m_footer.isAlwaysShown = footerAlwaysShown;
	}
	return this;
};

/**
 * Sets the percentage of the window size that will make up the left margin of the modal dialog.  The default value is 5.
 * @param {number} margin A number that determines what percentage of the window's width will make up the left margin of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setLeftMarginPercentage = function (margin) {
	if (typeof margin === "number") {
		this.m_margins.left = (margin <= 0) ? 1 : margin;
		//Resize the modal if it is active
		if (this.isActive()) {
			MP_ModalDialog.resizeModalDialog(this.getId());
		}
	}
	return this;
};

/**
 * Sets the percentage of the window size that will make up the right margin of the modal dialog.  The default value is 5.
 * @param {number} margin A number that determines what percentage of the window's width will make up the right margin of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setRightMarginPercentage = function (margin) {
	if (typeof margin === "number") {
		this.m_margins.right = (margin <= 0) ? 1 : margin;
		//Resize the modal if it is active
		if (this.isActive()) {
			MP_ModalDialog.resizeModalDialog(this.getId());
		}
	}
	return this;
};

/**
 * Sets the flag which identifies if the modal dialog close icon is shown or not
 * @param {boolean} showCloseIcon A boolean used to determine if the modal dialog close icon is shown or not
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setShowCloseIcon = function (showCloseIcon) {
	if (typeof showCloseIcon === "boolean") {
		this.m_showCloseIcon = showCloseIcon;
	}
	return this;
};

/**
 * Sets the percentage of the window size that will make up the top margin of the modal dialog.  The default value is 5.
 * @param {number} margin A number that determines what percentage of the window's width will make up the top margin of the modal dialog
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setTopMarginPercentage = function (margin) {
	if (typeof margin === "number") {
		this.m_margins.top = (margin <= 0) ? 1 : margin;
		//Resize the modal if it is active
		if (this.isActive()) {
			MP_ModalDialog.resizeModalDialog(this.getId());
		}
	}
	return this;
};
/**
 * Sets the text to be displayed in the footer of the modal dialog.
 * @param {string} footerText The text to display in the footer of the modal dialog.
 * @return {ModalDialog} The modal dialog object calling this function so chaining can be used
 */
ModalDialog.prototype.setFooterText = function (footerText) {
	if (typeof footerText === "string" && footerText !== "") {
		this.m_footer.footerText.text = footerText;
		if (this.isActive()) {
			//Update the footer text if the dialog is active
			$("#" + this.getFooterTextElementId()).html(footerText);
		}
	}
	return this;
};

/**
 * MessageModal is a DialogModal subclass with some extra state and responsibilities
 * To actually use a modal, it is preferred to create a subclass of this, such as ErrorModal.
 * @param {string} modalId The element id of the modal
 * @constructor
 */
function MessageModal(modalId) {
	this.m_line1 = "";
	this.m_line2 = "";
	this.m_customClass = "";

	//
	// set the modalId and other members in the superclass
	//
	ModalDialog.apply(this, [modalId]);
}

/**
 * MessageModal inherits from ModalDialog
 * @type {ModalDialog}
 */
MessageModal.prototype = new ModalDialog();

/**
 * Setter
 * This will be the first line of the message and will potentially be styled based on the message type being used.
 * @param {String} line1
 */
MessageModal.prototype.setLine1 = function(line1) {
	this.m_line1 = line1;
};

/**
 * Getter
 * This will be the first line of the message and will potentially be styled based on the message type being used.
 * @returns {string|String|*}
 */
MessageModal.prototype.getLine1 = function() {
	return this.m_line1 || "";
};

/**
 * Setter
 * This will be the text immediately following the line1 line.  This text will not be stylized.
 * @param {String} line2
 */
MessageModal.prototype.setLine2 = function(line2) {
	this.m_line2 = line2;
};

/**
 * Getter
 * This will be the text immediately following the line1 line.  This text will not be stylized.
 * @returns {string|String|*}
 */
MessageModal.prototype.getLine2 = function() {
	return this.m_line2 || "";
};

/**
 * Setter
 * This is the optional custom class that can be added to the message container
 * which will allow for custom styling of the message information.
 * @param {string} customClass
 */
MessageModal.prototype.setCustomClass = function(customClass) {
	this.m_customClass = customClass;
};

/**
 * Getter
 * This is the optional custom class that can be added to the message container
 * which will allow for custom styling of the message information.
 * @returns {string|string|*}
 */
MessageModal.prototype.getCustomClass = function() {
	return this.m_customClass || "";
};

/**
 * Generates the HTMl for informational messages that will be displayed to the user.  The msgType parameter will be used to determine
 * the correct styling for the message applied. If the message type cannot be mapped to a supported message or the field is left blank, the
 * default styling will be applied.  If custom styling should be applied for the message the customClass parameter can be used to override
 * any of the default properties of the standard messaging styles.
 * @returns {string}
 */
MessageModal.prototype.getModalTextHTML = function() {
	return "<div class='default-container " + this.getCustomClass() + "'><span class='message-info-text'>" + this.getLine1() + "</span>" + this.getLine2() + "</div>";
};

/**
 * Sets the message in the modal
 * @param {string} line1 This will be the first line of the message and will potentially be styled based on the message type being used.
 * @param {string} line2 This will be the text immediately following the msgText line.  This text will not be stylized.
 * @returns null
 */
MessageModal.prototype.setMessage = function(line1, line2) {
	var modalHTML = "";

	//
	// make this an empty string if it is undefined because
	// it will be rendered without any more processing
	//
    this.m_line1 = line1 || "";

	//
	// make this an empty string if it is undefined because
	// it will be rendered without any more processing
	//
	this.m_line2 = line2 || "";

	//Apply the proper margins for User informational messages
	this.setLeftMarginPercentage(35).setRightMarginPercentage(35).setTopMarginPercentage(20).setIsBodySizeFixed(false).setIsFooterAlwaysShown(true);

	//Generate the proper HTML string based on the type passed into the function
	modalHTML = this.getModalTextHTML();

	//Apply the new message to the modal
	if (this.isActive()) {
		this.setBodyHTML(modalHTML);
	}
	else {
		this.setBodyDataFunction(function(modalObj) {
			modalObj.setBodyHTML(modalHTML);
		});
	}
};

/**
 * The ErrorModal function exists for allowing specialization for error modals.
 * @param {string} modalId The element id for the modal.
 * @constructor
 */
function ErrorModal(modalId) {
	MessageModal.apply(this, [ modalId ]);
}

/**
 * The ErrorModal inherits from MessageModal
 * @type {ModalDialog}
 */
ErrorModal.prototype = new MessageModal();

/**
 * Return the string for the default HTML for the body of the modal.
 * @returns {string}
 */
ErrorModal.prototype.getModalTextHTML = function() {
	return "<div class='error-container " + this.getCustomClass() + "'><span class='error-text message-info-text'>" + this.getLine1() + "</span>" + this.getLine2() + "</div>";
};

/**
 * The WarningModal function exists for allowing specialization for warning modals.
 * @param {string} modalId The element id for the modal.
 * @constructor
 */
function WarningModal(modalId) {
	MessageModal.apply(this, [ modalId ]);
}

/**
 * The WarningModal inherits from MessageModal
 * @type {MessageModal}
 */
WarningModal.prototype = new MessageModal();

/**
 * Return the string for the default HTML for the body of the modal.
 * @returns {string}
 */
WarningModal.prototype.getModalTextHTML = function() {
	return "<div class='warning-container " + this.getCustomClass() + "'><span class='message-info-text'>" + this.getLine1() + "</span>" + this.getLine2() + "</div>";
};

/**
 * The InfoModal function exists for allowing specialization for information modals.
 * @param {string} modalId The element id for the modal.
 * @constructor
 */
function InfoModal(modalId) {
	MessageModal.apply(this, [ modalId ]);
}

/**
 * The InfoModal inherits from MessageModal
 * @type {MessageModal}
 */
InfoModal.prototype = new MessageModal();

/**
 * Return the string for the default HTML for the body of the modal.
 * @returns {string}
 */
InfoModal.prototype.getModalTextHTML = function() {
	return "<div class='information-container " + this.getCustomClass() + "'><span class='message-info-text'>" + this.getLine1() + "</span>" + this.getLine2() + "</div>";
};

/**
 * The BusyModal function exists for allowing specialization for busy modals.
 * @param {string} modalId The element id for the modal.
 * @constructor
 */
function BusyModal(modalId) {
	MessageModal.apply(this, [ modalId ]);
}

/**
 * The BusyModal inherits from MessageModal
 * @type {MessageModal}
 */
BusyModal.prototype = new MessageModal();

/**
 * Return the string for the default HTML for the body of the modal.
 * @returns {string}
 */
BusyModal.prototype.getModalTextHTML = function() {
	return "<div class='busy-container " + this.getCustomClass() + "'><span class='message-info-text'>" + this.getLine1() + "</span>" + this.getLine2() + "</div>";
};

/* global TemplateEngine */
/* eslint-disable no-redeclare */
var MPageControls = MPageControls || {};
/* eslint-enable no-redeclare */
/* eslint-disable no-undef */
MPageObjectOriented = {};
/* eslint-enable no-undef */

/* eslint-disable no-undef */
MPageObjectOriented.inherits = function(clazz, parent) {
	// instance methods
	$.each(parent.prototype, function(k, m) {
		clazz.prototype[ k ] = m;
	});

	// static methods
	$.each(parent, function(k, m) {
		clazz[ k ] = m;
	});
};
/* eslint-enable no-undef */

/* eslint-disable no-undef */
MPageObjectOriented.createAttribute = function(clazz, name) {
	clazz.prototype[ "set" + name ] = function(value) {
		this[ "m_" + name ] = value;
	};

	clazz.prototype[ "get" + name ] = function() {
		return this[ "m_" + name ];
	};
};
/* eslint-enable no-undef */

/**
 * Returns a string with the ID of the element. Element can be an ID string,
 * a jquery object, or a plain DOM element. Either way, the ID will be
 * automatically detected. If it can't detect, then an exception will
 * be thrown.
 *
 * @param {Object} element
 */
MPageControls.getId = function(element) {
	if (element instanceof String || typeof element === "string") {
		return element;
	}

	// note that null != undefined. We only want to return
	// an empty string when the client has explicitly informed
	// that it is a null variable.
	if (element === null) {
		return "";
	}
	/* eslint-disable no-undef-init */
	var id = undefined;
	/* eslint-enable no-undef-init */
	if (element instanceof jQuery) {
		id = element.attr("id");
	}

	if (element && element.getAttribute) {
		id = element.getAttribute("id");
	}

	if (!id) {
		throw new Error("You have tried to pass an object to MPageControls.getId that does not have a valid ID attribute.");
	}

	return id;
};

MPageControls.getDefaultTemplates = function() {
	return new TemplateEngine.TemplateFactory(MPageControls.defaultTemplates());
};

MPageControls.fromId = function(idStr) {
	var el = $("#" + idStr);
	return el.length === 0 ? null : el;
};

MPageControls.setMaxHeight = function(maxHeight) {
	this.m_maxHeight = maxHeight;
};

MPageControls.getMaxHeight = function() {
	return this.m_maxHeight;
};
/* global MPageObjectOriented */
/**
 * control.js
 * @author Leonardo Sa
 *
 * Control class
 * ============================================================================
 *
 * Serves as a base class for all other controls. It automatically assigns the
 * "element" constructor argument to its element attribute. It will also
 * automatically call the init method, that is meant to be overriden by child
 * classes.
 */

(function() {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.Control = function(element) {

		this.setControlId(ns.Control.idCounter);
		ns.Control.idCounter++;

		if (element) {
			this.setElement(element);
			this.init();
		} else {
			this.setElement(ns.Control.ID_PREFIX + this.getControlId());
		}
	};

	ns.Control.idCounter = 0;
	ns.Control.ID_PREFIX = "mpage_controls_control_";

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * A unique ID that identifies this control
	 */
	attribute(ns.Control, "ControlId");

	/**
	 * Some controls can be nested in a parent/child relationship
	 */
	attribute(ns.Control, "Parent");

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------

	/**
	 * Executed right after the control is created. Can be overriden by child
	 * classes. The purpose of a separate init method is to allow the user
	 * to rebuild the control from the ground up without having to call
	 * its constructor, removing the need to copy all properties.
	 */
	ns.Control.prototype.init = function() {

	};

	ns.Control.prototype.setElement = function(element) {
		this.m_element = MPageControls.getId(element);
	};

	ns.Control.prototype.getElement = function() {
		return MPageControls.fromId(this.m_element);
	};

	ns.Control.prototype.setContents = function(contents) {
		this.m_contents = MPageControls.getId(contents);
	};

	ns.Control.prototype.getContents = function() {
		return MPageControls.fromId(this.m_contents);
	};

	ns.Control.prototype.getElementId = function() {
		return this.m_element;
	};

	/**
	 * Renders a template function into the current element.
	 *
	 * Executes a function as specified by the template argument, passing the context
	 * as an argument, and sets the innerHTML of the current element to the result
	 * of the function execution. A "control_[id]" string will be set to the controlId
	 * property of the context if it has not been set yet.
	 *
	 * @param template
	 * @param context
	 */
	ns.Control.prototype.renderTemplate = function(template, context) {
		if (!context) {
			context = {};
		}

		if (!context.controlId) {
			context.controlId = this.getControlId();
		}

		var html = template(context);
		this.getElement().html(html);
	};

	// ________________________________________________________________________

	/**
	 * Calls the function as specified by eventName in the parent,
	 * passing the arguments.
	 */
	ns.Control.prototype.fire = function(eventName, args) {
		var parent = this.getParent();
		if (!parent) {
			return;
		}
		if (!(parent[ eventName ])) {
			return;
		}
		/* eslint-disable eqeqeq */
		if (args != undefined || args != null) {
			/* eslint-enable eqeqeq */
			parent[ eventName ].apply(parent, args);
		} else {
			parent[ eventName ].apply(parent, []);
		}
	};

	// ________________________________________________________________________

	/**
	 * Binds an event to a jQuery element. This is similar to jQuery's bind,
	 * except that here we keep track of the binded events in the control so
	 * we can destroy them later if needed.
	 * @param {Object} eventName
	 * @param {Object} element
	 * @param {Object} handler
	 */
	ns.Control.prototype.bind = function(eventName, element, handler) {
		element.bind(eventName + ".control" + this.getControlId(), handler);
	};

	// ________________________________________________________________________

	/**
	 * Destroys all the events associated with the current control
	 */
	ns.Control.prototype.destroyEvents = function() {
		if (this.getElement()) {
			this.getElement().unbind(".control" + this.getControlId());
		}
	};

	// ________________________________________________________________________

	ns.Control.prototype.focus = function() {
		this.getElement().focus();
	};

	// ________________________________________________________________________

	ns.Control.prototype.trigger = function(eventName, args) {
		if (this[ eventName ]) {
			if (!args) {
				args = [];
			}
			return this[ eventName ].apply(this, args);
		}
	};

})();
/* global TemplateEngine */
/* eslint-disable no-underscore-dangle */
MPageControls.defaultTemplates = function() {
	var te = TemplateEngine;
	var div = te.tag("div");
	var input = te.tag("input");
	var span = te.tag("span");

	return {

		// --------------------------------------------------------------------
		// List
		// --------------------------------------------------------------------

		list: function(context) {
			return div({
				"class": "list",
				"tabindex": "0",
				"id": context.listId
			}, context.items);
		},

		listItem: function(context) {
			return div({
				"class": "list-item",
				"id": context._elementId
			}, context.content);
		},

		// --------------------------------------------------------------------
		// Drop Down List
		// --------------------------------------------------------------------

		ddListItem: function(context) {
			return div({
				"class": "list-item",
				"id": context._elementId
			}, context[ context.displayKey ]);
		},

		// --------------------------------------------------------------------
		// AutoSuggest
		// --------------------------------------------------------------------

		autoSuggest: function(context) {
			return div({ "class": "auto-suggest input" },
				div({
					"id": context.closebtnId,
					"class": "close-btn"
				}, "&nbsp;"),
				div({ "class": "auto-suggest-input-wrapper" },
					input({
						"type": "text",
						"class": "search-box",
						"id": context.textboxId
					})
				)
			);
		},

		autoSuggestList: function(context) {
			return div({
				"class": "auto-suggest suggestions",
				"style": "position: relative",
				"tabindex": "0",
				"id": context.listId
			}, context.items);
		},

		emptyList: function() {
			return div({
				"class": "auto-suggest suggestions res-none",
				"style": "position: relative",
				"tabindex": "0"
			}, i18n.NO_RESULTS_FOUND);
		},

		// --------------------------------------------------------------------
		// ScriptSearch
		// --------------------------------------------------------------------
		cclSearch: function(context) {
			return div({ "class": "auto-suggest" },
				div({ "class": "auto-suggest-search-box" },
					input({ "type": "text", "id": context.textboxId })
				),
				div({ "class": "clear-search", "id": context.closebtnId },
					span({
						"class": "clear-button",
						"style": "display: inline-block"
					})
				)
			);
		},

		personnelSearchItem: function(context) {
			return div({ "id": context._elementId },
				context.NAME_FULL_FORMATTED
			);
		},

		providerSuggestList: function(context) {
			var divDetails = {
				"class": "auto-suggest suggestions",
				"style": "position: relative;",
				"tabindex": "0",
				"id": context.listId
			};

			var maxHeight = MPageControls.getMaxHeight();

			if (maxHeight) {
				divDetails.style = "position: relative; max-height: " + maxHeight + "px;";
			}

			return div(
				divDetails,
				context.items,
				div({ "id": "newProviderAssignment" }, i18n.ASSIGN_NEW_PROVIDER)
			);
		},

		// --------------------------------------------------------------------
		// OrderSearch
		// --------------------------------------------------------------------

		orderSearch: function(context) {
			return div({ "class": "auto-suggest" },
				div({ "class": "order-search-box" },
					input({
						"type": "text",
						"class": "search-box noe2-search",
						"id": context.textboxId
					})
				),
				div({ "class": "clear-search", "id": context.closebtnId },
					span({
						"class": "clear-button",
						"style": "display: inline-block"
					})
				)
			);
		},

		orderSearchItem: function(context) {
			return div({ "id": context._elementId },
				span({ "class": context.iconClass }, "&nbsp;"),
				context.content,
				span({ "class": "order-sentence" }, context.SENTENCE)
			);
		},

		documentedSearchItem: function(context) {
			return div({"id": context._elementId},
				span({"class": context.iconClass}, "&nbsp;"),
				context.content
			);
		},

		// --------------------------------------------------------------------
		// NomenclatureSearch
		// --------------------------------------------------------------------
		nomenSearchItem: function(context) {
			return div({ "id": context._elementId }, context.m_Data.SOURCESTRING);
		},

		// --------------------------------------------------------------------
		// Message
		// --------------------------------------------------------------------
		messageBar: function(context) {
			return div({ "class": context.msgDivClass },
				span("&nbsp;"),
				context.message,
				span({
					"class": 'close-btn hidden',
					'id': context.closeBtnId
				}, "&nbsp;"));
		},

		// --------------------------------------------------------------------
		// Venue dropdown
		// --------------------------------------------------------------------
		venueTemplate: function(context) {
			return div({
				"id": context._elementId
			}, div({
				"class": 'venue-item'
			}, context.VENUE_DISPLAY));

		}

	};
};
/* eslint-enable no-underscore-dangle */
/* global MPageObjectOriented */
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	/**
	 * A control that represents alert message, which can be added to any
	 * summary or workflow component.
	 */
	ns.AlertMessage = function(element, messageTemplate, messageType) {
		this.setTemplate(messageTemplate);
		this.setCssClass(messageType);
		this.setIsClosable(false);
		ns.Control.call(this, element);
	};

	inherits(ns.AlertMessage, ns.Control);
	/**
	 *The MessageTypes object will map the type of message with the css class.
	 */
	ns.AlertMessage.MessageTypes = {
		WARNING: "msg-warning",
		INFORMATION: "msg-info",
		ERROR: "msg-error"
	};
	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * A string-template that will be used when rendering the Message bar.
	 */
	attribute(ns.AlertMessage, "Template");

	/**
	 *Css class for the message div.
	 */
	attribute(ns.AlertMessage, "CssClass");

	/**
	 *Flag to allow closing of the alert message
	 */
	attribute(ns.AlertMessage, "IsClosable");


	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------

	var prot = ns.AlertMessage.prototype;

	// ________________________________________________________________________

	prot.getCloseBtnId = function() {
		return "control_" + this.getControlId() + "_closebtn";
	};
	/**
	 * Appends the html markup created by the template to the target element.
	 */
	prot.render = function(message) {
		var context = {
			"msgDivClass": this.getCssClass(),
			"message": message,
			"closeBtnId": this.getCloseBtnId()
		};
		var self = this;
		this.getElement().html(this.getTemplate().render(context));
		if (this.getIsClosable()) {
			$("#" + this.getCloseBtnId()).removeClass("hidden");
			$("#" + this.getCloseBtnId()).click(function() {
				self.close();
			});
		}
	};
	prot.close = function() {
		$(this.getElement()).hide();
	};
})(jQuery);
/* global MPageObjectOriented */
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.AutoSuggest = function(element) {
		this.setCaptionClass("caption");
		this.setTemplate(MPageControls.getDefaultTemplates().autoSuggest);
		this.setCaption("");
		this.setAutoHideCloseButton(true);
		this.setDelay(50);
		this.setDetailDialog(null);
		this.setHighlightEnabled(true);
		this.setSynchSuggestionsWidth(true);
		this.setBackgroundClass("search-box-image");
		this.mBlurEnabled = true;

		this.setOnChange(function() {
		});
		this.setOnClose(function() {
		});
		this.setOnEnter(function() {
		});
		this.setOnDelay(function() {
		});
		this.setRequestItemValueCallback(function(item) {
			return item.content;
		});

		ns.Control.call(this, element);
	};

	inherits(ns.AutoSuggest, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The list control responsible for displaying the suggestions
	 */
	attribute(ns.AutoSuggest, "List");

	/**
	 * Class that will be applied to the textbox when it has a caption
	 */
	attribute(ns.AutoSuggest, "CaptionClass");

	/**
	 * The DetailDialog where the List of suggestions will reside
	 */
	attribute(ns.AutoSuggest, "DetailDialog");

	/**
	 * Delay, in ms, that the control waits until it starts processing keys
	 */
	attribute(ns.AutoSuggest, "Delay");

	/**
	 * Template used to render the textbox and the close button - can be
	 * completely customized by the client.
	 */
	attribute(ns.AutoSuggest, "Template");

	/**
	 * A text to be displayed inside the textbox when it is empty and
	 * out of focus. This text will be erased once it receives focus.
	 * If the caption is not set, then the caption class will not be
	 * added.
	 */
	attribute(ns.AutoSuggest, "Caption");

	/**
	 * Callback to be executed when the textbox value is changed.
	 * The delay attribute has no effect here.
	 */
	attribute(ns.AutoSuggest, "OnChange");

	/**
	 * Callback to be executed when the suggestions drop down
	 * is closed.
	 */
	attribute(ns.AutoSuggest, "OnClose");

	/**
	 * Callback to be executed after the delay timer has expired.
	 * Here is where you will add logic to call setSuggestions()
	 * in order to show suggestions.
	 */
	attribute(ns.AutoSuggest, "OnDelay");

	/**
	 * Callback to be executed when the user presses "enter"
	 * while in the textbox.
	 */
	attribute(ns.AutoSuggest, "OnEnter");

	/**
	 * Holds the delay timer. If cleared, the timer will not fire.
	 */
	attribute(ns.AutoSuggest, "Timer");

	/**
	 * Callback to be executed whenever the control needs a textual
	 * value from an item object. This essentially needs to convert
	 * an Item object into a string.
	 */
	attribute(ns.AutoSuggest, "RequestItemValueCallback");

	/**
	 * Whether the suggestions will be highlighted with the text
	 * typed into the textbox or not.
	 *
	 * For custom highlighting logic, set this to false and manually
	 * instantiate the TextHighlighter class after calling renderItems
	 * in your script.
	 */
	attribute(ns.AutoSuggest, "HighlightEnabled");

	/**
	 * Whether the suggestion drop down will be resized to be the same
	 * width as the search text box
	 */
	attribute(ns.AutoSuggest, "SynchSuggestionsWidth");

	/**
	 * If set to true, hides the close button if there are no suggestions
	 * opened.
	 */
	attribute(ns.AutoSuggest, "AutoHideCloseButton");

	/**
	 * Will be automatically set to whatever value "items" is on
	 * "setSuggestions". This is useful to retrieve JSON data set by
	 * controls that abstract the setSuggestions method.
	 */
	attribute(ns.AutoSuggest, "Items");

	/**
	 * Class that will be applied to the textbox when search icon has to be set.
	 * This attribute will help maintain passivity.
	 */
	attribute(ns.AutoSuggest, "BackgroundClass");

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.AutoSuggest.prototype;

	/**
	 * Renders the template and attaches events to the textbox. The template
	 * must provide a textbox with getTextboxId() as its ID. The variable
	 * "textboxId" will be passed through the context.
	 */
	prot.init = function() {
		var self = this;
		var txtBox = null;

		// --------------------------------------------------------------------
		// Render template
		// --------------------------------------------------------------------
		this.getElement().empty();
		this.getElement().append(this.getTemplate().render({
			"textboxId": this.getTextboxId(),
			"closebtnId": this.getClosebtnId()
		}));
		txtBox = this.getTextbox();
		this.activateCaption();
		this.createDialog();
		this.setListTemplate(MPageControls.getDefaultTemplates().autoSuggestList);

		// --------------------------------------------------------------------
		// Textbox events
		// --------------------------------------------------------------------
		txtBox.click(function() {
			self.deactivateCaption();
		});

		txtBox.blur(function() {
			if (self.getValue().length === 0) {
				self.activateCaption();
			}

			// Gives a little time to process list click events
			setTimeout(function() {
				var suggestionsContainer = $("#control_" + self.getControlId() + "_content .suggestions");
				//close only if the autosuggest content is not in focus
				if (!suggestionsContainer.is(":focus")) {
					self.close();
				}
			}, 300);
		});

		txtBox.keyup(function(e) {
			self.processTextboxKeyDown(e);
		});

		// ------------------------------------------------------------------------
		// Attach event to the close button
		// ------------------------------------------------------------------------
		$("#" + this.getClosebtnId()).click(function() {
			self.close();
			self.getTextbox()[ 0 ].value = "";
			self.getOnClose()();
			self.activateCaption();
		});

		// hide the close button, if necessary
		if (this.getAutoHideCloseButton()) {
			this.hideCloseButton();
		}

	};

	// ________________________________________________________________________

	/**
	 * Handles key presses in the textbox
	 */
	prot.processTextboxKeyDown = function(e) {
		var self = this;
		var dialog = this.getDetailDialog();

		// Cleans the timer, if it exists
		if (self.getTimer()) {
			clearTimeout(self.getTimer());
		}

		// Disables the caption if it was enabled
		if (this.getTextbox().hasClass(this.getCaptionClass())) {
			this.getTextbox().removeClass(this.getCaptionClass());
		}

		// hides the close button and results if the text is empty. Displays it otherwise
		if (this.getValue().length === 0) {
			this.hideCloseButton();
			if (dialog && dialog.getVisible()) {
				this.close();
			}
			return;
		} else {
			$("#" + this.getClosebtnId()).css("display", "inline-block");
		}

		// The "enter" key will close the dialog, if any, and execute the
		// "onEnter" event. It will stop all other processing. Unless there
		// is an item selected in the dropdown. In that case, it will execute
		// the list's onEnter
		/* eslint-disable eqeqeq */
		if (e.keyCode == 13) {
			/* eslint-enable eqeqeq */

			if (dialog &&
				dialog.getVisible() &&
				this.getList().getSelectedIndex() >= 0) {
				this.getList().getOnEnter()();
				this.close();
				return;
			}

			this.close();
			this.getOnEnter()();
			return;
		}

		// binds key events to the list, so we can use the arrows to move
		// between suggestions.
		if (self.getList()) {
			self.getList().processKeyEvent(e);
		}

		// we wont process these keycodes:
		// up arrow, down arrow
		var dontProcess = [ 38, 40 ];
		/* eslint-disable eqeqeq */
		if ($.inArray(e.keyCode, dontProcess) != -1) {
			/* eslint-enable eqeqeq */
			this.moveCaretToEnd();
			return;
		}

		// fires the on change event
		this.getOnChange()();

		// ----------------------------------------------------------------
		// Triggers the OnDelay event after waiting "Delay" milliseconds
		// ----------------------------------------------------------------
		var t = setTimeout(function() {
			self.getOnDelay()();

			// we check textbox here because the user can delete the textbox in
			// the delay callback
			if (self.getValue() && self.getValue().length === 0) {
				self.close();
			}
		}, self.getDelay());

		self.setTimer(t);
	};

	// ________________________________________________________________________

	/**
	 * Displays the caption text in the textbox
	 */
	prot.activateCaption = function() {
		if (this.getCaption().length === 0) {
			return;
		}

		this.getTextbox().addClass(this.getCaptionClass());
		this.getTextbox()[ 0 ].value = this.getCaption();

		// hide the close button
		if (this.getAutoHideCloseButton()) {
			this.hideCloseButton();
		}
	};

	// ________________________________________________________________________

	/**
	 * Moves the caret position of the textbox to the last character
	 */
	prot.moveCaretToEnd = function() {
		var txtbox = this.getTextbox().get(0);
		var pos = this.getValue().length;

		if (txtbox.setSelectionRange) {
			txtbox.setSelectionRange(pos, pos);
			return;
		}

		if (txtbox.createTextRange) {
			var range = txtbox.createTextRange();
			range.moveEnd('character', pos);
			range.moveStart('character', pos);
			range.select();
		}
	};

	// ________________________________________________________________________

	/**
	 * Removes the close button from the search box
	 */
	prot.hideCloseButton = function() {
		$("#" + this.getClosebtnId()).css("display", "none");
	};

    /**
     * Shows the close button in the search box
     */
    prot.showCloseButton = function() {
        $("#" + this.getClosebtnId()).css("display", "inline-block");
    };

	// ________________________________________________________________________

	/**
	 * Erases the caption text from the textbox and removes the caption class
	 * from it. Will not fire if the class has already been removed.
	 */
	prot.deactivateCaption = function() {
		if (!this.getTextbox().hasClass(this.getCaptionClass())) {
			return;
		}

		this.getTextbox().removeClass(this.getCaptionClass());
		this.getTextbox()[ 0 ].value = "";
	};

	// ________________________________________________________________________

	/**
	 * Returns the textbox element
	 */
	prot.getTextbox = function() {
		return this.getElement().find("#" + this.getTextboxId());
	};

	// ________________________________________________________________________

	/**
	 * Returns the generated textbox element id
	 */
	prot.getTextboxId = function() {
		return "control_" + this.getControlId() + "_textbox";
	};

	// ________________________________________________________________________

	prot.getClosebtnId = function() {
		return "control_" + this.getControlId() + "_closebtn";
	};

	// ________________________________________________________________________

	/**
	 * Closes the suggestion drop down
	 */
	prot.close = function() {
		if (this.getDetailDialog()) {
			this.getDetailDialog().hide();
		}

		this.mBlurEnabled = true;
	};

	// ________________________________________________________________________

	/**
	 * Sets the items to be displayed as suggestions. These items should be an
	 * array of objects.
	 */
	prot.setSuggestions = function(items) {
		this.setItems(items);

		// No items or no text or caption active, hide it
		if (items.length === 0 || this.getValue().length === 0 || this.getTextbox().hasClass(this.getCaptionClass())) {
			this.close();
			return;
		}

		// Synchs the listDiv width, if necessary
		if (this.getSynchSuggestionsWidth()) {
			$("#control_" + this.getControlId() + "_content").css('min-width', this.getElement().width() + "px");
		}

		this.getList().renderItems(items);
		this.getDetailDialog().show();
		this.getDetailDialog().updatePosition();

		// apply highlighting, if enabled
		if (this.getHighlightEnabled()) {
			var hl = new ns.TextHighlighter(this.getList().getElement());
			hl.highlight(this.getValue());
		}

		var self = this;
		var suggestionsContainer = "#control_" + self.getControlId() + "_content .suggestions";
		//make the suggestions container focusable
		$(suggestionsContainer).attr("tabindex", 0);

		$(suggestionsContainer).on("blur", function() {
			// Gives a little time to process the blur event
			setTimeout(function() {
				//close the autosuggest content if the search textbox is not focused
				if (self.getElement() && !self.getTextbox().is(":focus")) {
					self.close();
				}
			}, 300);
		});
	};

	// ________________________________________________________________________

	/**
	 * Creates the detail dialog that contains the suggestions
	 */
	prot.createDialog = function() {
		var self = this;

		// creates the div that will contain the list
		var listDiv = $("<div></div>");
		listDiv.appendTo(this.getElement().offsetParent());
		listDiv.attr("id", "control_" + this.getControlId() + "_content");

		// creates the detail dialog that contains the list
		// and is attached to the textbox
		var dd = new ns.DetailDialog(this.getElement(), listDiv);
		dd.setElementCorner([ "bottom", "left" ]);
		dd.setAlwaysOnTop(true);

		// creates the list
		var list = new ns.List(listDiv);

		// When an item is selected, sets the value of the textbox,
		// fires this component's onEnter and closes the list.
		list.setOnSelect(function(item) {
			self.setValue(self.getRequestItemValueCallback()(item));
			self.getOnEnter()();
			self.close();
		});

		this.setList(list);
		this.setDetailDialog(dd);
	};

	// ________________________________________________________________________

	/**
	 * Returns the value that is currently in the textbox
	 */
	prot.getValue = function() {
		if (!this.getElement() || !this.getTextbox().length) {
			return null;
		}

		return this.getTextbox()[ 0 ].value;
	};

	// ________________________________________________________________________

	/**
	 * sets the textbox value
	 * @param {Object} value
	 */
	prot.setValue = function(value) {
		this.getTextbox()[ 0 ].value = value;
        this.showCloseButton();
	};

	// ________________________________________________________________________

	/**
	 * Destroys this control and its children controls
	 */
	prot.destroy = function() {
		if (this.getList()) {
			this.getList().destroy();
		}

		if (this.getDetailDialog()) {
			this.getDetailDialog().destroy();
		}
	};

	// ________________________________________________________________________

	/**
	 * Template used to render each item in the suggestion list
	 */
	prot.setListItemTemplate = function(template) {
		this.getList().setItemTemplate(template);
	};

	// ________________________________________________________________________

	/**
	 * Template used to render the list of suggestions
	 */
	prot.setListTemplate = function(template) {
		this.getList().setListTemplate(template);
	};

	//_________________________________________________________________________

	/**
	 * Displays the search icon in the textbox
	 */
	prot.activateBackground = function() {
		this.getTextbox().addClass(this.getBackgroundClass());
	};

})(jQuery);
/* global MPageObjectOriented */
/**
 * detail_dialog.js
 * @author Leonardo Sa
 *
 * DetailDialog class
 * ============================================================================
 *
 * Shows a dialog that is attached to an element. This means that
 * it will show next to that element when the show() method is called, similar
 * to drop down menus, except one can make it drop left, right, or even up
 * by changing the ElementCorner and ContentsCorner attributes.
 *
 */

(function($) {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var oo = MPageObjectOriented;
	var inherits = oo.inherits;
	var attribute = oo.createAttribute;

	// -----------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------

	/**
	 * Instantiates a new detail dialog attached to element, where its contents
	 * will be an element defined by contentsElement.
	 */
	/* eslint-disable no-shadow */
	ns.DetailDialog = function(element, contentsElement) {
		var defaultHideFx = function(element) {
			element.slideUp(150);
		};

		var defaultShowFx = function(element) {
			element.slideDown(150);
		};

		this.setAlwaysOnTop(false);
		this.setElementCorner([ "bottom", "left" ]);
		this.setContentsCorner([ "top", "left" ]);
		this.setBeforeShow(function() {
		});
		this.setAutoFlipVertical(true);
		this.setAutoFlipHorizontal(true);
		this.setContents(contentsElement);
		this.setShowEffect(defaultShowFx);
		this.setHideEffect(defaultHideFx);
		this.setVisible(false);
		this.setOnShow(function() {
		});
		this.setOnHide(function() {
		});

		// Calls the parent class constructor
		ns.Control.call(this, element);
	};
	/* eslint-enable no-shadow */

	inherits(ns.DetailDialog, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The contents of the dialog. Since we are using an external library
	 * to render the window, those contents will be used only as a base
	 * to create the dialog. To access the dialog HTML, use the pane()
	 * function.
	 */

	/**
	 * A jQuery effect for showing the dialog
	 */
	attribute(ns.DetailDialog, "ShowEffect");

	/**
	 * A jQuery effect for hiding the dialog
	 */
	attribute(ns.DetailDialog, "HideEffect");

	/**
	 * Whether the dialog is visible or not. This is read only - to change
	 * the visibility, use the hide() and show() functions.
	 */
	attribute(ns.DetailDialog, "Visible");

	/**
	 * Function to be executed after the dialog is shown and the
	 * animation is complete
	 */
	attribute(ns.DetailDialog, "OnShow");

	/**
	 * Function to be executed after the dialog is shown and the
	 * animation is complete
	 */
	attribute(ns.DetailDialog, "OnHide");

	/**
	 * Whether the dialog has been created or not. This is read only
	 * and does not signify that a dialog is visible, only that its
	 * HTML elements have been created.
	 */
	attribute(ns.DetailDialog, "Created");

	/**
	 * Defines to which corner of the element the dialog will attach to
	 */
	attribute(ns.DetailDialog, "ElementCorner");

	/**
	 * Defines which corner of the contents will attach to the element
	 */
	attribute(ns.DetailDialog, "ContentsCorner");

	/**
	 * Defines to which corner of the element the dialog will attach to when being flipped
	 */
	attribute(ns.DetailDialog, "ElementFlippedCorner");

	/**
	 * Defines which corner of the contents will attach to the element when being flipped
	 */
	attribute(ns.DetailDialog, "ContentsFlippedCorner");

	/**
	 * Event to be executed right before the dialog is shown
	 */
	attribute(ns.DetailDialog, "BeforeShow");

	/**
	 * Whether the dialog will automatically flip up, down or center if it's near
	 * the edge of the page.
	 */
	attribute(ns.DetailDialog, "AutoFlipVertical");

	/**
	 * Whether the dialog will automatically flip left or right if it's near
	 * the edge of the page.
	 */
	attribute(ns.DetailDialog, "AutoFlipHorizontal");

	/**
	 * When true, sets the z-index of the dialog to 100 to ensure
	 * it will be above everything else.
	 */
	attribute(ns.DetailDialog, "AlwaysOnTop");


	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.DetailDialog.prototype;

	prot.init = function() {
	};

	// ________________________________________________________________________

	/**
	 * Defines a jQuery element to be used as a reference for the autoflip.
	 * Sometimes this is necessary if you want the detail dialog to flip
	 * when it reaches the end of a certain DIV instead of the window.
	 */
	prot.setFlipReference = function(reference) {
		this.m_flipReference = MPageControls.getId(reference);
	};

	prot.getFlipReference = function() {
		return MPageControls.fromId(this.m_flipReference);
	};

	// ________________________________________________________________________

	/**
	 * Hides or shows the dialog every time this method is called
	 */
	prot.toggle = function() {
		if (this.getVisible()) {
			this.hide();
		}
		else {
			this.show();
		}
	};

	// ________________________________________________________________________

	/**
	 * Updates the position of the dialog in relation to its attached element.
	 * The position will vary according to values of getElementCorner and
	 * getContentsCorner, which specify which corners will be used for alignment.
	 */
	prot.updatePosition = function(elementConnection, contentConnection) {

		// --------------------------------------------------------------------
		// Gets the element x and y
		// --------------------------------------------------------------------
		var element = this.getElement();
		var content = this.getContents();

		var elx = 0;
		var ely = 0;
		var elpos = element.offset();

		//Make sure we have connections defined
		if (!elementConnection) {
			elementConnection = this.getElementCorner();
		}

		if (!contentConnection) {
			contentConnection = this.getContentsCorner();
		}

		switch (elementConnection[ 0 ]) {
			case "top":
				ely = elpos.top;
				break;
			case "bottom":
				ely = elpos.top + element.outerHeight();
				break;
		}

		switch (elementConnection[ 1 ]) {
			case "left":
				elx = elpos.left;
				break;
			case "right":
				elx = elpos.left + element.outerWidth();
				break;
		}
		/* eslint-disable eqeqeq */
		// --------------------------------------------------------------------
		// Offsets the x and y with the width and height of the contents
		// --------------------------------------------------------------------
		if (contentConnection[ 0 ] == "bottom") {
			ely = ely - content.outerHeight();
		}

		if (contentConnection[ 1 ] == "right") {
			elx = elx - content.outerWidth();
		}

		// --------------------------------------------------------------------
		// Compensate coordinates to be relative to parent instead of window
		// --------------------------------------------------------------------
		//This is a special case for IE7 when offsetParent returns the HTML tag which has offset of {top: 2, left: 2} even though it should be {top:0. left:0}.
		var parent = content.offsetParent();
		if (parent.length && parent.prop('tagName') === "HTML") {
			parent = $(document.body);
		}
		var x = elx - parent.offset().left;
		var y = 0;

		//windowTop is a special condition where the dialog contents will be hidden if flipped to the opposite side
		//so we use the top of the viewable area for the y offset.
		if (contentConnection[ 0 ] == "windowTop") {
			y = parent.offset().top;
		}
		else {
			y = ely - parent.offset().top;
		}
		/* eslint-enable eqeqeq */

		// --------------------------------------------------------------------
		// Updates the contents
		// --------------------------------------------------------------------
		if (this.getAlwaysOnTop()) {
			this.getContents().css("z-index", "100");
		}
		this.getContents().css("position", "absolute");
		this.getContents().css({
			left: x,
			top: y
		}).show();
	};

	// ________________________________________________________________________

	/**
	 * Displays the dialog
	 */
	prot.show = function() {
		if (this.getVisible()) {
			return;
		}
		/* eslint-disable no-unused-vars */
		// show it to calculate the position
		var self = this;
		/* eslint-enable no-unused-vars */
		this.beforeShow();
		this.getContents().css("display", "block");
		this.updatePosition(this.getElementCorner(), this.getContentsCorner());

		//Save a copy of the current connection corners for use when we attempt to flip the content
		this.setElementFlippedCorner(this.getElementCorner());
		this.setContentsFlippedCorner(this.getContentsCorner());
		this.autoFlipVertical();
		this.autoFlipHorizontal();
		this.autoSizeStatic();
		this.m_OnShow(this);
		this.setVisible(true);
	};

	// ________________________________________________________________________

	/**
	 * This function is used for passivity reasons and will call the updated autoFlipVertical function
	 */
	prot.autoFlipUp = function() {
		this.autoFlipVertical();
	};

	/**
	 * If the AutoFlipVertical is true and the content is close to the bottom of
	 * the viewport, this will move it to the top instead.  If it then does not fit in the top
	 * it will be positioned so that the top of the content is aligned with the top of the screen.
	 * If the contents still do not fit the content will be scrolled and a max-height will be set
	 * on the content element container.
	 */
	prot.autoFlipVertical = function() {
		var anchorVertical = "";
		//Check to see if we should attempt to auto flip
		if (!this.getAutoFlipVertical()) {
			return;
		}

		//Get the bottom edge of the window based on the scrolled position and the window height
		var windowEdge = $(window).scrollTop() + $(window).height();
		var contents = this.getContents();
		// If we have a flip reference, then we will use that as the edge instead of the window element
		if (this.getFlipReference()) {
			//May need to apply scrollTop() to the filp reference if it is scrolled
			windowEdge = this.getFlipReference().offset().top + parseInt(this.getFlipReference().outerHeight(), 10);
		}
		var contentHeight = parseInt(contents.outerHeight(), 10);
		var contentTop = contents.offset().top;
		var bottomEdge = contentTop + contentHeight;
		if (bottomEdge >= windowEdge) {
			/* eslint-disable eqeqeq */
			anchorVertical = (this.getElementFlippedCorner()[ 1 ] == this.getContentsFlippedCorner()[ 1 ]) ? "top" : "bottom";
			/* eslint-enable eqeqeq */
			if (contentTop <= contentHeight) {
				//Check to see if the dialog is larger than the screen.  If so we will scroll its content.
				if (contentHeight >= windowEdge) {
					//Reduce the size of the content container plus some padding
					contents.outerHeight(windowEdge - 10);
					//Expand the menu width to account for the scroll bar
					contents.outerWidth(contents.outerWidth() + 17);
					//Apply scrolling to the container
					contents.css("overflow-y", "auto");
				}
				//Flipping the content up will still hide some of the content so we will align it with the top of the screen
				this.setElementFlippedCorner([ anchorVertical, this.getElementFlippedCorner()[ 1 ] ]);
				this.setContentsFlippedCorner([ "windowTop", this.getContentsFlippedCorner()[ 1 ] ]);
				this.updatePosition(this.getElementFlippedCorner(), this.getContentsFlippedCorner());
			}
			else {
				//Flipping the menu up will let it show all of its contents
				this.setElementFlippedCorner([ anchorVertical, this.getElementFlippedCorner()[ 1 ] ]);
				this.setContentsFlippedCorner([ "bottom", this.getContentsFlippedCorner()[ 1 ] ]);
				this.updatePosition(this.getElementFlippedCorner(), this.getContentsFlippedCorner());
			}
		}
	};

	// ________________________________________________________________________


	/**
	 * If the AutoFlipHorizontal is true and the content is close to edge of
	 * the viewport, this will move it to the opposite side.
	 */
	prot.autoFlipHorizontal = function() {
		//Check to see if we should attempt to flip horizontally
		if (!this.getAutoFlipHorizontal()) {
			return;
		}

		//Get the viewport edge offsets
		var windowRightEdge = $(window).width();
		var windowLeftEdge = 0;
		var flipReference = this.getFlipReference();
		// if we have a flip reference, then we will use that as the edge instead
		if (flipReference) {
			windowLeftEdge = flipReference.offset().left;
			windowRightEdge = windowLeftEdge + parseInt(flipReference.outerWidth(), 10);
		}
		//Get the dialog edge offsets
		var dialogLeftEdge = this.getContents().offset().left;
		var dialogRightEdge = dialogLeftEdge + parseInt(this.getContents().outerWidth(), 10);

		//Flip the dialog if necessary
		if (dialogLeftEdge < windowLeftEdge) {
			//Dialog left edge is less than the viewport left edge so we will flip right
			this.updatePosition([ this.getElementFlippedCorner()[ 0 ], "right" ], [ this.getContentsFlippedCorner()[ 0 ], "left" ]);
		}
		else if (dialogRightEdge > windowRightEdge) {
			//Dialog right edge is greater than the viewport left edge so we will flip left
			this.updatePosition([ this.getElementFlippedCorner()[ 0 ], "left" ], [ this.getContentsFlippedCorner()[ 0 ], "right" ]);
		}
	};

	// ________________________________________________________________________

	/**
	 * If the AutoFlipVertical is false (meaning the menu will show statically
	 * below the anchor) then this will auto-size the menu such that it does not
	 * exceed the bottom of the window.
	 * @returns {undefined} Returns nothing.
	 */
	prot.autoSizeStatic = function() {
		/*
		 * If the detail dialog is set to auto-flip vertical, the adjustments
		 * have already been made in the autoFlipVertical function.
		 */
		if (this.getAutoFlipVertical()) {
			return;
		}
		var $contents = this.getContents();
		var contentsRect = $contents[ 0 ].getBoundingClientRect();
		var wHeight = window.innerHeight;
		if (contentsRect.bottom > wHeight) {
			$contents.css({
				"overflow": "auto",
				"height": (wHeight - contentsRect.top) + "px"
			});
		}
	};

	// ________________________________________________________________________

	/**
	 * Hides the dialog
	 */
	prot.hide = function() {
		if (!this.getVisible()) {
			return;
		}

		this.getContents().css("display", "none");
		this.setVisible(false);
		this.m_OnHide(this);
	};

	// ________________________________________________________________________

	/**
	 * Executed before showing the dialog. Is a wrapper for the beforeShow
	 * event.
	 */
	prot.beforeShow = function() {
		this.getBeforeShow()(this);
	};

	// ________________________________________________________________________

	/**
	 * Destroys the HTML elements inside the dialog, along with the dialog
	 * itself.
	 */
	prot.destroy = function() {
		if (this.getContents()) {
			this.getContents().remove();
		}
		this.setVisible(false);
		this.setCreated(false);
	};
})(jQuery);
/* global MPageObjectOriented */
/**
 * drop_down.js
 * @author Leonardo Sa
 *
 * DropDown Class
 * ============================================================================
 *
 * Abstract base for other drop down classes. Connects a detail dialog with a selector
 * in order to form a drop down like control. Also, makes it possible to change
 * or set a value by calling get/setValue.
 *
 */
/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */
	// -----------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.DropDown = function(element, contentsElement, defaultValue) {

		if (element) {
			this.setSelector(new ns.Selector(element, "selected", "unselected"));
		}

		if (contentsElement) {
			this.setContents(contentsElement);
		}

		this.setOnShow(function() {
		});
		this.setOnHide(function() {
		});
		this.setOnSelect(function() {
		});
		this.setDisabledCssClass("disabled");

		this.m_value = defaultValue;

		ns.Control.call(this, element);
	};

	inherits(ns.DropDown, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The DetailDialog that contains the menu content
	 */
	attribute(ns.DropDown, "DetailDialog");

	/**
	 * The selector that triggers the DetailDialog
	 */
	attribute(ns.DropDown, "Selector");

	/**
	 * Function to be executed when the drop down is shown
	 */
	attribute(ns.DropDown, "OnShow");

	/**
	 * Function to be executed when the drop down has been hidden
	 */
	attribute(ns.DropDown, "OnHide");

	/**
	 * Function to be executed when an item is selected
	 */
	attribute(ns.DropDown, "OnSelect");

	/**
	 * Whether the drop down will be clickable to be displayed or not
	 */
	attribute(ns.DropDown, "Enabled");

	/**
	 * Class to be added to the Selector when this control is disabled
	 */
	attribute(ns.DropDown, "DisabledCssClass");

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------

	var prot = ns.DropDown.prototype;

	/**
	 * Generates the root node with a tree of nodes and updates the contents
	 * of the DetailDialog with the generated <ul>s from the Node.
	 */
	prot.init = function() {
		this.setDetailDialog(new ns.DetailDialog(this.getElement(), this.getContents()));

		if (!this.getSelector()) {
			this.setSelector(new ns.Selector(this.getElement(), "selected", "unselected"));
		}

		var self = this;
		this.getSelector().setOnSelect(function() {
			self.getDetailDialog().show();
		});

		this.getSelector().setOnUnselect(function() {
			self.getDetailDialog().hide();
		});

		this.getDetailDialog().setOnShow(function() {
			// make sure this will be above everyone else
			self.getDetailDialog().getContents().css("z-index", "7000");
			self.onShow();
		});

		this.getDetailDialog().setOnHide(function() {
			self.m_OnHide(self);
		});

		// this is needed to force updating the value of the textbox
		this.setValue(this.getValue());
	};

	// ________________________________________________________________________

	prot.setValue = function(value) {
		this.m_value = value;

		if (this.getElement()) {
			this.getElement().html(value);
		}
	};

	// ________________________________________________________________________

	prot.onShow = function() {
		this.m_OnShow(this);
	};

	// ________________________________________________________________________

	prot.getValue = function() {
		if (!this.getDetailDialog()) {
			return "";
		}

		return this.m_value;
	};

	// ________________________________________________________________________

	/**
	 * Shows the drop down list
	 */
	prot.show = function() {
		if (!this.getDetailDialog()) {
			return;
		}

		this.getDetailDialog().show();
	};

	// ________________________________________________________________________

	/**
	 * Hides the drop down list
	 */
	prot.hide = function() {
		if (!this.getDetailDialog()) {
			return;
		}

		this.getDetailDialog().hide();
		this.getSelector().unselect();
	};

	// ________________________________________________________________________

	/**
	 * Erases the drop down list from the DOM
	 */
	prot.destroy = function() {
		if (!this.getDetailDialog() || !this.getElement()) {
			return;
		}

		this.getDetailDialog().destroy();
		this.getElement().remove();
	};

	// ________________________________________________________________________

	prot.disable = function() {
		this.m_Enabled = false;
		this.hide();
		this.getSelector().setEnabled(false);
		this.getSelector().getElement().addClass(this.getDisabledCssClass());
	};

	// ________________________________________________________________________

	prot.enable = function() {
		this.m_Enabled = true;
		this.getSelector().setEnabled(true);
		this.getSelector().getElement().removeClass(this.getDisabledCssClass());
	};

	// ________________________________________________________________________

	prot.setEnabled = function(val) {
		if (val) {
			this.enable();
		} else {
			this.disable();
		}
	};

})(jQuery);
/* global MPageObjectOriented */
/**
 * drop_down_list.js
 * @author Leonardo Sa
 *
 * DropDownNested Class
 * ============================================================================
 *
 * Renders a drop down list attached to the specified element.
 * The drop down list data can be provided in the form of a tree, causing the actual
 * drop down menu to appear nested into different levels. The tree format must
 * follow the standard set on DropDownNested.Node class.
 *
 * It uses a DetailDialog as the generator for the list. Therefore, to change
 * its position, one can change the associated DetailDialog alignment.
 *
 */
(function($) {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var attribute = MPageObjectOriented.createAttribute;
	var inherits = MPageObjectOriented.inherits;

	// -----------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.DropDownNested = function(element, tree) {
		this.setSelector(new ns.Selector(element, "selected", "unselected"));
		this.setOnShow(function() {
		});
		this.setOnHide(function() {
		});
		this.setOnSelect(function() {
		});
		this.setTree(tree);

		ns.Control.call(this, element);
	};

	inherits(ns.DropDownNested, ns.Control);
	var prot = ns.DropDownNested.prototype;

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The DetailDialog that contains the menu content
	 */
	attribute(ns.DropDownNested, "DetailDialog");

	/**
	 * The selector that triggers the DetailDialog
	 */
	attribute(ns.DropDownNested, "Selector");

	/**
	 * Data for the list
	 */
	attribute(ns.DropDownNested, "Tree");

	/**
	 * Root node element of the tree, once the tree is parsed
	 */
	attribute(ns.DropDownNested, "RootNode");

	/**
	 * Function to be executed when the drop down is shown
	 */
	attribute(ns.DropDownNested, "OnShow");

	/**
	 * Function to be executed when the drop down has been hidden
	 */
	attribute(ns.DropDownNested, "OnHide");

	/**
	 * Function to be executed when an item is selected
	 */
	attribute(ns.DropDownNested, "OnSelect");

	/**
	 * Returns the current selected node in the tree. It is
	 * updated by the select() method.
	 */
	attribute(ns.DropDownNested, "SelectedNode");

	// ------------------------------------------------------------------------
	// Inner Classes
	// ------------------------------------------------------------------------

	/**
	 * Represents a single node in a tree structure.
	 *
	 * This constructor will build an entire node tree according to JsonData
	 * and the provided arguments. If you are making a root node, parentNode
	 * can be null. ParentDropDown will be the same for all nodes in the tree.
	 *
	 * JsonData needs to be provided according to the following standard:
	 *
	 * var jsonData = {
	 *     name: "root",
	 *     children: [
	 *          {name: "Child 1" },
	 *          {
	 *           name: "Child 2",
	 *           children: [ ... ]
	 *          }
	 *     ]
	 * }
	 *
	 * @param {Object} jsonData
	 * @param {Object} parentNode
	 * @param {Object} parentDropDown
	 */
	ns.DropDownNested.Node = function(jsonData, parentNode, parentDropDown) {
		this.children = [];
		this.parent = parentNode;
		this.dropDown = parentDropDown;
		var self = this;

		$.each(jsonData, function(k, v) {
			/* eslint-disable eqeqeq */
			if (k == "children") {
				/* eslint-enable eqeqeq */
				$.each(v, function() {
					self.children.push(new ns.DropDownNested.Node(this, self, parentDropDown));
				});
			}
			else {
				self[ k ] = v;
			}
		});
	};

	// ________________________________________________________________________

	/**
	 * Appends a series of nested lists of <ul> and <li> tags based on the tree
	 * structure of the current node. Also, attaches dropdown.select() to the
	 * on click event of each <li>.
	 *
	 * @param {Object} parentElement
	 */
	ns.DropDownNested.Node.prototype.makeElement = function(parentElement) {
		var current = $("<li></li>").html(this.name);
		var self = this;
		$(current).click(function() {
			self.dropDown.select(self);
		});
		parentElement.append(current);

		var rootUl = "";
		if (this.children.length > 0) {
			rootUl = $("<ul></ul>");
			$.each(this.children, function() {
				this.makeElement(rootUl);
			});
		}
		parentElement.append(rootUl);

		return current;
	};

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------

	/**
	 * Generates the root node with a tree of nodes and updates the contents
	 * of the DetailDialog with the generated <ul>s from the Node.
	 */
	prot.init = function() {
		this.setRootNode(new ns.DropDownNested.Node(this.getTree(), null, this));
		var id = "controlContents" + this.getControlId();
		var rootUl = $("<ul></ul>");
		this.getRootNode().makeElement(rootUl);

		// we exclude the root node here
		var menuContent = $("<div></div>");
		menuContent.attr("id", id);
		menuContent.append(rootUl.children("ul"));
		menuContent.appendTo($("body"));

		this.setDetailDialog(new ns.DetailDialog(this.getElement(), menuContent));
		var self = this;
		this.getSelector().setOnSelect(function() {
			self.getDetailDialog().show();
		});
		this.getSelector().setOnUnselect(function() {
			self.getDetailDialog().hide();
		});
		this.getDetailDialog().setOnShow(function() {
			// make sure this will be above everyone else
			self.getDetailDialog().getContents().css("z-index", "7000");
			self.m_OnShow(self);
		});
		this.getDetailDialog().setOnHide(function() {
			self.m_OnHide(self);
		});
	};

	// ________________________________________________________________________

	/**
	 * Marks a node as selected, causing the drop down list to hide and its
	 * value to change.
	 *
	 * @param {Object} node
	 */
	prot.select = function(node) {
		this.getElement().html(node.name);
		this.setSelectedNode(node);
		this.getSelector().unselect();
		this.m_OnSelect(node);
	};

	// ________________________________________________________________________

	/**
	 * Shows the drop down list
	 */
	prot.show = function() {
		this.getDetailDialog().show();
	};
	// ________________________________________________________________________

	/**
	 * Hides the drop down list
	 */
	prot.hide = function() {
		this.getDetailDialog().hide();
	};
	// ________________________________________________________________________

	/**
	 * Erases the drop down list from the DOM
	 */
	prot.destroy = function() {
		this.getDetailDialog().destroy();
		this.getElement().remove();
	};
})(jQuery);
/* global MPageObjectOriented */
/**
 * drop_down_list.js
 * @author Leonardo Sa
 *
 * DropDownTree Class
 * ============================================================================
 *
 * Renders a detail dialog which contains a tree, usually used to lazy load
 * folders. The main difference between this control and the drop down list
 * is that this control can expand and controct folders, and perform ajax
 * calls for the folders
 *
 */

(function($) {
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var DropDown = MPageControls.DropDown;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	/* eslint-disable no-unused-vars */
	var Tree = MPageControls.Tree;
	/* eslint-enable no-unused-vars */

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.DropDownTree = function(element) {
		this.setTreeCreated(false);
		this.setOnSelect(function() {
		});
		this.setOnCreate(function() {

		});
		DropDown.call(this, element, null);
	};

	inherits(ns.DropDownTree, DropDown);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------
	attribute(ns.DropDownTree, "Tree");
	attribute(ns.DropDownTree, "TreeCreated");
	attribute(ns.DropDownTree, "OnLazyRead");
	attribute(ns.DropDownTree, "OnCreate");
	attribute(ns.DropDownTree, "OnSelect");

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.DropDownTree.prototype;

	prot.init = function() {
		var content = $("<div></div>");

		content.appendTo(this.getElement().offsetParent());
		content.attr("id", "content" + this.getControlId());
		this.setContents(content);

		DropDown.prototype.init.call(this);

		var self = this;
		this.getDetailDialog().setBeforeShow(function() {
			self.beforeShow();
		});

	};

	prot.setTreeElement = function(element) {
		this.mTreeElement = MPageControls.getId(element);
	};

	prot.getTreeElement = function() {
		return MPageControls.fromId(this.mTreeElement);
	};

	// ________________________________________________________________________

	prot.create = function() {
		var self = this;
		var treeElement = $("<div class='dynatree'></div>").appendTo(this.getContents());
		var id = "treeElement" + this.getControlId();
		treeElement.attr("id", id);

		this.setTreeElement(treeElement);
		this.setTree(new MPageControls.Tree(this.getTreeElement()));
		this.getTree().setOnSelect(function(node) {
			self.onSelect(node);
		});
		this.getOnCreate()();
		this.setTreeCreated(true);
	};

	// ________________________________________________________________________

	prot.onSelect = function(node) {
		this.setValue(node.data.title);
		this.getSelector().unselect();
	};

	// ________________________________________________________________________

	/**
	 * Returns the node that has been selected by the user mouse click
	 */
	prot.getSelectedNode = function() {
		if (this.getTree() === null || this.getTree() === undefined) {
			return null;
		}

		return this.getTree().getSelectedNode();
	};
	// ________________________________________________________________________

	/**
	 * Is executed before the tree is shown, and automatically triggers lazy
	 * loading if the tree hasn't been initialized yet.
	 */
	prot.beforeShow = function() {
		if (this.getTreeCreated()) {
			return;
		}

		this.create();
		if (this.getOnLazyRead()) {
			this.getTree().setOnLazyRead(this.getOnLazyRead());
		}
	};

})(jQuery);
/* global MPageObjectOriented */
/* eslint-disable no-unused-vars */
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	/* eslint-enable no-unused-vars */
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------


	/**
	 * Serves as a generic container for any functionality that can be applied
	 * to a range of controls
	 */
	ns.Group = function() {
		this.setControls([]);
		this.setCurrent(null);
	};

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * An array of mpage controls  or any other object that has select() and
	 * unselect() methods
	 */
	attribute(ns.Group, "Controls");

	/**
	 * The control(s) that are/is currently selected.
	 */
	attribute(ns.Group, "Current");

	// ------------------------------------------------------------------------
	// Member methods
	// ------------------------------------------------------------------------

	var prot = ns.Group.prototype;

	/**
	 * Appends a new control to the controls array
	 */
	prot.add = function(control) {
		this.getControls().push(control);
	};

	// ________________________________________________________________________

	/**
	 * Loops through the control array and executes unselect() on all the
	 * controls that are different than the one specified in the argument.
	 * Control.select() will then be performed.
	 *
	 *  @param control the control to be selected
	 */
	prot.selectSingle = function(control) {
		this.unselectAllExcept(control);
		control.select();
	};

	// ________________________________________________________________________

	/**
	 * Calls unselect on all controls except the one specified in the parameter
	 */
	prot.unselectAllExcept = function(control) {
		var controls = this.getControls();

		for (var i = controls.length; i--;) {
			/* eslint-disable eqeqeq */
			if (controls[ i ].unselect && controls[ i ] != control) {
				/* eslint-enable eqeqeq */
				controls[ i ].unselect();
			}
		}

		this.setCurrent(control);
	};

	// ________________________________________________________________________

	/**
	 * Executes fun for each item in the group
	 * @param fun
	 */
	prot.each = function(fun) {
		var controls = this.getControls();
		for (var i = controls.length; i--;) {
			fun(controls[ i ]);
		}
	};

})(jQuery);
/* global MPageObjectOriented */
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.List = function(element) {
		var self = this;

		ns.Control.call(this, element);
		this.setSelectedIndex(-1);
		this.setSelectedOption(0);
		this.setListTemplate(MPageControls.getDefaultTemplates().list);
		this.setItemTemplate(MPageControls.getDefaultTemplates().listItem);
		this.setHighlightClass("current");
		this.setSelectedOptionClass("selected-option");
		this.setOnSelect(function() {
		});
		this.setOnMoveUp(function() {
		});
		this.setOnMoveDown(function() {
		});
		this.setOnKeyDown(function() {
		});
		this.setOnDblClick(function() {
		});

		// By default, when pressing the enter key the control will perform
		// a select. This can be changed by the user by setting another
		// onEnter function.
		this.setOnEnter(function() {
			self.select(self.getSelectedIndex());
		});
	};

	inherits(ns.List, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------
	attribute(ns.List, "SelectedIndex");
	attribute(ns.List, "ListTemplate");
	attribute(ns.List, "ItemTemplate");
	attribute(ns.List, "Items");
	attribute(ns.List, "OnSelect");
	attribute(ns.List, "OnMoveUp");
	attribute(ns.List, "OnMoveDown");
	attribute(ns.List, "OnEnter");
	attribute(ns.List, "OnKeyDown");
	attribute(ns.List, "OnDblClick");
	attribute(ns.List, "HighlightClass");
	attribute(ns.List, "DisplayKey");
	attribute(ns.List, "SelectedOption");
	attribute(ns.List, "SelectedOptionClass");


	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.List.prototype;

	prot.init = function() {

	};

	/**
	 * Can be overriden to provide custom item processing logic
	 */
	prot.makeItem = function(item) {
		if (!item.content) {
			item.content = item[ this.getDisplayKey() ];
		}

		return item;
	};

	// ________________________________________________________________________

	/**
	 * Highlights the item placed before the currently selected item
	 */
	prot.moveUp = function() {
		if (this.getSelectedIndex() <= 0) {
			this.setSelectedIndex(0);
		}
		else {
			this.setSelectedIndex(this.getSelectedIndex() - 1);
		}
		var listDiv = $(this.getElement()).children();
		//Scroll up when current item is at the top
		var index = this.getSelectedIndex();
		var curItemDiv = listDiv.children().eq(index);
		//Calculate distance from item's top to list's top
		var itemTopY = curItemDiv.position().top;
		if (itemTopY < 0) {
			listDiv.scrollTop(listDiv.scrollTop() + itemTopY);
		}
		this.highlight(index);
		this.getOnMoveUp()(this.getSelectedItem());
	};

	// ________________________________________________________________________

	/**
	 * Highlights the item placed after the currently selected item
	 */
	prot.moveDown = function() {
		if (this.getSelectedIndex() >= this.getItems().length - 1) {
			this.setSelectedIndex(this.getItems().length - 1);
		}
		else {
			this.setSelectedIndex(this.getSelectedIndex() + 1);
		}
		var listDiv = $(this.getElement()).children();
		//Scroll down when current item is at the bottom
		var index = this.getSelectedIndex();
		var curItemDiv = listDiv.children().eq(index);
		//Calculate distance from item's bottom to list's bottom
		var itemBottomYDistance = curItemDiv.position().top + curItemDiv.outerHeight(true) - listDiv.height();
		if (itemBottomYDistance > 0) {
			listDiv.scrollTop(listDiv.scrollTop() + itemBottomYDistance);
		}

		this.highlight(index);
		this.getOnMoveDown()(this.getSelectedItem());
	};

	// ________________________________________________________________________

	/**
	 * Highlights the item at the specified index.
	 *
	 * @param {int} index The index to be selected
	 */
	prot.highlight = function(index) {
		// Removes highlight from other items
		this.getElement().find("." + this.getHighlightClass()).removeClass(this.getHighlightClass());

		// Adds highlight to the current element
		this.getElement().find("#" + this.getIdByIndex(index)).addClass(this.getHighlightClass());
	};

	// ________________________________________________________________________

	/**
	 *Highlight s the current selected option
	 *
	 *@param {int} index The index to be selected
	 */

	prot.highlightSelectedOption = function(index) {
		var selectedOption = this.getSelectedOption();
		// When the list is clicked for the first time, highlight the current option
		if (index < 0 && selectedOption === 0) {
			this.getElement().find("#" + this.getIdByIndex(selectedOption)).addClass(this.getSelectedOptionClass());
			this.getElement().find("#" + this.getIdByIndex(index)).removeClass(this.getSelectedOptionClass());
		}
		//When any item other than the first one is selected.
		if (index > 0 || selectedOption > 0) {
			this.getElement().find(".selected-item").removeClass(this.getSelectedOptionClass());
			this.getElement().find("#" + this.getIdByIndex(selectedOption)).addClass(this.getSelectedOptionClass());
		}
	};

	/**
	 * Get the current item. Index <=-1 assume not item is selected, so it will return null
	 */
	prot.getSelectedItem = function() {
		if (this.getSelectedIndex() <= -1) {
			return null;
		}

		var items = this.getItems();

		return items[ this.getSelectedIndex() ];
	};

	/**
	 * Highlights and marks the provided item as the selected one.
	 * Will not trigger any events.
	 *
	 * @param item
	 */
	prot.setSelectedItem = function(item) {
		var index = this.getItemIndex(item);
		this.setSelectedIndex(index);
		this.highlight(index);
	};

	/**
	 * Returns the position of the provided item in the list
	 *
	 * @param item
	 */
	prot.getItemIndex = function(item) {
		var items = this.getItems();
		for (var i = items.length; i--;) {
			/* eslint-disable eqeqeq */
			if (items[ i ] == item) {
				/* eslint-enable eqeqeq */
				return i;
			}
		}
		return -1;
	};

	// ________________________________________________________________________

	prot.renderItems = function(items) {
		var self = this;
		this.setItems(items);
		this.setSelectedIndex(-1);

		// --------------------------------------------------------------------
		// Render items
		// --------------------------------------------------------------------
		var renderedItems = [];
		$.each(items, function(i, item) {
			item = self.makeItem(item);
			/* eslint-disable no-underscore-dangle */
			item._elementId = self.getIdByIndex(i);
			/* eslint-enable no-underscore-dangle */
			var rendered = self.getItemTemplate().render(item);
			renderedItems.push(rendered);

			// Attaches the click event of the item to the select method
			rendered.click(function() {
				(function(index) {
					self.select(index);
				})(i);
			});

			// Attaches the click event of the item to the select method
			rendered.dblclick(function() {
				(function(index) {
					self.doubleClick(index);
				})(i);
			});

		});

		// --------------------------------------------------------------------
		// Renders the list
		// --------------------------------------------------------------------
		var list = this.getListTemplate().render({
			"items": renderedItems,
			"listId": this.getListId()
		});
		this.getElement().empty();
		this.getElement().append(list);

		// --------------------------------------------------------------------
		// Attaches key press events
		// --------------------------------------------------------------------
		list.keydown(function(e) {
			self.processKeyEvent(e);
		});
	};

	// ________________________________________________________________________

	prot.processKeyEvent = function(e) {
		this.getOnKeyDown()(e);
		switch (e.keyCode) {
			case (40):
				e.preventDefault();
				this.moveDown();
				break;
			case (38):
				e.preventDefault();
				this.moveUp();
				break;
			case (13):
				this.getOnEnter()();
				break;
		}
	};

	// ________________________________________________________________________

	prot.select = function(index) {
		if (typeof index === "undefined" || index === null) {
			index = this.getSelectedIndex();
		}
		this.setSelectedIndex(index);
		this.highlight(index);
		this.getOnSelect()(this.getSelectedItem());
		this.setSelectedOption(index);
	};

	// ________________________________________________________________________
	/* eslint-disable no-unused-vars */
	prot.doubleClick = function(index) {
		/* eslint-enable no-unused-vars */
		//doesn't need to set index or highlight, because onclick -> select function will do it.  
		this.getOnDblClick()(this.getSelectedItem());
	};


	// ________________________________________________________________________

	prot.getIdByIndex = function(index) {
		return "controls_" + this.getControlId() + "_" + index;
	};
	// ________________________________________________________________________

	prot.getListId = function() {
		return "controls_" + this.getControlId() + "_list";
	};
	// ________________________________________________________________________

	prot.focus = function() {
		$("#" + this.getListId()).focus();
	};
	// ________________________________________________________________________

	prot.destroy = function() {
		this.getElement().remove();
	};
})(jQuery);
/* global MPageObjectOriented */
/**
 * drop_down_list.js
 * @author Leonardo Sa
 *
 * Modeless Class
 * ============================================================================
 *
 * Renders a drop down list attached to the specified element. The only difference
 * between this class and the detaildialog class is that modeless windows can only
 * be opened one at a time.
 *
 */
/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var oo = MPageObjectOriented;
	var inherits = oo.inherits;
	var attribute = oo.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.Modeless = function(element, contentsElement) {
		this.setOnForceHide(function() {
		});
		ns.DetailDialog.call(this, element, contentsElement);
	};

	/**
	 * hides the last shown modeless instance
	 */
	ns.Modeless.hide = function() {

		if (ns.Modeless.visibleInstance && ns.Modeless.visibleInstance.getVisible()) {
			ns.Modeless.visibleInstance.hide();
			ns.Modeless.visibleInstance.getOnForceHide()();
		}
	};


	ns.Modeless.visibleInstance = null;
	inherits(ns.Modeless, ns.DetailDialog);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * Callback executed when the modeless is forced to hide because another
	 * one is about to be shown
	 */
	attribute(ns.Modeless, "OnForceHide");

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------
	var prot = ns.Modeless.prototype;

	prot.show = function() {
		ns.Modeless.hide();
		ns.DetailDialog.prototype.show.call(this);
		ns.Modeless.visibleInstance = this;
	};

})(jQuery);
/* global MPageObjectOriented */

/**
 * selector.js
 * @author Leonardo Sa
 *
 * Selector class
 * ============================================================================
 * A simple selector that alternates between two css classes on click, much
 * like a checkbox would do. The css styles can be specified in the constructor.
 */
/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */
	// -----------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.Selector = function(element, selClass, unselClass) {
		this.setIsSelected(false);
		this.setEnabled(true);
		this.setSelectedClass(selClass);
		this.setUnselectedClass(unselClass);
		this.setUnselectOnClickEnabled(true);
		this.setOnSelect(function() {
		});
		this.setOnUnselect(function() {
		});
		this.setDisabledClass("dithered");

		ns.Control.call(this, element);
	};

	// -----------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The CSS class to be applied to the element when it is selected
	 */
	attribute(ns.Selector, "SelectedClass");

	/**
	 * The CSS class to be applied to the element when it is unselected
	 */
	attribute(ns.Selector, "UnselectedClass");

	/**
	 * Whether the control has been selected or not
	 */
	attribute(ns.Selector, "IsSelected");

	/**
	 * Event fired on select
	 */
	attribute(ns.Selector, "OnSelect");

	/**
	 * Event fired on unselect
	 */
	attribute(ns.Selector, "OnUnselect");

	/**
	 * Whether the star will toggle when clicked on
	 */
	attribute(ns.Selector, "Enabled");

	/**
	 * CSS class to be applied to the element when it is set to enabled = false.
	 * Defaults to "dithered". The class will be removed once the element is enabled.
	 */
	attribute(ns.Selector, "DisabledClass");

	/**
	 * If set to false, the selector will not unselect after it is
	 * selected on a click event. Direct calls to select() will
	 * still work.
	 */
	attribute(ns.Selector, "UnselectOnClickEnabled");

	inherits(ns.Selector, ns.Control);
	var prot = ns.Selector.prototype;

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------

	prot.init = function() {
		var self = this;
		this.getElement().addClass(this.getUnselectedClass());
		this.bind("click", this.getElement(), function() {
			if (self.getIsSelected() && !self.getUnselectOnClickEnabled()) {
				return;
			}

			if (self.getEnabled()) {
				self.toggle();
			}
		});

		if (this.getIsSelected()) {
			this.performSelection();
		}
		else {
			this.performUnselection();
		}
	};

	// ________________________________________________________________________

	/**
	 * Toggles the selector to select() or unselect()
	 */
	prot.toggle = function() {
		if (this.getIsSelected()) {
			this.unselect();
		}
		else {
			this.select();
		}
	};

	// ________________________________________________________________________

	/**
	 * Triggers the selection of the control
	 */
	prot.select = function() {
		if (this.getIsSelected()) {
			return;
		}

		this.performSelection();
		this.m_OnSelect(this);
	};

	// ________________________________________________________________________

	prot.performSelection = function() {
		if (this.getUnselectedClass() !== undefined) {
			this.getElement().removeClass(this.getUnselectedClass());
		}

		this.getElement().addClass(this.getSelectedClass());
		this.setIsSelected(true);
	};

	// ________________________________________________________________________

	/**
	 * Triggers the unselection of the control
	 */
	prot.unselect = function() {
		if (!this.getIsSelected()) {
			return;
		}

		this.performUnselection();
		this.m_OnUnselect(this);
	};

	// ________________________________________________________________________

	prot.performUnselection = function() {
		
		if(!this.getElement()){
			return;
		}
		if (this.getSelectedClass() !== undefined) {
			this.getElement().removeClass(this.getSelectedClass());
		}

		this.getElement().addClass(this.getUnselectedClass());
		this.setIsSelected(false);
	};

	// ________________________________________________________________________

	prot.destroy = function() {
		this.destroyEvents();
	};

	// ________________________________________________________________________

	prot.setEnabled = function(value) {
		this.m_Enabled = value;

		if (!this.getElement()) {
			return;
		}

		if (value) {
			this.getElement().removeClass(this.getDisabledClass());
		} else {
			this.getElement().addClass(this.getDisabledClass());
		}
	};

})(jQuery);
/* global MPageObjectOriented, TemplateBuilder */
(function($) {
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	/**
	 * A control that represents a single tab, which can be added to a tab
	 * group.
	 */
	ns.Tab = function() {
		this.setButtonTemplate(null);
		this.setButtonSelectedClass("selected");
		this.setContentUnselectedClass("hidden");
		this.setOnSelect(function() {
		});
		this.setOnUnselect(function() {
		});
		this.setOnRender(function() {
		});
		this.setEnabled(true);

		ns.Control.call(this, null);
	};

	inherits(ns.Tab, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The name of the tab. It is not used by this class itself, but is a
	 * standardized way for derived class to set the title.
	 */
	attribute(ns.Tab, "Title");

	/**
	 * A selector that represents the button which the user will click to
	 * select the tab.
	 */
	attribute(ns.Tab, "Button");

	/**
	 * A selector that represents the contents of the tab
	 */
	attribute(ns.Tab, "Content");

	/**
	 * A string-template that will be used when rendering the button
	 */
	attribute(ns.Tab, "ButtonTemplate");

	/**
	 * The CSS class to be applied when the tab button is selected. Will
	 * default to "selected"
	 */
	attribute(ns.Tab, "ButtonSelectedClass");

	/**
	 * The CSS class to be applied when a tab is not selected. Will default to
	 * "hidden"
	 */
	attribute(ns.Tab, "ContentUnselectedClass");

	/**
	 * Callback executed whenever the tab is selected.
	 */
	attribute(ns.Tab, "OnSelect");

	/**
	 * Callback executed whenever the tab is unselected
	 */
	attribute(ns.Tab, "OnUnselect");

	/**
	 * Whether the tab can be selected or not
	 */
	attribute(ns.Tab, "Enabled");

	/**
	 * Callback executed whenever the tab is rendered. Tabs are initially
	 * rendered all at the same time, hence lazy loading functions should be
	 * placed inside OnSelect instead.
	 */
	attribute(ns.Tab, "OnRender");


	/**
	 * The tab group that this tab belongs to
	 */
	attribute(ns.Tab, "TabGroup");

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------

	var prot = ns.Tab.prototype;

	/**
	 * Returns the ID to be used for the button div
	 */
	prot.getButtonId = function() {
		return "control_" + this.getControlId() + "_button";
	};

	// ________________________________________________________________________

	/**
	 * Returns the ID to be used for the content div
	 */
	prot.getContentId = function() {
		return "control_" + this.getControlId() + "_content";
	};

	// ________________________________________________________________________

	/**
	 * When set to true, the user will not be able to click the tab button
	 */
	prot.setEnabled = function(isEnabled) {
		this.m_Enabled = isEnabled;
		if (this.getButton()) {
			this.getButton().setEnabled(isEnabled);
		}
	};

	// ________________________________________________________________________

	/**
	 * Creates a blank div in the target, where its id is
	 * control_[controlid]_button, and appends that div to targetId. Then
	 * creates a Selector with the newly created div, and sets that as the
	 * Button instance variable. Finally, renders the template set in
	 * buttonTemplate into the div.
	 *
	 * @param targetId the ID of the element that will contain the button
	 */
	prot.renderButton = function(targetId) {
		var template = TemplateBuilder.buildTemplate(this.getButtonTemplate());
		var self = this;

		// button html
		var html = template.render({
			"tab": this,
			"tabButtonId": this.getButtonId()
		});
		$("#" + targetId).append(html);
		var btnDiv = $("#" + this.getButtonId());

		if (!btnDiv.length) {
			// there is no button. This might happen if the template was empty
			this.setButton(undefined);
			return;
		}

		// button selector instance
		var selector = new ns.Selector(btnDiv);
		selector.setSelectedClass(this.getButtonSelectedClass());
		selector.setUnselectOnClickEnabled(false);
		selector.setOnSelect(function() {
			self.select();
		});
		selector.performUnselection();

		this.setButton(selector);
	};

	// ________________________________________________________________________

	/**
	 * Creates a blank div in the target, where its id is [controlid]_content,
	 * and appends that div to targetId. Then creates a Selector with the newly
	 * created div, and sets that as the Content instance variable.
	 *
	 * @param targetId the ID of the element that will contain the content
	 */
	prot.renderContent = function(targetId) {
		var contentDiv = $("<div id='" + this.getContentId() + "'></div>");
		$("#" + targetId).append(contentDiv);
		this.setElement(contentDiv);
		var selector = new ns.Selector(contentDiv);
		selector.setUnselectedClass(this.getContentUnselectedClass());
		selector.setEnabled(false);
		selector.performUnselection();
		this.setContent(selector);
	};

	// ________________________________________________________________________

	/**
	 * Calls renderButton and renderContents with their respective arguments
	 */
	prot.render = function(targetButtonId, targetContentId) {
		this.renderButton(targetButtonId);
		this.renderContent(targetContentId);
		this.getOnRender()();
	};

	// ________________________________________________________________________

	/**
	 * Makes the current tab visible
	 */
	prot.select = function() {
		var button = this.getButton();
		if (button !== undefined) {
			button.performSelection();
		}
		if (this.getTabGroup()) {
			this.getTabGroup().unselectAllExcept(this);
		}
		this.getContent().performSelection();
		this.getOnSelect()();
	};

	// ________________________________________________________________________

	/**
	 * Hides the current tab
	 */
	prot.unselect = function() {
		var button = this.getButton();
		if (button !== undefined) {
			button.unselect();
		}
		this.getContent().unselect();
		this.getOnUnselect()();
	};

})(jQuery);
/* global MPageObjectOriented */
/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------

	/**
	 * Extends the Group class, and assists on rendering a group of tabs and
	 * ensuring only one is displayed at a time.
	 *
	 * Example:
	 *
	 * var tab1 = new Tab();
	 * tab1.setButtonTemplate("<div id=${tabButtonId}>CLICK ME!</div>");
	 *
	 * var tab2 = new Tab();
	 * tab2.setTitle("my tab name");
	 * tab2.setButtonTemplate("<div id=${tabButtonId}> ${tab.getTitle()} </div>");
	 *
	 * var group = new TabGroup();
	 * group.addTab(tab1);
	 * group.addTab(tab2);
	 *
	 * group.setButtonsContainerId("an_id_to_store_the_buttons");
	 * group.setContentsContainerId("an_id_to_store_the_contents");
	 * group.render();
	 *
	 * tab1.getContentsElement().html("<div> some content </div>");
	 * tab2.getContentsElement().html("<div> some other tab </div>");
	 */
	ns.TabGroup = function() {
		ns.Group.call(this);

		this.setFirstTabCSSClass("first");
		this.setLastTabCSSClass("last");
	};

	inherits(ns.TabGroup, ns.Group);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * The ID of the HTML element which will contain all the tab buttons
	 */
	attribute(ns.TabGroup, "ButtonsContainerId");

	/**
	 * The ID of the HTML element which will hold the tab contents
	 */
	attribute(ns.TabGroup, "ContentsContainerId");

	/**
	 * A string template to be used when rendering a single button
	 */
	attribute(ns.TabGroup, "DefaultButtonTemplate");

	/**
	 * A CSS class to be added to the first tab in the list
	 */
	attribute(ns.TabGroup, "FirstTabCSSClass");

	/**
	 * A CSS class to be added to the last tab in the list
	 */
	attribute(ns.TabGroup, "LastTabCSSClass");

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------

	var prot = ns.TabGroup.prototype;

	/**
	 * Will cycle through the controls array, and execute the render method on
	 * each, passing buttonsContainerId and contentsContainerId as arguments.
	 * If the control (tab) does not have a buttonTemplate, the
	 * defaultButtonTemplate will be set as the template.
	 */
	prot.render = function() {
		var controls = this.getControls();
		var firstTabElement = null;
		var lastTabElement = null;

		for (var i = 0; i < controls.length; i++) {
			var tab = controls[ i ];
			if (tab.getButtonTemplate() === null) {
				tab.setButtonTemplate(this.getDefaultButtonTemplate());
			}

			tab.render(this.getButtonsContainerId(),
				this.getContentsContainerId());

			// no button? then we're done.
			if (tab.getButton() === undefined) {
				continue;
			}

			// identifies the first and last rendered tabs
			var tabElement = tab.getButton().getElement();
			if (firstTabElement === null) {
				firstTabElement = tabElement;
			}
			lastTabElement = tabElement;

			tab.setTabGroup(this);

		}

		// adds the CSS classes for first and last tabs
		var firstCssClass = this.getFirstTabCSSClass();
		var lastCssClass = this.getLastTabCSSClass();

		if (firstTabElement !== null && firstCssClass !== null) {
			firstTabElement.addClass(firstCssClass);
		}
		if (lastTabElement !== null && lastCssClass !== null) {
			lastTabElement.addClass(lastCssClass);
		}
	};

	// ________________________________________________________________________

	/**
	 * Executes a function in each control
	 */
	prot.eachControl = function(fun) {
		var controls = this.getControls();
		for (var i = controls.length; i--;) {
			fun(controls[ i ]);
		}
	};

	// ________________________________________________________________________	

	/**
	 * Sets the enabled attribute of all controls to false
	 */
	prot.disableAll = function() {
		this.eachControl(function(control) {
			if (control.setEnabled) {
				control.setEnabled(false);
			}
		});
	};

	// ________________________________________________________________________

	/**
	 * Sets the enabled attribute of all controls to true
	 */
	prot.enableAll = function() {
		this.eachControl(function(control) {
			if (control.setEnabled) {
				control.setEnabled(true);
			}
		});
	};

	// ________________________________________________________________________

	/**
	 * Adds a new tab to be rendered
	 */
	prot.addTab = function(tab) {
		this.getControls().push(tab);
	};

})(jQuery);
/* global MPageObjectOriented */
/**
 * @author LS025469
 */
/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	ns.TextHighlighter = function(element) {
		this.setClass("highlight");
		this.setTag("span");

		ns.Control.call(this, element);
	};

	inherits(ns.TextHighlighter, ns.Control);

	attribute(ns.TextHighlighter, "Tag");
	attribute(ns.TextHighlighter, "Class");
	attribute(ns.TextHighlighter, "OnHighlightWord");

	ns.TextHighlighter.prototype.highlight = function(term) {
		// regex efficiently reused from the original autosuggest control
		var regex = new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1").split(/[, ]/).join("|") + ")(?![^<>]*>)(?![^&;]+;)", "gi");

		var tagStart = "<" + this.getTag() + " class='" + this.getClass() + "'>";
		var tagEnd = "</" + this.getTag() + ">";
		var textNode;
		var newHtml;

		// we have to cycle through the elements instead of just getting
		// the HTML so we don't lose event data attached to the DOM.
		var textNodes = this.getElement().find('*').contents().filter(function() {
			return (this.nodeType === 3);
		});
		$.each(textNodes, function(i, node) {
			textNode = $(node);
			newHtml = textNode.text().replace(regex, tagStart + "$1" + tagEnd);
			textNode.replaceWith(newHtml);
		});
	};
})(jQuery);
/* global MPageObjectOriented */
/**
 * tree.js
 * @author Leonardo Sa
 *
 * Tree class
 * ============================================================================
 *
 * Renders a AJAX tree of folders, based on the dynatree jquery plugin.
 * In order to populate the tree, one needs to register a function listener
 * by using setOnLazyRead.
 *
 */

/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */
	// ------------------------------------------------------------------------
	// Imports
	// ------------------------------------------------------------------------
	var ns = MPageControls;
	var attribute = MPageObjectOriented.createAttribute;
	var inherits = MPageObjectOriented.inherits;

	// ------------------------------------------------------------------------
	// Class declaration
	// ------------------------------------------------------------------------
	ns.Tree = function(element) {
		this.setDynatreeOptions({});
		this.setOnSelect(function() {
		});

		ns.Control.call(this, element);
	};

	inherits(ns.Tree, ns.Control);

	// ------------------------------------------------------------------------
	// Attributes
	// ------------------------------------------------------------------------

	/**
	 * Options for the dynatree third party library
	 */
	attribute(ns.Tree, "DynatreeOptions");

	/**
	 * Function to be executed when an element is selected
	 */
	attribute(ns.Tree, "OnSelect");

	/**
	 * Returns the dynatree node that is currently selected
	 */
	attribute(ns.Tree, "SelectedNode");

	var prot = ns.Tree.prototype;

	// ________________________________________________________________________

	prot.init = function() {

		var self = this;
		var opts = this.getDynatreeOptions();
		opts.onLazyRead = function(node) {
			self.lazyRead(node);
		};
		opts.onActivate = function(node) {
			self.onSelect(node);
		};
		opts.OnPostInit = this.treeInit;
		opts.autoFocus = false;
		opts.initAjax = {};
		this.getElement().dynatree(opts);
	};

	// ________________________________________________________________________

	/**
	 * Defines a function to be executed whenever there is a need to load more
	 * nodes in the tree. A "node" argument will be passed with the node that
	 * is the parent caller. A first call to this function will be performed
	 * with the dynatree's root node to populate the initial folders.
	 *
	 * @param {function} function to be executed
	 */
	prot.setOnLazyRead = function(fun) {
		this.m_OnLazyRead = fun;
		this.lazyRead(this.getElement().dynatree("getRoot"));
	};

	// ________________________________________________________________________

	prot.getOnLazyRead = function() {
		return this.m_OnLazyRead;
	};

	// ________________________________________________________________________

	prot.lazyRead = function(node) {
		this.m_OnLazyRead(node);
	};

	// ________________________________________________________________________

	prot.onSelect = function(node) {
		this.getOnSelect()(node);
		this.setSelectedNode(node);
	};
})(jQuery);
/* global MPageObjectOriented */
(function() {

	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	var List = MPageControls.List;

	ns.DropDownList = function(element) {
		this.setList(new List());
		this.setHighlightClass("current");
		this.setIsMouseOverContents(false);
		ns.DropDown.call(this, element);
	};

	attribute(ns.DropDownList, "List");
	attribute(ns.DropDownList, "DisplayKey");

	/**
	 * The CSS class to be applied to the current value in the list. Defaults to
	 * "current"
	 *
	 * @type String
	 */
	attribute(ns.DropDownList, "HighlightClass");

	/**
	 * Whether the mouse is currently hovering over the contents or not.
	 * Is set automatically.
	 *
	 * @type boolean
	 */
	attribute(ns.DropDownList, "IsMouseOverContents");

	inherits(ns.DropDownList, ns.DropDown);

	var prot = ns.DropDownList.prototype;

	prot.init = function() {
		var self = this;
		var selector = $("<div tabindex='0' id='control_" + this.getControlId() + "_selector' class='selector'></div>");
		var contents = $("<div style='display: none' id='control_" + this.getControlId() + "_contents' class ='contents' ></div>");

		var list = this.getList();
		list.setElement(contents);
		list.setListTemplate(MPageControls.getDefaultTemplates().list);
		list.setItemTemplate(MPageControls.getDefaultTemplates().ddListItem);
		list.setHighlightClass(this.getHighlightClass());
		list.setOnSelect(function() {
			self.selectItem();
		});

		list.bind("mouseover", contents, function() {
			self.setIsMouseOverContents(true);
		});
		list.bind("mouseout", contents, function() {
			self.setIsMouseOverContents(false);
		});
		list.bind("blur", selector, function() {
			if (!self.getIsMouseOverContents()) {
				self.hide();
			}
		});

		this.getElement().append(selector);
		this.getElement().append(contents);
		this.setContents(contents);
		this.setElement(selector);

		// if an element is passed in the constructor it will build a selector automatically.
		// this ensures we remove the events of the old selector before changing the element.
		if (this.getSelector()) {
			this.getSelector().destroyEvents();
			this.getSelector().setElement(selector);
			this.getSelector().init();
		}

		this.getList().makeItem = function(item) {
			item.displayKey = self.getDisplayKey();
			return item;
		};

		ns.DropDown.prototype.init.call(this);

		// we rendered contents with display none, so it is hidden
		this.getDetailDialog().setVisible(false);

	};

	/**
	 * Overrides the DropDown onShow method to provide highlighting
	 * functionality for the currently selected item.
	 */
	prot.onShow = function() {
		var selectedIndex = this.getList().getSelectedIndex();

		ns.DropDown.prototype.onShow.call(this);

		this.getList().setSelectedIndex(selectedIndex);
		this.getList().highlight(selectedIndex);
	};

	/**
	 * Collapses the drop down and sets the display value according
	 * to the current selected item
	 */
	prot.selectItem = function() {
		this.hide();
		this.setValue(this.getList().getSelectedItem()[ this.getDisplayKey() ]);
		this.getOnSelect()(this.getList().getSelectedItem());
	};

	/**
	 * Returns the currently selected item
	 * @return {*}
	 */
	prot.getSelectedItem = function() {
		return this.getList().getSelectedItem();
	};

	/**
	 * Sets the currently selected item without firing any events or
	 * callbacks.
	 *
	 * @param item
	 */
	prot.setSelectedItem = function(item) {
		this.setValue(item[ this.getDisplayKey() ]);
		this.getList().setSelectedItem(item);
	};

	/**
	 * Renders all the items inside the drop down
	 *
	 * @param items
	 * @return {*}
	 */
	prot.renderItems = function(items) {
		return this.getList().renderItems(items);
	};

	prot.setItemTemplate = function(template) {
		this.getList().setItemTemplate(template);
	};

	prot.setItems = function(items) {
		this.getList().setItems(items);
	};

	prot.selectByIndex = function(index) {
		this.getList().select(index);
	};

})();
/* global MPageObjectOriented */
/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */

	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	var ns = MPageControls;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------

	MPageControls.CclSearch = function(element) {
		this.setRequestCount(0);
		this.setSynchSuggestionsWidth(true);
		this.setInBrowserDir("../../mpages/reports/");
		ns.AutoSuggest.call(this, element);
	};

	inherits(ns.CclSearch, ns.AutoSuggest);

	/**
	 * Name of the CCL program to be executed
	 */
	attribute(ns.CclSearch, "ProgramName");

	/**
	 * How many requests have been queued. This is needed to ensure
	 * the right request will be displayed in case there are multiple
	 * keystrokes in a period less than the delay.
	 */
	attribute(ns.CclSearch, "RequestCount");

	/**
	 * Directory to be prepended to a CCL call when CERN_BrowserDevInd is true
	 */
	attribute(ns.CclSearch, "InBrowserDir");

	var prot = ns.CclSearch.prototype;

	// ------------------------------------------------------------------------
	// Member Methods
	// ------------------------------------------------------------------------

	/**
	 * Sets the template to render list items and attaches searchOrders()
	 * function to be triggered when the user types.
	 */
	prot.init = function() {
		MPageControls.AutoSuggest.prototype.init.call(this);

		var self = this;

		this.setTemplate(MPageControls.getDefaultTemplates().cclSearch);

		this.setOnDelay(function() {
			self.callProgram();
		});

		this.setRequestItemValueCallback(function(item) {
			return item.content;
		});
	};

	// ..................................................................................

	/**
	 * Performs a CCL call to the program specified by setProgramName(), with parameters
	 * generated by buildParameters()
	 */
	prot.callProgram = function() {
		/* eslint-disable no-unused-vars */
		var searchPhrase = this.getValue();
		/* eslint-enable no-unused-vars */
		var self = this;

		// increase the request count
		this.setRequestCount(this.getRequestCount() + 1);
		var reqNumber = this.getRequestCount();

		new ScriptRequest()
		.setRawDataIndicator(true)
		.setProgramName(this.getProgramName())
		.setArtifactInfo({
			artifactId: "mpages-controls",
			functionName: "callProgram"
		})
		.setParameterArray(this.buildParameters().split(","))
		.setResponseHandler(function(reply){
			MP_Util.LogScriptCallInfo(null, this, "script_search.js", "callProgram");
			self.handleSuccess(reqNumber, reply.getResponse());
        })
		.performRequest();
	};

	// ..................................................................................

	/**
	 * Handles a successful request from the Ajax program call
	 */
	prot.handleSuccess = function(reqNumber, responseText) {

		// ensure we are processing the latest request made
		/* eslint-disable eqeqeq */
		if (reqNumber != this.getRequestCount() || !responseText) {
			/* eslint-enable eqeqeq */
			return;
		}

		var jsonSearch = JSON.parse(responseText);

		// Handle failed CCL call
		if (jsonSearch.RECORD_DATA.STATUS_DATA.STATUS === "F") {
			/* eslint-disable new-cap */
			MP_Util.LogScriptCallError(null, responseText, "program_search.js", "handleSuccess");
			MP_Util.LogError(this.getProgramName() + " failed: " + responseText);
			/* eslint-enable new-cap */
			return;
		}

		// Do not render if there is no response
		if (!jsonSearch) {
			return;
		}

		var context = this.makeContext(jsonSearch);
		this.setSuggestions(context);
	};

	// ..................................................................................

	/**
	 * Should be overwritten by the derived class to return the parameter string
	 * to be used on the CCL call
	 */
	prot.buildParameters = function() {
		throw "buildParameters() is abstract.";
	};

	// ..................................................................................

	/**
	 * Can be overriden by the client if there is a need to edit the context before
	 * it is sent to rendering.
	 */
	prot.makeContext = function(responseJson) {
		return responseJson;
	};


}(jQuery));
/* global MPageObjectOriented */
/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;
	var ns = MPageControls;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	MPageControls.OrderSearch = function(element) {
		this.setRequestCount(0);
		this.setSynchSuggestionsWidth(true);

		ns.AutoSuggest.call(this, element);
	};

	inherits(ns.OrderSearch, ns.AutoSuggest);

	// ----------------------------------------------------------------
	// Attributes
	// ----------------------------------------------------------------
	attribute(ns.OrderSearch, "Criterion");
	attribute(ns.OrderSearch, "SuggestionLimit");
	attribute(ns.OrderSearch, "EncounterTypeCd");
	attribute(ns.OrderSearch, "FacilityId");
	attribute(ns.OrderSearch, "SearchIndicators");
	attribute(ns.OrderSearch, "VenueType");
	attribute(ns.OrderSearch, "RequestCount");
	attribute(ns.OrderSearch, "BirthDate");
	attribute(ns.OrderSearch, "BirthDateTimeZone");
	attribute(ns.OrderSearch, "ClinicalWeight");
	attribute(ns.OrderSearch, "ClinicalWeightUnit");
	attribute(ns.OrderSearch, "PMAInDays");

	// ------------------------------------------------------------------------
	// Public Member Methods
	// ------------------------------------------------------------------------
	var prot = MPageControls.OrderSearch.prototype;

	/**
	 * Sets the template to render list items and attaches searchOrders()
	 * function to be triggered when the user types.
	 */
	prot.init = function() {
		MPageControls.AutoSuggest.prototype.init.call(this);

		var self = this;

		this.setListItemTemplate(MPageControls.getDefaultTemplates().orderSearchItem);
		this.setTemplate(MPageControls.getDefaultTemplates().orderSearch);

		this.setOnDelay(function() {
			var originalValue = self.m_SearchIndicators;
			self.m_SearchIndicators &= ~(1 << 10); //Turns 10th bit of searchIndicators off. Auto-search always filtered
			self.searchOrders();
			self.m_SearchIndicators = originalValue;
		});

		this.setRequestItemValueCallback(function(item) {
			return item.content;

		});


	};

	// ________________________________________________________________________

	prot.searchOrders = function(callback) {
		var searchPhrase = this.getValue();
		var self = this;

		// increase the request count
		this.setRequestCount(this.getRequestCount() + 1);
		var reqNumber = this.getRequestCount();

		// --------------------------------------------------------------------
		// Initialize the request object
		// --------------------------------------------------------------------
		var xhr = (CERN_BrowserDevInd) ? new XMLHttpRequest() : new XMLCclRequest();

		// --------------------------------------------------------------------
		// Handle response
		// --------------------------------------------------------------------
		xhr.onreadystatechange = function() {
			/* eslint-disable eqeqeq */
			if (xhr.readyState == 4 && xhr.status == 200) {
				/* eslint-enable eqeqeq */
				/* eslint-disable new-cap */
				MP_Util.LogScriptCallInfo(null, this, "order_search.js", "handleSearchOrderSuccess");
				/* eslint-enable new-cap */
				self.handleSearchOrdersSuccess(reqNumber,
					xhr.responseText, callback);
			}
		};

		// --------------------------------------------------------------------
		// Send request
		// --------------------------------------------------------------------
		if (this.getSearchIndicators() === null) {
			throw "OrderSearch: no search indicators specified";
		}

		var birthDate = this.getBirthDate() ? this.getBirthDate() : "";
		var birthDateTimeZone = this.getBirthDateTimeZone() ? this.getBirthDateTimeZone() : 0;
		var weightValue = this.getClinicalWeight() ? this.getClinicalWeight() : 0.0;
		var weightUnit = this.getClinicalWeightUnit() ? this.getClinicalWeightUnit() : 0;
		var pmaInDays = this.getPMAInDays() ? this.getPMAInDays() : 0;

		var sugLimit = this.getSuggestionLimit();
		if (this.getSuggestionLimit() <= 0) {
			sugLimit = 50;
		}

		var params = "^MINE^,^" + searchPhrase + "^," + sugLimit + "," + this.getEncounterTypeCd() + ".0," + this.getFacilityId() + ".0," + this.getCriterion().provider_id + ".0," + this.getCriterion().ppr_cd + ".0," + this.getVenueType() + "," + this.getSearchIndicators() + "," + 1 + "," + this.getCriterion().person_id + ".0,^" + birthDate + "^," + birthDateTimeZone + "," + weightValue + "," + weightUnit + "," + pmaInDays;
		if (CERN_BrowserDevInd) {
			var url = "mp_search_orders?parameters=" + params;
			xhr.open("GET", url);
			xhr.send(null);
		}
		else {
			xhr.open('GET', "mp_search_orders");
			xhr.send(params);
		}
	};

	// ________________________________________________________________________

	prot.handleSearchOrdersSuccess = function(requestNumber, responseText, callback) {
		// ensure we are processing the latest request made
		/* eslint-disable eqeqeq */
		if ((requestNumber != this.getRequestCount()) || !responseText) {
			return;
		}
		/* eslint-enable eqeqeq */

		var jsonSearch = "";

		jsonSearch = JSON.parse(responseText);

		if (!jsonSearch) {
			return;
		}

		if (jsonSearch.RESULTS.STATUS_DATA.STATUS === "F") {
			/* eslint-disable new-cap */
			MP_Util.LogScriptCallError(null, responseText, "order_search.js", "handleSearchOrderSuccess");
			MP_Util.LogError("mp_search_orders failed: " + responseText);
			/* eslint-enable new-cap */
			return;
		}

		//Cache the patient demographic information for future use.
		if (jsonSearch.RESULTS.BIRTH_DATE) {
			this.setBirthDate(jsonSearch.RESULTS.BIRTH_DATE);
		}
		if (jsonSearch.RESULTS.BIRTH_DATE_TZ) {
			this.setBirthDateTimeZone(jsonSearch.RESULTS.BIRTH_DATE_TZ);
		}
		if (jsonSearch.RESULTS.WEIGHT_VALUE) {
			this.setClinicalWeight(jsonSearch.RESULTS.WEIGHT_VALUE);
		}
		if (jsonSearch.RESULTS.WEIGHT_CODE) {
			this.setClinicalWeightUnit(jsonSearch.RESULTS.WEIGHT_CODE);
		}
		if (jsonSearch.RESULTS.PMA_VALUE) {
			this.setPMAInDays(jsonSearch.RESULTS.PMA_VALUE);
		}
		if (callback) {
			callback(responseText);
		} else {
			var returnData = jsonSearch.RESULTS.ORDERS.concat(jsonSearch.RESULTS.PLANS);
			this.renderJson(returnData);
		}

	};

	// ________________________________________________________________________

	prot.renderJson = function(returnData) {
		$.each(returnData, function(i, item) {
			// Figures out the item content
			if (item.SYNONYM) {
				item.content = item.SYNONYM;
			} else if (item.PW_CAT_SYN_NAME) {
				item.content = item.PW_CAT_SYN_NAME;
			}

			// Figures out the item CSS class
			/* eslint-disable eqeqeq */
			if (item.ORDERABLE_TYPE_FLAG == 6) {
				/* eslint-enable eqeqeq */
				item.iconClass = "careset-icon";
			} else if (item.ORDERABLE_TYPE_FLAG === 0) {
				item.iconClass = "";
			} else if (item.PATH_CAT_ID) {
				item.iconClass = "powerplan-icon";
				// ensure no personal_plan_id exists
				item.PATH_CAT_SYN_ID = 0.0;
			}
		});

		this.setSuggestions(returnData);

	};

})(jQuery);
/* global MPageObjectOriented */
/* eslint-disable no-unused-vars */
(function($) {
	/* eslint-enable no-unused-vars */
	var ns = MPageControls;
	var inherits = MPageObjectOriented.inherits;
	var attribute = MPageObjectOriented.createAttribute;

	// ------------------------------------------------------------------------
	// Class Declaration
	// ------------------------------------------------------------------------
	/**
	 * A component level control that creates a dropdown list for venues, which can be used by components like New order entry option 1 and 2.
	 */
	ns.OrderVenueGroup = function(element, defaultValue, venueList, selectedOption) {
		ns.DropDownList.call(this, element);
		this.setValue(defaultValue);
		this.setVenueList(venueList);
		this.getList().setSelectedOption(selectedOption);
		this.getList().setItemTemplate(MPageControls.getDefaultTemplates().venueTemplate);
	};

	attribute(ns.OrderVenueGroup, "VenueList");
	inherits(ns.OrderVenueGroup, ns.DropDownList);

	var prot = ns.OrderVenueGroup.prototype;

	prot.init = function() {
		var self = this;
		this.setOnShow(function() {

			self.getList().setDisplayKey("VENUE_DISPLAY");
			self.getList().renderItems(self.getVenueList());
			self.getList().highlightSelectedOption(self.getList().getSelectedIndex());
		});
		ns.DropDownList.prototype.init.call(this);
	};

})(jQuery);
/* global MPageObjectOriented */
/* eslint-disable no-unused-vars */
(function($) {
    /* eslint-enable no-unused-vars */
    var inherits = MPageObjectOriented.inherits;
    var attribute = MPageObjectOriented.createAttribute;
    var ns = MPageControls;

    /**
     * Renders a textbox autosuggest control into element and uses
     * MP_GET_PRSNL_JSON to suggest results.
	 * @param {element} element in which search box to be placed
	 * @returns {Undefined} this function does not return a value
     */
    MPageControls.PersonnelSearch = function(element) {
        ns.CclSearch.call(this, element);

        this.orgSecurityInd = 0;
        this.organizationInd = 0;
        this.specialtyInd = 0;
        this.physicianInd = 0;

        this.setProgramName("MP_GET_PRSNL_JSON");
        this.setSuggestionLimit(10);
        this.setListItemTemplate(MPageControls.getDefaultTemplates().personnelSearchItem);
    };

    inherits(ns.PersonnelSearch, MPageControls.CclSearch);

    attribute(ns.PersonnelSearch, "UserId");
    attribute(ns.PersonnelSearch, "SuggestionLimit");

    var prot = ns.PersonnelSearch.prototype;

    prot.setOrgSecurityInd = function(orgSecInd) {
        this.orgSecurityInd = orgSecInd;
    };
    prot.getOrgSecurityInd = function() {
        return this.orgSecurityInd;
    };
    prot.setOrganizationInd = function(orgInd) {
        this.organizationInd = orgInd;
    };
    prot.getOrganizationInd = function() {
        return this.organizationInd;
    };
    prot.setSpecialtyInd = function(spltyInd) {
        this.specialtyInd = spltyInd;
    };
    prot.getSpecialtyInd = function() {
        return this.specialtyInd;
    };
    prot.setPhysicianInd = function(physicianInd) {
        this.physicianInd = physicianInd;
    };
    prot.getPhysicianInd = function() {
        return this.physicianInd;
    };
    prot.buildParameters = function() {
        var lastName = "";
        var firstName = "";
        // split first/last name if a comma exists
        var splitted = (this.getValue() || "").split(",");
        if (splitted.length > 1) {
            lastName = splitted[ 0 ];
            firstName = splitted[ 1 ];
        }
		else {
            lastName = splitted[ 0 ];
            firstName = "";
        }

        // builds the parameter string
        return "^MINE^"
            + "," + this.getUserId() + ".00"
            + ",^" + lastName + "^"
            + ",^" + firstName + "^"
            + "," + this.getSuggestionLimit()
            + "," + this.getOrgSecurityInd()
            + "," + this.getOrganizationInd()
            + "," + this.getSpecialtyInd()
            + "," + this.getPhysicianInd();
    };

    prot.makeContext = function(response) {
        return response.RECORD_DATA.PRSNL;
    };

    prot.setTemplateMaxHeight = function(maxHeight) {
        ns.setMaxHeight(maxHeight);
    };
})(jQuery);

var MPageEntity = {
    "protocol": {},
    "generators": {},
    "entities": {}
};

/**
 * Stores configuration functions to be executed before any entity
 * is created. These configurations are executed only once. Add
 * new configurations by using the configure function:
 *
 * Entity.configure(function() {
 *   MPageEntity.meta.user = "something";
 * });
 *
 * @type {Array}
 */
MPageEntity.configurations = [];

/**
 * Adds a new function that will be executed before any entity is
 * created. Those functions will only be executed once.
 * @type {MPageEntity.XmlHttpRequest}
 */
MPageEntity.configure = function (fun) {
    MPageEntity.configurations.push(fun);
};


/**
 * Runs all the registered configurations. Will run only once.
 */
MPageEntity.startup = function () {
    if (MPageEntity.isConfigured) {
        return;
    }
    for (var i = MPageEntity.configurations.length; i--;) {
        MPageEntity.configurations[i]();
    }
    MPageEntity.isConfigured = true;
};

/**
 * Whether the configure function was executed already or not.
 * Do not change this unless you know what you are doing.
 * @type {boolean}
 */
MPageEntity.isConfigured = false;(function() {
	var attribute = MPageOO.attribute;

    /**
     * Abstract class from where all the protocols will inherit.
     */
    MPageEntity.protocol.EntityProtocol = function() {
    };

    var EntityProtocol = MPageEntity.protocol.EntityProtocol;
    var prot = EntityProtocol.prototype;

	/**
	 * Whether the request will pass data as a blob field (POST/setBlobIn)
	 */
	attribute(EntityProtocol, "UseBlob");

    prot.generateRequestStr = function(entity, action, values) {
        throw "generateRequestStr is abstract and needs to be implemented.";
    };

    prot.handleResponseStr = function(entity, action, response) {
        throw "handleResponseStr is abstract and needs to be implemented.";
    };

    /**
     * Transforms the provided json into a json that is suitable to be passed
     * as a parameter to a CCL script.
     */
    prot.sanitizeJson = function(json) {
        var self = this;

        // quit on null
        if (json == null) { return null; }

         // check if it's a string
        if ( typeof (json) == 'string') {
            var strField = new MPageEntity.String();
            json = strField.toCcl(json);
            return json;
        }

        // check if it's an entity
        if (json.mEntityClass) {
            return json.getCclJson();
        }

        // check if it's a number
        if (json.toFixed) {
            var numField = new MPageEntity.Number();
            json = numField.toCcl(json);
            return json;
        }

        // if it gets here, then is either an array or a generic object
        $.each(json, function(k, v) {
           json[k] = self.sanitizeJson(v);
        });
        return json;
    };

    /*
     * Converts a jsonObject to a string that can be used in a request.
     * We didn't use the native stringify because the CCL service is sometimes
     * picky on what it accepts as json (ex.: ^ as string delimiters), so
     * we have to do some sanitizing.
     */
    prot.serializeJson= function(json) {
        var values = [];
        var self = this;

        // We don't like null values for our json
        if (json === null || typeof(json) == 'undefined') {
            return "''";
        }

        // Check for string and escape single quotes
        if ( typeof (json) == 'string') {
            json = json.replace("'", "\'");
            return json;
        }

        // Check for array
        if (json.push) {
            $.each(json, function(k, v) {
                values.push(self.serializeJson(v));
            });
            return "[" + values.join(",") + "]";
        }

        // Check for number
        if (json.toFixed) {
            return "'" + json + "'";
        }

        // Defaults to object if not string or array
        $.each(json, function(k, v) {
            var val = "'" + k + "':";
            val += self.serializeJson(v);
            values.push(val);
        });
        return "{" + values.join(',') + "}";
    };

})();
(function() {
    var attribute = MPageOO.attribute;
    var ns = MPageEntity.protocol;

    MPageEntity.protocol.EntityProtocolError = function(msg) {
        Error.call(this, msg);
        this.name = "Entity Protocol Error";
        this.message = msg;
    };

    ns.EntityProtocolError.prototype = new Error();

})();(function () {
    var ns = MPageEntity.protocol;

    ns.EntityProtocolV1 = function() {
        ns.EntityProtocol.call(this);
    };

    ns.EntityProtocolV1.prototype = new ns.EntityProtocol();

    var prot = ns.EntityProtocolV1.prototype;

    prot.generateRequestStr = function(entity, action, values) {
        var json = {"jsonRequest": {
            "action": "'" + action + "'",
            "meta": entity.getMeta(),
            "values": values
        }};

        return '"mine",' + '"' + this.serializeJson(json) + '"';
    };

    prot.generateRequestJsonStr = function(entity, action, values) {
        var json = {"jsonRequest": {
            "action": "'" + action + "'",
            "meta": entity.getMeta(),
            "values": values
        }};
        return this.serializeJson(json);
    }


    prot.handleResponseStr = function(entity, action, response) {
        var recordData = JSON.parse(response);
        if (recordData == null
            || recordData.RECORD_DATA == undefined
            || recordData.RECORD_DATA.VALUES == undefined) {
            throw new ns.EntityProtocolError("Response from the service does not match the entity protocol version 1");
        }

        if (recordData.RECORD_DATA.META.STATUS == "error") {
            throw new ns.EntityProtocolError(recordData.RECORD_DATA.META.STATUSMESSAGE);
        }

        if (recordData.RECORD_DATA.META.STATUS == "empty" || recordData.RECORD_DATA.VALUES.length == 0) {
            return {
                values: [],
                meta: recordData.RECORD_DATA.META
            };
        }
        var vals = recordData.RECORD_DATA.VALUES;
        if (!$.isArray(vals)) {
            vals = [vals];
        }
        return {
            values: vals,
            meta: recordData.RECORD_DATA.META
        };
    };
})();
(function () {
    var ns = MPageEntity.protocol;

    /**
     * The V2 protocol accepts requests in the following format:
     *
     * request: {
     *  protocolVersion: 2,
     *  action: <string>,
     *  meta: { ... },
     *  valueCount: <integer>,
     *  values: [ {...}, ...]
     * }
     *
     * The reply follows the same format, except it is named reply.
     */
    ns.EntityProtocolV2 = function() {
        ns.EntityProtocol.call(this);
		this.setUseBlob(true);
    };

    ns.EntityProtocolV2.prototype = new ns.EntityProtocol();

    var prot = ns.EntityProtocolV2.prototype;

    prot.generateRequestStr = function(entity, action, values) {
        var serialized = this.generateRequestJsonStr(entity, action, values);
        return this.getUseBlob() ?
			serialized : '"mine",' + '"' + serialized + '"';
    };

    prot.generateRequestJsonStr = function(entity, action, values) {
        if (!values.push) {
            values = [values];
        }
        var json = {"request": {
            "protocolVersion": 2,
            "action": "'" + action + "'",
            "meta": entity.getMeta(),
            "valueCount": values.length,
            "values": values
       }};

        return this.serializeJson(json);
    };

    prot.handleResponseStr = function(entity, action, response) {
        var resp = JSON.parse(response);
        // compatibility with CCL cnvtrectojson()
        if (resp != null && resp.RECORD_DATA) {
            resp = resp.RECORD_DATA;
        } else {
            resp = resp.REPLY;
        }
        if (resp == null || resp == undefined || resp.VALUES == undefined) {
            throw new ns.EntityProtocolError("Response from the service does not match the entity protocol version 2");
        }
        if (resp.META.STATUS == "error") {
            throw new ns.EntityProtocolError(resp.META.STATUSMESSAGE);
        }
        var vals = resp.VALUES;
        return {
            values: vals,
            meta: resp.META
        };
    };
})();
MPageEntity.CodeSets = {
    "ACTIVITYTYPE": 106,
    "CATALOGTYPE": 6000,
    "CONTRIBUTORSYSTEM": 89,
    "DCPCLINICALCATEGORY": 16389,
    "LANGUAGE": 36,
    "MEDORDERTYPE": 18309,
    "NOMENCLATUREIDENTIFIERSOURCE": 12100,
    "ORDERCATALOG": 200,
    "ORDERSOURCETYPES": 6500,
    "ORDERSTATUS": 6004,
    "PHARMACYDISCONTINUETYPES": 4038,
    "PHASTOPTYPE": 4009,
    "POSITNCODE": 88,
    "PRINCIPLETYPE": 401,
    "SOURCEVOCABULARY": 400,
    "STRINGSTATUS": 12103,
    "SOURCEVOCABULARYAXIS": 15849
};(function() {

    var attribute = MPageOO.attribute;
	var map = MPageOO.map;
	var mapObject = MPageOO.mapObject;
	var each = MPageOO.each;
	var reduce = MPageOO.reduce;
	var values = MPageOO.values;
	var mergeObjects = MPageOO.mergeObjects;

    var EntityProtocolError = MPageEntity.protocol.EntityProtocolError;
    /**
     * Base class for any class that aims to connect to the database using the
     * entity standards. Entities make it seamless to persist data without having
     * to handle requests and responses, and by imposing a communication standard
     * that aims to facilitate relationships between tables.
     */
    MPageEntity.Entity = function () {
        MPageEntity.startup();
        this.id = null;
        Entity.meta.userId = MPageEntity.Config.user;
        Entity.meta.positionCd = MPageEntity.Config.position;
        this.setMeta(Entity.meta);
		this.setChangeObservers([]);
        this.setData({});
        this.setCachedEntityRelations({});
		this.setIsLocked(false);
    };
    MPageEntity.Config = {};
    var Entity = MPageEntity.Entity;
    var prot = Entity.prototype;
	/**
	 * The entity class used to create the current entity instance.
	 */
	attribute(Entity, "EntityClass");

    /**
     * The name of the entity as a string
     */
    attribute(Entity, "EntityName");

    /**
     * Metadata to be sent to the service
     */
    attribute(Entity, "Meta");

    /**
     * Metadata received from the service
     */
    attribute(Entity, "ResponseMeta");

    /**
     * The actual contents of the entity
     */
    attribute(Entity, "Data");

    /**
     * Caching related entities (one-to-one and one-to-many relationships)
     */
    attribute(Entity, "CachedEntityRelations");

	/**
	 * Functions to be triggered whenever this condition changes
	 */
	attribute(Entity, "ChangeObservers");

	/**
	 * Whether an action is taking place asynchronously on the entity
	 */
	attribute(Entity, "IsLocked");

    // ========================================================================
    // Private Methods
    // ========================================================================


	/**
	 * Initializes the fields (call each field's initialize() method) and
	 * returns a new object where the key is the uppercased field's name and the
	 * value the initialized field object.
	 *
	 * @param entityClass
	 * @param fieldsJson
	 * @returns {*|{}}
	 */
	var initializeFields = function(entityClass, fieldsJson) {
		return mapObject(fieldsJson, function(k, v) {
			v.setName(k);
			v.initialize(entityClass, k);
			return [k.toUpperCase(), v]
		});
	};

	/**
	 * Asks the protocol to make a response object based on the result string
	 */
	var makeResponse = function (action, responseStr, onError) {
        var protocol = this.getProtocol();
        var response = null;
        try {
            response = protocol.handleResponseStr(this, action, responseStr);
		}
		catch (e) {
            if (onError) {
                onError(e);
            }
            if (!onError || (Entity.throwRequestErrors && !(e instanceof EntityProtocolError))) {
                this.throwException(action, e);
            }
        }
		return response;
	};

	/**
	 * Checks if the provided values JSON is valid
	 */
	var validateValues = function(action, responseStr, values) {
        if (values === null || typeof(values) == "undefined" || typeof(values.length) == "undefined") {
            var msg = this.getEntityName() + "." + action + ": could not generate valid values";
            msg += " from the provided JSON response\r\n";
            msg += "Response: " + responseStr;
            this.throwException(action, msg);
        }
		return values;
	};

    // ========================================================================
    // Static Methods
    // ========================================================================

    /**
     * Static method that creates fields for an entity class
     * @param {Object} entityClass
     * @param {Object} fields
     */
    Entity.initialize = function(entityClass, entityJson) {
		entityClass.fields = initializeFields(entityClass, entityJson.fields);
        entityClass.entityJson = entityJson;
        entityClass.fieldsJson = entityJson.fields;
        entityClass.listQuals = entityJson.listQuals;
        entityClass.actions = entityJson.actions;

        // entityClass static methods
        entityClass.list = Entity.list;
        entityClass.supportsAction = Entity.supportsAction;
        entityClass.defaultEntityListClass = MPageEntity.EntityList;

        if (!entityJson.doNotRegister) {
            Entity.allEntities.push(entityClass);
        }
    };

    /**
     * This defines what object will be used to handle the protocol - the translation
     * between values to a request string, and response string to array of values
     */
    Entity.protocol = new MPageEntity.protocol.EntityProtocolV1();

    /**
     * When set to TRUE, errors originating from CCL script calls will be thrown
     * directly to the browser/interpreter.
     */
    Entity.throwRequestErrors = true;

    /**
     * The transaction, if any, that is currently taking place.
     * @type {null}
     */
    Entity.currentTransaction = null;

	/**
	 * All entity classes created must be placed inside this variable so that
     * they can be initialized by other scripts.
     */
    Entity.allEntities = [];

    /**
     * Set to true if you want to see extra information about requests
     */
    Entity.debug = false;

    /**
     * Constants for the default actions
     * @type {string}
     */
    Entity.CCL_ERROR_STATUS = "error";
    Entity.CCL_EMPTY_STATUS = "empty";
    Entity.ACT_CREATE = "create";
    Entity.ACT_READ = "read";
    Entity.ACT_LIST = "list";
    Entity.ACT_UPDATE = "update";
    Entity.ACT_REMOVE = "remove";

    Entity.meta = {};

    // The log defaults to the console if executed standalone, or the logger,
    // when executed inside unified content. Change this to any custom logger
    // during inclusion into the final artifact.
    Entity.log = function(msg) {
         if (typeof logger !== "undefined" && logger && logger.logMessage) {
            logger.logMessage(msg);
		}
		else if (typeof console !== "undefined" && console && console.log) {
            console.log(msg);
        }
    };

    /**
     * Creates an entity class called entityName in the specified namespace.
     * For example, Entity.create(MPageEntity, "Person", {...}) will create
     * the MPageEntity.Person entity class with the fields specified by the
     * "fields" parameter, and the list qualifications in array form.
     */
    Entity.create = function(namespace, entityName, entityJson) {

		// When we have only two arguments, it means we are not specifying a
		// namespace
		if (arguments.length == 2) {
			entityJson = entityName;
			entityName = namespace;
			namespace = {};
		}

        // Class constructor
        namespace[entityName] = function() {
            Entity.call(this);
            this.init(namespace[entityName]);
        };
        var entityClass = namespace[entityName];

        // Inheritance and field initialization
        MPageOO.inherits(entityClass, Entity);
        entityClass.entityName = entityName;
        Entity.initialize(entityClass, entityJson);

		return entityClass;
    };

    /**
     * Creates a new entity class by extending an existing base entity class.
     * The fields of the new one will be merge with the base. Equal keys will
     * be overwritten.
     */
    Entity.extend = function(baseClass, namespace, entityName, entityJson) {

        // Class constructor
        namespace[entityName] = function() {
            baseClass.call(this);
            this.init(namespace[entityName]);
        };
        var entityClass = namespace[entityName];

        // Inheritance
        MPageOO.inherits(entityClass, baseClass);
        entityClass.entityName = entityName;

        // Merge the json and initialize
        entityJson.fields = $.extend({}, baseClass.entityJson.fields, entityJson.fields);
        Entity.initialize(entityClass, entityJson);

		return entityClass;
    };

    /**
     * Creates a new entity class based on the definition (provided as a json),
     * and then sets its values according to the "values" attribute, provided as
     * a field/value map.
     *
     * @param definition the JSON definition for the entity
     * @param values a map of values
     * @returns {Entity}
     */
    Entity.createInstanceFromValues = function(definition, values) {

        // Builds only the fields present in values. If the value
        // doesn't have an equivalent field definition, it creates a String field
        var definedFields = {};
        var data = {};
		each(values, function(v, k) {
            if (definition.fields[k]) {
                definedFields[k] = definition.fields[k];
			}
			else {
                definedFields[k] = new MPageEntity.String();
            }
            data[k.toUpperCase()] = v;
        });
        definition.fields = definedFields;

        // creates the entity class
        var ns = {};
        Entity.create(ns, "TempEntity", definition);

        // instantiates the class and sets the data
        var inst = new ns.TempEntity();
        inst.setData(data);
        return inst;
    };

    /**
     * Sets the data of an entity to be the same as another. Will reset all
     * field caches.
     */
    var origSetData = prot.setData;
    prot.setData = function(data) {
    	// set data can be called before initialization, hence the check
		if (this.mEntityClass) {
			this.clearFieldCaches();
		}
		origSetData.call(this, data);
    };

    /*
     * DEPRECATED: use EntityProtocol.serializeJson() instead.
     *
     * Converts a jsonObject to a string that can be used in a request.
     * We didn't use the native stringify because the CCL service is sometimes
     * picky on what it accepts as json (ex.: ^ as string delimiters), so
     * we have to do some sanitizing.
     */
    Entity.serializeJson = function(json) {
        var p = new MPageEntity.protocol.EntityProtocol();
        return p.serializeJson(json);
    };

    /**
     * True or false if the specified action was defined during entity creation
     */
    Entity.supportsAction = function(actionName) {

        if (!this.actions) {
            return false;
        }

        for (var i=this.actions.length; i--;) {
            if (this.actions[i] == actionName) {
                return true;
            }
        }
        return false;
    };

	/**
	 * Returns a new instance of the entity list class associated with this
	 * entity.
	 *
	 * @returns {*}
	 */
    Entity.makeEmptyList = function() {
        return new this.defaultEntityListClass(this);
    };

    /**
     * DEPRECATED. Use EntityProtocol's sanitize json instead.
     *
     * Remaining here just for compatibility reasons.
     */
    Entity.sanitizeJson = function(json) {
        var p = new MPageEntity.protocol.EntityProtocol();
        return p.sanitizeJson(json);

    };

    Entity.list = function(params, callback) {
        var instance = new this();
        return instance.list(params, callback);
    };

    Entity.action = function(actionName, params, callback) {
       var instance = new this();
       return instance.action(actionName, params, callback);
    };

    // ========================================================================
    // CRUD Methods
    // ========================================================================
    prot.create = function(callback) {
        return this.action(Entity.ACT_CREATE, this, callback);
    };

    prot.read = function(id, callback) {
        this.clearFieldCaches();
		return this.action(Entity.ACT_READ, {
			"id": id
		}, callback);
    };

    prot.update = function(callback) {
        return this.action(Entity.ACT_UPDATE, this, callback);
    };

    prot.remove = function(callback) {
		return this.action(Entity.ACT_REMOVE, {
			id: this.getId()
		}, callback);
    };

    prot.list = function(params, callback) {
        return this.action(Entity.ACT_LIST, params, callback);
    };

    // ========================================================================
    // Member Methods
    // ========================================================================

    /**
     * Initializes the entity class and name of the instance.
     * This method should be called in the constructor of derived
     * classes. If entityName is not provided, it will try to guess it from
     * the entityName attribute in the entityClass.
     */
    prot.init = function(entityClass, entityName) {
        var self = this;
		this.setEntityClass(entityClass);
		this.mEntityClass = entityClass; // DEPRECATED. Here for compat purposes.

        if (!entityName && entityClass.entityName) {
            this.setEntityName(entityClass.entityName);
		}
		else {
            this.setEntityName(entityName);
        }

        // initializes fields with null
		each(this.getEntityClass().fields,
			function(v, k) {
				self.getData()[v.getName()
					.toUpperCase()] = null;
        });
		return this;
    };

	/**
	 * Calls the read action with the current entity ID, making the entity
	 * refresh itself with data from the backend.
	 */
    prot.refresh = function() {
        this.read(this.getId());
		return this;
    };

	/**
	 * Throws an exception and prints it to the console.
	 *
	 * @param action
	 * @param msg
	 */
    prot.throwException = function(action, msg) {
		var out = "Entity name: " + this.getEntityName() + "\r\n";
        out += "Action: " + action;

        if (msg.message) {
            msg.message = msg.message + "\r\n" + out;
            throw msg;
        }

        if (Entity.debug) {
            console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            console.log("EXCEPTION");
            console.log(msg);
            console.log(out);
            console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        }
        throw (msg + "\r\n" + out);
    };

    /**
     * Returns the EntityProtocol used to manage this entity. Protocols can be
     * defined per entity class by setting [whateverEntity].protocol = obj
     *
     * Ex.: Person.protocol = new EntityProtocolV2();
     *
     * If a protocol is not set for an entity class, it will use the default
     * set at Entity.
     */
    prot.getProtocol = function() {
		if (!this.getEntityClass()
			.protocol) {
            return Entity.protocol;
        }
		return this.getEntityClass().protocol;
    };

    /**
     * Some fields might use caches for performance reasons. This forces them
     * to clean the cache.
     *
     * Example: OneToOne field will store the entity it has retrieved from the
     * relationship on the first getWhatever() function call. If you clean its
     * cache, then it will perform the query again.
     */
     prot.clearFieldCaches = function() {
		var keys = Object.keys(this.getEntityClass().fields);
        for (var i=keys.length; i--;) {
			var field = this.getEntityClass().fields[keys[i]];
            field.emptyCache(this);
        }
		return this;
     };

    /**
     * Returns an array of strings with all the field names for the current
     * entity
     */
    prot.getFieldNames = function() {
        var fields = [];
		each(this.getEntityClass().fields,
			function(v) {
            fields.push(v.getName());
        });
        return fields;
    };

    /**
     * Converts all the fields of the current entity instance into a CCL
     * compatible JSON that can be passed to the request() function
     */
	prot.getCclJson = function(fields) {
		fields = fields ? initializeFields(this.getEntityClass(), fields) : {};
		return reduce(
			mergeObjects(this.getEntityClass().fields, fields),
			function(memo, field) {
				var fieldName = field.getName();
				memo[fieldName] = field.toCcl(this.getProperty(fieldName), this);
				return memo;
			}.bind(this), {});
    };

    /**
     * Returns the value of fieldName converted to its equivalent CCL value
     */
    prot.getCclValue = function(fieldName) {
		var field = this.getEntityClass().fields[fieldName.toUpperCase()];
        return field.toCcl(this[fieldName], this);
    };

	/**
	 * The same as calling get[fieldname] except it accepts a string as the
	 * field name.
	 *
	 * @param fieldName
	 * @param callback
	 * @returns {*}
	 */
	prot.getFieldValue = function(fieldName, callback) {
		var field = this.getEntityClass().fields[fieldName.toUpperCase()];
		return field.get(this, callback);
	};

	/**
	 * The same as calling set[fieldname] except it accepts a string as the
	 * field name.
	 *
	 * @param fieldName
	 * @param callback
	 * @returns {*}
	 */
	prot.setFieldValue = function(fieldName, value) {
		var field = this.getEntityClass().fields[fieldName.toUpperCase()];
		field.set(this, value);
		return this;
	};

    /**
     * Sets the property of the entity to a specified value. This differs from
     * just assigning to data directly because it does a case insensitive
     * search for the property.
     *
     */
    prot.setProperty = function(property, value) {
        var self = this;

		each(self.getData(), function(v, k) {
            var upperK = k.toUpperCase();
            if (upperK == property.toUpperCase()) {
                self.getData()[upperK] = value;
                return true;
            }
        });
		return this;
    };

    /**
	 * Returns the value of a property by giving its name as a string. This
	 * will return the RAW property value, with no field formatting whatsoever.
	 * Use getValue to get the value from the field.
     */
    prot.getProperty = function(property) {
        var data = this.getData()[property.toUpperCase()];
        if (data === undefined) {
            return this.getData()[property];
        }
        return data;
    };

    /**
     * Returns the Field instance for the specified property
     */
    prot.getField = function (property) {
		return this.getEntityClass().fields[property.toUpperCase()];
    };

    /**
     * Updates the entity fields with the values present in the json.
     * The key names in the json must match the field names.
     *
     * @param {Object} json
     */
    prot.updateEntity = function(json) {
        this.clearFieldCaches();
        var self = this;
        var data = this.getData();
		each(json, function(v, k) {
			var field = self.getEntityClass().fields[k.toUpperCase()];
            if (typeof(field) != "undefined"){
                data[k.toUpperCase()] = field.toJs(v, self);
			}
			else if (Entity.debug) {
				Entity.log("WARNING: Could not find field " + k + " in " + self.getEntityClass()
					.entityName + ".");
              Entity.log("This means that the server and client entities are out of synch.");
            }
        });
		return this;
    };

    /**
     * DEPRECATED. Use handleResponse instead.
     *
     * Handles the JSON that comes back from a CCL request.
     */
    prot.handleCclResponse = function(recordData) {
       return this.handleResponse("unknown", JSON.stringify(recordData));
    };

	/**
	 * Transforms a raw response from the backend into actual entity objects.
	 * Will also update the current entity with data from the response.
	 *
	 * @param {String} action
	 * @param {String} responseStr
	 * @param {Function} onError
	 * @returns {MPageEntity.EntityList}
	 */
    prot.handleResponse = function(action, responseStr, onError) {
		this.unlock();
        if (Entity.debug) {
            Entity.log("");
            Entity.log("RESPONSE:");
            Entity.log(responseStr);
        }


        var response = makeResponse.call(this, action, responseStr, onError);
        if (!response){
                return;
        }
        var values = validateValues.call(this, action, responseStr, response.values);

        // always update the current entity with the first value
        if (values.length) {
            this.updateEntity(values[0]);
            this.setResponseMeta(response.meta);
			this.broadcastChanges();
        }

        // generate list for all values
		var Class = this.getEntityClass();
        var ListClass = Class.defaultEntityListClass;
        var result = new ListClass(Class);
        result.setResponseMeta(response.meta);

        for (var i=0; i<values.length; i++) {
            var ent = new Class();
            ent.updateEntity(values[i]);
            ent.setResponseMeta(response.meta);
            result.push(ent);
        }
        return result;
    };

    function makeUrl(url) {
        var cclGroup = MPageEntity.Config && MPageEntity.Config.cclGroup;
        return cclGroup ? url + ":" + cclGroup
            : url;
    }
    /**
     * Generates a standard request json with the provided action and invokes
     * the CCL script with the same name as the current entity, such as
     * mp_ent_person.
     *
     * If callback is provided, an asynchronous call will be performed. If not,
     * it will default to synchronous. In the later case, the result of the
     * request will be returned.
     */
    prot.request = function(action, params, callback, async) {
        this.lock();
        var self = this;
        var scriptRequest = new ScriptRequest();
        var handledResp = undefined;
        var scriptName = "mp_ent_" + this.getEntityName()
            .toLowerCase();
        var data = this.getProtocol().generateRequestJsonStr(this, action, params);
        var useBlob = this.getProtocol().getUseBlob();
        var parameters = ['"mine"'];
        if (useBlob) {
            scriptRequest.setDataBlob(data);
        }
        else {
            parameters.push('"' + data + '"');
        }
        scriptRequest.setProgramName(makeUrl(scriptName));
        if (!async) {
            scriptRequest.setAsyncIndicator(false);
        }
        scriptRequest.setParameterArray(parameters);
        scriptRequest.setRawDataIndicator(true);
        scriptRequest.setErrorStatusHandler(function(responseText, status){
            throw new Error("Entity request failed. HTTP status: "
              + status + ". Response: " + responseText);
        });
        scriptRequest.setResponseHandler(function(dataReply) {
            var responseStr = dataReply.getResponse();
            var error = null
            var returnedEntity = null;
            handledResp = self.handleResponse(action, responseStr, function(e) {
                error = e;
            });
            if (callback) {
                callback(handledResp, responseStr, error);
            }
        });
        scriptRequest.performRequest();
        return handledResp;
    };

	/**
	 * Sets the name of the entity. The name is used to generate the
	 * script to be called automatically.
	 *
	 * @param {String} name
	 */
    prot.setEntityName = function(name) {
        this.mEntityName = name;
		return this;
    };

	/**
	 * Returns the name of the entity
	 * @returns {String}
	 */
    prot.getEntityName = function() {
        return this.mEntityName;
    };

    /**
     * Same as request, except it does some sanitizing of the data for us.
     * If only the callback is provided, it will default to an async request,
     * unless the last parameter is set to false.
     *
     * @param {Object} action
     * @param {Object} params
     * @param {Object} callback
     */
    prot.action = function(action, params, callback, async) {

        // if the action has fields defined, we create a new
        // instance of an entity with those fields and pass as the data.
		if (this.getEntityClass()
			.actions && this.getEntityClass()
			.actions[action]) {
            params = Entity.createInstanceFromValues({
                doNotRegister: true,
				fields: this.getEntityClass().actions[action]
            }, params);
        }

        params = Entity.sanitizeJson(params);

        if (Entity.currentTransaction !== null) {
            Entity.currentTransaction.add({
                actionName: action,
                params: params,
                callback: callback,
                entity: this
            });
            return;
        }

        if ((async === undefined && callback) || async) {
            return this.request(action, params, callback, true);
        }
        return this.request(action, params, callback, false);
    };

    /**
     * Automatically detects if a insert or update should be called depending
     * on whether id is null or not.
     *
     * @param {Object} callback if provided, request will be asynchronous
     */
    prot.save = function(callback) {
        if (this.getId && this.getId() !== null) {
            this.update(callback);
		}
		else {
            this.create(callback);
        }
		return this;
    };

    /**
     * Copies the data from the current entity to another entity. Will not
     * fire any lazy load operations.
     */
    prot.copyTo = function(dest) {
        var data = this.getData();
        var keys = Object.keys(data);
        for (var i=keys.length; i--;) {
            dest.getData()[keys[i]] = data[keys[i]]
        }
		return this;
    };

    /**
     * Clears the entity cache for the current entity
     */
     prot.clearEntityCache = function() {
        this.setCachedEntityRelations({});
     };

    /**
	 * Adds a function that will be called whenever the current entity
	 * changes. Changes are triggered either by manually calling
	 * broadcastChanges or when the entity values are updated as the result of
	 * a backend reply.
	 *
	 * @param observer
	 * @returns {prot}
     */
	prot.watchForChanges = function(observer) {
		this.getChangeObservers()
			.push(observer);
		return this;
    };

	/**
	 * Fires all the observers currently registered with watchForChanges.
	 *
	 * @returns {prot}
	 */
	prot.broadcastChanges = function() {
		each(this.getChangeObservers(), function(observer) {
			observer(this);
		}.bind(this));
		return this;
	};

    /**
     * Calls the "define" action for the entity, and checks the response with
     * the fields declared for this entity. If there is any discrepancy, it
     * will return an array of strings with the names of all the discrepant fields
     * that are present on the server, but not on the client. Otherwise, it
     * will return an empty array.
     *
     * The server definition is always a subset of the client, but never the
     * opposite. In other words, all the fields in the server have to be
     * contained into the client, but not all fields in the client need to
     * be declared in the server.
     *
     * This is due to the fact that some client fields are dynamically
     * generated, or customized by the developer.
     */
    prot.validateFields = function() {
		var data = this.getProtocol()
			.generateRequestStr("define");

        if (values.length === 0) {
            return [];
        }

        var fields = this.getFieldNames();
        var notmatched = values.slice(0);

        // cycles through the server response checking if all fields are
        // present in the client
        for (var i=values.length; i--;) {
            var server = values[i];
            var matched = false;
            for (var ii=fields.length; ii--;) {
                var client = fields[ii];
                matched = (client.toUpperCase() == server.toUpperCase());
                if (matched) {
                  break;
                }
            }

            if (!matched) {
                notmatched.push(server);
            }
        }
        return notmatched;


    };

	/**
	 * Locks the entity. When an entity is locked, no other actions can be performed
	 * until it is unlocked.
	 */
	prot.lock = function() {
		if (this.getIsLocked()) {
			this.throwException("", "Cannot lock an entity while another action is in progress.");
			return this;
		}
		this.setIsLocked(true);
		return this;
	};

	/**
	 * Unlockes the entity so actions can be performed.
	 */
	prot.unlock = function() {
		this.setIsLocked(false);
	};
})();
(function() {
    var ns = MPageEntity;
    var attribute =  MPageOO.attribute;

    /**
     * Allows perfomring actions in a group of entities with a single request.
     * For example:
     *
     * var people = new EntityList(MPageEntity.Person);
     * people.push(person1);
     * people.push(person2);
     * people.save();
     *
     * That would call the action "saveall" on the Person entity while passing person1 and
     * person2 as action parameters. Person1 and person2 MUST be of type Person.
     *
     * EntityList inherits from Array, therefore all array methods will be available,
     * including accessors (such as people[0], people[1] ...)
     */
    ns.EntityList = function(cls) {
        if (cls) {
            this.setEntityClass(cls);
        }
        this.setMeta(null);
        this.setEntityListClass(ns.EntityList);
    };

    ns.EntityList.prototype = new Array();

    ns.EntityList.SORTING = {
        ASC: 1,
        DESC: 2
    };

    /**
     * If this EntityList is extended, this has to be set to the extended class
     * so that methods that depend on creating new lists will create the correct
     * type.
     */
    attribute(ns.EntityList, "EntityListClass");

    /**
     * The class which this entity list will operate on
     */
    attribute(ns.EntityList, "EntityClass");

    /**
     * Meta attributes that will be passed to all contained entities when performing
     * actions on a group of entities.
     */
    attribute(ns.EntityList, "Meta");

    /**
     * Meta attributes returned by the server, when this entity list was created
     * as a result of a backend call.
     */
    attribute(ns.EntityList, "ResponseMeta");

    var prot = ns.EntityList.prototype;

    prot.isArray = true;

    // ...................................................................................

    /**
     * Returns a new instance of the entity list - or whatever EntityListClass is set to,
     * and passes the Entity class to it.
     */
    prot.makeEmptyList = function() {
        var list = new (this.getEntityListClass())();
        list.setEntityClass(this.getEntityClass());
        return list;
    };

    // ...................................................................................

    /**
     * Executes an entity action, but passes the list as the parameter so that the
     * action is taken on all entities in the list.
     */
    prot.action = function(action, callback) {
        if (this.getMeta() != null) {
            this.runMethodOnChildren("setMeta", getMeta());
        }
        var Class = this.getEntityClass();
        var inst = new Class();
        return inst.action(action, this, callback);
    };

    // ...................................................................................

    /**
     * Runs the specified method on all items in the list
     */
    prot.runMethod = function(methodName) {
        var args = [].splice.call(arguments, 1, arguments.length - 1);
        for (var i=this.length; i--;) {
            var obj = this[i];
            obj[methodName].apply(obj, args);
        }
    };

    // ...................................................................................

    /**
     * Inserts items from the specified entity array into the entity list
     */
    prot.fromArray = function(arr) {
        var self = this;
        $.each(arr, function(k,v) {
            self.push(v);
        });
    };

    // ...................................................................................

    /**
     * Returns only entities that have a property that matches a value
     */
    prot.filter = function(field, value) {
        // if the first arg is a function call filterFunction instead
        if (field.call) {
            return this.filterFunction(field);
        }

        var result = this.makeEmptyList();
        for (var i=0; i<this.length; i++) {
	    var data = this[i].getData()[field.toUpperCase()];

	    // retrieve the ID if it has it
	    data = data && data.id ? data.id : (data && data.ID ? data.ID : data);
	    
            if (data == value) {
                result.push(this[i]);
            }
        }
        return result;
    };

    // ...................................................................................

    prot.filterFunction = function(fun) {
        var result = this.makeEmptyList();
        for (var i=0; i<this.length; i++) {
            if (fun(this[i])) {
                result.push(this[i]);
            }
        }
        return result;
    };

    // ...................................................................................

    /**
     * Returns a new list where the the specified fields are matching on both sides.
     * If the fields are not set, it defaults to id.
     */
    prot.intersect = function(list, myfield, theirfield) {
        var result = this.makeEmptyList();

        if (!myfield) myfield = "id";
        if (!theirfield) theirfield = "id";
        var upperMyfield = myfield.toUpperCase();
        var upperTheirfield = theirfield.toUpperCase();
        this.each(function(i) {
            if (list.filter(theirfield, i.getData()[upperMyfield]).length > 0) {
                result.push(i);
            }
        });
        return result;
    };

    // ...................................................................................

    prot.splice = function(a, b) {
        var result = this.makeEmptyList();
        result.fromArray(Array.prototype.splice.call(this, a, b));
        return result;
    };

    // ...................................................................................

    prot.concat = function(arr) {
        var result = this.makeEmptyList();
        result.fromArray(this);
        result.fromArray(arr);
        return result;
    };

    // ...................................................................................

    /**
     * Executes a function for every item in the list
     */
    prot.each = function(f) {
        for (var i=0; i<this.length; i++) {
            f(this[i]);
        }
    };

    // ...................................................................................

    /**
     * Returns the items in this list minus the ones in the provided list, whenever the
     * specified fields match. If the name of the fields are not specified, id will be
     * used by default.
     */
     prot.subtract = function(list, myfield, theirfield) {
        var result = this.makeEmptyList();

        if (!myfield) myfield = "id";
        if (!theirfield) theirfield = "id";
        var upperMyfield = myfield.toUpperCase();
        var upperTheirfield = theirfield.toUpperCase();
        this.each(function(i) {
            if (list.filter(theirfield, i.getData()[upperMyfield]).length == 0) {
                result.push(i);
            }
        });
        return result;
     };

    // ...................................................................................

    /**
     * Either updates or creates the entities based on their id value.
     * IMPORTANT: if some entities are created and others updated, the callback will be
     * executed twice, once for each action.
     */
    prot.save = function(callback) {
        // separate entities that need update from the ones that need creation
        var needUpdate = this.makeEmptyList();
        var needCreate = this.makeEmptyList();
        for (var i=this.length; i--;) {
            var entity = this[i];
            if (entity.id === null) {
                needCreate.push(entity);
            } else {
                needUpdate.push(entity);
            }
        }

        // calls both actions separately
        if (needUpdate.length) needUpdate.action("update", callback);
        if (needCreate.length) needCreate.action("create", callback);
    };

    // ...................................................................................

    /**
     * Sorts the array list by the list specified. Will be ascending by default, or
     * descending if direction is set to EntityList.SORTING.DESC
     *
     * @param fieldName
     * @param direction
     * @return {Array.<T>|*|Array}
     */
    prot.sortBy = function(fieldName, direction) {
        if (!direction) {
            direction = ns.EntityList.SORTING.ASC;
        }

        var entityClass = this.getEntityClass();
        var ucaseFieldName = fieldName.toUpperCase();
        var field = entityClass.fields[ucaseFieldName];

        if (!field) {
            throw new Error("sortBy(): Cannot find entity field '" + fieldName + "'");
        }

        var sortFunction = function(a, b) {
            if (direction == ns.EntityList.SORTING.ASC) {
                return field.compareValues(a.getData()[ucaseFieldName], b.getData()[ucaseFieldName]);
            }
            return -1 * field.compareValues(a.getData()[ucaseFieldName], b.getData()[ucaseFieldName]);
        };

        return this.sort(sortFunction);
    };

    // ...................................................................................

    /**
     * Executes a mapping function over the list.
     *
     * @param entityType The entity class that the list will be assigned to. If mapFun is
     *                 ommitted, this becomes the map function and the list generated
     *                 will be the same class as the current.
     * @param mapFun   The mapping function
     * @returns {EntityList}
     */
    prot.map = function(entityType, mapFun) {
        var entityListClass = entityType.defaultEntityListClass;
        if (!mapFun) {
            mapFun = entityType;
            entityType = this.getEntityClass();
            entityListClass = this.getEntityListClass();
        }

        var newList = new entityListClass();
        newList.setEntityClass(entityType);
        this.each(function (i) {
            newList.push(mapFun(i));
        });
        return newList;
    };

})();
(function() {
    
    var attribute = MPageOO.attribute;
    var mergeObjects = MPageOO.mergeObjects;
    
    MPageEntity.Field = function() {};
    
    /**
     * The name of the field. 
     */
    attribute(MPageEntity.Field, "Name");

    var prot = MPageEntity.Field.prototype;
    
    /**
     * Converts val to be sent to the backend.
     *
     * @param val
     * @param entity
     * @returns {*}
     */
    prot.toCcl = function(val, entity) {
        return val;
    };
    
    /**
     * Converts val to be used as a javascript value
     * to be stored in the internal data representation.
     *
     * @param val
     * @param entity
     * @returns {*}
     */
    prot.toJs = function(val, entity) {
        return val;
    };
    
    /**
     * Returns the field value as if you were calling the
     * getter on entity directly. It can be overriden by individual
     * field implementations, specially foreign fields.
     *
     * @param entity
     */
    prot.get = function(entity, callback) {
        return entity.getData()[this.getName().toUpperCase()];
        };
    
    /**
     * Sets the field value as if you were calling the setter on the entity
     * directly. It can be overriden by individual field implementations.
     *
     * @param entityClass
     * @param fieldName
     */
    prot.set = function(entity, value) {
        entity.getData()[this.getName().toUpperCase()] = value;
        return this;
    };
    
    /**
     * Returns a function that is equivalent to a getter to be used in an
     * entity instance.
     *
     * @returns {Function}
     */
    prot.makeGetter = function() {
        var field = this;
        return function(callback) {
            return field.get(this, callback);
        }
    };
        
    /**
     * Returns a function that is equivalent to a setter to be used in an
     * entity instance.
     *
     * @returns {Function}
     */
    prot.makeSetter = function() {
        var field = this;
        return function(value) {
            return field.set(this, value);
        };
    };
      
    /**
     * Creates a getter and setter into the associated entity class.
     */
    prot.generateGetterAndSetter = function(entityClass) {
        var ucaseField = this.getName()
                .charAt(0)
                .toUpperCase() + this.getName().slice(1);
        entityClass.prototype["get" + ucaseField] = this.makeGetter();
        entityClass.prototype["set" + ucaseField] = this.makeSetter();
    };
    
    prot.initialize = function(entityClass, fieldName) {
        this.setName(fieldName);
        this.generateGetterAndSetter(entityClass);
    };

    prot.emptyCache = function(entityInstance) {
        // Abstract.
    };

    /**
     * Returns 1 if a comes before b, -1 if b comes before a, and 0 if they are equal.
     * This is used inside sorting functions. Can and should be overriden for the
     * different field types.
     */
    prot.compareValues = function(a, b) {
        if (a == b) {
            return 0;
        }
        if (a > b) {
            return 1;
        }
        if (a < b) {
            return -1;
        }
    };

})();
(function() {
    
    var attribute = MPageOO.attribute;
    
    MPageEntity.Request = function(xmlHttpRequestInstance) {
        var self = this;
        
        this.setRequestInstance(xmlHttpRequestInstance);
        this.getRequestInstance().onreadystatechange = function() {
            self.handleStateChange();
        };
        this.setOnReadyStateChange(function() {});
        this.setOnSuccess(function(){});
    };
    
    var Request = MPageEntity.Request;
    
    // Called globally for all requests
    Request.onOpen = function(requestInstance) {};
    Request.onSuccess = function(requestInstance) {};
	Request.userId = 0;
	Request.pprCd = 0;
    Request.positionCd = 0;
    Request.encounterId = 0;
    Request.personId = 0;

	Request.cclGroup = null;

    // Static members
    Request.LOG_AS_FILE_NAME = "mpage_entity/core/request.js";
    Request.LOG_AS_FUNCTION = "open";

    attribute(Request, "RequestInstance");
    attribute(Request, "OnReadyStateChange");
    attribute(Request, "OnSuccess");
    attribute(Request, "Data");
    attribute(Request, "Asynch");
    attribute(Request, "Url");
	
	// ________________________________________________________________________
    
    var prot = MPageEntity.Request.prototype;
    
    prot.open = function(url, data, isAsynch) {
        this.setUrl(url);
        this.setData(data);
        this.setAsynch(isAsynch);
        this.logRequestOpen();
        Request.onOpen(this);
    };
    
	// ________________________________________________________________________
	
    prot.getJsonResponse = function() {
        return JSON.parse(this.getResponseStr());
    };

    // ________________________________________________________________________

    prot.getResponseStr = function() {
        return this.getRequestInstance().responseText;
    };
    
	// ________________________________________________________________________
	
    prot.handleStateChange = function() {
        var reqInstance = this.getRequestInstance();
        
        this.getOnReadyStateChange()();
        
        if (reqInstance.readyState == 4 && reqInstance.status == 200) {
            this.logSuccess();
            this.handleSuccess();
        } else if (reqInstance.readyState == 4) {
            this.logError();
            throw new Error("Entity request failed. HTTP status: "
              + reqInstance.status + ". Response: " + reqInstance.responseText);
        }
    };

    // ________________________________________________________________________

    prot.logError = function() {
        var request = this.getRequestInstance();
        if (typeof logger != 'undefined' && logger.logErrors) {
            logger.logErrors(["Entity Request Error: ",
                                "Script: " + this.getUrl(),
                                "Request: " + this.getData(),
                                "Status: " + request.status,
                                "Response: " + request.responseText]);
        }
    };

    // ________________________________________________________________________
    
    prot.logRequestOpen = function() {
        var request = this.getRequestInstance();
        if (typeof logger != 'undefined' && logger.logMessages) {
            logger.logMessages(["Entity Request Start: ",
                                "Script: " + this.getUrl(), 
                                "Request: " + this.getData()]);
        }
    };

    // ________________________________________________________________________

    prot.logSuccess = function() {
        var request = this.getRequestInstance();
        if (typeof logger != 'undefined' && logger.logMessages) {
            logger.logMessages(["Entity Request Success: ",
                                "Script: " + this.getUrl(), 
                                "Request: " + this.getData(),
                                "ReadyState: " + request.readyState,
                                "Status: " + request.status,
                                "Response: " + request.responseText]);
        }
    };

	// ________________________________________________________________________
    
    prot.handleSuccess = function() {
        Request.onSuccess(this);
        this.getOnSuccess()();
    };
    
})();
var MPageScriptRunner = MPageScriptRunner ? MPageScriptRunner : {};

(function() {
    
    var attribute = MPageOO.attribute;
    
    MPageScriptRunner.ScriptRunner = function() {
        // --------------------------------------------------------------------
        // Sets up the templates
        // --------------------------------------------------------------------
        var te = TemplateEngine;
        var div = te.tag("div");
        var li = te.tag("li");
        var a = te.tag("a")
        
        this.templates = new TemplateEngine.TemplateFactory({
           message: function(context) {
            return li({"class":"message " + context.loadingClass,"id":context._elementId},
                div({"class":"ccl-script-name"}, context.url),
                div({"class":"ccl-action"}, context.action),
                div({"class":"ccl-request"}, context.request),
                div({"class":"ccl-response"},"&nbsp;")   
            );       
           },
           
           listItem: function(context) {
            return li({"class":"script-item","id":context._elementId},
                a({"class":"ccl-script-name"}, context.name)                   
            );       
           }
        });
        
        this.setFailClass("fail");
        this.setLoadingClass("loading");
        this.setSuccessClass("success");
    };
    
    var ScriptRunner = MPageScriptRunner.ScriptRunner;
    
    ScriptRunner.msgCount = 0;
    
    attribute(ScriptRunner, "ElScriptList");
    attribute(ScriptRunner, "ElLoadedScriptName");
    attribute(ScriptRunner, "ElLoadedScriptDesc");
    attribute(ScriptRunner, "ElRunScriptBtn");
    attribute(ScriptRunner, "ElMessagesContainer");
    attribute(ScriptRunner, "DefaultMessageTemplate");
    attribute(ScriptRunner, "FailClass");
    attribute(ScriptRunner, "LoadingClass");
    attribute(ScriptRunner, "SuccessClass");
    attribute(ScriptRunner, "ScriptListCtrl");
    
    var prot = MPageScriptRunner.ScriptRunner.prototype;
    
    prot.init = function() {
        var self = this;
        
        // --------------------------------------------------------------------
        // Request events
        // --------------------------------------------------------------------
        MPageEntity.Request.onOpen = function(reqInst) {
            self.onRequestOpen(reqInst);
        };
        
        MPageEntity.Request.onSuccess = function(reqInst) {
            self.onRequestSuccess(reqInst);
        };
        
        // --------------------------------------------------------------------
        // Script list control
        // --------------------------------------------------------------------
        var list = new MPageControls.List(this.getElScriptList());
        list.setItemTemplate(this.templates.listItem);
        list.setOnSelect(function() {
            self.loadScript(list.getSelectedItem());
        });
        this.setScriptListCtrl(list);
    };
    
    prot.readScripts = function(scriptsArr) {
        this.getScriptListCtrl().renderItems(scriptsArr);
    };
    
    prot.loadScript = function(scriptJson) {
        var self = this;
        
        this.getElLoadedScriptName().html(scriptJson.name);
        this.getElLoadedScriptDesc().html(scriptJson.description);
        this.getElRunScriptBtn().click(function() {
            self.run(scriptJson);
        });
    };
    
    prot.run = function(scriptJson) {
        this.clearMessages();
        scriptJson.action(this);
    };
    
    prot.clearMessages = function() {
        this.getElMessagesContainer().empty();
    };
    
    prot.onRequestOpen = function(requestInstance) {
        var elId = "script_runner_msg_" + ScriptRunner.msgCount;
        ScriptRunner.msgCount++;
        requestInstance._elementId = elId;
        
        /*this.message({
            _elementId: elId,
            loadingClass: this.getLoadingClass(),
            url: requestInstance.getUrl(),
            action: requestInstance.requestJson.jsonRequest.action,
            request: requestInstance.getData()
        }, this.templates.message); */
    };
    
    prot.onRequestSuccess = function(requestInstance) {
        /*var reqEl = $("#" + requestInstance._elementId);
        var requestEl = reqEl.find(".ccl-request");
        var responseEl = reqEl.find(".ccl-response");
        
        requestEl.html(requestInstance.getData());
        responseEl.html(requestInstance.getRequestInstance().responseText);
        reqEl.removeClass(this.getLoadingClass());
        
        var jsonResponse = requestInstance.getJsonResponse();
        
        if (jsonResponse.RECORD_DATA && jsonResponse.RECORD_DATA.META &&
            jsonResponse.RECORD_DATA.META.STATUS == MPageEntity.Entity.CCL_ERROR_STATUS) {
            reqEl.addClass(this.getFailClass());
            return;
        }
        
        reqEl.addClass(this.getSuccessClass()); */
    };
    
    prot.message = function(context, template) {
        var msgc = this.getElMessagesContainer();
        msgc.append(template.render(context));
    };
})();
    (function() {
    var Entity = MPageEntity.Entity;

    MPageEntity.Transaction = function() {
        this.queue = {};
        this.mActionsLength = 0;
        this.isEmpty = true;
    };

    // ...................................................................................

    MPageEntity.Transaction.Action = function(act, params, callback, ent) {
        this.actionName = act;
        this.params = params;
        this.callback = callback;
        this.entity = ent;
    };

    var prot = MPageEntity.Transaction.prototype;

    // ...................................................................................

    /**
     * Anything executed within the track() method will be intercepted as a single
     * transaction.
     *
     * @param {function} The logic that manipulates entities and which will be intercepted
     *                   by the transaction.
     */
    prot.track = function(fun) {
        var oldtr = Entity.currentTransaction;
        MPageEntity.Entity.currentTransaction = this;
        fun();
        MPageEntity.Entity.currentTransaction = oldtr;
    };

    // ...................................................................................

    /**
     * Adds the provided Transaction.Action object into the queue so that action can be
     * executed when calling commit().
     *
     * @param {Transaction.Action} The Transaction.Action instance to be queued
     */
    prot.add = function(actionJson) {
        var entityName = actionJson.entity.mEntityName;
        var actName = actionJson.actionName;
        this.isEmpty = false;

        // Check if we have an entry in the queue for the entity
        if (this.queue[entityName] === undefined) {
            this.queue[entityName] = {};
        }

        // Check if we have an entry in the queue for the entity action
        var act = this.queue[entityName][actName];
        if (act === undefined) {
            act = {};
            this.queue[entityName][actName] = act;
            act.params = [];
            act.callbacks = [];
            act.entities = [];
            this.mActionsLength++;
        }

        // Add the action to the queue
        act.params.push(actionJson.params);
        act.callbacks.push(actionJson.callback);
        act.entities.push(actionJson.entity);
    };

    // ...................................................................................

    prot.commit = function(callback, isAsync) {
        var errors = [];
        var pendingRequests = this.mActionsLength;
        
        if(this.isEmpty){
            callback(errors);
        }

        var commitCallback = function(entities, values, error) {
            pendingRequests--;
            if (error != null) {
                errors.push(error);
            }
            if (pendingRequests == 0 && callback) {
                callback(errors);
            }
        };

        var ents = Object.keys(this.queue);
        for (var i=ents.length; i--;) {
            var entName = ents[i];
            var actions = Object.keys(this.queue[entName]);
            for (var ii=actions.length; ii--;) {
                var action = actions[ii];
                isAsync = (isAsync === undefined && callback) || isAsync;
                this.commitSingle(entName, action, commitCallback, isAsync);
            }

        }
    };

    // ...................................................................................

    prot.commitSingle = function(entityName, action, callback, isAsync) {
        var Cls = this.queue[entityName][action].entities[0].mEntityClass;
        var inst = new Cls();
        var self = this;

        var commitSingleCallback = function(handledResp, resp, error) {
            var respJson = inst.getProtocol().handleResponseStr(inst, action, resp);
            var values = respJson.values;
            var singleCallback = null;
            var entity = null; 
            for (var i=values.length; i--;) {
                entity = self.queue[entityName][action].entities[i];
                entity.updateEntity(values[i]);
                singleCallback = self.queue[entityName][action].callbacks[i];
                if (singleCallback){
                    singleCallback(entity);
                }
            }
            if (callback) {
                callback(self.queue[entityName][action].entities, values, error);
            }
        };

        var params = this.queue[entityName][action].params;

        // if async is not defined but we have a callback, default to true
        isAsync = ((isAsync === undefined && callback) || isAsync);

        return inst.request(action, params, commitSingleCallback, isAsync);
    };

})();
(function() {
    var attribute = MPageOO.attribute;
    var inherits = MPageOO.inherits;
    
    MPageEntity.XmlCclRequest = function() {
        MPageEntity.Request.call(this, new XMLCclRequest());
    };
    
    inherits(MPageEntity.XmlCclRequest, MPageEntity.Request);
    
    var prot = MPageEntity.XmlCclRequest.prototype;

	var makeUrl = function(url) {
		return MPageEntity.Request.cclGroup ? url + ":" + MPageEntity.Request.cclGroup
			: url;
	};

	var handleSyncSuccess = function(reqInst, isAsync) {
       if (!isAsync && reqInst.readyState == 4 && reqInst.status == 200) {
            this.handleSuccess();
       }
	};

	prot.open = function(url, data, isAsync, useBlob) {
		return useBlob ?
			this.openWithBlob(url, data, isAsync)
			: this.openWithParams(url, data, isAsync);
	};
	
    prot.openWithParams = function(url, data, isAsynch) {
       MPageEntity.Request.prototype.open.call(this, url, data, isAsynch);
       var reqInst = this.getRequestInstance();
	   reqInst.open("GET", makeUrl(url), isAsynch);
       reqInst.send(data);
	   handleSyncSuccess.call(this, reqInst, isAsynch); 
    };

	prot.openWithBlob = function(url, data, isAsynch) {
		MPageEntity.Request.prototype.open.call(this, url, data, isAsynch);
		var reqInst = this.getRequestInstance();
		reqInst.open("GET", makeUrl(url), isAsynch);
		reqInst.setBlobIn(data);
		reqInst.send(isAsynch ? '' : 'MINE');
		handleSyncSuccess.call(this, reqInst, isAsynch); 
	};

})();
(function() {
    var attribute = MPageOO.attribute;
    var inherits = MPageOO.inherits;
    
    MPageEntity.XmlHttpRequest = function() {
        MPageEntity.Request.call(this, new XMLHttpRequest());
    };
    
    inherits(MPageEntity.XmlHttpRequest, MPageEntity.Request);
    
    MPageEntity.XmlHttpRequest.baseUrl = "";
    
    var prot = MPageEntity.XmlHttpRequest.prototype;

	var makeUrlParams = function(data, isBlob) {
		return isBlob ? "^mine^,^" + data + "^" : data;
	};
	
    prot.open = function(scriptName, data, isAsynch, isBlob) {
       MPageEntity.Request.prototype.open.call(this, scriptName, data, isAsynch);
       var reqInst = this.getRequestInstance();
       
		var url = MPageEntity.XmlHttpRequest.baseUrl + scriptName + "?parameters=" +
			makeUrlParams(data, isBlob); 
       
       reqInst.open("GET", url, isAsynch);
       reqInst.send(null);
       
       if (!isAsynch && reqInst.readyState == 4 && reqInst.status == 200) {
            this.handleSuccess();
       }
    };
})();
(function() {

	var inherits = MPageOO.inherits;
	var attribute = MPageOO.attribute;
	var map = MPageOO.map;
	var objectFromList = MPageOO.objectFromList;
	var shallowClone = MPageOO.shallowClone;

	/**
	 * Base class for any fields that aim to have relationships with other
	 * entity classes.
	 *
	 * @constructor
	 */
	MPageEntity.ForeignField = function() {};
	var ForeignField = MPageEntity.ForeignField;

	inherits(ForeignField, MPageEntity.Field);
	var method = ForeignField.prototype;

	/**
	 * When set to true, sends the serialized entity in the request
	 * instead of sending just the ID.
	 */
	attribute(ForeignField, "SendFullObject");

	/**
	 * Which of the children to serialize when sending the full object
	 */
	attribute(ForeignField, "ExpandChildren");

	method.initialize = function(entityClass, fieldName) {
		MPageEntity.Field.prototype.initialize.call(this, entityClass, fieldName);
		this.generateGetterAndSetterForValues(entityClass);
	};

	/**
	 * Returns the class that represents the foreign entity
	 * @returns {*}
	 */
	method.getEntityClass = function() {
		if (typeof(this.m_EntityClass) != 'string') {
			return this.m_EntityClass;
		}

		// if it is a string, then try to resolve it
		var className = this.m_EntityClass;
		var pieces = this.m_EntityClass.split(".");
		var obj = window[pieces[0]];

		if (!obj) {
			throw new Error("Could not find '" + className + "' in the global scope.");
		}
		
		for (var i = 1; i < pieces.length; i++) {
			obj = obj[pieces[i]];
		}
		this.m_EntityClass = obj;

		if (obj == undefined || obj == null) {
			throw new Error("The following class could not be resolved: " + className);
		}

		return obj;

	};

	/**
	 * Sets the class that represents the foreign entity.
	 *
	 * @param entityClass
	 */
	method.setEntityClass = function(entityClass) {
		if (entityClass === null || entityClass === undefined) {
			throw "The entity class for this field is" +
			" undefined. If you want to associate to a class that" +
			" has not yet been loaded, use a string to declare" +
			" it, such as 'MPageEntity.Person'";
			return;
		}
		this.m_EntityClass = entityClass;
	};

	method.generateGetterAndSetterForValues = function(eClass) {
		var fieldName = this.getName();
		var ucaseField = fieldName
				.charAt(0)
				.toUpperCase() + fieldName.slice(1);

		eClass.prototype["get" + ucaseField + "Value"] = this.makeValueGetter();
		eClass.prototype["set" + ucaseField + "Value"] = this.makeValueSetter();
	};

	/**
	 * Parses the options JSON and sets internal attributes accordingly.
	 */
	method.loadOptionsFromJson = function(json) {
		if (json.sendFullObject) {
			this.setSendFullObject(json.sendFullObject);
		}
		if (json.expandChildren) {
			this.setExpandChildren(json.expandChildren);
		}
	};

	/**
	 * Returns an array of the fields specified by expandChildren, cloned from
	 * the entity type provided by the argument.
	 *
	 * @param entityType
	 */
	method.makeClonedFields = function(entityType) {
		return map(this.getExpandChildren(),
			function(fieldName) {
				var newField = shallowClone(entityType.fields[fieldName.toUpperCase()]);
				newField.setSendFullObject(true);
				return newField;
			}
		);
	};

	/**
	 * Clones each field from entityType specified by expandChildren and
	 * returns an object where the field names are keys, and the actual field
	 * instances are the the values.
	 *
	 * @param entityType
	 * @returns {*}
	 */
	method.makeOverridenFields = function(entityType) {
		if (!this.getExpandChildren()) return [];
		return objectFromList(this.makeClonedFields(entityType),
			function(field) {
				return [field.getName(), field];
			}
		);
	};

	/**
	 * Returns the JSON representation of the foreign entity instance
	 */
	method.getForeignJson = function(entity) {
		return entity.getCclJson(
			this.makeOverridenFields(entity.getEntityClass()));
	};

	/**
	 * The same as the "set" of a regular field. Foreign fields will usually
	 * override the default set and get to use objects, so use this if you
	 * need direct access to the values.
	 *
	 * @param entity
	 * @param value
	 */
	method.setValue = function(entity, value) {
		return MPageEntity.Field.prototype.set.call(this, entity, value);
	};

	/**
	 * The same as the "get" of a regular field. Foreign fields will usually
	 * override the default set and get to use objects, so use this if you
	 * need direct access to the values.
	 *
	 * @param entity
	 * @param value
	 */
	method.getValue = function(entity, callback) {
		return MPageEntity.Field.prototype.get.call(this, entity, callback);
	};

	/**
	 * Returns a function that is equivalent to a set[Fieldname]Value to be used
	 * in an entity instance.
	 *
	 * @returns {Function}
	 */
	method.makeValueSetter = function() {
		var field = this;
		return function(value) {
			return field.setValue(this, value);
		};
	};

	/**
	 * Returns a function that is equivalent to a get[Fieldname]Value to be used
	 * in an entity instance.
	 *
	 * @returns {Function}
	 */
	method.makeValueGetter = function() {
		var field = this;
		return function(callback) {
			return field.getValue(this, callback);
		}
	};
})();
(function () {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;

    var getIdFromData = function (data) {
        // if data is number return
        if (data && data.toFixed) {
            return data;
        }

        // if data has id return it as number, else return null
        var id = data && data.id ? data.id
            : (data && data.ID ? data.ID : null);

        if (id && typeof (id) == 'string') {
            var numberField = new MPageEntity.Number();
            return numberField.toJs(id);
        }

        return id;
    };

    MPageEntity.OneToOne = function (entityClass, options) {
        this.setEntityClass(entityClass);
        this.setDefaultValue(0);
        this.setSendFullObject(false);

        if (options && !options.toFixed && !options.substr) {
            this.loadOptionsFromJson(options);
        }
        else if (options) {
            this.setDefaultValue(options);
        }
    };

    inherits(MPageEntity.OneToOne, MPageEntity.ForeignField);

    /**
     * The value to be returned if the field is not populated
     */
    attribute(MPageEntity.OneToOne, "DefaultValue");

    var prot = MPageEntity.OneToOne.prototype;

    prot.loadOptionsFromJson = function (json) {
        MPageEntity.ForeignField.prototype.loadOptionsFromJson.call(this, json);

        if (json.defaultValue) {
            this.setDefaultValue(json.defaultValue);
        }
    };

    prot.toCcl = function (val, entity) {

        // send the full json if the sendFullObject is true
        if (this.getSendFullObject()) {
            return this.getForeignJson(this.getForeignEntity(entity));
        }

        // if it's null, then just return the default value
        if (val === undefined || val === null) {
            return "'" + this.getDefaultValue()
                .toFixed() + "'";
        }

        // value is a number
        if (val.toFixed) {
            var numberField = new MPageEntity.Number();
            return numberField.toCcl(val);
        }

        // value is a string
        if (typeof (val) == 'string') {
            var stringField = new MPageEntity.String();
            return stringField.toCcl(val);
        }

        // value is a JSON with an ID field
        var dataId = getIdFromData(val);
        if (dataId !== null) {
            var numberField = new MPageEntity.Number();
            return numberField.toCcl(dataId);
        }

        // anything else, return the default value
        return "'" + this.getDefaultValue()
            .toFixed() + "'";
    };

    /**
           * Creates initial cached instance of entity
           * @param  {Object} val    JSON to generate entity from
           * @param  {Entity} entity Parent entity
           * @return {Entity}        Entity generated from passed value
     */
    prot.createCachedInstance = function (val, entity) {
        var foreignEntity = new (this.getEntityClass())();
        foreignEntity.updateEntity(val);
        entity.getCachedEntityRelations()[this.getName() + "_entity"] = foreignEntity;
        return foreignEntity;
    };

    /**
     * Creates a copy of entity from the passed data and caches it
     * @param  {Object} data   JSON containing parsed entity data
     * @param  {Entity} entity Parent entity
     * @return {Entity}        Entity generated from passed data
     */
    prot.createCachedCopy = function (data, entity) {
        var foreignEntity = new (this.getEntityClass())();
        foreignEntity.setData(data);
        entity.getCachedEntityRelations()[this.getName() + "_entity"] = foreignEntity;
        return foreignEntity;
    };


    /**
     * Converts a backend value into javascript
     *
     * @param val
     * @param entity
     * @returns {*}
     */
    prot.toJs = function (val, entity) {
        if (!val) {
            return null;
        }
        // We have lazy loading going on. In this case
        // we'll return the id and let the getter handle
        // the actual loading of the object.
        if (typeof (val) == 'string') {
            var numberField = new MPageEntity.Number();
            return numberField.toJs(val);
        }
        // Return the entity json, but hold off on entity creation until 'getter' called
        var ent = this.createCachedInstance(val, entity);
        return ent.getData();
        //return val;
    };

    prot.get = function (origEntity, callback) {
        var fieldName = this.getName();
        var data = origEntity.getData();
        var cachedRelatedEntites = origEntity.getCachedEntityRelations();
        var fieldData = data[fieldName.toUpperCase()];
        var self = this;
        // return cached entity if present in cache
        if (cachedRelatedEntites[fieldName + "_entity"]) {
            if (callback) {
                callback(null, null, cachedRelatedEntites[fieldName + "_entity"]);
                return cachedRelatedEntites[fieldName + "_entity"];
            }
            return cachedRelatedEntites[fieldName + "_entity"];
        }

        // create a cached one if we have data for it
        if (fieldData && !fieldData.toFixed) {
            return this.createCachedCopy(fieldData, origEntity);
        }

        // nulls shall return nulls
        if (fieldData === null) {
            return fieldData;
        }

        // lazy load as a last resource
        var entity = new (this.getEntityClass())();

        if (MPageEntity.Entity.currentTransaction || callback) {
            entity.read(origEntity.getData()[fieldName.toUpperCase()], function (entities, response) {
                self.set(origEntity, entity);
                if (callback) {
                    callback(entities, response, entity);
                }
            });
            return;
        }

        entity.read(origEntity.getData()[fieldName.toUpperCase()], callback);
        //Sets the cached entity / data to the retrieved entity
        this.set(origEntity, entity);
        return entity;
    };

    prot.set = function (origEntity, value) {
        if (!value) {
            this.empty(origEntity);
            return;
        }

        var fieldName = this.getName();
        var cachedRelatedEntites = origEntity.getCachedEntityRelations();
        var data = origEntity.getData();

        //Update the value in the related entity cache
        cachedRelatedEntites[fieldName + "_entity"] = value;
        data[fieldName.toUpperCase()] = value.getData();
        return origEntity;
    };

    /**
     * Clears the cache and data for the field
     * @param  {Entity} entity Parent entity for which the field is cleared
     * @return {undefined}     undefined
     */
    prot.empty = function (origEntity) {
        var upperName = this.getName().toUpperCase();
        this.emptyCache(origEntity);
        origEntity.getData()[upperName] = null;
    };

    prot.getValue = function (entity, value) {
        var data = entity.getData()[this.getName().toUpperCase()];
        return getIdFromData(data);
    };

    prot.setValue = function (entity, value) {
        entity.getData()[this.getName().toUpperCase()] = value;
        this.emptyCache(entity);
        return this;
    };

    prot.emptyCache = function (entity) {
        entity.getCachedEntityRelations()[this.getName() + "_entity"] = null;
    };

    /**
     * Returns the entity object stored by this field in the entity provided
     *
     * @param entity
     * @returns {*}
     */
    prot.getForeignEntity = function (entity) {
        var foreignEntity = entity.getCachedEntityRelations()[this.getName() + "_entity"];
        if (!foreignEntity) {
            throw new Error("The " + entity.getEntityName() + " entity requires the '" + this.getName() + "' field to be filled with an instance of '" + this.getEntityClass()
                .entityName + "'");
        }
        return foreignEntity;
    };

})();
(function() {
    var inherits = MPageOO.inherits;
    
    MPageEntity.CclBool = function() {
    };
    
    inherits(MPageEntity.CclBool, MPageEntity.Field);
    
    var prot = MPageEntity.CclBool.prototype;
    
    prot.toCcl = function(val) {
        if (val === true) {
            return "'1'";
        }
        return "'0'";
    };
    
    prot.toJs = function(val) {
        if (val === "1") {
            return true;
        }
        return false;
    };
    
})();
(function() {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;

    MPageEntity.CodeValueField = function(codeSetId) {
		MPageEntity.OneToOne.call(this, "MPageEntity.CodeValue");
		this.codeSetId = codeSetId;
		this.codeSet = null;
    };
    
    MPageEntity.cachedCodeValues = {};
    
    inherits(MPageEntity.CodeValueField, MPageEntity.OneToOne);

    var prot = MPageEntity.CodeValueField.prototype;
    
    // ________________________________________________________________________

    prot.getCodeSet = function() {
        if (this.codeSet != null) {
            return this.codeSet;
        }

        this.codeSet = new MPageEntity.CodeSet();
        this.codeSet.read(this.codeSetId);
    };

    // ________________________________________________________________________

    prot.listCodeValues = function() {
        return this.getCodeSet().getCodeValues();
    };

})();
(function() {

    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;
    var ns = MPageEntity;

    /**
     * A field which gets automatically updated based on the values of other fields.
     * Useful for utilizing in entities that have a composite primary key.
     * Note that the field itself only gets update during a reply, but never a request.
     *
     * @param {fieldNames} An array of strings with the names of the fields of the entity
     */
    ns.Composite = function(fieldNames) {
        this.setFieldNames(fieldNames);
    };

    inherits(ns.Composite, ns.Field);
    attribute(ns.Composite, "FieldNames");

    var prot = ns.Composite.prototype;

    // ..................................................................................

    prot.toCcl = function(val, ent) {
        var result = {};

        if (val == null) return result;

        $.each(this.getFieldNames(), function(i, fieldName) {
            var field = ent.mEntityClass.fields[fieldName.toUpperCase()];
            result[fieldName] = field.toCcl(val[fieldName], ent);
        });
        return result;
    };

    // ..................................................................................

    /**
     * Will ignore any values returned in the value field and use the entity values.
     */
    prot.toJs = function(val, ent) {
        var result = {};
        $.each(this.getFieldNames(), function(i, fieldName) {
            var field = ent.mEntityClass.fields[fieldName.toUpperCase()];
            result[fieldName] = field.toJs(val[fieldName], ent);
        });
        return result;
    };

    // ..................................................................................


})();
(function() {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;
    
    MPageEntity.DateTime = function(format) {
        if (format) {
            this.setFormat(format);
        } else {
            this.setFormat("DD-MMM-YYYY HH:mm:ss");
        }
    };
    
    var DateTime = MPageEntity.DateTime;
    
    inherits(DateTime, MPageEntity.Field);
    attribute(DateTime, "Format");
    
    var prot = DateTime.prototype;
    
    prot.toCcl = function(val) {
        if (val === undefined || val === null || val == "") {
            return "'0'";
        }
        
        // if it's a string, try to parse it to date
        if (typeof val == "string") {
            val = this.toJs(val);
        }
        
        return "'" + moment(val).format(this.getFormat()).toUpperCase() + "'";
    };
    
    prot.toJs = function(val) {
        var valMoment = moment(val, this.getFormat());
        if (valMoment === null) {
            return null;
        }
        
        return valMoment.toDate();
    };
    

})();
(function() {

    var inherits = MPageOO.inherits;

    MPageEntity.EncodedString = function() {};

    inherits(MPageEntity.EncodedString, MPageEntity.Field);

    var prot = MPageEntity.EncodedString.prototype;

    prot.toCcl = function(val) {
        if (val === null || val === undefined) {
            val = "";
        }
        //Ensure string delimiters are html-encoded before being sent to ccl
        val = val.replace(/%/g, "%25");
        var encoded = val.replace(/[\/\\~'"<^&#\r\n]/g, function(m){
            var charCode = m.charCodeAt(0).toString(16).toUpperCase();
            if (charCode.length < 2) {
                charCode = "0" + charCode;
            }
            return "%" + charCode;
        });

        return "'" + encoded + "'";
    };

    /**
     * Ensures html-encoded characters are decoded on the javascript side
     *
     * @param val
     * @return {String}
     */
    prot.toJs = function(val) {
         var decoded = val;
         try {
            decoded = val.replace(/%([0-9A-F]{2})/g, function(m, n) {
                var code = parseInt(n, 16);
                return String.fromCharCode(code);
            });
        }
        catch(e){
            return decoded; 
        }
        return decoded;
    };


})();
(function() {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;
    
    /**
     * The iso8601 has been copied here to avoid dependency on locale.js.
     * It also avoids forcing consumers to polute the global Date scope, as
     * is necessary with the current summary/workflow locale.js definition.
     */
    var setISO8601 = function(targetdate, string) {
        if (!string) return null;
        var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\\.([0-9]+))?)?Z?)?)?)?";
        var d = string.match(new RegExp(regexp));
        var date = new Date(d[1], 0, 1);
        if (d[7]) {
            date.setUTCHours(d[7]);
        } else {
            date.setUTCHours(0);
        } if (d[8]) {
            date.setUTCMinutes(d[8]);
        } else {
            date.setUTCMinutes(0);
        } if (d[10]) {
            date.setUTCSeconds(d[10]);
        } else {
            date.setUTCSeconds(0);
        } if (d[12]) {
            date.setUTCMilliseconds(Number("0." + d[12]) * 1000);
        } else {
            date.setUTCMilliseconds(0);
        } if (d[1]) {
            date.setUTCFullYear(d[1]);
        }
        if (d[5]) {
            date.setUTCDate(d[5]);
        }
        if (d[3]) {
            date.setUTCMonth(d[3] - 1);
        }
        targetdate.setTime(date.getTime());
    };


    MPageEntity.Iso8601DateTime = function() {};
    
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    
    inherits(Iso8601DateTime, MPageEntity.Field);
    
    var prot = Iso8601DateTime.prototype;
    
    prot.toCcl = function(val) {
        if (val === undefined || val === null || val == "") {
            return "'0'";
        }
        
        // if it's a string, try to parse it to date
        if (typeof val == "string") {
            val = this.toJs(val);
        }
        if (!val.toISOString) {
            (function () {
                function f(n) {
                    // Format integers to have at least two digits.
                    return n < 10 ? '0' + n : n;
                }
                Date.prototype.toISOString = function(){
                    return this.getUTCFullYear()   + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z';
                };
            }());
       }
        
        return "'" + val.toISOString() + "'";
    };
    
    prot.toJs = function(val) {
        if (val == "" || val == "0") {
            return null;
        }

        var d = new Date();
        setISO8601(d, val);
        return d;
    };
    
})();
(function() {
    var inherits = MPageOO.inherits;
    
    MPageEntity.Number = function(precision, defaultValue) {
        if (!precision) {
            precision = 4;
        }
        this.precision = precision;
        this.defaultValue = defaultValue;
        if (!this.defaultValue) {
            this.defaultValue = 0;
        }
    };
    
    inherits(MPageEntity.Number, MPageEntity.Field);
    
    var prot = MPageEntity.Number.prototype;
    
    prot.toCcl = function(val) {
		
        if (val === null || val === undefined) {
			if (this.defaultValue !== undefined) {
				val = this.defaultValue;
			} else {
				val = 0;
			}
        }
        
		if (val.toFixed) {
			return "'" + val.toFixed(this.precision) + "'";
		}
		return "'" + val + "'";
    };
    
    prot.toJs = function(val) {
        var num = parseFloat(val);
        if (isNaN(num)) {
            return null;
        }
        return num;
    };
    

})();
(function () {
    var inherits = MPageOO.inherits;
    var attribute = MPageOO.attribute;
    var map = MPageOO.map;
    var each = MPageOO.each;

    MPageEntity.OneToMany = function (entityClass, listField, options) {
        this.setEntityClass(entityClass);
        this.setListField(listField);
        if (options) {
            this.loadOptionsFromJson(options);
        }
    };

    inherits(MPageEntity.OneToMany, MPageEntity.ForeignField);
    attribute(MPageEntity.OneToMany, "ListField");

    var prot = MPageEntity.OneToMany.prototype;

    prot.toCcl = function (val, entity) {

        if (this.getSendFullObject()) {
            return map(this.getForeignEntities(entity), function (child) {
                return this.getForeignJson(child);
            }.bind(this));
        }

        // if it's not an array, return nothing
        if (val === null || !(val.push)) {
            return "''";
        }

        return map(val, function (entity) {
            if (entity.getCclValue) {
                return entity.getCclValue("id");
            }
            if (entity.id) {
                return entity.id;
            }
        }.bind(this));
    };

    prot.toJs = function (val, ent) {
        var result = [];
        if (!val || val.length === 0) {
            return result;
        }

        var entities = this.makeEntitiesFromArray(val);
        if (ent) {
            this.set(ent, entities);
            return this.getFieldData(ent);
        }
        return getDataArray(entities);
    };

    /**
     * Generates entities from an array of unparsed JSON from entity reply
     * @param  {Array<Object>} array Array of JSON entity details
     * @return {EntityList}          Generated list of entities based on the passed details
     */
    prot.makeEntitiesFromArray = function (array) {
        var cls = this.getEntityClass();
        if (cls == undefined || cls == null) {
            throw "The field \"" + this.getName() + "\" for the " + origEntity.mEntityName +
            " entity is invalid: could not find the many to many class";
        }

        var result = new MPageEntity.EntityList(cls);
        if (!array) { return result; }

        each(array, function (entityJson) {
            var entity = new cls();
            entity.updateEntity(entityJson);
            result.push(entity);
        });
        return result;
    };

    /**
     * Generates entities from an array of entity data objects
     * Does this by copying the passed in data into new entity instances
     * @param  {Array<Object>} dataArray Array of entity data objects
     * @return {EntityList}              Generated list of entities based on the passed data
     */
    prot.makeEntitiesFromDataArray = function (dataArray) {
        var cls = this.getEntityClass();
        if (cls == undefined || cls == null) {
            throw "The field \"" + this.getName() + "\" for the " + origEntity.mEntityName +
            " entity is invalid: could not find the many to many class";
        }
        var result = new MPageEntity.EntityList(cls);
        if (!dataArray) { return result; }

        each(dataArray, function (data) {
            var entity = new cls();
            entity.setData(data);
            result.push(entity);
        });
        return result;
    };

    prot.get = function (origEntity, callback) {
        var self = this;
        var data = origEntity.getData();
        var cachedRelatedEntites = origEntity.getCachedEntityRelations();
        var fieldName = this.getName();

        //Return cached entities if present in cache
        if (cachedRelatedEntites[fieldName + "_entities"]) {
            if (callback) {
                callback(cachedRelatedEntites[fieldName + "_entities"]);
                return cachedRelatedEntites[fieldName + "_entities"];
            }
            return cachedRelatedEntites[fieldName + "_entities"];
        }

        var upperName = this.getName()
            .toUpperCase();
        // if we have an array, convert them to entities
        if (data[upperName] && data[upperName].push) {
            var entitiesFromData = this.makeEntitiesFromDataArray(data[upperName]);
            this.set(origEntity, entitiesFromData);
            return entitiesFromData;
        }

        // if it gets here, we lazy load them
        var entity = new (this.getEntityClass())();
        var qualification = {};
        qualification[this.getListField()] = origEntity.getId();

        if (MPageEntity.Entity.currentTransaction || callback) {
            entity.list(qualification, function (entities, response) {
                self.set(origEntity, entities);
                if (callback) {
                    callback(entities, response);
                }
            });
            return;
        }

        var entities = entity.list(qualification);
        self.set(origEntity, entities);
        return entities;
    };

    /**
     * Sets the value of the current field for the parent entity to the passed in value
     * @param {Entity} entity Parent entity for which the field is being set
     * @param {EntityList} value  Entity list that the field is being set to
     */
    prot.set = function (entity, value) {
        if (!value) {
            this.empty(entity);
        }
        //Sets the cached entity list to the passed in value
        this.updateEntityCache(entity, value);
        //Updates the data for the entity
        this.updateDataArray(entity, value);
    };

    /**
     * Clears the cache and data for the field
     * @param  {Entity} entity Parent entity for which the field is cleared
     * @return {undefined}     undefined
     */
    prot.empty = function (entity) {
        this.emptyCache(entity);
        this.setFieldData(entity, null);
    };

    /**
     * Returns the data stored for the specified entity
     * @param  {Entity} entity The parent entity for which the field's data is being retrieved
     * @return {Object}        Returns the data object containing the current field's details
     */
    prot.getFieldData = function (entity) {
        var data = entity.getData();
        var upperName = this.getName().toUpperCase();
        return data[upperName];
    };

    /**
     * Sets the data stored for the specified entity
     * @param  {Entity} entity The parent entity for which the field's data is being retrieved
     * @param  {Object}        The value to store in the data cache for the field
     * @return {Object}        Returns the data object containing the current field's details
     */
    prot.setFieldData = function (entity, val) {
        var data = entity.getData();
        var upperName = this.getName().toUpperCase();
        data[upperName] = val;
    };

    /**
     * Sets the cached version of the entity in this field to the passed value
     * @param  {Entity} entity The parent entity that will cache the passed entity
     * @param  {Entity} value  The entity to cache
     * @return {undefined}     undefined
     */
    prot.updateEntityCache = function (entity, value) {
        var cachedRelatedEntites = entity.getCachedEntityRelations();
        cachedRelatedEntites[this.getName() + "_entities"] = value;
    };

    /**
     * Updates the cached data to equal the data of each individual entity
     * @param  {Entity} entity The parent entity that will cache the data array
     * @param  {EntityList} values The list of entities to cache data for
     * @return {undefined}         undefined
     */
    prot.updateDataArray = function (entity, values) {
        this.setFieldData(entity, this.getDataArray(values));
    };

    /**
     * Returns an array of entity data
     * @param  {EntityList} entities List of entities to retrieve data from
     * @return {Array}         		 Array of entity data
     */
    prot.getDataArray = function (entities) {
        var dataArray = null;
        if (entities && entities.push) {
            dataArray = Array.prototype.map.call(entities, function (entity) {
                return entity.getData ? entity.getData() : {};
            });
        }
        return dataArray;
    }

    prot.emptyCache = function (instance) {
        instance.getCachedEntityRelations()[this.getName() + "_entities"] = null;
    };

    prot.getForeignEntities = function (entity) {
        var foreignEntity = entity.getCachedEntityRelations()[this.getName() + "_entities"];
        if (typeof (foreignEntity) == "undefined" || !foreignEntity) {
            foreignEntity = this.makeEntitiesFromDataArray(this.getFieldData(entity));
        }
        return foreignEntity || [];
    };
})();
(function() {
    var inherits = MPageOO.inherits;
    
    MPageEntity.SelfOneToMany = function(listField) {
        this.setListField(listField);
    };
    
    inherits(MPageEntity.SelfOneToMany, MPageEntity.OneToMany);
    
    var prot = MPageEntity.SelfOneToMany.prototype;
    
    prot.initialize = function(entityClass, fieldName) {
        this.setEntityClass(entityClass);
        OneToMany.prototype.initialize.call(this, entityClass, fieldName);
        
    };
})();

(function() {
    var inherits = MPageOO.inherits;
    var OneToOne = MPageOO.OneToOne;
    
    MPageEntity.SelfOneToOne = function() {
        this.setEntityClass(entityClass);
    };
    
    inherits(MPageEntity.SelfOneToOne, MPageEntity.OneToOne);
    
    var prot = MPageEntity.SelfOneToOne.prototype;
    
    prot.initialize = function(entityClass, fieldName) {
        this.setEntityClass(entityClass);
        OneToOne.prototype.initialize.call(this, entityClass, fieldName);
        
    };
})();(function() {
    
    var inherits = MPageOO.inherits;
    
    MPageEntity.String = function() {
        
    };
    inherits(MPageEntity.String, MPageEntity.Field);
    
    var prot = MPageEntity.String.prototype;

    prot.toCcl = function(val) {
        if (val === null || val === undefined) {
            val = "";
        }
        
        return "'" + val + "'";
    };
    
    prot.toJs = function(val) {
        return val;
    };

})();
(function() {
	MPageEntity.BedrockConfig = function() {
		var thisVisitVocab = 0;
		var chronicVocab = 0;
		var searchVocabCodeValues = [];
		var filteredSearchVocabCodeValues = [];
		// array to collect vocabulary details from new "Nomenclature Search Vocabulary" bedrock filter
		var nomenclatureSearchVocabularies = [];
		var diagnosisClassification = 0;
		var diagnosisConfirmation = 0;
		var problemClassification = 0;
		var problemConfirmation = 0;
		var diagnosisType = 0;
		var infoButtonInd = 0;
		var modifyInd = 0;
		var problemListFlag = 2;
		var duplicateAllowedInd = 0;

		this.getProblemListFlag = function(){
			return problemListFlag;
		};

		this.setProblemListFlag = function(value){
			problemListFlag = value;
		};

		this.getSearchVocabCodeValues = function() {
			return searchVocabCodeValues;
		};

		this.setSearchVocabCodeValues = function(value) {
			searchVocabCodeValues = value;
		};

		this.getFilteredSearchVocabCodeValues = function() {
			return filteredSearchVocabCodeValues;
		};

		this.setFilteredSearchVocabCodeValues = function(value) {
			filteredSearchVocabCodeValues = value;
		};

		this.getNomenclatureSearchVocabularies = function() {
			return nomenclatureSearchVocabularies;
		};

		this.setNomenclatureSearchVocabularies = function(value) {
			nomenclatureSearchVocabularies = value;
		};

		this.getThisVisitVocab = function() {
			return thisVisitVocab;
		};

		this.setThisVisitVocab = function(value) {
			thisVisitVocab = value;
		};

		this.getChronicVocab = function() {
			return chronicVocab;
		};

		this.setChronicVocab = function(value) {
			chronicVocab = value;
		};

		this.getDiagnosisClassification = function() {
			return diagnosisClassification;
		};

		this.setDiagnosisClassification = function(value) {
			diagnosisClassification = value;
		};

		this.getDiagnosisConfirmation = function() {
			return diagnosisConfirmation;
		};

		this.setDiagnosisConfirmation = function(value) {
			diagnosisConfirmation = value;
		};

		this.getProblemClassification = function() {
			return problemClassification;
		};

		this.setProblemClassification = function(value) {
			problemClassification = value;
		};

		this.getProblemConfirmation = function() {
			return problemConfirmation;
		};

		this.setProblemConfirmation = function(value) {
			problemConfirmation = value;
		};

		this.getDiagnosisType = function() {
			return diagnosisType;
		};

		this.setDiagnosisType = function(value) {
			diagnosisType = value;
		};

		this.getInfoButtonInd = function() {
			return infoButtonInd;
		};

		this.setInfoButtonInd = function(value) {
			infoButtonInd = value;
		};

		this.setModifyInd = function(value) {
			modifyInd = value;
		};

		this.getModifyInd = function() {
			return modifyInd;
		};

		this.setDuplicateAllowedInd = function(value) {
			duplicateAllowedInd = value;
		};

		this.getDuplicateAllowedInd = function() {
			return duplicateAllowedInd;
		};
	};
})();
(function() {

	var CclString     = MPageEntity.String;
	var CclNumber     = MPageEntity.Number;
	var Entity        = MPageEntity.Entity;
	var OneToOne      = MPageEntity.OneToOne;
	var OneToMany     = MPageEntity.OneToMany;

	Entity.create(MPageEntity, "CodeSet", {
	    "fields": {
	        "id"         : new CclNumber(),
            "display"    : new CclNumber(),
            "description": new CclString(),
            "displayKey" : new CclString(),
            "codeValues" : new OneToMany("MPageEntity.CodeValue", "codeSet")
	    },

	    "listQuals": ["display", "displayKey"],

	    "actions": ["read", "list"]
	});

})(); (function() {
    var ns = MPageEntity.entities;
	var CclString     = MPageEntity.String;
	var CclNumber     = MPageEntity.Number;
	var Entity        = MPageEntity.Entity;
	var OneToOne      = MPageEntity.OneToOne;
	var SelfOneToOne  = MPageEntity.SelfOneToOne;
	var SelfOneToMany = MPageEntity.SelfOneToMany;
    var attribute     = MPageOO.attribute;
    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;

	Entity.create(MPageEntity, "CodeValue", {
	    "fields": {
	        "id"         : new CclNumber(),
            "codeSet"    : new OneToOne("MPageEntity.CodeSet"),
            "meaning"    : new CclString(),
            "display"    : new CclString(),
            "description": new CclString(),
            "definition" : new CclString(),
            "cki"        : new CclString()
	    },

	    "listQuals": ["meaning", "displayKey", "display", "codeSet"],

	    "actions": ["read", "list"]
	});

    // ------------------------------------------------------------------------
    // Override the read() method to support fastRead action
    //
    // Set CodeValue.setUseFastRead(false) or instance.setUseFastRead(false) to
    // disable using fast read.
    // ------------------------------------------------------------------------

    var CodeValue = MPageEntity.CodeValue;
    CodeValue.protocol = new EntityProtocolV2();
	CodeValue.setUseFastRead = function(fastread) {
	    MPageEntity.CodeValue.m_useFastRead = fastread;
	};

	CodeValue.getUseFastRead = function() {
	    return MPageEntity.CodeValue.m_useFastRead;
	};

    attribute(CodeValue, "UseFastRead");

	MPageEntity.CodeValue.prototype.read = function(id, callback) {
	    var fread = CodeValue.getUseFastRead();
	    var instPref = this.getUseFastRead();

	    if (instPref !== undefined && instPref !== null) {
            fread = this.getUseFastRead();
	    }

        if (fread) {
            this.clearFieldCaches();
            return this.action("fastRead", {"id": id}, callback);
        }
        return MPageEntity.Entity.prototype.read.call(this, id, callback);
	};


})(); 
(function() {
    var ns = MPageEntity.entities;
    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var CclBool = MPageEntity.CclBool;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity = MPageEntity.Entity;
    var OneToOne = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var CodeValueField = MPageEntity.CodeValueField;
    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;
    var Problem = "MPageEntity.entities.Problem";
    var Diagnosis = "MPageEntity.entities.Diagnosis";
    var Nomenclature = "MPageEntity.entities.Nomenclature";
    var HccInfo = "MPageEntity.entities.HccInfo";
    var HccCategory = "MPageEntity.entities.HccCategory";
    var RelatedRecords = "MPageEntity.entities.RelatedRecords";

    Entity.create(ns, "HccCategory", {
        "fields": {
            "description": new CclString(),
            "code": new CclNumber()
        }
    });

    Entity.create(ns, "HccInfo", {
        "fields": {
            "hccStatus": new CclString(),
            "lastServiceDateTime": new Iso8601DateTime(),
            "icd10code": new CclString()
        }
    });

	Entity.create(ns, "RelatedRecords", {
        "fields": {
            "related_rec_dt_tm": new Iso8601DateTime(),
            "related_rec_role": new CclString(),
            "related_rec_author_display": new CclString(),
			"related_rec_tranmitter_display": new CclString(),
			"doc_id": new CclString(),
			"doc_status": new CclString()
        }
    });

    Entity.create(ns, "Condition", {
        "fields": {
            "id": new CclNumber(),
            "lastUpdate": new Iso8601DateTime(),
            "problemDriver": new OneToOne(Problem),
            "diagnosisDriver": new OneToOne(Diagnosis),
            "display": new CclString(),
            "nomenclature": new OneToOne(Nomenclature),
            "targetNomenclature": new OneToOne(Nomenclature),
            "transitionNomenclature": new OneToOne(Nomenclature),
            "descriptionFreeText": new CclString(),
            "encounter": new OneToOne("MPageEntity.Encounter"),
            "onset": new Iso8601DateTime(),
            "onsetPrecision": new CclNumber(),
            "person": new OneToOne("MPageEntity.Person"),
            "problems": new OneToMany(Problem, "problemId", {
                sendFullObject: true
            }),
            "diagnoses": new OneToMany(Diagnosis, "diagnosisId", {
                sendFullObject: true
            }),
            "lifeCycleStatus": new CodeValueField(12030),
            "isThisVisit": new CclBool(),
            "isChronic": new CclBool(),
            "isHistorical": new CclBool(),
            "isInactive": new CclBool(),
            "isCernerNKP": new CclBool(),
            "diagnosisType": new CodeValueField(17),
            "classification": new CodeValueField(12033),
            "confirmationStatus": new CodeValueField(12031),
            "clinicalPriority": new CclNumber(),
            "contributorSystem": new CodeValueField(89),
            "clinicalService": new CodeValueField(29741),
            "laterality": new CodeValueField(4002375),
            "responsibleProvider": new OneToOne("MPageEntity.Person"),
            "responsibleProviderName": new CclString(),
            "activeInd": new CclBool(),
            "hccInd": new CclBool(),
            "hccLastAddressed": new Iso8601DateTime(),
            "hccInfo": new OneToOne(HccInfo),
            "hccCategories": new OneToMany(HccCategory),
            "comments": new OneToMany("MPageEntity.entities.ConditionComment"),
            "areCommentsStale": new CclBool(),
            "isSpecific": new CclBool(),
            "externalDataOriginatingAuthor": new CclString(),
            "externalDataOriginatingSource": new CclString(),
            "externalDataOriginatingDate"  : new CclString(),
            "externalDataOriginatingDtPrecision": new CclNumber(),
			"externalDataTransmittingSource"  : new CclString(),
			"externalDataDocId" : new CclString(),
			"externalDataDocStatus" : new CclString(),
            //This number could be from either code set 333 or 331, so CodeValueField will not work
            "pprCd": new CclNumber(1, MPageEntity.Config.ppr),
			"relatedRecords": new OneToMany(RelatedRecords),
			"iAdvInteropInd": new CclString(),
			"iPendingExtDataInd": new CclString(),
			"bypassDuplicateCheckInd": new CclBool(),
			"createTvAndChronicInd": new CclBool()
        },
        "listQuals": ["personId", "encounterId", "nomenclatureId", "origNomenId"],
        "actions": ["list", "insert"]
    });

    ns.Condition.protocol = new EntityProtocolV2();

    ns.Condition.TYPES = {
        THIS_VISIT: 0,
        THIS_VISIT_AND_CHRONIC: 1,
        NKP: 2,
        CHRONIC: 3,
        HISTORICAL: 4,
        INACTIVE: 5,
        THIS_VISIT_AND_INACTIVE: 6
    };

    var markCommentsAsStale = function(instance, callback) {
        return function() {
            instance.setAreCommentsStale(true);
            if (callback) {
                callback.apply(instance, arguments);
            }
        };
    };

    /**
     * Performs an asynchnous action while preserving various fields and meta data
     * @param  {String}   action   Name of the action to be performed
     * @param  {Object}   params   Paramaters to be passed with the action request
     * @param  {Object}   preservedFields Object used as dictionary from the entity field names to the cached entity field value
     * @param  {Object}   preservedMeta   Object used as dictionary from the entity name to the cached entity
     * @return {Condition}         The condition updated by the performed action
     */
    var preserveDetailsSync = function(action, params, preservedEntities,
        preservedMetaData) {
        var c = this.action(action, params);
        restoreDetails.call(this, preservedEntities, preservedMetaData);
        return c;
    };

    /**
     * Performs an asynchnous action while preserving various fields and meta data
     * @param  {String}   action   Name of the action to be performed
     * @param  {Object}   params   Paramaters to be passed with the action request
     * @param  {Object}   preservedFields Object used as dictionary from the entity field names to the cached entity field value
     * @param  {Object}   preservedMeta   Object used as dictionary from the entity name to the cached entity
     * @param  {Function} callback Function to be performed after action is completed
     * @return {Condition}         The condition updated by the performed action
     */
    var preserveDetailsAsync = function(action, params, preservedEntities,
        preservedMetaData, callback) {
        var self = this;
        return this.action(action, params, function() {
            var actionArguments = arguments;
            self.updateWin32(function() {
                restoreDetails.call(self, preservedEntities, preservedMetaData);
                callback.apply(self, actionArguments);
            });
        });
    };

    /**
     * Restores entity to point to previously cached meta data or related fields
     * @param  {Object} preservedEntities Object used as dictionary from the entity field names to the cached entity field value
     * @param  {Object} preservedMetaData Object used as dictionary from the entity name to the cached entity
     * @return {undefined}                undefined
     */
    var restoreDetails = function(preservedEntities, preservedMetaData) {
        restoreMeta.call(this, preservedMetaData);
        restoreEntities.call(this, preservedEntities);
    };

    /**
     * Restores the state of the meta object based on  a dictionary containing cached meta data
     * @param  {Object} preservedMetaData Object used as dictionary from the meta field name to the cached meta object field
     * @return {undefined}                Undefined
     */
    var restoreMeta = function(preservedMetaData) {
        var metaObj = this.getResponseMeta();
        Object.keys(preservedMetaData).forEach(function(field) {
            metaObj[field] = preservedMetaData[field];
        });
    };

    /**
     * Restores the state of the entities based on a dictionary containing cached entities
     * @param  {Object} preservedEntities Object used as dictionary from the entity name to the cached entity
     * @return {undefined}                undefined
     */
    var restoreEntities = function(preservedEntities) {
        var entity = this;
        Object.keys(preservedEntities).forEach(function(entityName) {
            entity["set" + entityName](preservedEntities[entityName]);
        });
    };

    /**
     * Runs an action but avoids overwriting certain existing entity fields
     * @param  {String}   action   Name of the action to be performed
     * @param  {Object}   params   Paramaters to be passed with the action request
     * @param  {Function} callback Function to be performed after action is completed
     * @param  {Boolean}   async   True if the action should take place asynchrnously
     * @return {Condition}         The condition updated by the performed action
     */
    var actionAndPreserveDetails = function(action, params, callback, async) {
        var preservedMetaFields = ["ICD10_VOCAB_CDS", "VALID_SOURCE_VOCAB_CDS",
            "BEDROCK_VOCAB_CDS"
        ];
        var preservedEntities = {};
        var preservedMetaData = {};
        var metaObj = this.getResponseMeta();

        if (metaObj){
            preservedMetaFields.forEach(function(metaField) {
                preservedMetaData[metaField] = metaObj[metaField];
            });
        }

        preserveComments.call(this, preservedEntities);

        if (callback || async) {
            return preserveDetailsAsync.call(this, action, params, preservedEntities,
                preservedMetaData, callback);
        }
        this.updateWin32();
        return preserveDetailsSync.call(this, action, params, preservedEntities,
            preservedMetaData);
    };

    /**
     * Handles preserving the previous state of the condition comments before an action is commited
     * @param  {Object} preservedEntities Object used as dictionary from the entity field names to the cached entity field value
     * @return {undefined}                undefined
     */
    var preserveComments = function(preservedEntities) {
        var comments = this.getCommentsValue() ? this.getComments() : [];
        preservedEntities["Comments"] = comments;
    };

	/**
     * Calls the action method to retrieve the condition list
     * @return {conditions} Returns the conditions with historical diagnoses and comments
     * for a specific condition nomenclature
     */
    MPageEntity.entities.Condition.listByNomen = function(params, callback){
        var ACT_LIST_BY_NOMENCLATUREID = "byNomen";
        var condition = new MPageEntity.entities.Condition();
        var inEdge = CERN_Platform.inEdgeContext();
        // If the browser is edge then send the last parameter which is async indicator as true.
        if (inEdge) {
            return condition.action(ACT_LIST_BY_NOMENCLATUREID, params, callback, true);
        }
        return condition.action(ACT_LIST_BY_NOMENCLATUREID, params, callback, false);
    };

    var prot = ns.Condition.prototype;
    prot.getNomenConverter = function() {
        if (this.nomenConverter) {
            return this.nomenConverter;
        }
        if (MPageEntity.Win32NomenclatureConverter) {
            this.nomenConverter = new MPageEntity.Win32NomenclatureConverter(MPageEntity.Config.ppr,
                Entity.meta.positionCd);
        }
        return this.nomenConverter;
    };

    prot.setNomenConverter = function(converter) {
        this.nomenConverter = converter;
    };

    /**
     * Creates a new condition that is this visit and chronic.
     * This function is async only.
     */
    prot.createTvAndChronic = function(bedrock, callback) {
        var self = this;
        this.getNomenConverter().convertTvAndChronic(this, bedrock, function(mappings){
            if (!mappings) {
                callback(null, null, {
                    crossMappingError: true
                });
                return;
            }
            self.setIsChronic(false);
            self.setTargetNomenclatureValue(mappings.thisVisit);
            self.create(function (conds, raw, err) {
                if (err) {
                    callback(conds, raw, err);
                    return;
                }
                self.setTargetNomenclatureValue(mappings.chronic);
                self.setIsChronic(true);
                self.moveToChronic(bedrock, callback);
            });
        });
    };

    /**
     * Creates the new condition.
     * @param  {Function} callback Function to be performed after action is completed
     */
    prot.create = function(callback) {
        //ensure that new conditions are created with the proper PPR_CD
        this.setPprCd(MPageEntity.Config.ppr);
        var self = this;
        if (callback) {
            return Entity.prototype.create.call(self, function (conditions, response, error) {
                if (error) {
                  callback(conditions, response, error);
                } else {
                  self.updateWin32(function () {
                    self.retrieveSpecificity(function () {
                      callback(conditions, response, error);
                    });
                  });
                }
            });
        }
        else {
            Entity.prototype.create.call(self, callback);
            self.updateWin32();
            self.retrieveSpecificity();
            return self;
        }
    };

    /**
     * Returns the problem driver by looking it up in the problems array
     */
    prot.getProblemDriverFromArray = function() {
        return this.getProblems().filter("id", this.getProblemDriverValue())[0];
    };

    /**
     * Returns the diagnosis driver by looking it up in the diagnosis array
     */
    prot.getDiagnosisDriverFromArray = function() {
        return this.getDiagnoses().filter("id", this.getDiagnosisDriverValue())[0];
    };

    /**
     * Whether the user has the necessary privs to modify the condition.
     * Takes into account whether a condition is this visit or chronic, and exceptions.
     * @return {boolean}
     */
    prot.canModify = function() {

        // this visit and chronic
        if (this.getProblemDriverValue() > 0 && this.getDiagnosisDriverValue() > 0) {
            return this.canModifyChronic() && this.canModifyThisVisit();
        }

        // chronic
        if (this.getProblemDriverValue() > 0) {
            return this.canModifyChronic();
        }

        // this visit
        if (this.getDiagnosisDriverValue() > 0) {
            return this.canModifyThisVisit();
        }

        return false;
    };

    prot.isResolved = function() {
        return (!this.getIsChronic() && !this.getIsInactive() && this.getIsHistorical() &&
            this.getProblemDriverValue());
    };

    prot.canModifyChronic = function() {
        return this.getProblemDriverValue() > 0 && this.getProblemDriverFromArray()
            .getCanCondModify();
    };

    prot.canModifyThisVisit = function() {
        return this.getDiagnosisDriverValue() > 0 && this.getDiagnosisDriverFromArray()
            .getCanCondModify();
    };

    prot.getCrossMapping = function(bedrockConfig, callback) {
        var self = this;
        try {
            var converter = this.getNomenConverter();

            if (callback) {
                converter.convert(this, bedrockConfig, function (condition, response,
                    error){
                    if (error) {
                        logger.logError("Condition.js (getCrossMapping) with callback - " + error);
                        return callback(condition, null, error);
                    }
                    self.setTargetNomenclatureValue(response);
                    callback(condition, response, error);
                });
            }
            else {
                this.setTargetNomenclatureValue(converter.convert(this, bedrockConfig));
            }
        } catch (err) {
            throw new Error("Condition.js (getCrossMapping) - " + err);
        }
    };

    prot.getCrossMappingTV = function (bedrockConfig, callback) {
        var self = this;
        try {
            var converter = this.getNomenConverter();

            if (callback){
                converter.convertTv(this, bedrockConfig, function (condition, response, error){
                    if (error) {
                        logger.logError("Condition.js (getCrossMappingTV) with callback - " + error);
                        return callback(condition, null, error);
                    }
                    self.setTargetNomenclatureValue(response);
                    callback(condition, response, error);
                });
            }
            else {
                this.setTargetNomenclatureValue(converter.convertTv(this, bedrockConfig));
            }
        } catch (err) {
            throw new Error("Condition.js (getCrossMappingTV) - " + err);
        }
    };


    prot.getCrossMappingChronic = function(bedrockConfig, callback) {
        var self = this;
        try {
            var converter = this.getNomenConverter();

            if (callback){
                converter.convertChronic(this, bedrockConfig, function (condition, response, error){
                    if (error){
                        logger.logError("Condition.js (getCrossMappingChronic) with callback - " + error);
                        callback(condition, null, error);
                    }
                    self.setTargetNomenclatureValue(response);
                    callback(condition, response, error);
                });
            }
            else{
                this.setTargetNomenclatureValue(converter.convertChronic(this,
                    bedrockConfig));
            }

        } catch (err) {
            throw new Error("Condition.js (getCrossMappingChronic) - " + err);
        }
    };

    /**
     * Retrieve the specificity for the current condition
     * @param  {Function} callback Function to be performed after action is completed
     * @return {Condition} Returns the condition that specificity has been retrieved for
     */
    prot.retrieveSpecificity = function(callback) {
        //Specificity is only retrieved for TV conditions with associated diagnoses
        var diagnoses = this.getDiagnoses();
        var self = this;
        if (callback) {
            if (self.getIsThisVisit() && diagnoses && diagnoses.length) {
                var conditionList = new ns.ConditionList();
                conditionList.push(self);
                conditionList.retrieveSpecificities(function(error) {
                    callback(self, error);
                    return self;
                });
		return self;
            }
            callback(self);
            return self;
        } else {
            if (this.getIsThisVisit() && diagnoses && diagnoses.length) {
                var conditionList = new ns.ConditionList();
                conditionList.push(this);
                conditionList.retrieveSpecificities();
            }
            return this;
        }
    };


    /**
     * Performs necessary actions after the This Visit driver nomenclature has been updated
     * @param  {ConditionList}   conditions ConditionList returned by updating action
     * @param  {String}   response   Raw response string from action
     * @param  {Error}   error       Error thrown by action
     * @param  {Function} callback   Callback to be called after TV updates completed
     * @return {undefined}           undefined
     */
    prot.onThisVisitNomenclatureUpdate = function(conditions, response, error,
        callback) {
        if (callback) {
            this.retrieveSpecificity(function(){
                callback(conditions, response, error);
            });
        } else {
            this.retrieveSpecificity();
        }
    };

    prot.moveToThisVisit = function(bedrockConfig, callback, async) {
        if (!this.getEncounterValue()) {
            throw new Error("Encounter is required for moveToThisVisit.");
        }
        var self = this;
        this.setIsThisVisit(true);
        var afterMoveToThisVisit = function(conditions, response, error) {
            self.onThisVisitNomenclatureUpdate(conditions, response, error, callback);
        };
        var isAsynch = async ? true : (callback ? true : false);
        return actionAndPreserveDetails.call(this, "moveToThisVisit", this,
            afterMoveToThisVisit, isAsynch);
    };

    prot.removeFromThisVisit = function(callback) {
        var self = this;
        var afterRemoveFromThisVisit = markCommentsAsStale(this, function(
            conditions, response, error) {
			if (!self.getIsThisVisit()) {
				self.setIsSpecific(null);
			}
            self.onThisVisitNomenclatureUpdate(conditions, response, error, callback);
        });
        var isAsynch = callback ? true : false;
        return actionAndPreserveDetails.call(this, "removeFromThisVisit", this,
            afterRemoveFromThisVisit, isAsynch);
    };

    prot.activate = function(callback) {
        return actionAndPreserveDetails.call(this, "activate", this, callback);
    };

    prot.inactivate = function(callback) {
        return actionAndPreserveDetails.call(this, "inactivate", this, callback);
    };

    prot.moveToChronic = function(bedrockConfig, callback) {
        this.setIsChronic(true);
        return actionAndPreserveDetails.call(this, "moveToChronic", this, callback);
    };

    function inVocabList(vocab, vocabList) {
        var vocabCnt = vocabList.length;
        for (var i = 0; i < vocabCnt; i++) {
            if (vocab === vocabList[i].VOCAB_CD) {
                return true;
            }
        }
        return false;
    }

    /**
     * ProblemFlaggingType - Enum to store possible flagging settings
     * MATCHING_SEARCH_VOCAB - Flag if condition source nomenclature different thatn search nomenclature
     * NONE - Don't flag conditions
     * VALID_VOCAB - Flag if condition not IMO, SNOMED, MAYO, or HLIPFT
     */
    var ProblemFlaggingType = {
        "MATCHING_SEARCH_VOCAB": 1,
        "NONE": 2,
        "VALID_VOCAB": 3
    };

    prot.isFlagged = function(bedrockConfig) {
        var metaObj = this.getResponseMeta();
        var problemTypeFlag;
        var pregnancyFlag = 2;

        var problemListFlag = parseInt(bedrockConfig.getProblemListFlag(), 10);
        var searchVocabCodeValues = bedrockConfig.getSearchVocabCodeValues().map(function(codeValue){
            return parseInt(codeValue, 10)
        });

        var validVocabs = metaObj.VALID_SOURCE_VOCAB_CDS;

        /**
         * Determine if given vocabulary is ICD10
         * @param  {Number} codeValue code value of vocabulary
         * @return {Boolean} true if given vocabulary is ICD10
         * @private
         */
        var isICD10 = function(codeValue) {
            return inVocabList(codeValue, metaObj.ICD10_VOCAB_CDS);
        };

        /**
         * Determine if condition vocabulary matches with the search vocabulary
         * @param  {Number} searchVocab code value of search vocabulary
         * @param  {Number} condVocab   code value of vocabulary associated with condition
         * @return {Boolean} true if search and condition vocabulary matches else false
         * @private
         */
        var isSearchAndCondVocabMatching = function(searchVocab, condVocab) {
            if (isICD10(searchVocab)) {
                return isICD10(condVocab);
            } else {
                return (searchVocab === condVocab);
            }
        };

        var condition = this;
        var problemDriver = condition.getProblemDriverFromArray();
        if (problemDriver) {
            problemTypeFlag = problemDriver.getProblemTypeFlag();
        }

        if (!condition.getProblemDriverValue() || searchVocabCodeValues.length <= 0 || problemTypeFlag === pregnancyFlag) {
            return false;
        }
        switch (problemListFlag) {
            case ProblemFlaggingType.NONE:
                return false;
            case ProblemFlaggingType.MATCHING_SEARCH_VOCAB:
                //map from bedrock setting to actual vocabulary
                var condSearchVocab = condition.getNomenclature().getSourceVocabularyValue();
                // determine if condSearch vocab matches with either of search vocabularies
                // if Yes, then don't flag it
                return !searchVocabCodeValues.some(function (item) {
                   return isSearchAndCondVocabMatching(item, condSearchVocab);
                });
            case ProblemFlaggingType.VALID_VOCAB:
                var targetVocab = problemDriver.getNomenclature().getSourceVocabularyValue();
                var searchVocab = condition.getNomenclature().getSourceVocabularyValue();
                if (!validVocabs) {
                    return false;
                }

                var hasValidTargetVocab = inVocabList(targetVocab, validVocabs);
                var hasValidSourceVocab = inVocabList(searchVocab, validVocabs);
                //Flag condition if it doesn't have valid target vocab or source vocab
                return !(hasValidTargetVocab || hasValidSourceVocab);
            default:
                return false;
        }
    };

    prot.moveToHistorical = function(callback) {
        return actionAndPreserveDetails.call(this, "moveToHistorical", this, callback);
    };

    prot.cancel = function(callback) {
        return actionAndPreserveDetails.call(this, "cancel", this,
            markCommentsAsStale(this, callback));
    };

    prot.unresolve = function(callback) {
        return actionAndPreserveDetails.call(this, "unresolve", this, callback);
    };

    prot.update = function(callback) {
        return actionAndPreserveDetails.call(this, "update", this, callback);
    };

    prot.updatePriority = function(callback) {
        return actionAndPreserveDetails.call(this, "updatePriority", this, callback);
    };

    /**
     * Checks whether the condition is of free text type
     */
    prot.isFreeText = function() {
        return (this.getNomenclatureValue() === 0.0 || this.getNomenclatureValue() === null);
    };

    /**
     * Refreshes the list of probs and dxs that is held by win32
     * @param  {Function} callback Function to be performed after action is completed
     */
    prot.updateWin32 = function(callback) {
        var probDxUtils;
        var self = this;
        if (callback) {
            probDxUtils = MPageEntity.getProbDxUtils(callback);
            return probDxUtils.isAvailable().then(function (isProbDxUtilAvailable) {
                if (isProbDxUtilAvailable) {
                    return Promise.all([
                        probDxUtils.invoke("RefreshDiagnosisCollection", [self.getPersonValue(), self.getEncounterValue()]),
                        probDxUtils.invoke("RefreshProblemCollection", [self.getPersonValue()])
                    ]).then(function() {
                        callback();
                    });
                } else {
                    throw new Error("PROBDXUTILS COM object is not available");
                }
            }).catch(function(err) {
                logger.logJSError(err, null, "condition.js", "updateWin32");
                callback(err);
            });
        } else {
            probDxUtils = MPageEntity.getProbDxUtils();
            if (!probDxUtils) {
                logger.logError("Unable to create the PROBDXUTILS COM object");
                return;
            }
            probDxUtils.RefreshDiagnosisCollection(this.getPersonValue(), this.getEncounterValue());
            probDxUtils.RefreshProblemCollection(this.getPersonValue());
        }
    };

    /**
     * Overrides the base list method so that we can monitor load times
     */
    prot.list = function(params, callback) {
        if (typeof(RTMSTimer) !== 'undefined') {
            var loadTimer = new RTMSTimer("ENG:MPG.CONDITION_ENTITY - list");
            loadTimer.addMetaData("key");
            loadTimer.start();
        }
        var self = this;
        if (callback) {
            return Entity.prototype.list.call(this, params, function(conditions) {
                try {
                    var actionArguments = arguments;
                    if (self.m_Meta.isDxAssistantEnabled){
                        conditions.retrieveSpecificities(function(){
                            callback.apply(window, actionArguments);
                            return;
                        });
                    } else {
                        callback.apply(window, actionArguments);
                    }
                } catch (err) {
                    if (loadTimer) {
                        loadTimer.fail();
                    }
                    throw (err);
                } finally {
                    if (loadTimer) {
                        loadTimer.stop();
                    }
                }
            });
        } else {
            return Entity.prototype.list.call(this, params, callback);
        }
    };

    /**
     * Returns comments with the current condition associated to them.
     */
    prot.getCommentsWithAssociation = function(callback) {
        var self = this;
        if (callback) {
            self.getComments(function(comments) {
                self.associateComments(comments);
                callback.apply(this, arguments);
            });
        } else {
            var comments = this.getComments();
            self.associateComments(comments);
            return comments;
        }
    };

    /**
     * Sets the conditions of a comment list to the current condition
     * instance.
     */
    prot.associateComments = function(comments) {
        var self = this;
        comments.each(function(comment) {
            comment.setCondition(self);
        });
    };

    /**
     * Whether mapping has been performed on the condition or not.
     */
    prot.isMapped = function() {
        return this.getTargetNomenclatureValue() ? true : false;
    };

    /**
     * Whether the target nomenclature is ICD10
     */
    prot.isTargetICD10 = function() {
        if (!this.getResponseMeta() || !this.getResponseMeta().ICD10_VOCAB_CDS) {
            throw new Error('Condition instance does not have an associated' +
                ' ICD10 vocabulary list.');
        }

        var icd10vocabs = this.getResponseMeta().ICD10_VOCAB_CDS;
        for (var i = icd10vocabs.length; i--;) {
            var targetVocab = this.getTargetNomenclature().getSourceVocabularyValue();
            if (icd10vocabs[i].VOCAB_CD == targetVocab) {
                return true;
            }
        }
        return false;
    };

    /**
     * Whether the condition is empty (has no driver diagnosis or problem)
     * @return {Boolean} Returns true iff the condition has no driver problem or diagnosis
     */
    prot.isEmpty = function() {
        return !this.getDiagnosisDriverValue() && !this.getProblemDriverValue();
    };

    /**
     * Whether this condition meets all the criteria necessary
     * to be able to open the dx assistant.
     */
    prot.hasDxAssistant = function() {
        if (this.getDiagnosisDriverValue() &&
            this.isMapped() &&
            !this.isFreeText() &&
            this.getIsSpecific() !== null &&
            this.getIsSpecific() !== undefined) {
            return true;
        }

        return false;
    };

    /**
     * Fills in chronic conditions details based on bedrock settings
     * Utilized for move-to-chronic and chronic creation
     * @param   {Condition} condition Condition to fill details with
     * @returns {Condition}           Returns self for chaining
     */
    var fillChronicCondition = function(condition, bedrockConfig) {
        condition.setIsChronic(true);
        if (condition.getIsHistorical()) {
            condition.setIsHistorical(false);
        }
        condition.setClassificationValue(bedrockConfig.getProblemClassification());
        condition.setConfirmationStatusValue(bedrockConfig.getProblemConfirmation());
        condition.setOnset(new Date());
        return condition;
    };

    /**
     * Handles attempts to move to chronic // includes resolved
     * @param   {Object}   bedrockConfig Bedrock Configuration
     * @param   {Function} callback      Function to be applied after updating condition
     * @returns {undefined}              undefined
     */
    prot.crossmapToChronic = function (bedrockConfig, callback) {
        var inEdge = CERN_Platform.inEdgeContext();
        if (inEdge) {
            var condition = this;
            if (condition.isResolved()) {
                condition.activate(function (conditions, raw) {
                    callback(condition, raw);
                });
            } else {
                var initialTarget = condition.getTargetNomenclatureValue();
                condition.getCrossMappingChronic(bedrockConfig, function () {
                    // Return early with no updates if no target nomenclature selected
                    // from cross-mapping
                    if (!condition.getTargetNomenclatureValue()) {
                        condition.setTargetNomenclatureValue(initialTarget);
                        return callback(condition, null);
                    }
                    fillChronicCondition.call(self, condition, bedrockConfig)
                        .moveToChronic(bedrockConfig, function (conditions, raw, error) {
                            callback(condition, raw, error);
                        });
                });
            }
        }
        else {
            var condition = this;
            if (condition.isResolved()) {
                condition.activate(function (conditions, raw) {
                    callback(condition, raw);
                });
            } else {
                var initialTarget = condition.getTargetNomenclatureValue();
                condition.getCrossMappingChronic(bedrockConfig);

                // Return early with no updates if no target nomenclature selected
                // from cross-mapping
                if (!condition.getTargetNomenclatureValue()) {
                    condition.setTargetNomenclatureValue(initialTarget);
                    return false;
                }
                fillChronicCondition.call(self, condition, bedrockConfig)
                    .moveToChronic(bedrockConfig, function (conditions, raw, error) {
                        callback(condition, raw, error);
                    });
            }
            return true;
        }
    };

    /**
     * Fills in TV conditions details based on bedrock settings
     * Utilized for move-to-this-visit and this visit creation
     * @param   {Condition} condition Condition to fill details with
     * @param   {Number}    priority  The priority to associate to the condition
     * @returns {Condition}           Returns self for chaining
     */
    var fillThisVisitCondition = function(condition, priority, bedrockConfig) {
        condition.setIsThisVisit(true);
        if (condition.getIsHistorical()) {
            condition.setIsHistorical(false);
        }
        condition.setDiagnosisTypeValue(bedrockConfig.getDiagnosisType());
        condition.setClassificationValue(bedrockConfig.getDiagnosisClassification());
        condition.setConfirmationStatusValue(bedrockConfig.getDiagnosisConfirmation());
        if (priority) {
            condition.setClinicalPriority(priority);
        }
        return condition;
    };


    /**
     * Handles attempts to move condition to this visit
     * @param   {Object}   bedrockConfig Bedrock configuration
     * @param   {Number}   priority      Priority to associate to diagnosis
     * @param   {Function} callback      Function to be applied after updating condition
     * @returns {undefined}              undefined
     */
    prot.crossmapToThisVisit = function(bedrockConfig, priority, callback) {
        var condition = this;
        var inEdge = CERN_Platform.inEdgeContext();
        if (inEdge) {
            var initialTarget = condition.getTargetNomenclatureValue();
            condition.getCrossMappingTV(bedrockConfig, function () {
                //Return early with no update if no target nomenclature selected from cross-mapping
                if (!condition.getTargetNomenclatureValue()) {
                    condition.setTargetNomenclatureValue(initialTarget);
                    return callback(condition, null);
                }

                fillThisVisitCondition(condition, priority, bedrockConfig)
                    .moveToThisVisit(bedrockConfig, function (conditions, raw, err) {
                        callback(condition, raw, err);
                    });
            });
        }
        else {
            var initialTarget = condition.getTargetNomenclatureValue();
            condition.getCrossMappingTV(bedrockConfig, function () {
                //Return early with no update if no target nomenclature selected from cross-mapping
                if (!condition.getTargetNomenclatureValue()) {
                    condition.setTargetNomenclatureValue(initialTarget);
                    return false;
                }

                fillThisVisitCondition(condition, priority, bedrockConfig)
                    .moveToThisVisit(bedrockConfig, function (conditions, raw, err) {
                        callback(condition, raw, err);
                    });
            });
            return true;
        }
    };

     /**
     * Determines condition is HCC, HCC satisfied or HCC not satisfied
     * @returns {string}              hccStatus
     */
    prot.getHccStatus = function() {
        var condition = this;
        var isInactive = condition.getIsInactive();
        var isHistorical = condition.getIsHistorical();
        var isHcc = condition.getHccInd();
        var hccLastAddressed = condition.getHccLastAddressed();
        var isThisVisit = condition.getIsThisVisit();
        var hccLastAddressedYear = new Date(hccLastAddressed).getFullYear();
        var currentYear = new Date().getFullYear();
        var outOfCalendarYear = false;
        if(hccLastAddressed){
            outOfCalendarYear = currentYear - hccLastAddressedYear > 0;
        }
        var hccStatus = {
            NOT_HCC: "NOT HCC",
            HCC_SATISFIED: "HCC SATISFIED",
            HCC_NOT_SATISFIED: "HCC NOT SATISFIED"
        }
       if (!isHcc) {
            return hccStatus.NOT_HCC;
       }
       else {
            if (isThisVisit || isInactive || (!isThisVisit && !condition.getIsChronic() && isHistorical) || (!isThisVisit && hccLastAddressed && !outOfCalendarYear)) {
                /*return HCC SATISFIED for the following scenarios
                    - Condition is This Visit.
                    - Condition is Chronic but Inactive
                    - Condition is Resolved or Condition is This Visit Historical
                    - Condition is not a This Visit but Chronic with last addressed date within calendar year
                */
                return hccStatus.HCC_SATISFIED;
            }
            else {
                /*return HCC NOT SATISFIED for the following scenarios
                    - Condition is not This Visit but Chronic with last addressed date out of calendar year
                    - Condition is not This Visit but Chronic with no last addressed date
                */
                return hccStatus.HCC_NOT_SATISFIED;
            }
       }
    };
})();
(function(ns, inherits, attribute) {

    var EntityList = MPageEntity.EntityList;
    var SORTING = MPageEntity.EntityList.SORTING;

    ns.ConditionList = function() {
        EntityList.call(this, ns.Condition);

        // this ensures generator methods like splice() will
        // create the correct class.
        this.setEntityListClass(ns.ConditionList);
    };

    MPageEntity.entities.Condition.defaultEntityListClass = ns.ConditionList;

    inherits(ns.ConditionList, EntityList);

    var prot = ns.ConditionList.prototype;

    /**
     * Performs the moveToHistoric action on all entities.
     */
    prot.moveToHistoric = function() {
        this.action("moveToHistoric");
    };

    /**
     * Performs the cancel action on all the entities
     */
    prot.cancel = function() {
        this.action("cancel");
    };

    /**
     * Retrieve the value of the highest priority found in the condition list
     * @return {Integer} Highest priority present in the condition list
     */
    prot.getHighestPriority = function(){
        var conditionList = this;
        var highestPriority = 0;
        var conditionCnt = this.length;
        var priority = 0;
        var condition = null;
        for (var i = 0; i < conditionCnt; i++){
            condition = conditionList[i];
            priority = condition.getClinicalPriority() || 0;			            
            if (condition.getIsThisVisit() && priority > highestPriority){				
                highestPriority = priority;
            }
        }
        return highestPriority;
    };

    /**
     * Returns a new ConditionList where the conditions are ordered
     * according to the order array. The types are specified on Condition.TYPES.
     *
     * ex:
     * var thisAndChron = mylist.sortByType([Condition.TYPES.THIS_VISIT, Condition.TYPES.CHRONIC]);
     *
     * Additionally, the internal alpha sorting can be specified by setting the alphaSort parameter:
     *
     * var thisVisit = mylist.sortByType([Condition.TYPES.THIS_VISIT], EntityList.SORTING.DESC);
     */
    prot.sortByType = function(order, alphaSort) {
        var result = this.makeEmptyList();
        var types = MPageEntity.entities.Condition.TYPES;

        for (var i=0; i<order.length; i++) {
            var filterName = "";
            var filtered;

            switch(order[i]) {
                case types.THIS_VISIT: {
                    filtered = this.filter("isThisVisit", true);
                    break;
                }
                case types.CHRONIC: {
                    filtered = this.filter("isChronic", true)
                        .filter("isThisVisit", false)
                        .filter("isCernerNKP", false);
                    break;
                }
                case types.HISTORICAL: {
                    filtered = this.filter("isHistorical", true)
                    .filter("isThisVisit", false)
                    .filter("isChronic", false)
                    .filter("isCernerNKP", false);
                    break;
                }
                case types.NKP: {
                    filtered = this.filter("isCernerNKP", true)
                    .filter("isThisVisit", false);
                    break;
                }
                default:
                    throw new Error("Invalid Condition type provided in sortByType()");
            }

            // apply alpha sorting
            alphaSort = alphaSort ? alphaSort : MPageEntity.EntityList.SORTING.ASC;
            filtered.sortBy("display", alphaSort);

            result = result.concat(filtered);
        }
        return result;
    };

    /**
     * Returns a ConditionList where the conditions are ordered by priority.
     * Only this visit conditions will be sorted and returned. Conditions with
     * no priorities (priority of 0) will be placed at the bottom.
     *
     * The order parameter can be asceding or descending by passing the
     * correspondent EntityList.SORTING value.
     *
     * @param {EntityList.SORTING|null} order
     * @return {T[]|Array.<any>|*[]}
     */
    prot.sortByPriority = function(order) {
        if (!order) {
            order = SORTING.ASC;
        }

        var thisVisits = this.filter("isThisVisit", true);
        var priorityNotSet = thisVisits.filter(function(cond) {
           return cond.getClinicalPriority() <= 0 || !cond.getClinicalPriority();
        });
        var prioritySet = thisVisits.getPrioritizedOnly();
        prioritySet.sortBy("clinicalPriority", order);

        return prioritySet.concat(priorityNotSet);
    };

    /**
     * Returns only the conditions which have a priority set
     * @return {*}
     */
    prot.getPrioritizedOnly = function() {
        return this.filter(function(condition) {
            return condition.getClinicalPriority() > 0 && condition.getIsThisVisit();
        });
    };

    /**
     * Returns only the condition which have a greater priority than what's passed in
     * @param {Number} The priority for which conditions must be greater to return
     * @param {ConditionList} Conditions with priority grater than N
     */
    prot.getPrioritizedOverN = function(n) {
        return this.filter(function(condition) {
            return condition.getClinicalPriority() > n && condition.getIsThisVisit();
        });
    };

    /**
     * Resequences conditions according to their priority. Will return a new
     * condition list with only the conditions that need update.
     *
     * @param condition
     * @param newPriority
     * @param removeConditionFlag
     */
    prot.updatePriorityAndResequence = function(condition, newPriority, removeConditionFlag) {

		var toSave = this.makeEmptyList();
		var prioritized = null;
		var priorityOfCondition = condition.getClinicalPriority();

		//Prioritize only the subset of conditions whose priorities are being changed.
		//priority of the condition is being updated to -- or 0,
		//prioritize only conditions that have clinical priority greater than the current condition.
		if (newPriority === 0 || removeConditionFlag) {
			prioritized = this.filter(function(cond) {
				return cond.getClinicalPriority() >= priorityOfCondition && cond.getIsThisVisit();
			});
		} else if (priorityOfCondition < newPriority && priorityOfCondition) {//priority of the condition is set to a higher/lower numerical value, grab all conditions between current value and new value
			prioritized = this.filter(function(cond) {
				return cond.getClinicalPriority() >= priorityOfCondition && cond.getClinicalPriority() <= newPriority && cond.getIsThisVisit();
			});
		} else if (priorityOfCondition > newPriority) {
			prioritized = this.filter(function(cond) {
				return cond.getClinicalPriority() <= priorityOfCondition && cond.getClinicalPriority() >= newPriority && cond.getIsThisVisit();
			});
		} else if (priorityOfCondition === 0 && newPriority <= this.getHighestPriority()) {//condition with no priority is set to value that exists in the list, grab all conditions with priority greater and equal to the new priority
			prioritized = this.filter(function(cond) {
				return cond.getClinicalPriority() >= newPriority && cond.getIsThisVisit() || cond == condition;
			});
		} else if (priorityOfCondition === 0 && newPriority > this.getHighestPriority()) {//condition with no priority is set to a value greater than the current highest priority, then we need to just update this condition.
			condition.setClinicalPriority(newPriority);
			toSave.push(condition);
		}

		if (!toSave.length) {
			prioritized = prioritized.sortBy("clinicalPriority", SORTING.ASC);
			//Since we are going to prioritize from the beginning of the subset of conditions between the new and the previous priority,
			//grab the very first one in the list.
			var firstCondition = prioritized[0].getClinicalPriority();

			//Since the conditions are being sorted, the condition with 0 priority will be at the top of the list.
			var priority = ( firstCondition ? firstCondition : prioritized[1].getClinicalPriority()) - removeConditionFlag;
			prioritized.each(function(cond) {

				// will not resequence conditions we do not have permission
				if (!cond.canModify()) {
					return;
				}
				toSave.push(cond);
				// Change the priority of the current condition to the new priority
				if (cond == condition) {
					cond.setClinicalPriority(newPriority);
					return;
				}
				if (priority >= newPriority && newPriority > 0) {
					cond.setClinicalPriority(priority + 1);
				} else {
					cond.setClinicalPriority(priority);
				}
				priority++;

			});
		}
		return toSave;
    };

    /**
    * Removes the specified condition from the list and resequences the remaining
    * conditions. Will return a list of conditions that have had their priorities changed.
    *
    * @param condition
    */
    prot.removeAndResequence = function(condition, priority) {
        // we don't resequence if it is the last prioritized condition
		var removeConditionFlag = 1;
        if (priority === 0 || priority === this.getHighestPriority()) {
            this.removeIfEmpty(condition);
            return this.makeEmptyList();
        }		
        //var prioritized = this.getPrioritizedOnly().sortBy("clinicalPriority", SORTING.ASC);				        
		var prioritized = this.getPrioritizedOverN(priority).sortBy("clinicalPriority", SORTING.ASC);
        var nextCondition = prioritized[0];
        this.removeIfEmpty(condition);
        
        if(!nextCondition){
        	return this.makeEmptyList();
        }
        return this.updatePriorityAndResequence(nextCondition,
            nextCondition.getClinicalPriority() - 1, removeConditionFlag);
    };

    /**
     * Removes the specified condition from the conditon list
     * @param  {Condition} condition Condition to remove from list
     * @return {ConditionList}       Updated condition list without the passed condition
     */
    prot.remove = function(condition) {
        var index = this.indexOf(condition);
        return this.splice(index, 1);
    };

    /**
     * Removes the specified condition only if empty
     * @param  {Condition} condition Condition to remove from list if empty
     * @return {ConditionList}       Returns updated condition list
     */
    prot.removeIfEmpty = function(condition) {
        if (condition.isEmpty()){
            this.remove(condition);
        }
        return this;
    };

    /**
     * Performs an update on all conditions in the list
     * @param callback
     */
    prot.update = function(callback) {
        return this.action('update', callback);
    };
	
    /**
     * Performs priority update on dx conditions in the list
     * @param callback
     */
    prot.updatePriority = function(callback) {
        return this.action('updatePriority', callback);
    };

    prot.getUnspecified = function(){
       return this
        .filter("isThisVisit", true)
        .filter("isSpecific", false);
    };

    /**
     * Returns whether or not APIs necessary for Diagnosis Assistant are present in the environment
     * @param {Function} callback Function to be applied after DxAssistant is available
     * @return {Boolean} True iff diagnosis assistant is available
     */
    function isDxAssistantAvailable(callback) {
        if(callback) {
            var dxAssistantDiscernObject = CERN_Platform.getWrappedDiscernObject("DIAGNOSISASSISTANT");
            Promise.all([dxAssistantDiscernObject.isAvailable(), dxAssistantDiscernObject.supports("GetNomenclatureSpecificityInfo")])
                .then( function(values) {
                    var isAvailable = values[0];
                    var isDxAssitantAvailable = values[1];
                    callback(isAvailable && isDxAssitantAvailable);
                });

        } else {
            var dxAssistantDiscernObject = CERN_Platform.getDiscernObject("DIAGNOSISASSISTANT");
            // utilize diagnosis assistant if diagnosis assistant and specificity retrieval
            return !!(dxAssistantDiscernObject && ("GetNomenclatureSpecificityInfo" in dxAssistantDiscernObject));
        }
    };

    /**
     * Returns a dx assistant instance for the currently running
     * platform. The instance will have two methods:
     *
     * launch(list, callback): opens up a dx assistant window and calls callback when done
     * populateSpecificities(list): sets the isSpecific flag of the conditions
     */
     function getDxAssistant(dxAssistantAvailable) {
        if (CERN_Platform && CERN_Platform.inMillenniumContext() && dxAssistantAvailable) {
            return new MPageEntity.entities.Condition.Win32DxAssistant();
        }

        // implement a dummy interface for when not in win32. If
        // we ever implement a web only DxAssistant, it shall be
        // instantiated here.
        logger.logWarning("DIAGNOSISASSISTANT or GetNomenclatureSpecificityInfo not available in environment, continuing without dx assistant");
        return {
            launch: function() {},
            populateSpecificities: function() {}
        };
    };

    /**
     * Returns a dx assistant instance for the currently running
     * platform. The instance will have two methods:
     * @param {Function} callback Function to be applied after creating dx assistant instance
     *
     * launch(list, callback): opens up a dx assistant window and calls callback when done
     * populateSpecificities(list): sets the isSpecific flag of the conditions
     */
    prot.createDxAssistant = function(callback) {
        if(callback) {
            isDxAssistantAvailable(function(isAvailable){
                callback(getDxAssistant(isAvailable));
            });
        } else {
            return getDxAssistant(isDxAssistantAvailable());
        }
    };

    /**
     * Runs the dx assistant generated by createDxAssistant and
     * executes the provided callback when closed.
     * @param {Function} callback Function to be applied after launching dx assistant
     */
    prot.launchDxAssistant = function(callback) {
        var conditions = this;
        this.createDxAssistant(function(dxAss){
            dxAss.launch(conditions, callback);
        });
    };

    /**
     * Populates the isSpecific fields of all the conditions in
     * the list
     * @param {Function} callback Function to be applied after populating specificities
     */
    prot.retrieveSpecificities = function(callback){
        if(callback) {
            var conditions = this;
            this.createDxAssistant(function(dxAss){
                dxAss.populateSpecificities(conditions, null, callback);
            });
        } else {
            var dxAss = this.createDxAssistant();
            dxAss.populateSpecificities(this);
        }
    };

    /**
     * Fires the dx assistant in order to specify the unspecified conditions
     * in the list
     */
    prot.resolveUnspecified = function(callback) {
      var conditions = this
        .filter("isSpecific", false)
        .filter(function (c) { return c.hasDxAssistant(); })
        .launchDxAssistant(callback);
    };

    /**
     * Returns an array with the code values as provided in the meta
     * object.
     *
     * @returns {*}
     */
    prot.getICD10CodeValuesFromMeta = function() {
        var vocabs = this.getResponseMeta().ICD10_VOCAB_CDS;
        var result = [];
        for (var i=vocabs.length; i--;) {
            result.push(vocabs[i].VOCAB_CD);
        }
        return result;
    };
	
	/**
     * Filters the historical diagnosis for this visit and historical encounters
     * remove the duplicate diagnoses and sets the resulted diagnoses to the resouce data condiltion list
     * @param   {Conditions} conditions Conditions retrieved by nomenclatureId
     * @return {undefined}                undefined
     */
    prot.filterDiagnoses = function (selectedCondition) {
        var conditions = this;

        var thisVisitDiagnoses = selectedCondition.getDiagnoses();
        var historicalDiagnoses = conditions[0].getDiagnoses();
        if(thisVisitDiagnoses.length){
            var historicalDiagnosesLen = historicalDiagnoses.length;
            for (var j = 0; j < historicalDiagnosesLen; j++) {
                if (thisVisitDiagnoses[0].getEncounterValue() === historicalDiagnoses[j].getEncounterValue()) {
                    historicalDiagnoses.splice(j, 1);
                    break;
                }
            }
        }
        $.merge(thisVisitDiagnoses, historicalDiagnoses);
        selectedCondition.setDiagnoses(thisVisitDiagnoses.sortBy("DIAGDTTM", SORTING.DESC));

        var thisVisitComments = selectedCondition.getComments();
        var thisVisitCommentsLen = thisVisitComments.length;
        var historicalComments = conditions[0].getComments();
        if(thisVisitCommentsLen){
            var historicalCommentsLen = historicalComments.length;
            var historicalCommentTime = null;
            var historicalCommentAuthor = null;
            var thisVisitCommentTime = null;
            var thisVisitCommentAuthor = null;
            for (var k = 0; k < historicalCommentsLen; k++) {
                historicalCommentTime = (historicalComments[k].getCreatedDateTime()).getTime();
                historicalCommentAuthor = historicalComments[k].getAuthorValue();
                for (var i = 0; i < thisVisitCommentsLen; i++) {
                    thisVisitCommentTime = thisVisitComments[i].getCreatedDateTime()
                        ? (thisVisitComments[i].getCreatedDateTime()).getTime()
                        : null;
                    thisVisitCommentAuthor = thisVisitComments[i].getAuthorValue();	
                    if (thisVisitCommentTime === historicalCommentTime && thisVisitCommentAuthor === historicalCommentAuthor) {
                        historicalComments.splice(k, 1);
                        historicalCommentsLen--;
                        k--;
                        break;
                    }
                }
            }
        }
        $.merge(thisVisitComments, historicalComments);
        selectedCondition.setComments(thisVisitComments.sortBy("CREATEDDATETIME", SORTING.DESC));
    };

    /**
     * Determines conditions has any hcc condition
     * @return {boolean}
     */
    prot.hasHccCondition = function () {
        var conditions = this;
        var condsLength = conditions.length;
        for(var i = 0; i < condsLength; i++){
           if(conditions[i].getHccInd()){
                return true;
            }
        }
        return false;
    };

     /**
     * Determines conditions has overdue hcc condition(s) to address
     * @return {boolean}
     */
    prot.hasOverdueHccCondition = function () {
        var conditions = this;
        var condsLength = conditions.length;
        for(var i = 0; i < condsLength; i++){
            if(conditions[i].getHccStatus() == "HCC NOT SATISFIED"){
                return true;
            }
        }
        return false;
    };
})(
    MPageEntity.entities,
    MPageOO.inherits,
    MPageOO.attribute
);
(function() {

    var ns = MPageEntity.entities;

    var EncodedString = MPageEntity.EncodedString;
    var EntNumber = MPageEntity.Number;
    var EntBool = MPageEntity.CclBool;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity = MPageEntity.Entity;
    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;
    var OneToOne = MPageEntity.OneToOne;
    var attribute = MPageOO.attribute;

    Entity.create(ns, "ConditionComment", {
        "fields": {
            "id": new EntNumber(),
            "author": new OneToOne("MPageEntity.entities.Prsnl"),
            "text": new EncodedString(),
            "createdDateTime": new Iso8601DateTime(),
            "condition": new OneToOne("MPageEntity.entities.Condition", {sendFullObject: true}),
            "originalCreatedDateTime": new MPageEntity.String()
        }
    });

     ns.ConditionComment.protocol = new EntityProtocolV2();

    /**
     * The date and personnel name as extracted from the comment text, if the comment
     * was identified as having a header by the splitDxComments method.
     */
     attribute(ns.ConditionComment, "Header");

     ns.ConditionComment.protocol = new EntityProtocolV2();

     // IE8 compatible trim function
     var trim = function(text) {
        return text.replace(/^\s+|\s+$/g, '');
     };

     ns.ConditionComment.splitDxComments = function(comments) {
        var result = this.makeEmptyList();
        var self = this;

        comments.each(function(comment) {
            var individualComment;
            var newComment;
            var header;
            var firstLine;
            var newlinePos;

            // if it doesn't start with a date, then it is most likely a problem
            if (!comment.startsWithDate()) {
                result.push(comment);
                return;
            }

            // splits two consecutive newlines into its separate comments.
            // this will not care about the style of line endings (\n versus \r\n)
            var individualComments = comment.getText().split(/\n\s*\r?\n/gm);

            // loops over the individual comments and parse dates/personnel names
            for (var i=0; i<individualComments.length; i++) {
                individualComment = individualComments[i];
                newlinePos = individualComment.indexOf("\n");
                firstLine = individualComment.substr(0, newlinePos);

                newComment = new self();
                comment.copyTo(newComment);
                newComment.setText(trim(individualComment.substr(newlinePos + 1)));
                newComment.setHeader(trim(firstLine));
                result.push(newComment);
            }
        });
        return result;
     };

     ns.ConditionComment.prototype.getFormattedHeader = function() {
        if (this.getHeader()) { return this.getHeader(); }

        var dt = this.getCreatedDateTime();
        var formattedDate = "";
        if (dt) {
            var format = dateFormat.masks.shortDate2 + " " + dateFormat.masks.shortTime;
            formattedDate = dt.format(format);
        }

        return formattedDate + " - " + this.getAuthor().getPerson().getNameFullFormatted();
     };

     ns.ConditionComment.prototype.startsWithDate = function() {
        var txt = this.getText();

        if (!txt) return false;

        var startOfFirstLine = txt.substr(0, txt.indexOf(" "));
        var dt = Date.parse(startOfFirstLine);
        return dt ? true : false;
     };

     /**
      * Override the standard create in order to force updating the most recent diagnosis
      * if we are updating this visit only (just diagnosis driver)
      */
     ns.ConditionComment.prototype.create = function(cb) {
        var cond = this.getCondition();

        if (!cond.getDiagnoses().length || !cond.getDiagnosisDriverValue() || cond.getProblemDriverValue()) {
            MPageEntity.Entity.prototype.create.call(this, cb);
            return;
        }

        var mostRecentDx = cond
            .getDiagnoses()
            .sortBy("diagDtTm", MPageEntity.EntityList.SORTING.DESC)[0];

        // copy the condition to avoid changing the driver of the original
        var condCopy = new MPageEntity.entities.Condition();
        cond.copyTo(condCopy);
        condCopy.setDiagnosisDriver(mostRecentDx);
        this.setCondition(condCopy);
        MPageEntity.Entity.prototype.create.call(this, cb);
     };
})();
(function() {

    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
	var CclBool   = MPageEntity.CclBool;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var CodeValueField = MPageEntity.CodeValueField;

    Entity.create(MPageEntity.entities, "Diagnosis", {
        "fields": {
			"id"                  : new CclNumber(),
			"display"             : new CclString(),
			"attestation"         : new Iso8601DateTime(),
			"certainty"           : new CodeValueField(12035),
			"classification"      : new CodeValueField(12033),
			"clinicalDiagPriority": new CclNumber(),
			"clinicalService"     : new CodeValueField(29741),
			"conditionalQual"     : new CodeValueField(29740),
			"confidLevel"         : new CodeValueField(87),
			"confirmationStatus"  : new CodeValueField(12031),
			"contributorSystem"   : new CodeValueField(89),
			"diagnosticCategory"  : new CodeValueField(1314),
			"diagClass"           : new CodeValueField(12033),
			"diagDtTm"            : new Iso8601DateTime(),
			"ftdesc"              : new CclString(),
			"note"                : new CclString(),
			"encounter"           : new OneToOne("MPageEntity.Encounter"),
			"hac"                 : new CclBool(),
			"laterality"          : new CodeValueField(4002375),
			"person"              : new OneToOne("MPageEntity.Person"),
			"priority"            : new CclNumber(),
			"originatingNomen"    : new OneToOne("MPageEntity.Nomenclature"),
			"nomenclature"        : new OneToOne("MPageEntity.Nomenclature"),
			"presentOnAdmit"      : new CodeValueField(4002009),
			"probability"         : new CclNumber(),
			"ranking"             : new CodeValueField(12034),
			"referenceNbr"        : new CclString(),
			"severity"            : new CodeValueField(12022),
			"severityClass"       : new CodeValueField(29743),
			"severityFtDesc"      : new CclString(),
			"type"                : new CodeValueField(17),
			"updateDtTm"          : new Iso8601DateTime(),
			"isHistorical"		  : new CclBool(),
			"canCondModify"       : new CclBool(),
			"begEffectiveDtTm"	: new Iso8601DateTime()
        },

        "listQuals": ["personId", "encounterId", "nomenclatureId", "originatingNomenId"],

        "actions": ["insert", "read", "update", "list"]

    });

    MPageEntity.entities.Diagnosis.protocol = new MPageEntity.protocol.EntityProtocolV2();

})();
(function() {
    
    var CclString = MPageEntity.String;
    var CclNumber = MPageEntity.Number;
    var DateTime  = MPageEntity.DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var CodeValue = "MPageEntity.CodeValue";
    var Person    = "MPageEntity.Person";
    var CodeValueField = MPageEntity.CodeValueField;
    
    Entity.create(MPageEntity, "Encounter", {
        "fields": {
            "id"              : new CclNumber(),
            "financialId"     : new CclNumber(), // should be transformed into an entity
            "person"          : new OneToOne(Person),
            "personnel"       : new OneToOne(Person),
            "type"            : new CodeValueField(71),
            "typeClass"       : new CodeValueField(69),
            "status"          : new CodeValueField(261),
            "arrive"          : new DateTime(),
            "depart"          : new DateTime(),
            "begEffective"    : new DateTime(),
            "admitType"       : new CodeValueField(3),
            "admitMode"       : new CodeValueField(68),
            "dataStatus"      : new CodeValueField(8),
            "admitSrc"        : new CodeValueField(2),
            "referringComment": new CclString(),
            "organization"    : new CclNumber(),
            "facility"        : new OneToOne("MPageEntity.Facility"),
            "location"        : new CclNumber(),
            "class"           : new CodeValueField(321),
            "reasonForVisit"  : new OneToOne(CodeValue)
        },

        "listQuals": ["personId"],

        "actions": ["insert", "read", "update", "list"]
    });

})();(function() {

    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var DateTime  = MPageEntity.DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var CodeValueField = MPageEntity.CodeValueField;
    var CodeSets = MPageEntity.CodeSets;
    var CclBool = MPageEntity.CclBool;
    var EncodedString = MPageEntity.EncodedString;
    var RiskIndicatorTypes = "MPageEntity.entities.RiskIndicatorTypes";

    Entity.create(MPageEntity.entities, "RiskIndicatorTypes", {
        "fields": {
            "type": new CclString()
        }
    });

    Entity.create(MPageEntity.entities, "Nomenclature", {
        "fields": {
            "id": new CclNumber(),
            "cmti": new CclString(),
            "conceptCki": new CclString(),
            "conceptIdentifier": new CclString(),
            "conceptSource": new CodeValueField(CodeSets.NOMENCLATUREIDENTIFIERSOURCE),
            "contributorSystem": new CodeValueField(CodeSets.CONTRIBUTORSYSTEM),
            "language": new CodeValueField(CodeSets.LANGUAGE),
            "mnemonic": new CclString(),
            "primaryCTerm": new CclBool(),
            "primaryVTerm": new CclBool(),
            "principleType": new CodeValueField(CodeSets.PRINCIPLETYPE),
            "shortString": new CclString(),
            "riskIndicatorTypes": new OneToMany(RiskIndicatorTypes),
            "sourceIdentifier": new CclString(),
            "sourceIdentifierKeycap": new CclString(),
            "sourceString": new CclString(),
            "sourceStringKeycap": new CclString(),
            "sourceVocabulary": new CodeValueField(CodeSets.SOURCEVOCABULARY),
            "stringIdentifier": new CclString(),
            "stringSource": new CodeValueField(CodeSets.NOMENCLATUREIDENTIFIERSOURCE),
            "stringStatus": new CodeValueField(CodeSets.STRINGSTATUS),
            "vocabAxis": new CodeValueField(CodeSets.SOURCEVOCABULARYAXIS),
            "vocabAxisDisplay": new CclString(),
            "vocabAxisMeaning": new CclString(),
            "isSpecific": new CclBool()
        },

        "actions": {

            "search": {
                'searchTerm' : new EncodedString(),
                'sourceFlag' : new CclNumber(),
                'resultLimit' : new CclNumber(),
				'searchVocab' : new EncodedString()
            },

            "list": {
                'sourceStringEquals': new CclString(),
                'sourceStringContains': new CclString(),
                'mnemonicContains': new CclString(),
                'languageId': new CclNumber(),
                'idGreaterThan': new CclNumber()
            }
        }
    });

    MPageEntity.entities.Nomenclature.protocol = new MPageEntity.protocol.EntityProtocolV2();
    
    // backwards compatibility - shall be removed soon
    MPageEntity.Nomenclature = MPageEntity.entities.Nomenclature;
    
    MPageEntity.entities.Nomenclature.search = function(params, callback, async) {
    	return MPageEntity.entities.Nomenclature.action("search", params, callback, async);
    };
})();
(function() {
    var ns = MPageEntity.entities;
    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var Problem = "MPageEntity.entities.Problem";

    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;

    var CodeValue = "MPageEntity.CodeValue";
    var Person    = "MPageEntity.Person";
    var CodeValueField = MPageEntity.CodeValueField;
    var Problem        = "MPageEntity.entities.Problem";
    var Nomenclature   = "MPageEntity.entities.Nomenclature";
    var PatientRequestModifyField = "MPageEntity.entities.PatientRequestModifyField";
    
    Entity.create(ns, "PatientRequestComment", {
        "fields": {
            "comment"   : new CclString()
        }
    });


    Entity.create(ns, "PatientRequestModifyField", {
        "fields": {
            "id"                : new CclNumber(),
            "display"           : new CclString(),
            "modifiedDisplay"   : new CclString(),
            "modifyStatus"      : new OneToOne(CodeValue)
        }
    });

    Entity.create(ns, "PatientProblemRequest", {
        "fields": {
            "id"              : new CclNumber(),
            "healthIssue"     : new CclString(),
            "problem"         : new OneToOne(Problem),
            "person"          : new OneToOne(Person),
            "managingProvider": new OneToOne(PatientRequestModifyField),
            "nomenclature"    : new OneToOne(Nomenclature),
            "requestType"     : new OneToOne(CodeValue),
            "submissionDate"  : new Iso8601DateTime(),
            "submittedBy"     : new CclString(),
            "submittedByType" : new OneToOne(CodeValue),
            "onsetDate"       : new OneToOne(PatientRequestModifyField),
            "comments"        : new OneToMany("MPageEntity.entities.PatientRequestComment")
        },

        "listQuals": ["personId"],

        "actions": ["insert", "acknowledge", "list"]
    });

    ns.PatientProblemRequest.protocol = new EntityProtocolV2();

})();(function() {
    
    var CclString = MPageEntity.String;
    var CclNumber = MPageEntity.Number;
    var DateTime  = MPageEntity.DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var CodeValue = "MPageEntity.CodeValue";
    var OneToMany = MPageEntity.OneToMany;
    var CodeValueField = MPageEntity.CodeValueField;
    
    Entity.create(MPageEntity, "Person", {
        "fields": {
            "id"               : new CclNumber(),
            "nameFirst"        : new CclString(),
            "nameLast"         : new CclString(),
            "updateDateTime"   : new DateTime(),
            "nameFullFormatted": new CclString(),
            "sex"              : new CodeValueField(57),
            "mrn"              : new CclString(),
            "organization"     : new CclNumber(),
            "encounters"       : new OneToMany("MPageEntity.Encounter","personId"),
            "privileges"       : new OneToMany("MPageEntity.Privilege","person"),
            "dob"              : new DateTime()
        },

        "listQuals": ["nameFirstKey", "nameLastKey"],

        "actions": ["insert", "update", "read", "list"]

        
    });

    // One can add functions for the Person class here by referencing its
    // prototype, such as:
    //
    // var prot = MPageEntity.Person.prototype;

})();(function () {

    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var CclBool = MPageEntity.CclBool;
    var DateTime = MPageEntity.DateTime;
    var Entity = MPageEntity.Entity;
    var OneToOne = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var CodeValueField = MPageEntity.CodeValueField;
    var Nomenclature = "MPageEntity.entities.Nomenclature";
    var Person = "MPageEntity.Person";

    Entity.create(MPageEntity.entities, "Problem", {
        "fields": {
            "id":                   new CclNumber(),
            "annotatedDisplay":     new CclString(),
            "begEffectiveDateTime": new Iso8601DateTime(),
            "classificationCd":     new CodeValueField(12033),
            "confirmationStatus":   new CodeValueField(12031),
            "endEffectiveDateTime": new Iso8601DateTime(),
            "lifeCycleStatusCd":    new CodeValueField(12030),
            "onsetDateTime":        new Iso8601DateTime(),
            "onsetPrecision":       new CclNumber(),
            "problemTypeFlag":      new CclNumber(),
            "showInPMHxInd":        new CclBool(),
            "originatingNome":      new OneToOne(Nomenclature),
            "person":               new OneToOne(Person),
            "nomenclature":         new OneToOne(Nomenclature),
            "severity":             new CodeValueField(12022),
            "severityClass":        new CodeValueField(29743),
            "laterality":           new CodeValueField(4002375),
            "severityFtDesc":       new CclString(),
            "descriptionFtDesc":    new CclString(),
            "sourceVocabularyCd":   new CclNumber(),
            "sourceIdentifier":     new CclString(),
            "problemFtDesc":        new CclString(),
            "qualifierCd":          new CclNumber(),
            "persistenceCd":        new CclNumber(),
            "certainityCd":         new CclNumber(),
            "rankingCd":            new CclNumber(),
            "contributorSystemCd":  new CclNumber(),
            "updateDtTm":           new Iso8601DateTime(),
            "organization":         new CclNumber(),
            "isHistorical":         new CclBool(),
            "externalDataOriginatingAuthor": new CclString(),
            "externalDataOriginatingSource": new CclString(),
            "externalDataOriginatingDate"  : new CclString(),
            "externalDataOriginatingDtPrecision": new CclNumber(),
            "canCondModify":        new CclBool()
          },
        "listQuals": ["personId", "nomenclatureId", "originatingNomenId"],
        "actions": ["insert", "read", "update", "list"]
    });
})();
(function() {
    var ns = MPageEntity.entities;
    var CclString = MPageEntity.EncodedString;
    var CclNumber = MPageEntity.Number;
    var Iso8601DateTime = MPageEntity.Iso8601DateTime;
    var Entity    = MPageEntity.Entity;
    var OneToOne  = MPageEntity.OneToOne;
    var OneToMany = MPageEntity.OneToMany;
    var Problem = "MPageEntity.entities.Problem";
    var Encounter = "MPageEntity.entities.Encounter";
    var DateWithPresion = "MPageEntity.entities.DateWithPresion";
    var ModifiableDateField = "MPageEntity.entities.ModifiableDateField";
    var ModifiableTextField = "MPageEntity.entities.ModifiableTextField";
    var ExternalRequestComment = "MPageEntity.entities.ExternalRequestComment";
    var ExternalRequest = "MPageEntity.entities.ExternalRequest";

    var EntityProtocolV2 = MPageEntity.protocol.EntityProtocolV2;

    var CodeValue = "MPageEntity.CodeValue";
    var Person    = "MPageEntity.Person";
    var CodeValueField = MPageEntity.CodeValueField;
    var Nomenclature   = "MPageEntity.entities.Nomenclature";

    Entity.create(ns, "DateWithPresion", {
        "fields": {
            "dateTime"           : new Iso8601DateTime(),
            "precision"          : new CclNumber()
        }
    });

    Entity.create(ns, "ModifiableTextField", {
        "fields": {
            "display"           : new CclString(),
            "modifiedDisplay"   : new CclString(),
            "modifyStatus"      : new OneToOne(CodeValue)
        }
    });

    Entity.create(ns, "ModifiableDateField", {
        "fields": {
            "originalDate"   : new OneToOne(DateWithPresion),
            "modifiedDate"   : new OneToOne(DateWithPresion),
            "modifyStatus"   : new OneToOne(CodeValue)
        }
    });

    Entity.create(ns, "ExternalRequestComment", {
        "fields": {
            "comment"   : new CclString()
        }
    });

    Entity.create(ns, "ExternalRequest", {
        "fields": {
            "id"                        : new CclNumber(),
            "encounter"                 : new OneToOne(Encounter),
            "problem"                   : new OneToOne(Problem),
            "requestType"               : new OneToOne(CodeValue),
            "sourceType"                : new OneToOne(CodeValue),
            "onsetDate"                 : new OneToOne(ModifiableDateField),
            "lastModifiedDate"          : new OneToOne(ModifiableDateField),
            "resolutionDate"            : new OneToOne(ModifiableDateField),
            "comments"                  : new OneToMany(ExternalRequestComment),
            "managingProviders"         : new OneToMany(ModifiableTextField),
            "extContribSource"          : new OneToOne(CodeValue),
            "authors"                   : new OneToMany(ModifiableTextField),
            "authorInstitutions"        : new OneToMany(ModifiableTextField),
            "authorInstitutionsString"  : new CclString(),
            "duplicateInd"               : new CclNumber(),
            "extReqStatusCd"               : new CclString(),
            "cammDataMediaId"               : new CclString(),
            "cammDataMediaVersion"               : new CclString(),            
            "classification"            : new OneToOne(CodeValue)
        }
    });

    Entity.create(ns, "ProblemExternalRecord", {
        "fields": {
        "nomenclature"              : new OneToOne(Nomenclature),
        "freetextInd"               : new CclNumber(),
        "updatePrivsGrantedInd"     : new CclNumber(),
        "groupOnsetDate"            : new OneToOne(DateWithPresion),
        "externalRequests"          : new OneToMany(ExternalRequest)
        },

        "listQuals": ["personId", "pprCd"],
        "actions": ["list"]
    });
    ns.ProblemExternalRecord.protocol = new EntityProtocolV2();
})();
(function() {
    
    var CclString = MPageEntity.String;
    var CclNumber = MPageEntity.Number;
    var Person    = "MPageEntity.Person";
    var OneToOne = MPageEntity.OneToOne;
	var CodeValue = "MPageEntity.CodeValue";
	var CodeValueField = MPageEntity.CodeValueField;
	var CodeSets = MPageEntity.CodeSets;

    MPageEntity.Entity.create(MPageEntity.entities, "Prsnl", {
        "fields": {
            "id"               : new CclNumber(),
            "person"           : new OneToOne("MPageEntity.Person", {sendFullObject:true}),
            "userName"         : new CclString(),
            "email"            : new CclString(),
            "title"            : new CclString(),
            "posCd"            : new CodeValueField(CodeSets.POSITNCODE)
        },

        "listQuals": ["userName"],

        "actions": ["read", "insert", "update", "list"]
    });


    MPageEntity.entities.Prsnl.protocol = new MPageEntity.protocol.EntityProtocolV2();

    // One can add functions for the Prsnl class here by referencing its
    // prototype, such as:
    //
    // var prot = MPageEntity.Prsnl.prototype;

})();

(function() {
    var probDxUtils;

    MPageEntity.getProbDxUtils = function(callback) {
        if(callback) {
            return probDxUtils || CERN_Platform.getWrappedDiscernObject("PROBDXUTILS");
        } else {
            return probDxUtils || CERN_Platform.getDiscernObject("PROBDXUTILS");
        }

    };
    MPageEntity.Win32ConditionModifier = function(entity, callback, calledFrom, forceInvokeProblemModify) {
        var probDxUtils;
        var condition = entity;
        var encounterId = condition.getEncounterValue();
        var personId = condition.getPersonValue();
        var drivingDx = condition.getDiagnosisDriverValue();
        var drivingProblem = condition.getProblemDriverValue();
        var modifyConditionTimer = new CapabilityTimer("CAP:MPG Condition Entity Modify", calledFrom);
        if (modifyConditionTimer) {
            modifyConditionTimer.capture();
        }
        if (callback) {
            probDxUtils = MPageEntity.getProbDxUtils(callback);
            return probDxUtils.isAvailable().then(function(isProbDxUtilsAvailable) {
                if (isProbDxUtilsAvailable) {
                    if (drivingDx && condition.getIsThisVisit() && condition.canModifyThisVisit() && !(forceInvokeProblemModify)) {
                        return probDxUtils.invoke("LoadDiagnosisAndInvokeModify", [drivingDx, personId, encounterId, true]);
                    }
                    else if (drivingProblem && condition.canModifyChronic()) {
                        return probDxUtils.invoke("LoadProblemAndInvokeModify", [drivingProblem, personId, true]);
                    }
                    else {
                        throw new Error("Condition has no valid diagnosis or problem");
                    }
                } else {
                    throw new Error("PROBDXUTILS COM object is not available");
                }
            }).then(function() {
                callback();
            }).catch(function(error) {
                callback(error);
            });
        } else {
            probDxUtils = MPageEntity.getProbDxUtils();
            if (drivingDx && condition.getIsThisVisit() && condition.canModifyThisVisit() && !(forceInvokeProblemModify)) {
                probDxUtils.LoadDiagnosisAndInvokeModify(drivingDx, personId, encounterId, true);
            }
            else if (drivingProblem && condition.canModifyChronic()) {
                probDxUtils.LoadProblemAndInvokeModify(drivingProblem, personId, true);
            }
            else {
                throw new Error("Condition has no valid diagnosis or problem");
            }
            // Execute callback after Synchronous Win32 session is completed
            callback();
        }
    };
})();
(function() {

	/**
	 * Launch Win32DxAssistant based on the passed condition entities
	 * @param {Array}    conditionList Array of condition entities
	 * @param {Function} callback      Function to perform after Win32 diagnosis assistant has closed if a diagnosis has been modified
	 * @param {String}   calledFrom    String containing logging information about where the utility is launched from (category mean/component name)
	 */
	MPageEntity.entities.Condition.Win32DxAssistant = function() {};

	var Class = MPageEntity.entities.Condition.Win32DxAssistant;
	var method = Class.prototype;

	// ---------------------------------------------------------------------------
	// Private
	// ---------------------------------------------------------------------------

	var logError = function(msg, exception) {
		if (typeof(logger) !== 'undefined' && logger) {
			logger.logError(msg + ": " + exception);
			return;
		}
		throw msg;
	};

    /**
     * Generates a win32 clinical diagnosis object based on passed condition entity
     * @param  {MPageEntity.Condition} condition  Condition Entity to create corresponding win32 object for
     * @param  {Function}               callback  Function to be applied after generating clinical diagnosis object
     * @return {CLINICALDIAGNOSIS} Win32 clinical diagnosis object
     */
    var populateClinicalDiagnosisObj = function(condition, callback) {
        if(callback) {
            if (!condition) {
                return callback();
            }

            clinicalDiagnosis = CERN_Platform.getWrappedDiscernObject("CLINICALDIAGNOSIS");
            return clinicalDiagnosis
                .isAvailable()
                .then( function(isClinicalDiagnosisAvailable) {
                    if (!isClinicalDiagnosisAvailable) {
                        return callback();
                    }

                    var diagnosis = condition.getDiagnosisDriverFromArray();

                    clinicalDiagnosis.set("DiagnosisID", condition.getDiagnosisDriverValue());
                    clinicalDiagnosis.set("DiagnosisGroupID", condition.getDiagnosisDriverValue());
                    clinicalDiagnosis.set("EncounterID", condition.getEncounterValue());
                    clinicalDiagnosis.set("DiagnosisDisplay", condition.getDisplay()); //clinicalDiagnosis.DiagnosisDisplay is the win32 field for annotated_display
                    clinicalDiagnosis.set("NomenclatureID", condition.getDiagnosisDriverFromArray().getNomenclatureValue()); //diagnosis.TARGET_NOMENCLATURE_ID is the target nomenclature id
                    
                    //DATE will be stored as double value in COM. for example "1899/12/30 00:00:00" will be stored as 0.0 and calculating difference from origin date
                    var startDateTime = new Date(1899, 11, 30, 00, 00, 00);
                    var begDateTime = new Date();
                    var begEffectiveDtTm = null;
                    var timeDiff = null;
                    if (diagnosis.getBegEffectiveDtTm() != undefined) {
                        begDateTime = diagnosis.getBegEffectiveDtTm();
                        timeDiff = begDateTime.getTime() - startDateTime.getTime();
                        begEffectiveDtTm = timeDiff / (1000 * 60 * 60 * 24);
                    }

                    return Promise.all([
                        clinicalDiagnosis.get("BegEffectiveDtTm"),
                        clinicalDiagnosis.get("ClinicalPriority"),
                        clinicalDiagnosis.get("OriginatingSourceString"),
                        clinicalDiagnosis.get("OriginatingNomenclatureID")
                    ]).then(function(propertiesArray) {
                        if (propertiesArray[0] != undefined) {
                            clinicalDiagnosis.set("BegEffectiveDtTm", begEffectiveDtTm);
                        }

                        if (propertiesArray[1] != undefined && condition.getClinicalPriority()) {
                            clinicalDiagnosis.set("ClinicalPriority", condition.getClinicalPriority());
                        }

                        // Need to validate OriginatingSourceString exists on the object to prevent crash on pre 2010.02 code lines
                        if (propertiesArray[2] != undefined) {
                            clinicalDiagnosis.set("OriginatingSourceString", condition.getDisplay()); // condition.DISPLAY is from the source_string
                        }

                        // Need to validate OriginatingNomenclatureID exists on the object to prevent crash on pre 2010.02 code lines
                        if (propertiesArray[3] != undefined && propertiesArray[3] === 0) {
                            clinicalDiagnosis.set("OriginatingNomenclatureID", condition.getNomenclatureValue()); // condition.NOMENCLATURE_ID is the source nomenclature id
                        }

                        return callback(clinicalDiagnosis);
                    });
                });       
        } else {
            if (!condition) return null;

            var clinicalDiagnosis = CERN_Platform.getDiscernObject("CLINICALDIAGNOSIS");
            var diagnosis = condition.getDiagnosisDriverFromArray();

            if (!clinicalDiagnosis) return null;

            clinicalDiagnosis.DiagnosisID = condition.getDiagnosisDriverValue();
            clinicalDiagnosis.DiagnosisGroupID = condition.getDiagnosisDriverValue();
            clinicalDiagnosis.EncounterID = condition.getEncounterValue();
            clinicalDiagnosis.DiagnosisDisplay = condition.getDisplay(); //clinicalDiagnosis.DiagnosisDisplay is the win32 field for annotated_display
            clinicalDiagnosis.NomenclatureID =  condition.getDiagnosisDriverFromArray().getNomenclatureValue(); //diagnosis.TARGET_NOMENCLATURE_ID is the target nomenclature id
            
            //DATE will be stored as double value in COM. for example "1899/12/30 00:00:00" will be stored as 0.0 and calculating difference from origin date
            var startDateTime = new Date(1899, 11, 30, 00, 00, 00);
            var begDateTime = new Date();
            var begEffectiveDtTm = null;
            var timeDiff = null;
            if (diagnosis.getBegEffectiveDtTm() != undefined) {
                begDateTime = diagnosis.getBegEffectiveDtTm();
                timeDiff = begDateTime.getTime() - startDateTime.getTime();
                begEffectiveDtTm = timeDiff / (1000 * 60 * 60 * 24);
            }
            if (clinicalDiagnosis.BegEffectiveDtTm != undefined) {
                clinicalDiagnosis.BegEffectiveDtTm = begEffectiveDtTm;
            }

            if (clinicalDiagnosis.ClinicalPriority != undefined && condition.getClinicalPriority()) {
                clinicalDiagnosis.ClinicalPriority = condition.getClinicalPriority();
            }

            //Need to validate OriginatingSourceString exists on the object to prevent crash on pre 2010.02 code lines
            if (clinicalDiagnosis.OriginatingSourceString != undefined) {
                clinicalDiagnosis.OriginatingSourceString = condition.getDisplay(); //condition.DISPLAY is from the source_string						
            }
            //Need to validate OriginatingNomenclatureID exists on the object to prevent crash on pre 2010.02 code lines
            if (clinicalDiagnosis.OriginatingNomenclatureID != undefined && clinicalDiagnosis.OriginatingNomenclatureID === 0) {
                clinicalDiagnosis.OriginatingNomenclatureID = condition.getNomenclatureValue(); //condition.NOMENCLATURE_ID is the source nomenclature id
            }
            return clinicalDiagnosis;
        }
	};
    /**
     * Adds Win32 Clinical Diagnosis Objects to the passed dxCollection corresponding
     * to condition entities from the passed conditionList
     * @param {DISPATCHCOLLECTION} dxCollection  collection to add clinical diagnosis objects to
     * @param {Array}              conditionList array of condition entities
     * @param {Function}           callback      Function to be applied after generating clinical diagnosis object
     */
    var addConditionsToDxCollection = function(dxCollection, conditionList, callback) {
        if(callback) {
            var conditionPromises = conditionList.reduce(function(promise, condition) {
                return promise.then(function() {
                    if (!condition.getIsThisVisit() || condition.isFreeText()) return;

                     return populateClinicalDiagnosisObj(condition, function(dxObj) {
                        return Promise.all([dxObj.isAvailable(), dxObj.get("NomenclatureID")])
                            .then(function(values){
                                if(values[1] > 0) {
                                    return dxCollection.invoke("Add", [dxObj]);
                                }
                            });
                     });
                 });
             }, Promise.resolve());
             conditionPromises.then(function(){
                callback(dxCollection);
             });
        } else {
            conditionList.each(function(condition) {
                if (!condition.getIsThisVisit() || condition.isFreeText()) return;
                var dxobj = populateClinicalDiagnosisObj(condition);
    
                // Only add diagnoses with valid nomenclature id
                if (dxobj && dxobj.NomenclatureID > 0) {
                    dxCollection.Add(dxobj);
                }
            });
            return dxCollection;
        }
	};

	/**
	 * Returns the Win32 dx assistant object
	 */
	var getDxAssistantFromWin32 = function() {
        var dxass = CERN_Platform.getDiscernObject("DIAGNOSISASSISTANT");
        if (!dxass) {
            logError("Could not instantiate dx assistant");
        }
        return dxass;
	};

    /**
     * Returns the Async Win32 dx assistant object
     */
    var getDxAssistantFromWin32Async = function() {
        return CERN_Platform.getWrappedDiscernObject("DIAGNOSISASSISTANT");
	};

    /**
     * Creates a new Win32 collection object
     * @param {Array} conditionList array of condition entities
     * @param {Function} callback Function to be applied after creating Win32 collection object
     */
    var convertListToWin32Collection = function(conditionList, callback) {
        if(callback) {
            var collection = CERN_Platform.getWrappedDiscernObject("DISPATCHCOLLECTION");
            addConditionsToDxCollection(collection, conditionList, function(dxCollection){
                callback(dxCollection);
            });
        } else {
            var collection = CERN_Platform.getDiscernObject("DISPATCHCOLLECTION");
            if (!collection) {
                logError("Could not create the dx assistant collection");
            }
            addConditionsToDxCollection(collection, conditionList);
            return collection;
        }
	};

    /**
     * Sets the isSpecific field of the conditions specified in the
     * condition list.
     * @param {Hash} dxObj diagnosis assitant object
     * @param {Array} conditionList array of condition entities
     * @param {String} diagnosisGroupID diagnosis Group ID to be applied on condition filter
     * @returns {Promise} condition list promise.
     */
     var fillDiagnosisDetails = function(dxObj, conditionList, diagnosisGroupID) {
        return conditionList
            .filter("diagnosisDriver", diagnosisGroupID)
            .reduce(function(collectorPromise, condition) {
                if (!condition.isTargetICD10()) {
                    condition.setIsSpecific(null);
                    return collectorPromise.then(Promise.resolve);
                }
                var initialTargetNomenclature = condition.getTargetNomenclatureValue();
                // Update the target nomenclatures if different from what is currently in the condition
                return collectorPromise
                    .then(function() {
                        return dxObj.get("NomenclatureId")
                            .then(function(nomenclatureId) {
                                if (initialTargetNomenclature !== nomenclatureId) {
                                    condition.getDiagnosisDriverFromArray().setNomenclatureValue(nomenclatureId);
                                    condition.setTargetNomenclatureValue(nomenclatureId);
                                }
                            });
                    })
                    .then(function() {
                        return dxObj.get("NomenclatureSpecific")
                            .then(function(nomenclatureSpecific) {
                                if (nomenclatureSpecific >= 0) {
                                    condition.setIsSpecific(nomenclatureSpecific ? true : false);
                                }
                            });
                    });
            }, Promise.resolve());
	};

    /**
     * Sets the isSpecific field of the conditions specified in the
     * condition list.
     * @param {DISPATCHCOLLECTION} collection  collection to add clinical diagnosis objects to
     * @param {Array} conditionList array of condition entities
     * @param {Function} callback Function to be applied after setting isSpecific field to conditions
     * @returns {Promise}
     */
    var populateSpecificitiesAsync = function(conditionList, collection, callback) {
        var dxAss = getDxAssistantFromWin32Async();
        dxAss
        .isAvailable()
        .then(function(isDxAssitantAvailable) {
            if (!isDxAssitantAvailable) {
                return;
            }
            return dxAss.invoke("GetNomenclatureSpecificityInfo", [collection]);
        })
        .then(function(specificities) {
            if (!specificities) { // We were unable to grab the specificities info for the passed in diagnoses
                return;
            }
            return collection.invoke("GetCount");
        })
        .then(function(count) {
            if(!count) {
                return;
            } 
            return Array.from({length: count}).reduce(function(acc, ele, index){
                return acc.then(function() {
                    collection.invoke("GetAt", [index])
                        .then(function(dxObj) {
                            return dxObj.get("DiagnosisGroupID")
                                .then(function(diagnosisGroupID) {
                                    return fillDiagnosisDetails(dxObj, conditionList, diagnosisGroupID);
                                });
                        });
                });
            }, Promise.resolve());
        })
        .then(function() {
            callback();
        });
	};

	// ---------------------------------------------------------------------------
	// Public
	// ---------------------------------------------------------------------------

    /**
     * Launch the dx assistant with the selected conditions
     */
    method.launch = function(conditionList, callback) {
        if (!conditionList.length) {
            logError("Tried to launch Dx assistant, but no conditions were passed.");
            return;
        };

        // filter out non ICD10 conditions
        conditionList = conditionList.filter(function(c) { return c.isTargetICD10(); });

        // retrieve authentication info from the first condition's meta
        var self = this;
        var cond = conditionList[0];
        var meta = cond.getMeta();

        var providerId = meta.userId;
        var pprCd = cond.getPprCd();
        var positionCd = meta.positionCd;
        var patientId = cond.getPersonValue();
        var encounterId = cond.getEncounterValue();

        var dxAssistantTimer = new CapabilityTimer("CAP:MPG Condition Entity Launch Dx Assistant", "condition entity");
        dxAssistantTimer.capture();

        var dxAssistant = getDxAssistantFromWin32Async();
        dxAssistant
            .isAvailable()
            .then(function(isDxAssistantAvailable) {
                if(!isDxAssistantAvailable) {
                    return;
                }

                convertListToWin32Collection(conditionList, function(dxCollection) {
                    dxAssistant.invoke("IsDxAssistantNeeded", [providerId, pprCd, positionCd, dxCollection])
                        .then(function(dxCollectionWithPrivs){
                            // if our list is now empty, we didn't have privs to use dx assistant.
                            Promise.all([dxCollectionWithPrivs.isAvailable(), dxCollectionWithPrivs.invoke("GetCount")])
                                .then(function(values){
                                    if(!values[0] || !dxCollectionWithPrivs || values[1] < 1) {
                                        return;
                                    }
                                    var dxAssistantCriteriaObj = CERN_Platform.getWrappedDiscernObject("DXASSISTANTCRITERIA");

                                    return Promise.all([
                                        dxAssistantCriteriaObj.invoke("SetParentWnd", [0.0]),
                                        dxAssistantCriteriaObj.invoke("SetUserID", [providerId]),
                                        dxAssistantCriteriaObj.invoke("SetPPRCD", [pprCd]),
                                        dxAssistantCriteriaObj.invoke("SetPatientID", [patientId]),
                                        dxAssistantCriteriaObj.invoke("SetEncounterID", [encounterId]),
                                        dxAssistantCriteriaObj.invoke("SetCrossMapModeByEnum", [0]),
                                        dxAssistantCriteriaObj.invoke("SetDialogType", [0]),
                                        dxAssistantCriteriaObj.invoke("SetReturnEffectiveDtTmByEnum", [0]),
                                        dxAssistantCriteriaObj.invoke("SetEnableEarlyTransitionDx", [false])
                                    ])
                                    .then(function(){
                                        return dxAssistant.invoke("LaunchDiagnosisAssistantByCriteria", [dxAssistantCriteriaObj, dxCollection])
                                            .then(function(result) {
                                                // Call callback if a condition was modified from the diagnosis assistant
                                                if(result) {
                                                    self.populateSpecificities(conditionList, dxCollection, callback);
                                                }
                                            });
                                    })
                                    .catch(function(error){
                                        logError("Failed to create DXASSISTANTCRITERIA. Reverting back to old API.", error);
                                        return dxAssistant.invoke("LaunchDiagnosisAssistant", [0.0, providerId, pprCd, patientId, encounterId, dxCollection])
                                            .then(function(result){
                                                // Call callback if a condition was modified from the diagnosis assistant
                                                if(result) {
                                                    self.populateSpecificities(conditionList, dxCollection, callback);
                                                }
                                            });
                                    });
                                });
                        });
                });
        });
	};

    /**
     * Sets the isSpecific field of the conditions specified in the
     * condition list.
     * @param {Function} callback Function to be applied after populating specificities
     */
    method.populateSpecificities = function(conditionList, collection, callback) {
        if(callback) {
            if (!collection) {
                convertListToWin32Collection(conditionList, function(collection){
                    populateSpecificitiesAsync(conditionList, collection, callback);
                });
            } else {
                populateSpecificitiesAsync(conditionList, collection, callback);
            }
        } else {
            var dxAss = getDxAssistantFromWin32();

            if (!collection) {
                collection = convertListToWin32Collection(conditionList);
            }

            var specificities = dxAss.GetNomenclatureSpecificityInfo(collection);

            if (!specificities) { //We were unable to grab the specificities info for the passed in diagnoses
                return;
            }

            var dxObj = null;
            for (var i = 0; i < collection.GetCount(); i++) {
                dxObj = collection.GetAt(i);
                conditionList
                    .filter("diagnosisDriver", dxObj.DiagnosisGroupID)
                    .each(function(condition) {
                        if (!condition.isTargetICD10()) {
                            condition.setIsSpecific(null);
                            return;
                        }
                        var initialTargetNomenclature = condition.getTargetNomenclatureValue();
                        //Update the target nomenclatures if different from what is currently in the condition
                        if (initialTargetNomenclature !== dxObj.NomenclatureId){
                            condition.getDiagnosisDriverFromArray().setNomenclatureValue(dxObj.NomenclatureID);	
                            condition.setTargetNomenclatureValue(dxObj.NomenclatureID);
                        }
                        if (dxObj.NomenclatureSpecific >= 0) {
                            condition.setIsSpecific(dxObj.NomenclatureSpecific ? true : false);
                        }
                    });
            }
        }
	};
})();
(function() {
    var THIS_VISIT_MAP_MODE = 9;
    var CHRONIC_MAP_MODE = 5;
    var HISTORIC_MAP_MODE = 6;
    var visitLabelDisplay = "This Visit";
    var activeLabelDisplay = "Active";
    var historicalLabelDisplay = "Historical";

    MPageEntity.Win32NomenclatureConverter = function(pprCd, positionCd){
        this.pprCd = pprCd;
        this.positionCd = positionCd;
    };

	var method = MPageEntity.Win32NomenclatureConverter.prototype;

	method.getMapping = function(mapper, condition, mapMode, targetVocabCd, callback) {
		if (callback) {
			mapper.isAvailable()
				.then(function (isKiaCrossMappingAvailable) {
					if (!isKiaCrossMappingAvailable) {
						throw new Error("Win32NomenclatureConverter : An error occured when trying to get the cross mapping Async object" + error);
					}
					return mapper.invoke("GetDxProbMapping", [
						condition.getPersonValue(),
						condition.getEncounterValue(),
						mapMode,
						condition.getNomenclatureValue(),
						targetVocabCd,
						this.pprCd,
						this.positionCd,
						visitLabelDisplay,
						activeLabelDisplay,
						historicalLabelDisplay
					]);
				}).then(function (result) {
					callback(condition, result);
				}).catch(function (error) {
					callback(condition, null, error);
				});
		}
		else {
			return mapper.GetDxProbMapping(
				condition.getPersonValue(),
				condition.getEncounterValue(),
				mapMode,
				condition.getNomenclatureValue(),
				targetVocabCd,
				this.pprCd,
				this.positionCd,
				visitLabelDisplay,
				activeLabelDisplay,
				historicalLabelDisplay);
		}
	};

	method.createMapper = function() {
		var crossMapping = CERN_Platform.getDiscernObject("KIACROSSMAPPING");
		if(!crossMapping){
    		throw new Error("Win32NomenclatureConverter : An error occured when trying to get the cross mapping object");
		}
		return crossMapping;
	};

	method.createMapperAsync = function () {
		return CERN_Platform.getWrappedDiscernObject("KIACROSSMAPPING");
	};

	method.mapThisVisit = function(mapper, bedrock, condition, callback) {
		return this.getMapping(mapper, condition, THIS_VISIT_MAP_MODE, bedrock.getThisVisitVocab(), callback);
	};
	
	method.mapChronic = function(mapper, bedrock, condition, callback) {
		return this.getMapping(mapper, condition, CHRONIC_MAP_MODE, bedrock.getChronicVocab(), callback);
	};

	method.mapHistoric = function(mapper, bedrock, condition, callback) {
		return this.getMapping(mapper, condition, HISTORIC_MAP_MODE, bedrock.getChronicVocab(), callback);
	};

	/**
	 * Will return an object with the nomenclatures for both this visit and chronic:
	 * { thisVisit: ..., chronic: ... }
	 * Will return null if it cannot find either. That might happen if the user clicks
	 * cancel.
	 */
	method.convertTvAndChronic = function(condition, bedrockConfig, callback) {
		var self = this;
		var mapper = callback ? this.createMapperAsync() : this.createMapper();
		if (callback) {
			self.mapThisVisit(mapper, bedrockConfig, condition, function (condition, thisVisitResult) {
				self.mapChronic(mapper, bedrockConfig, condition, function (condition, chronicResult) {
					var result = {
						thisVisit: thisVisitResult,
						chronic: chronicResult
					}
					var mapping = (!result.thisVisit || !result.chronic) ? null : result;
					callback(mapping);
				})
			})
		}
		else {
			var result = {
				thisVisit: this.mapThisVisit(mapper, bedrockConfig, condition),
				chronic: this.mapChronic(mapper, bedrockConfig, condition)
			};
			return (!result.thisVisit || !result.chronic) ? null : result;
		}
	};

    /**
     * Method will call KiaCrossMapping Win32 dll in order to launch cross mapping window and return diagnosis/problem target Vocabulary code
     * 
     * @param {object} condition : The specified condition that cross mapping is being performed on
     * @param {object} bedrockConfig : The Bedrock settings class from the Condition Entity
	 * @param  {Function} callback Function to be performed after action is completed
     */ 
    method.convert = function(condition, bedrockConfig, callback) {
		if (!condition) {
			return callback ? callback(condition, null) : null;
		 }
		var mapper = callback ? this.createMapperAsync() : this.createMapper();
        
		if (condition.getIsThisVisit()) {
			return this.mapThisVisit(mapper, bedrockConfig, condition, callback);
		} else if (condition.getIsChronic()) {
			return this.mapChronic(mapper, bedrockConfig, condition, callback);
		} else if (condition.getIsHistorical()) {
			return this.mapHistoric(mapper, bedrockConfig, condition, callback);
        	}
		throw new Error("Win32NomenclatureConverter: cannot convert a condition with no flags.");
	};

    /**
     * Method will call KiaCrossMapping Win32 dll in order to launch cross mapping window for only diagnoses
     * 
     * @param {object} condition : The specified condition that cross mapping is being performed on
     * @param {object} bedrockConfig : The Bedrock settings class from the Condition Entity
	 * @param  {Function} callback Function to be performed after action is completed
     */ 
    method.convertTv = function(condition, bedrockConfig, callback) {
        if (!condition) {
        	return callback ? callback(condition, null) : null;
        }
        var mapper = callback ? this.createMapperAsync() : this.createMapper();

        return this.mapThisVisit(mapper, bedrockConfig, condition, callback);
    };

    /**
     * Method will call KiaCrossMapping Win32 dll in order to launch cross mapping window for only problems
     * 
     * @param {object} condition : The specified condition that cross mapping is being performed on
     * @param {object} bedrockConfig : The Bedrock settings class from the Condition Entity
	 * @param {Function} callback Function to be performed after action is completed
     */ 
    method.convertChronic = function(condition, bedrockConfig, callback) {
        if (!condition) {
        	return callback ? callback(condition, null) : null;
        }
        var mapper = callback ? this.createMapperAsync() : this.createMapper(); 
		
        return this.mapChronic(mapper, bedrockConfig, condition, callback);
    };
})();
/**
 * Configuration to be executed when included in an mpage view
 */

MPageEntity.configure(function() {
    if (typeof m_criterionJSON === "undefined" || !m_criterionJSON) {
        return; // we're not in an mpage
    }

    if (typeof MPageEntity.Config === "undefined"){
        MPageEntity.Config = {};
    }
    var criterion = JSON.parse(m_criterionJSON).CRITERION;
    MPageEntity.Config.user = criterion.PRSNL_ID;
    MPageEntity.Config.ppr = criterion.PPR_CD;
    MPageEntity.Config.position = criterion.POSITION_CD;
    MPageEntity.Entity.throwRequestErrors = false;
});

/**
 * A collection of functions which can be used to maintain, create, destroy and update menus.
 * The MP_MenuManager function keeps a copy of all of the Menu objects that have been created
 * for the current view.  If a Menu object is updated outside of these functions, the updated
 * version of the object should replace the stale version that is stored here by using the
 * updateMenuObject functionality.
 * @constructor
 */
var MenuManager = function() {
    // A collection of menu objects references by a unique i
    this.menuCollection = {};
    // Active Menu Stack
    this.menuStack = [];
    // Root menu offsetParent which will be used by submenus to attach their content
    this.offsetParent = null;
};

/**
 * This function will be used to add Menu objects to the collection of Menu objects.  This collection of
 * Menu objects will be the one source of this type of object and will be used when showing menus.
 * @param {Menu} menuObj An instance of the Menu object
 * @return {boolean} true if the object was added successfully, false otherwise
 */
MenuManager.prototype.addMenuObject = function(menuObj) {
    var menuId = "";
    // Check that he object is not null and that the object type is Menu
    if (!(Menu.prototype.isPrototypeOf(menuObj))) {
        logger.logError("MenuManager.addMenuObject only accepts objects of type Menu or any object that uses Menu.prototype");
        return false;
    }

    // Check for a valid id.
    menuId = menuObj.getId();
    if (!menuId) {
        // Menu id is not populated
        logger.logError("MenuManager.addMenuObject: no/invalid menu id given");
        return false;
    }
    else if (this.menuCollection[ menuId ]) {
        // Menu id is already in use
        logger.logError("MenuManager.addMenuObject: menu id" + menuId + " is already in use");
        return false;
    }

    // Add the Menu Object to the list of Menu objects
    this.menuCollection[ menuId ] = menuObj;
    return true;
};

/**
 * Closes the menus based on the elements currently in the menuStack.  If the forceClose flag is set to true, all menus will be
 * closed regardless of where a user is hovering.  If the forceClose flag is set to true all menus will be closed up to the first menu
 * that is being hovered over by the user.
 * @param {boolean} forceClose A flag which determines if all menus should be closed or if if we should stop closing menus when we find one
 * that the user is still hovering over.
 * @return {boolean} True if the top menu was closed successfully, false otherwise
 */
MenuManager.prototype.closeMenuStack = function(forceClose) {
    var anchorActiveClass = "";
    var topMenuItem = null;

    try {
        // Check to see if there are any menus on the stack
        topMenuItem = this.menuStack.pop();
        if (topMenuItem) {
            // Check to see if the cursor is still over this menu, if so return
            if (!forceClose) {
                if (topMenuItem.isMouseOverMenu()) {
                    // Push the menu back on the stack since we aren't closing it
                    this.menuStack.push(topMenuItem);
                    return true;
                }
            }

            // Delete the menu DOM elements
            $("#" + topMenuItem.getContentElementId()).remove();
            topMenuItem.setContentElementId("");

            // Remove the active class for the anchor element if supplied
            anchorActiveClass = topMenuItem.getAnchorActiveClass();
            if (anchorActiveClass) {
                $("#" + topMenuItem.getAnchorElementId()).removeClass(anchorActiveClass);
            }

            // Mark the menu as inactive so it can update all of its MenuItems with the proper active indicator
            topMenuItem.setIsActive(false);
            topMenuItem.setIsVisible(false);

            // Reset the mouse hover flag
            topMenuItem.setIsMouseOverMenu(false);

            // Clear the hover timeout since we are forcing the menu closed
            topMenuItem.clearHoverTimeout();

            // Close the next menu on stack and close it.
            return this.closeMenuStack(forceClose);
        }
        // Reset the offset parent since we have closed all menus down to the root
        this.offsetParent = null;
        return true;
    }
    catch (err) {
        logger.logJSError(err, null, "MenuManager", "closeMenu");
        return false;
    }
};

/**
 * Deletes the Menu object with the associated id of menuId from the collection of Menu objects.
 * @param {string} menuId The id of the Menu item to be deleted
 * @param {boolean} True if the menu was removed from the collection
 */
MenuManager.prototype.deleteMenuObject = function(menuId) {
    return delete this.menuCollection[ menuId ];
};

/**
 * Retrieves the Menu object with the associated id of menuId.
 * @param {string} menuId The id of the Menu object to retrieve
 * @return {Menu} The Menu object if it exists, null otherwise
 */
MenuManager.prototype.getMenuObject = function(menuId) {
    return this.menuCollection[ menuId ] || null;
};

/**
 * Render and show the menu based on the settings applied in the Menu object referenced by the menuId parameter.  This function will
 * create the container for the menu and have the menu populate the contents for that container.
 * @param {string} menuId The id of the Menu object to render
 * @return {boolean} True if the menu was rendered successfully, false otherwise.
 */
MenuManager.prototype.showMenu = function(menuId) {
    var anchorActiveClass = "";
    var anchorElement = null;
    var contentParentElement = null;
    var menuClass = "";
    var menuControl = null;
    var menuEle = null;
    var menuItems = null;
    var menuObj = null;

    // Get the Menu object
    menuObj = this.getMenuObject(menuId);
    if (!menuObj) {
        logger.logError("Menu " + menuId + " does not exist");
        return false;
    }

    // See if the menu already exists, if so delete it
    $("#menuContent" + menuId).remove();

    // See if this is a root menu.  If so close all other open menus
    if (menuObj.isRootMenu()) {
        this.closeMenuStack(true);
    }

    // Create the main container for the menu
    menuClass = (menuObj.isRootMenu()) ? "menu-container-root" : "menu-container-submenu";
    menuEle = $("<div></div>").attr("id", "menuContent" + menuId).addClass(menuClass + " " + menuObj.getTypeClass());

    // Check to see if the menu should be persistent.  If it is persistent ignore the hover events else create the hover events.
    if (!(menuObj.isPersistent() && menuObj.isRootMenu())) {
        // Setup the hover actions so we know which menu item the user is hovering over
        menuEle.hover(function() {
            // Set the flag to indicate that the user is hovering over the menu content
            menuObj.setIsMouseOverMenu(true);
            // Clear the timeout since we are back in the menu
            menuObj.clearHoverTimeout();
        }, function() {
            // Set the flag to indicate that the user is not hovering over the menu content
            menuObj.setIsMouseOverMenu(false);
            // Set the timeout since we have left the menu
            menuObj.startHoverTimeout();
        });
    }
    // Set the id for the menu's content section
    menuObj.setContentElementId("menuContent" + menuId);

    // Tell the menu object to create its own content
    menuItems = menuObj.generateMenuContent();
    $(menuItems).each(function(index, element) {
        $(menuEle).append(element);
    });

    // Apply the active class for the anchor element if supplied
    anchorActiveClass = menuObj.getAnchorActiveClass();
    if (anchorActiveClass) {
        $("#" + menuObj.getAnchorElementId()).addClass(anchorActiveClass);
    }

    // Append the menu to the offsetParent for the anchor so it will scroll correctly
    anchorElement = $("#" + menuObj.getAnchorElementId());
    // If the developer has defined a content parent element id then append the content to that location
    if(menuObj.getContentParentId()){
        contentParentElement = $("#" + menuObj.getContentParentId());
    }
    if (contentParentElement && contentParentElement.length) {
        $(contentParentElement).append(menuEle);
    }
    else {
        $(document.body).append(menuEle);
    }

    // We must explicitly set the width of the menu element for the controls framework
    $(menuEle).width($(menuEle).outerWidth());
    // Create the controls DetailDialog for our menu visuals
    menuControl = new MPageControls.DetailDialog(anchorElement, menuEle);
    menuControl.setAutoFlipHorizontal(menuObj.autoFlipHorizontal());
    menuControl.setAutoFlipVertical(menuObj.autoFlipVertical());
    menuControl.setElementCorner(menuObj.getAnchorConnectionCorner());
    menuControl.setContentsCorner(menuObj.getContentConnectionCorner());
    menuControl.show();

    // Push this menu onto the stack and update all of the necessary identifiers
    menuObj.setIsActive(true);
    menuObj.setIsVisible(true);
    if (menuObj.isRootMenu() && !menuObj.isPersistent()) {
        menuObj.startHoverTimeout(3000);
    }
    this.menuStack.push(menuObj);
};

/**
 * This function will update the visuals of the top menu currently being shown.  This function is typically
 * called when visual elements of a menu are being changed, such as the label for a menu item.
 * @param {string} menuId The id of the menu that needs to be refreshed.
 */
MenuManager.prototype.refreshMenuDisplay = function(menuId) {
    var menuObj = null;
    var topMenuIndex = 0;

    // Get the Menu object
    menuObj = this.getMenuObject(menuId);
    if (!menuObj) {
        logger.logError("Menu " + menuId + " does not exist");
        return false;
    }

    // Check to see if the menu is on top of the menu stack
    topMenuIndex = this.menuStack.length - 1;
    if (topMenuIndex >= 0 && menuObj === this.menuStack[ topMenuIndex ]) {
        this.showMenu(menuId);
    }
};

/**
 * Updates the existing Menu with a new instance of the object.  If the menu object does not exist it is added to the
 * collection
 * @param {Menu} menuObj The updated instance of the Menu object.
 * @return {boolean} True if the menu object was added/updated successfully, false otherwise.
 */
MenuManager.prototype.updateMenuObject = function(menuObj) {
    // Check that the object is not null and that the object type is Menu
    if (!Menu.prototype.isPrototypeOf(menuObj)) {
        logger.logError("MenuManager.updateMenuObject only accepts objects of type Menu");
        return false;
    }

    // Blindly update the Menu object.  If it didn't previously exist, it will now.
    this.menuCollection[ menuObj.getId() ] = menuObj;
    return true;
};

// This should only be instantiated once
/* eslint-disable no-unused-vars */
/* eslint-disable no-redeclare */
var MP_MenuManager = new MenuManager();
/* eslint-enable no-unused-vars */
/* eslint-enable no-redeclare */
/**
 * The MenuItem object contains all of the basic information needed for the various menu item elements.  Depending on how these
 * variables are set the menu will flex accordingly.  All elements that will be displayed within a menu will inherit from this
 * base class.
 * @constructor
 */
function MenuItem(menuId) {

    // A boolean to determine if this MenuItem is active or not
    this.m_activeInd = false;

    // This is the developer defined click function that can be created to handle any custom logic that needs to occur when the menu item
    //  is selected
    this.m_clickFunc = function() {
    };

    // This flag will determine if the containing menu should be closed when the item is clicked
    this.m_closeOnClick = true;

    // This is the default function that will be executed when the MenuItem is clicked
    this.m_defaultClickFunction = function() {
    };

    // This flag will determine if the menu item is disabled or not.
    this.m_disabledInd = false;

    // This will be the id of the DOM element associated with this MenuItem
    this.m_elementId = "";

    // This will be the label used when the MenuItem is shown within a menu
    this.m_label = "";

    // The id given to the MenuItem object.  This id should be unique and will be used to set/retrieve the
    // MenuItem object
    this.m_menuItemId = menuId;

    // This type CSS class will be used to style the different types of menu item elements
    this.m_menuItemTypeClass = "";

}

/** Checkers **/

/**
 * A check to see if this MenuItem object will force the containing Menu to close when clicked
 * @return {boolean} True if the containing menu should close, false otherwise
 */
MenuItem.prototype.closeOnClick = function() {
    return this.m_closeOnClick;
};

/**
 * Checks to see if this MenuItem is actively being used or shown to the user
 */
MenuItem.prototype.isActive = function() {
    return this.m_activeInd;
};

/**
 * A check to see if this MenuItem object is disabled or not
 * @return {boolean} True if the menu item is disabled, false otherwise
 */
MenuItem.prototype.isDisabled = function() {
    return this.m_disabledInd;
};

/** Getters **/

/**
 * Returns the click function assigned to this MenuItem object.
 * @return {function} The function to be assigned to the click action for this MenuItem
 */
MenuItem.prototype.getClickFunction = function() {
    return this.m_clickFunc;
};

/**
 * Retrieves the default onClick function for the MenuItem object.  This default functionality should be created for each object
 * that uses the MenuItem prototype if special actions need to occur when the element is clicked.  The developer will still be able
 * to define custom actions in the standard onClick function.
 * @return {function} The default function to execute when an element is clicked.
 */
MenuItem.prototype.getDefaultClickFunction = function() {
    return this.m_defaultClickFunction;
};

/**
 * Retrieves the DOM element id associated with the visuals for this MenuItem object
 * @return {string} The DOM element id given to this MenuItem object
 */
MenuItem.prototype.getElementId = function() {
    return this.m_elementId;
};

/**
 * Retrieves the id given to this MenuItem object
 * @return {string} The id given to this MenuItem object
 */
MenuItem.prototype.getId = function() {
    return this.m_menuItemId;
};

/**
 * Retrieves the menu item label for this MenuItem object
 * @return {string} The label given to this MenuItem object
 */
MenuItem.prototype.getLabel = function() {
    return this.m_label;
};

/**
 * Retrieves the menu item type class given to this MenuItem object for visual styling purposes
 * @return {string} The type class given to this MenuItem object
 */
MenuItem.prototype.getTypeClass = function() {
    return this.m_menuItemTypeClass;
};

/** Setters **/

/**
 * Sets the function to execute when the MenuItem item is clicked within the context of a menu
 * @param {function} clickFunc The function that will be executed when the MenuItem item is clicked
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setClickFunction = function(clickFunc) {
    if (typeof clickFunc === "function") {
        this.m_clickFunc = clickFunc;
    }
    return this;
};

/**
 * Sets the flag which determines if the menu which contains this MenuItem should be closed when the user selects this item.
 * @param {boolean} closeFlag The boolean that identifies whether the containing menu will be closed or not.
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setCloseOnClick = function(closeFlag) {
    if (typeof closeFlag === "boolean") {
        this.m_closeOnClick = closeFlag;
    }
    return this;
};

/**
 * Retrieves the default onClick function for the MenuItem object.  This default functionality should be created for each object
 * that uses the MenuItem prototype if special actions need to occur when the element is clicked.  The developer will still be able
 * to define custom actions in the standard onClick function.
 * @param {function} The default function to execute when an element is clicked.
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setDefaultClickFunction = function(clickFunc) {
    if (typeof clickFunc === "function") {
        this.m_defaultClickFunction = clickFunc;
    }
    return this;
};

/**
 * Sets the id which will be used to identify the DOM element associated with this MenuItem
 * @param {string} elementId The id that will be assigned to this MenuItem object
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setElementId = function(elementId) {
    if (typeof elementId === "string") {
        this.m_elementId = elementId;
    }
    return this;
};

/**
 * Sets the id which will be used to identify a particular MenuItem object.
 * @param {string} id The id that will be assigned to this MenuItem object
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setId = function(id) {
    if (id && typeof id === "string") {
        this.m_menuItemId = id;
    }
    return this;
};

/**
 * Sets the active flag for this MenuItem indicating that the containing menu is being shown
 * @param {boolean} activeInd The indicator which will be used to determine if the menu is active or not
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setIsActive = function(activeInd) {
    if (typeof activeInd === "boolean") {
        this.m_activeInd = activeInd;
    }
    return this;
};

/**
 * Sets the flag which determines if the menu item should be disabled or not.
 * @param {boolean} disabled The boolean that identifies whether the menu item should be disabled or not
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setIsDisabled = function(disabled) {
    if (typeof disabled === "boolean") {
        this.m_disabledInd = disabled;
    }
    return this;
};

/**
 * Sets the label used when showing the MenuItem within the context of a menu.  The display of the menu will be updated if the menu
 * is currently being shown
 * @param {string} label The label that will be shown within the menu for this menu item
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setLabel = function(label) {
    var menuContainerId = "";

    if (label && typeof label === "string") {
        this.m_label = label;

        // Update the label if this menu item is acive
        if (this.isActive()) {
            // Refresh the menu contents
            menuContainerId = this.getElementId().replace(/menuSel[0-9]+-/, "");
            MP_MenuManager.refreshMenuDisplay(menuContainerId);
        }
    }

    return this;
};

/**
 * Sets the specific css class for this type of MenuItem object.  This class will be used for styling purposes
 * @param {string} typeClass The CSS class that will be assigned to this MenuItem object for styling purposes
 * @return {MenuItem} The menu item object calling this function so chaining can be used
 */
MenuItem.prototype.setTypeClass = function(typeClass) {
    if (typeof typeClass === "string") {
        this.m_menuItemTypeClass = typeClass;
    }
    return this;
};

/**
 * This function is used to generate the default HTML for the MenuItem.  This includes a selection indicator and the label.  Any
 * object which inherits the MenuItem prototype can override this function and create its own selection content.
 * @return {[jQuery]} An array of jQuery objects which will be appended to the menu.
 */
MenuItem.prototype.generateSelectionContent = function() {
    return [ $("<span>&nbsp;</span>").addClass("menu-selection-ind"), $("<span></span>").addClass("menu-selection").html(this.getLabel()) ];
};
/* global MenuItem */
/**
 * The Menu object inherits from the MenuItem object and adds additional functionality used to create standard menus.
 * Specifically the developer can define the individual items that will be displayed within the menu.  Those elements
 * must be an object that inherits from the MenuItem object.
 * @constructor
 */
function Menu(menuId) {     // eslint-disable-line no-redeclare
    // Set the id for this object
    this.setId(menuId);

    // Set the close on click flag to false
    this.setCloseOnClick(false);

    // Set the default on click function for this element.  This function will be run regardless of the existence of the
    // developer defined click function.  This function is used when a menu items is defined as a submenu.  If the menu is
    // defined as a root menu, this will be ignored.
    /*eslint-disable no-unused-vars*/
    this.setDefaultClickFunction(function(clickEvent) {
        MP_MenuManager.showMenu(this.getId());
    });
    /*eslint-enable no-unused-vars*/

    // This following flags are used to allow the menu content to flip horizontally and vertically when there isn't room on the screen to
    // accommodate them based on the anchor/content connection corners.
    this.m_autoFlipVertical = true;
    this.m_autoFlipHorizontal = true;

    // This string identifies the CSS class to add to the anchor element when the menu it is
    // associated with is active
    this.m_anchorActiveClass = "";

    // This string identifies the id of the anchor element that this menu will be attached to
    this.m_anchorElementId = "";

    // This object defines which corners of the content section and the anchor will be connected.  The default
    // values attach the bottom right corner of the anchor with the top right corner of the content
    this.anchorCorner = null;
    this.contentCorner = null;

    // This string identifies the id of the content element that will be created when the menu is opened.  This id
    // will be created on the fly when the menu is opened.
    this.m_contentElementId = "";

    // This string will identify the id of the element to append the menu to.  If this is not defined the menu will be appended to the body
    this.m_contentParentId = "";

    // This flag will determine if the menu can be shown as persistent.  If set, no hover timeout or mouseleave will cause the
    // menu to disappear.  This setting is only valid for root menus
    this.m_isPersistent = false;

    // This this the timeout reference we are using to determine if the menu contents should still be displayed or not
    this.m_hoverTimout = null;

    // This array contains the list of MenuItem objects which will make up the contents of the Menu.  This element starts off
    // as null to ensure each instance of the Menu object gets its own list of MenuItem objects.
    this.m_menuItemArr = null;

    // This will be the function which gets executed when the menu is being closed
    this.m_onCloseFunction = null;

    // This boolean will be used to determine if this menu item is the root or a submenu item
    this.m_rootMenuInd = false;

    // This boolean indicates if the user is hovering over the menu or not
    this.m_mouseOverContent = false;

    // This boolean indicated whether the user has their mouse over the MenuItem selection within a menu
    this.m_mouseOverAnchor = false;

    // This boolean indicates if the menu contents are visible to the user or not
    this.m_visibleInd = false;

}

/**
 * Setup the prototype and constructor to inherit from the base Menu object
 */
Menu.prototype = new MenuItem();
Menu.prototype.constructor = MenuItem;

/** Checkers **/

/**
 * Checks to see if the menu should be auto flipped horizontally by the detailed dialog controls.
 * @return {boolean} True if this Menu should be auto flipped horizontally
 */
Menu.prototype.autoFlipHorizontal = function() {
    return this.m_autoFlipHorizontal;
};

/**
 * Checks to see if the menu should be auto flipped vertically by the detailed dialog controls.
 * @return {boolean} True if this Menu should be auto flipped vertically
 */
Menu.prototype.autoFlipVertical = function() {
    return this.m_autoFlipVertical;
};

/**
 * Checks to see if the MenuItem with the passed in id is already defined within the context of this menu.
 */
Menu.prototype.containsMenuItem = function(menuItemId) {
    var x = 0;
    var itemArr = this.m_menuItemArr;
    if (!itemArr) {
        return false;
    }
    for (x = itemArr.length; x--;) {
        if (itemArr[ x ].getId() === menuItemId) {
            return true;
        }
    }
    return false;
};

/**
 * Checks to see if the menu is a root menu or a sub menu element
 * @return {boolean} True if this Menu is considered a root menu, false otherwise
 */
Menu.prototype.isRootMenu = function() {
    return this.m_rootMenuInd;
};

/**
 * Checks to see if the user is hovering over the menu or not
 * @return {boolean} True if the mouse is currently over the menu content
 */
Menu.prototype.isMouseOverMenu = function() {
    return this.m_mouseOverContent;
};

/**
 * Checks to see if the user is hovering over the menu anchor or not.
 * @return {boolean} True if the mouse is hovering over the menu anchor, false otherwise
 */
Menu.prototype.isMouseOverAnchor = function() {
    return this.m_mouseOverAnchor;
};

/**
 * Checks to see if the menu should be persistent or not.  A persistent menu does not have a hover timeout nor does the menu
 * disappear when the user hovers outside of the menu's area.  The menu can only be closed programatically or when another menu
 * is opened.
 * @return {boolean} True if the menu should be shown as persistent, false otherwise
 */
Menu.prototype.isPersistent = function() {
    return this.m_isPersistent;
};

/**
 * Checks to see if the menu contents are visible to the user or not.
 * @return {boolean} True if the menu is currently visible, false otherwise
 */
Menu.prototype.isVisible = function() {
    return this.m_visibleInd;
};

/** Getters **/

/**
 * Gets the CSS class to apply to the menu's anchor element when the menu is active
 * @return {string} The CSS class to apply to the anchor element when the associated menu is active
 */
Menu.prototype.getAnchorActiveClass = function() {
    return this.m_anchorActiveClass;
};

/**
 * Gets the corner of the anchor element which the content section should connect with.
 * @return {[string]} An array of two strings which identify which corner of the anchor element should connect with the content
 * element.
 */
Menu.prototype.getAnchorConnectionCorner = function() {
    if (!this.anchorCorner) {
        return [ "bottom", "right" ];
    }
    return this.anchorCorner;
};

/**
 * Gets the id of the DOM element that this menu is attached to.
 * @return {string} The id of the DOM element that this menu is attached to
 */
Menu.prototype.getAnchorElementId = function() {
    return this.m_anchorElementId;
};

/**
 * Gets the function to call when the Menu is closed
 * @return {function} The function to execute when the Menu is closed
 */
Menu.prototype.getCloseFunction = function() {
    return this.m_onCloseFunction;
};

/**
 * Gets the corner of the content section which the anchor element should connect with.
 * @return {[string]} An array of two strings which identify which corner of the content element should connect with the anchor
 * element.
 */
Menu.prototype.getContentConnectionCorner = function() {
    if (!this.contentCorner) {
        return [ "top", "right" ];
    }
    return this.contentCorner;
};

/**
 * Gets the id of the content container element that is created when the menu is active.
 * @return {string} The id of the DOM element that contains all of the menus contents.
 */
Menu.prototype.getContentElementId = function() {
    return this.m_contentElementId;
};

/**
 * Gets the id of the parent element where the content will be appended.  If this is not set the the document.body will be used
 * @return {string} The id of the DOM element where the menu content will be appended.
 */
Menu.prototype.getContentParentId = function() {
    return this.m_contentParentId;
};

/**
 * Gets the array of MenuItem elements that are set to show within this menu.
 * @return {[MenuItem]} An array of MenuItem object that will be used when creating the menu
 */
Menu.prototype.getMenuItemArray = function() {
    return this.m_menuItemArr;
};

/** Setters **/

/**
 * Sets the corner of the anchor element which should connect with the content section.  The cornerArr should only contain two
 * strings.  The first string will determine the top or bottom edge of the anchor element and the second string will determine the
 * left or right edge of the anchor element.  For example, ["top", "left"].
 * @param {[string]} cornerArr The string array identifying the corner of the anchor element which should connect with the content
 * section
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAnchorConnectionCorner = function(cornerArr) {
    if (typeof cornerArr === "object" && cornerArr.length) {
        this.anchorCorner = cornerArr;
    }
    return this;
};

/**
 * Sets the CSS class to apply to the anchor element when it's associated menu is active
 * @param {string} activeClass The CSS class to apply to the anchor element when the menu is active
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAnchorActiveClass = function(activeClass) {
    if (typeof activeClass === "string") {
        this.m_anchorActiveClass = activeClass;
    }
    return this;
};

/**
 * Sets the id of the DOM element that this menu is anchored to
 * @param {string} anchorId The id of the DOM element that this menu is attached to
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAnchorElementId = function(anchorId) {
    if (typeof anchorId === "string") {
        this.m_anchorElementId = anchorId;
    }
    return this;
};

/**
 * Sets the flag to allow/disallow the horizontal repositioning of menus based on available space.
 * @param {boolean} horizontalFlip A flag used to set the horizontal flip indicator of the detail dialog that is used to house the menu contents
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAutoFlipHorizontal = function(horizontalFlip) {
    if (typeof horizontalFlip === "boolean") {
        this.m_autoFlipHorizontal = horizontalFlip;
    }
    return this;
};

/**
 * Sets the flag to allow/disallow the vertical repositioning of menus based on available space.
 * @param {boolean} verticalFlip A flag used to set the vertical flip indicator of the detail dialog that is used to house the menu contents
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setAutoFlipVertical = function(verticalFlip) {
    if (typeof verticalFlip === "boolean") {
        this.m_autoFlipVertical = verticalFlip;
    }
    return this;
};

/**
 * Sets the function that will be called when this menu is closed
 * @param {function} closeFunc The function to execute when the menu is closed
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setCloseFunction = function(closeFunc) {
    if (typeof closeFunc === "function") {
        this.m_onCloseFunction = closeFunc;
    }
    return this;
};

/**
 * Sets the corner of the content container element which should connect with the anchor element.  The cornerArr should only contain
 * two strings. The first string will determine the top or bottom edge of the content container element and the second string will
 * determine the left or right edge of the content container element.  For example, ["top", "left"].
 * @param {[string]} cornerArr The string array identifying the corner of the anchor element which should connect with the content
 * section
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setContentConnectionCorner = function(cornerArr) {
    if (typeof cornerArr === "object" && cornerArr.length) {
        this.contentCorner = cornerArr;
    }
    return this;
};

/**
 * Sets the id of the DOM element that contains this menu's content.  This id will be set when the menu is being shown and removed
 * with it is closed.
 * @param {[string]} elementId The id of the DOM element that contains all of the menus contents.
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setContentElementId = function(elementId) {
    if (typeof elementId === "string") {
        this.m_contentElementId = elementId;
    }
    return this;
};

/**
 * Sets the id of the DOM element where the menu contents will be appended.  If this value is set in the root menu
 * all submenus will also be appended to the same parent.  If no value is supplied then the menu content will be
 * appended to the document.body
 * @param {[string]} parentId The id of the DOM element where the menu content will be appended
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setContentParentId = function(parentId) {
    if (typeof parentId === "string") {
        this.m_contentParentId = parentId;
    }
    return this;
};

/**
 * Sets the element id for the sub menu selection.  This element is only used when creating sub menus
 * @param {string} elementId The element id for the sub menu selection
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setElementId = function(elementId) {
    if (typeof elementId === "string") {
        this.m_elementId = elementId;
        this.m_anchorElementId = elementId;
    }
    return this;
};

/**
 * Sets the active flag for this menu item indicating that the menu is being shown.  Setting a Menu item as active also sets all of
 * the MenuItems that are contained within it to active
 * @param {boolean} activeInd The indicator which will be used to determine if the menu is active or not
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsActive = function(activeInd) {
    var menuItems = null;
    var x = 0;

    if (typeof activeInd === "boolean") {
        this.m_activeInd = activeInd;
    }

    // Set all of the menuItems as active/inactive as well
    menuItems = this.getMenuItemArray();
    if (menuItems && menuItems.length) {
        for (x = menuItems.length; x--;) {
            menuItems[ x ].setIsActive(activeInd);
        }
    }

    return this;
};

/**
 * Sets the flag which determines if this menu is a root menu or not
 * @param {boolean} rootMenuInd The indicator which will be used to determine if the menu is a root menu or a submenu
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsRootMenu = function(rootMenuInd) {
    if (typeof rootMenuInd === "boolean") {
        this.m_rootMenuInd = rootMenuInd;
    }
    return this;
};

/**
 * Sets the flag which indicates if the mouse is hovering over the menu's contents or not.
 * @param {boolean} mouseOver The indicator which indicates if the mouse if over the menu's contents or not
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsMouseOverMenu = function(mouseOver) {
    if (typeof mouseOver === "boolean") {
        this.m_mouseOverContent = mouseOver;
    }
    return this;
};

/**
 * Sets the flag which indicates if the mouse is hovering over the menu's anchor or not.
 * @param {boolean} mouseOver The indicator which indicates if the mouse if over the menu's anchor or not
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsMouseOverAnchor = function(mouseOver) {
    if (typeof mouseOver === "boolean") {
        this.m_mouseOverAnchor = mouseOver;
    }
    return this;
};


/**
 * Sets the flag which indicates if the menu is persistent or not.  A persistent menu does not have a hover timeout nor does the menu
 * disappear when the user hovers outside of the menu's area.  The menu can only be closed programatically or when another menu
 * is opened.
 * @param {boolean} persistent The boolean which indicates if the menu should be persistent or not.
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsPersistent = function(persistent) {
    if (typeof persistent === "boolean") {
        this.m_isPersistent = persistent;
    }
    return this;
};

/**
 * Sets the visible flag for this menu item indicating that the menu is being shown
 * @param {boolean} visibleInd The indicator which will be used to determine if the menu is being shown or not
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.setIsVisible = function(visibleInd) {
    if (typeof visibleInd === "boolean") {
        this.m_visibleInd = visibleInd;
    }
    return this;
};

/** Helper Functions **/

/**
 * Adds a MenuItem object to the list of menu items that will be shown within this menu
 * @param {MenuItem} menuItem The MenuItem object to add to the Menu.
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.addMenuItem = function(menuItem) {
    // Verify that this element is a MenuItem
    if (MenuItem.prototype.isPrototypeOf(menuItem)) {
        if (!this.m_menuItemArr) {
            this.m_menuItemArr = [];
        }
        this.m_menuItemArr.push(menuItem);

        // Add the menu to the collection within MP_MenuManager so we can reference it later when attempting to render the menu
        if (Menu.prototype.isPrototypeOf(menuItem)) {
            // Make sure we append the submenu to the same parent as the root
            menuItem.setContentParentId(this.m_contentParentId);
            MP_MenuManager.updateMenuObject(menuItem);
        }
    }
    return this;
};

/**
 * Sets the hover timeout for the menu contents.  This hover timeout will be used when moving the mouse over and out of the menu's
 * content.  This can be set to a specific time or default to 250 ms.
 * @param {number} setTime The time in milliseconds before the menu will atempt to close itself
 */
Menu.prototype.startHoverTimeout = function(setTime) {
    var that = this;
    setTime = setTime || 250;
    this.clearHoverTimeout();
    this.m_hoverTimout = window.setTimeout(function() {
        // Get the close function and execute it
        var closeFunc = that.getCloseFunction();
        if (closeFunc) {
            closeFunc.call(that);
        }
        MP_MenuManager.closeMenuStack(false);
    }, setTime);

};

/**
 * Clears the hover timeout for the menu.  This happens when the user hovers over the menu's content or when the user hovers
 * over the menu's anchor.
 */
Menu.prototype.clearHoverTimeout = function() {
    window.clearTimeout(this.m_hoverTimout);
};

/**
 * This function will insert a MenuItem object into the list of MenuItems that will be shown within the menu.
 * @param {MenuItem} menuItem The MenuItem object to insert
 * @param {number} index The index where the MenuItem will be inserted
 * @return {Menu} The Menu object calling this function so chaining can be used
 */
Menu.prototype.insertMenuItem = function(menuItem, index) {
    // create the menu item array if it is null
    if (!this.m_menuItemArr) {
        this.m_menuItemArr = [];
    }

    if (typeof index !== "number") {
        return this;
    }

    // Verify that this element is a MenuItem and the index is valid
    if (MenuItem.prototype.isPrototypeOf(menuItem) && index <= this.m_menuItemArr.length && index >= 0) {
        this.m_menuItemArr.splice(index, 0, menuItem);
        // Add the menu to the collection so we can reference it later when attempting to render the menu
        if (Menu.prototype.isPrototypeOf(menuItem)) {
            MP_MenuManager.updateMenuObject(menuItem);
        }
    }
    return this;
};

/**
 * This function removes a specific MenuItem element from the menu item array
 * @param {MenuItem} menuItem The MenuItem object to remove from the Menu's list of menu items.
 * @return {boolean} True if a MenuItem was removed, false otherwise
 */
Menu.prototype.removeMenuItem = function(menuItem) {
    var x = 0;
    var menuItemArr = this.m_menuItemArr;

    if (!menuItemArr) {
        return false;
    }
    // Verify that this element is a MenuItem
    if (MenuItem.prototype.isPrototypeOf(menuItem) && !this.isActive()) {
        for (x = menuItemArr.length; x--;) {
            if (menuItemArr[ x ] === menuItem) {
                menuItemArr.splice(x, 1);
                // Remove the menu from  the collection
                if (Menu.prototype.isPrototypeOf(menuItem)) {
                    MP_MenuManager.deleteMenuObject(menuItem);
                }
                return true;
            }
        }
    }
    return false;
};

/**
 * This function is used to generate the HTML content for this menu.  It examines each MenuItem that is contained within
 * the m_menuItemArray and generates the content for each item, applies the hover events, applies the click events and returns an
 * array of jQuery objects which will make up the contents of the menu.
 * @return {[jQuery]} An array of jQuery object which make of the menu contents.
 */
Menu.prototype.generateMenuContent = function() {
    var disabledClass = "";
    var element = null;
    var elementArr = [];
    var itemArr = this.getMenuItemArray();
    var itemArrCnt = (itemArr) ? itemArr.length : 0;
    var menuItem = null;
    var menuItemId = "";
    var selectorEle = null;
    var x = 0;

    function generateClickFunction(menuItemObj) {
        return function(ele) {
            var clickFunc = null;
            if (!menuItemObj.isDisabled()) {
                // Check to see if the element should close on click
                if (menuItemObj.closeOnClick()) {
                    // Close the entire menu
                    MP_MenuManager.closeMenuStack(true);
                }
                else {
                    // Close any menus above this item
                    MP_MenuManager.closeMenuStack(false);
                }

                // Perform the default MenuItem click event
                clickFunc = menuItemObj.getDefaultClickFunction();
                clickFunc.call(menuItemObj, ele);

                // Perform the specialized MenuItem click action
                clickFunc = menuItemObj.getClickFunction();
                if (clickFunc) {
                    clickFunc.call(menuItemObj, ele);
                }

            }
        };

    }

    function generateHoverOverFunction(menuItemObj) {
        return function() {
            // If the MenuItem is a Menu
            if (Menu.prototype.isPrototypeOf(menuItemObj)) {
                // Set the flag to indicate that the user is hovering over the menu anchor
                menuItemObj.setIsMouseOverAnchor(true);
                // Check to see if the menu is currently active
                if (menuItemObj.isVisible()) {
                    // Clear the hover timeout so it doesn't disappear
                    menuItemObj.clearHoverTimeout();
                }
                else {
                    // Show the menu after a quarter of a second
                    // Need to make sure we don't open this menu item too soon
                    window.setTimeout(function() {
                        // If we are still hovering over this menu item selector, show the menu
                        if (menuItemObj.isMouseOverAnchor()) {
                            MP_MenuManager.showMenu(menuItemObj.getId());
                        }
                    }, 251);

                }
            }
        };

    }

    function generateHoverOutFunction(menuItemObj) {
        return function() {
            // If the MenuItem is a Menu
            if (Menu.prototype.isPrototypeOf(menuItemObj)) {
                // Set the flag to indicate that the user is no longer hovering over the menu anchor
                menuItemObj.setIsMouseOverAnchor(false);
                // Check to see if the menu is currently active
                if (menuItemObj.isVisible()) {
                    // Start the hover timeout so the menu will disappear if we dont go back
                    menuItemObj.startHoverTimeout();
                }
            }
        };

    }

    // Loop through each MenuItem and have it generate its menu selection content
    for (x = 0; x < itemArrCnt; x++) {
        menuItem = itemArr[ x ];
        // Create and store the dom element id for the menu item
        menuItemId = "menuSel" + x + "-" + this.getId();
        menuItem.setElementId(menuItemId);
        // Create the menu item html container
        disabledClass = (menuItem.isDisabled()) ? "menu-item-disabled" : "";
        element = $("<div></div>").addClass("menu-item " + disabledClass + " " + menuItem.getTypeClass()).attr("id", menuItemId);

        // Hover logic for the menu items
        $(element).hover(generateHoverOverFunction(menuItem), generateHoverOutFunction(menuItem));
        selectorEle = menuItem.generateSelectionContent();
        /*eslint-disable no-loop-func*/
        $(selectorEle).each(function(index, selector) {
            $(element).append(selector);
        });
        /*eslint-enable no-loop-func*/

        // Add the default and custom click event to the action
        $(element).click(generateClickFunction(menuItem));

        elementArr.push(element);
    }
    return elementArr;
};

/**
 * This function is in charge of generating the selection content when it is defined as a submenu.  This content will make up the
 * anchor of the submenu.
 * @return {[jQuery]} An array of jQuery elements which will make up the menu selection HTML content.
 */
Menu.prototype.generateSelectionContent = function() {
    return [ $("<span>&nbsp;</span>").addClass("menu-selection-ind"), $("<span></span>").addClass("menu-selection").html(this.getLabel()), $("<span>&nbsp;</span>").addClass("menu-submenu-ind") ];
};
/**
 * The DynamicMenu object inherits from the Menu object and adds additional functionality used when creating dynamic menus.
 * Specifically the developer can define the content creation function which will be in charge of generating the HTML content
 * to show within the menu display.
 * @constructor
 */
function DynamicMenu(menuId) {
    // Set the id for this object
    this.setId(menuId);

    // Set the close on click flag to false
    this.setCloseOnClick(false);

    // This will be the function used to generate the dynamic menu's content
    this.m_contentCreationFunc = function() {
    };

}

/**
 * Setup the prototype and constructor to inherit from the base Menu object
 */
DynamicMenu.prototype = new Menu();
DynamicMenu.prototype.constructor = Menu;

/** Checkers **/

/** Getters **/

/**
 * Returns the function that will be used to create the dynamic menu content.
 * @return {function} The function to call when the dynamic menu should create its content
 */
DynamicMenu.prototype.getContentCreationFunction = function() {
    return this.m_contentCreationFunc;
};

/** Setters **/

/**
 * Sets the function to execute when the DynamicMenu should render its contents.
 * @param {function} creationFunc The function that will be executed when the MenuSelection items is clicked for this DynamicMenu
 * @return {DynamicMenu} The DynamicMenu object calling this function so chaining can be used
 */
DynamicMenu.prototype.setContentCreationFunction = function(creationFunc) {
    if (typeof creationFunc === "function") {
        this.m_contentCreationFunc = creationFunc;
    }
    return this;
};

/** Helper Functions **/
/**
 * Call the function defined to create the dynamic menu's content and passes the results back to the caller.  If no function
 * is defined it will simply return null.
 * @return {[jQuery]} An array of jQuery object which will be used as the dynamic menu content.  Null of the content creation
 * function is not defined.
 */
DynamicMenu.prototype.generateMenuContent = function() {
    var contentCreationFunct = this.getContentCreationFunction();
    if (contentCreationFunct) {
        return contentCreationFunct.call(this);
    }
    return null;
};
/*global DynamicMenu*/
/**
 * @constructor
 * The AdvancedFilterMenu object will be used by component developers creating specialized filter menus for components.
 * This menu creates dialog for the developer so that advanced filter menus are consistent across all uses.
 */
function AdvancedFilterMenu(menuId) {

    // Set the id for the menu element
    this.setId(menuId);

    // Set the type class for this type of menu
    this.setTypeClass("adv-filter-menu-override");

    // Prevent the vertical flipping of the advanced filter menu
    this.setAutoFlipVertical(false);

    // Default settings for the Advanced Filter Menu
    this.settings = {
        // Settings for the cancel button
        cancel: {
            enabled: false,
            onclick: function() {
                return false;
            },

            label: i18n.CANCEL
        },
        // Settings for the options checkbox
        checkbox: {
            enabled: false,
            isChecked: false,
            onclick: function() {
                return false;
            },

            label: ""
        },
        // Settins for the sction link
        actionLink: {
            enabled: false,
            onclick: function() {
                return false;
            },

            label: ""
        },
        // This is the function that will be called when attempting to populate the advanced filter menu content
        advancedFilterCreationFunction: function() {
            return null;
        },
        // This is the width that will be applied to the menu when rendering
        dimensions: {
            width: 600
        },
        // Settings for the save button
        save: {
            enabled: false,
            onclick: function() {
                return false;
            },

            label: i18n.SAVE
        }
    };
    // Set the content creation function for this instance of the AdvnacedFilterMenu
    this.setContentCreationFunction(function() {
        var checkbox = this.settings.checkbox;
        var actionLink = this.settings.actionLink;
        var save = this.settings.save;
        var cancel = this.settings.cancel;
        // Create the main container for all of the AdvancedFilterMenu
        var menuContent = $("<div class='adv-filter-menu'></div>").width(this.settings.dimensions.width);
        // Create the inner container for the AdvancedFilterMenu
        var innerContainer = $("<div class='adv-filter-menu-inner-container'></div>").appendTo(menuContent);
        // Create the label based on the label defined in the object and append to the innerContainer
        $("<div class='adv-filter-menu-label'>" + this.getLabel() + "</div>").appendTo(innerContainer);
        // Add the custom content into a pre-defined section by calling the advancedFilterCreationFunction
        $("<div class='adv-filter-menu-custom-content'></div>").html(this.settings.advancedFilterCreationFunction()).appendTo(innerContainer);
        // If we do not have any of the controls enabled, just return the menu without any controls
        if (!(checkbox.enabled || save.enabled || cancel.enabled || actionLink.enabled)) {
            return menuContent;
        }

        // At this point, we have at least one control
        var controlContainer = $("<div class='adv-filter-menu-control-container'></div>").appendTo(menuContent);
        var buttonContainer = $("<span class='adv-filter-menu-button-container'></span>");
        var savePadding = 0;
        // Check to see if we should create a check box or an action link
        if (checkbox.enabled && checkbox.label) {
            var checkBoxContainer = $("<span class='adv-filter-menu-checkbox-container'></span>");
            // Create the contents for the checkbox and label and apply the click events
            var checkboxEle = $("<input type='checkbox'>");
            checkboxEle[ 0 ].checked = checkbox.isChecked;
            checkboxEle.click(checkbox.onclick).appendTo(checkBoxContainer);
            $("<span class='adv-filter-menu-checkbox-label'>" + checkbox.label + "</span>").appendTo(checkBoxContainer);
            checkBoxContainer.appendTo(controlContainer);
        }
        else if (actionLink.enabled && actionLink.label) {
            // Create the content for the action link and apply the click events
            var actionLinkContainer = $("<span class='adv-filter-menu-action-container'></span>");
            $("<span class='adv-filter-menu-action-label'>" + actionLink.label + "</span>").click(actionLink.onclick).appendTo(actionLinkContainer);
            actionLinkContainer.appendTo(controlContainer);
        }
        // If the cancel button is enabled
        if (cancel.enabled) {
            $("<button type='button' class='adv-filter-menu-button'>").html(cancel.label).click(cancel.onclick).appendTo(buttonContainer);
            savePadding = 6;
            buttonContainer.appendTo(controlContainer);
        }
        // If the save button has been enabled
        if (save.enabled) {
            $("<button type='button' class='adv-filter-menu-button'>").html(save.label).css("margin-right", savePadding).click(save.onclick).appendTo(buttonContainer);
            buttonContainer.appendTo(controlContainer);
        }
        return menuContent;
    });

}

AdvancedFilterMenu.prototype = new DynamicMenu();
AdvancedFilterMenu.prototype.constructor = DynamicMenu;

/**
 * Sets the function that will inject the custom menu content for the AdvancedFilterMenu
 * @param {function} contentFunction The function used to inject the custom content into this menu
 */
AdvancedFilterMenu.prototype.setAdvancedFilterCreationFunction = function(contentFunction) {
    if (contentFunction && typeof contentFunction === "function") {
        this.settings.advancedFilterCreationFunction = contentFunction;
    }
};

/**
 * Sets the label to appear on the Cancel button
 * @param {string} lebel The string used as the label
 */
AdvancedFilterMenu.prototype.setCancelButtonLabel = function(label) {
    if (label && typeof label === "string") {
        // If the user is setting the label, assume they want the button enabled
        this.setIsCancelButtonEnabled(true);
        this.settings.cancel.label = label;
    }
};

/**
 * Sets the function to occur when the user clicks the cancel button
 * @param {function} cancelFunction The function to execute when the user clicks the cancel button
 */
AdvancedFilterMenu.prototype.setCancelFunction = function(cancelFunction) {
    if (cancelFunction && (typeof cancelFunction === "function")) {
        // If the user is setting the cancel function, assume they want the button enabled
        this.setIsCancelButtonEnabled(true);
        this.settings.cancel.onclick = cancelFunction;
    }
};

/**
 * Sets the function for when the user clicks the check box
 * @param {function} checkboxClickFunction the function to execute when the user clicks the check box
 */
AdvancedFilterMenu.prototype.setCheckboxClickFunction = function(checkboxClickFunction) {
    if (checkboxClickFunction && (typeof checkboxClickFunction === "function")) {
        // If the user defines the checkbox click function, assume they want it enabled
        this.setIsCheckboxEnabled(true);
        this.settings.checkbox.onclick = checkboxClickFunction;
    }
};

/**
 * Sets the label to the right of the checkbox
 * @param {string} label The label to the right of the checkbox
 */
AdvancedFilterMenu.prototype.setCheckboxLabel = function(label) {
    if (typeof label === "string") {
        this.settings.checkbox.label = label;
    }
};

/**
 * Sets the function to execute when you click on the action link
 * @param {function} linkFunc The function to execute when the action link is clicked
 */
AdvancedFilterMenu.prototype.setActionLinkFunction = function(linkFunc) {
    if (linkFunc && typeof linkFunc === "function") {
        // If the user is setting the action label assume they are wanting it to show
        this.setIsActionLinkEnabled(true);
        this.settings.actionLink.onclick = linkFunc;
    }
};

/**
 * Sets the label for the action link
 * @param {string} label The label for the action link
 */
AdvancedFilterMenu.prototype.setActionLinkLabel = function(label) {
    if (typeof label === "string") {
        this.settings.actionLink.label = label;
    }
};

/**
 * Function to set if the cancel button is enabled
 * @param {boolean} isEnabled True if the cancel button is to be enabled, false otherwise
 */
AdvancedFilterMenu.prototype.setIsCancelButtonEnabled = function(isEnabled) {
    if (typeof isEnabled === "boolean") {
        this.settings.cancel.enabled = isEnabled;
    }
};

/**
 * Sets whether or not the check box is checked by default
 * @param {boolean} isChecked True if the check box is checked by default, false otherwise
 */
AdvancedFilterMenu.prototype.setIsCheckboxChecked = function(isChecked) {
    if (typeof isChecked === "boolean") {
        this.settings.checkbox.isChecked = isChecked;
    }
};

/**
 * Sets whether or not the check box for the menu is enabled
 * @param {boolean} isEnabled True if the check box should be enabled, false otherwise
 */
AdvancedFilterMenu.prototype.setIsCheckboxEnabled = function(isEnabled) {
    if (typeof isEnabled === "boolean") {
        this.settings.checkbox.enabled = isEnabled;
    }
};

/**
 * Sets whether or not the action link for the menu is enabled
 * @param {boolean} isEnabled True if the action link should be enabled or not
 */
AdvancedFilterMenu.prototype.setIsActionLinkEnabled = function(isEnabled) {
    if (typeof isEnabled === "boolean") {
        this.settings.actionLink.enabled = isEnabled;
    }
};

/**
 * Function to set if the save button is enabled
 * @param {boolean} isEnabled True if the save button should be enabled or not
 */
AdvancedFilterMenu.prototype.setIsSaveButtonEnabled = function(isEnabled) {
    if (typeof isEnabled === "boolean") {
        this.settings.save.enabled = isEnabled;
    }
};

/**
 * Sets the label to appear on the Save button
 * @param {string} label The string used as the label
 */
AdvancedFilterMenu.prototype.setSaveButtonLabel = function(label) {
    if (label && typeof label === "string") {
        this.setIsSaveButtonEnabled(true);
        this.settings.save.label = label;
    }
};

/**
 * Sets the function to occur when the user clicks the save button
 * @param {function} saveFunction The function to execute when the user clicks the save button
 */
AdvancedFilterMenu.prototype.setSaveFunction = function(saveFunction) {
    if (saveFunction && (typeof saveFunction === "function")) {
        // If the user is setting the save function, assume they want the button enabled
        this.setIsSaveButtonEnabled(true);
        this.settings.save.onclick = saveFunction;
    }
};

/**
 * Sets the width of the AdvancedFilterMenu
 * @param {number} width How wide the menu is to be when first rendered
 */
AdvancedFilterMenu.prototype.setWidth = function(width) {
    if (width && typeof width === "number") {
        this.settings.dimensions.width = width;
    }
};
function ContextMenu(menuId) {
    // Set the id for this object
    this.setId(menuId);
    // The is the x offset of the cursor at the time of the context menu creation
    this.m_xOffset = 0;
    // The is the x offset of the cursor at the time of the context menu creation
    this.m_yOffset = 0;
}

/**
 * Setup the prototype and constructor to inherit from the base Menu object
 */
ContextMenu.prototype = new Menu();
ContextMenu.prototype.constructor = Menu;

/** Checkers **/

/** Getters **/

ContextMenu.prototype.getXOffset = function() {
    return this.m_xOffset;
};


ContextMenu.prototype.getYOffset = function() {
    return this.m_yOffset;
};


/** Setters **/


ContextMenu.prototype.setXOffset = function(xOffset) {
    if (typeof xOffset === "number") {
        this.m_xOffset = xOffset;
    }
    return this;
};


ContextMenu.prototype.setYOffset = function(yOffset) {
    if (typeof yOffset === "number") {
        this.m_yOffset = yOffset;
    }
    return this;
};

/** Helper Functions **/

ContextMenu.prototype.setAnchorElement = function() {
    $(document.body).append($("<div id='" + this.getId() + "Anchor' class='context-menu'></div>").css({
        "top": this.getYOffset(),
        "left": this.getXOffset()
    }));
};

ContextMenu.prototype.removeAnchorElement = function() {
    $("#" + this.getId() + "Anchor").remove();
};
/* global MenuItem */

/**
 * The MenuSelection object inherits from the MenuItem object and is used as a basic selection option for a menu.
 * The MenuSelection object does have the power to determine if the parent Menu will closed or not when it is clicked.
 * Additional options for this menu item include showing a custom selection icon in front of the menu item.
 * @constructor
 */
function MenuSelection(selectionId) {   // eslint-disable-line no-redeclare
    // Set the id for this object
    this.setId(selectionId);

    // Set the default on click function for this element.  This function will be run regardless of the existence of the
    // developer defined click function.
    /*eslint-disable no-unused-vars*/
    this.setDefaultClickFunction(function(clickEvent) {
        // Toggle the selection indicator if we aren't supposed to close the menu and this item isn't disabled
        if (!this.closeOnClick() && !this.isDisabled()) {
            this.toggleSelection();
        }
    });
    /*eslint-enable no-unused-vars*/

    // This flag determines if the menu selection should show as being selected or not.
    this.m_selectedInd = false;

    // The selection class will be used to style item which have been selected within the menu
    this.m_selectedClass = "menu-item-selected";
}

/**
 * Setup the prototype and constructor to inherit from the base MenuItem object
 */
MenuSelection.prototype = new MenuItem();
MenuSelection.prototype.constructor = MenuItem;

/** Checkers **/
/**
 * Checks to see if this MenuSelection should be shown as selected or not
 * @return {boolean} True if this MenuSelection has been selected or should default to being selected
 */
MenuSelection.prototype.isSelected = function() {
    return this.m_selectedInd;
};

/** Getters **/
/**
 * Returns the class to apply to items which have been selected within the menu or are defaulted to being selected
 * @return {string} The class which will be applied to selected menu selection items
 */
MenuSelection.prototype.getSelectedClass = function() {
    return this.m_selectedClass;
};

/** Setters **/
/**
 * Sets the indicator which determines if this MenuSelection should be shown as selected or not within the menu
 * @param {boolean} selected A boolean which indicates if this MenuSelection item should show up as selected within the menu
 * @return {MenuSelection}
 */
MenuSelection.prototype.setIsSelected = function(selected) {
    var selectedClass = "";
    var element = null;
    if (typeof selected === "boolean") {
        this.m_selectedInd = selected;

        // If the MenuSelection element is active update the visuals
        if (this.isActive()) {
            selectedClass = this.getSelectedClass();
            element = $("#" + this.getElementId() + " :first-child");
            if (selected) {
                $(element).addClass(selectedClass);
            }
            else {
                $(element).removeClass(selectedClass);
            }
        }
    }

    return this;
};

/**
 * Sets the class which will be applied to the menu item element which indicates an item has been selected.
 * @param {string} selectedClass The CSS class to apply to a selected menu item
 * @return {MenuSelection} The MenuSelection object calling this function so chaining can be used
 */
MenuSelection.prototype.setSelectedClass = function(selectedClass) {
    if (typeof selectedClass === "string") {
        this.m_selectedClass = selectedClass;
    }
    return this;
};

/** Helper Functions **/

/**
 * This function is used to toggle the isSelected flag for the MenuSelection item
 */
MenuSelection.prototype.toggleSelection = function() {
    this.setIsSelected(!this.isSelected());
};

/**
 * This function is used to generate the HTML which will be shown within the menu when it is rendered
 */
MenuSelection.prototype.generateSelectionContent = function() {
    var selectedClass = this.getSelectedClass();
    if (!this.isSelected()) {
        selectedClass = "";
    }
    return [ $("<span>&nbsp;</span>").addClass("menu-selection-ind " + selectedClass), $("<span></span>").addClass("menu-selection").html(this.getLabel()) ];
};
/* global MenuItem */

/* This object is used to easily place a separator within the context of a menu */
function MenuSeparator(seperatorId) {
    // Set the id for this object
    this.setId(seperatorId);

    // Set the type class for this item since it requires special styling
    this.setTypeClass("menu-separator");
}

/**
 * Setup the prototype and constructor to inherit from the base MenuItem object
 */
MenuSeparator.prototype = new MenuItem();
MenuSeparator.prototype.constructor = MenuItem;

/**
 * Returns a non-breaking space so the container element will always show.
 */
MenuSeparator.prototype.generateSelectionContent = function() {
    return [ "&nbsp;" ];
};
/* global MenuItem */

/* This object is used to easily place a separator within the context of a menu */
function MenuSeparator(seperatorId) {
    // Set the id for this object
    this.setId(seperatorId);

    // Set the type class for this item since it requires special styling
    this.setTypeClass("menu-separator");
}

/**
 * Setup the prototype and constructor to inherit from the base MenuItem object
 */
MenuSeparator.prototype = new MenuItem();
MenuSeparator.prototype.constructor = MenuItem;

/**
 * Returns a non-breaking space so the container element will always show.
 */
MenuSeparator.prototype.generateSelectionContent = function() {
    return [ "&nbsp;" ];
};
/* global DynamicMenu */

/**
 * The ThemeSelector object inherits from the DynamicMenu object and adds additional functionality used when choosing a theme color.
 * @param themeSelectorId This is the id of the MenuItem
 * @param compId This theme selector should be tied to a component, this component id is for that component
 * @param fullId Used to specify the anchor element of this menu
 * @param ns Used the specify the namespace for the component, e.g. "cust" for custom components (available in getStyles())
 * @constructor
 */
function ThemeSelector(themeSelectorId, compId, fullId, ns) {

    this.m_componentId = compId;
    this.m_styleId = ns + compId;

    // Set the id for this object
    this.setId(themeSelectorId);
    this.setLabel(i18n.discernabu.COLOR_THEME);
    this.setAnchorElementId(fullId);
    this.setAnchorConnectionCorner([ "top", "left" ]);
    this.setContentConnectionCorner([ "top", "right" ]);
    this.setContentCreationFunction(function() {
        var themeSelectorHtml = "";
        var i18nCore = i18n.discernabu;
        var themeSelectorColors = [
            {
                "title": i18nCore.COLOR_STANDARD,
                "name": "lightgrey",
                "capsName": "LightGrey"
            },
            {
                "title": i18nCore.COLOR_BROWN,
                "name": "brown",
                "capsName": "Brown"
            },
            {
                "title": i18nCore.COLOR_CERNER_BLUE,
                "name": "cernerblue",
                "capsName": "CernerBlue"
            },
            {
                "title": i18nCore.COLOR_DARK_GREEN,
                "name": "darkgreen",
                "capsName": "DarkGreen"
            },
            {
                "title": i18nCore.COLOR_GREEN,
                "name": "green",
                "capsName": "Green"
            },
            {
                "title": i18nCore.COLOR_GREY,
                "name": "grey",
                "capsName": "Grey"
            },
            {
                "title": i18nCore.COLOR_LIGHT_BLUE,
                "name": "lightblue",
                "capsName": "LightBlue"
            },
            {
                "title": i18nCore.COLOR_NAVY,
                "name": "navy",
                "capsName": "Navy"
            },
            {
                "title": i18nCore.COLOR_ORANGE,
                "name": "orange",
                "capsName": "Orange"
            },
            {
                "title": i18nCore.COLOR_PINK,
                "name": "pink",
                "capsName": "Pink"
            },
            {
                "title": i18nCore.COLOR_PURPLE,
                "name": "purple",
                "capsName": "Purple"
            },
            {
                "title": i18nCore.COLOR_YELLOW,
                "name": "yellow",
                "capsName": "Yellow"
            }
        ];
        var titleMarkup;
        var idMarkup;
        var classMarkup;
        var dataMarkup;
        var componentIdMarkup;
        var styleIdMarkup;

        for (var i = 0; i < themeSelectorColors.length; i++) {
            titleMarkup = ' title="' + themeSelectorColors[ i ].title + '"';
            idMarkup = ' id="optConfigMnu' + themeSelectorColors[ i ].capsName + '"';
            classMarkup = ' class="opts-menu-config-item opt-config-mnu-' + themeSelectorColors[ i ].name + '"';
            dataMarkup = ' data-color="' + themeSelectorColors[ i ].name + '"';
            componentIdMarkup = ' component-id="' + this.m_componentId + '"';
            styleIdMarkup = ' style-id="' + this.m_styleId + '"';

            themeSelectorHtml += '<div' + titleMarkup + classMarkup + dataMarkup + componentIdMarkup + styleIdMarkup + idMarkup + '></div>';
        }
        themeSelectorHtml = '<div class="opts-menu-config-content-custom" id="optMenuConfig' + this.m_componentId + '">' + themeSelectorHtml + '</div>';

        return [ $("<span>&nbsp;</span>").html(themeSelectorHtml).click(this.themeSelectorClickHandler) ];
    });

}

/**
 * Setup the prototype and constructor to inherit from the base DynamicMenu object
 */
ThemeSelector.prototype = new DynamicMenu();
ThemeSelector.prototype.constructor = DynamicMenu;


/**
 * This function will handle the click events on the menu colors
 * @param e
 */
ThemeSelector.prototype.themeSelectorClickHandler = function(e) {
    var color = e.target.getAttribute("data-color");
    var section = _g(e.target.getAttribute("style-id"));
    if (section) {
        var colorString = "brown|cernerblue|darkgreen|grey|green|lightblue|lightgrey|lowlight|navy|orange|pink|purple|yellow";
        // a color is found in the class name so replace it with ""
        if (colorString.indexOf(color) >= 0) {
            var colorRegExp = /brown|cernerblue|darkgreen|grey|green|lightblue|lightgrey|lowlight|navy|orange|pink|purple|yellow/;
            section.className = section.className.replace(colorRegExp, "");
        }

        // add the new color so it changes for the user
        Util.Style.acss(section, color);
        var componentId = Number(e.target.getAttribute("component-id"));
        var component = MP_Util.GetCompObjById(componentId);
        component.setCompColor(color);
        // add the color to the component properties
        setTimeout(function() {
            MP_Core.AppUserPreferenceManager.SaveCompPreferences(componentId, color, null, false);  // eslint-disable-line new-cap
        }, 0);
    }
};


/** Checkers **/

/** Getters **/
/* global DynamicMenu */
/**
 * @constructor
 * The UtilitiesMenu object will be used by component developers to create utilities drop down dialogs which are persistent.
 * This means that there will be no timeout when the user hovers over and hovers our of the menus content area.  These menus
 * will need to be closed programitically or will be closed automatically when another menu is opened.
 */
function UtilitiesMenu(menuId) {

    // Set the id for the menu element
    this.setId(menuId);

    // Set the type class for this type of menu
    this.setTypeClass("utilities-menu-override");

    // Set the default active anchor class
    this.setAnchorActiveClass("vwp-util-active");
    // Set the menu as persistent
    this.setIsPersistent(true);

    // Set the root menu flag
    this.setIsRootMenu(true);

    // Default settings for the Utilities Menu
    this.settings = {
        // This is the function that will be called when attempting to populate the Utilities Menu content
        utilitiesContentCreationFunction: function() {
            return null;
        },
        // This is the width that will be applied to the menu when rendering
        dimensions: {
            width: 300,
            maxHeight: ""
        }
    };
    // Set the content creation function for this instance of the UtilitiesMenu
    this.setContentCreationFunction(function() {
        // Create the main container for all of the UtilitiesMenu
        var menuContent = $("<div class='utilities-menu'></div>").width(this.settings.dimensions.width);
        // Create the inner container for the UtilitiesMenu
        var innerContainer = $("<div class='utilities-menu-inner-container'></div>").appendTo(menuContent);
        // Create the label based on the label defined in the object and append to the innerContainer
        $("<div class='utilities-menu-label'>" + this.getLabel() + "</div>").appendTo(innerContainer);
        // Add the custom content into a pre-defined section by calling the utilitiesContentCreationFunction
        $("<div class='utilities-menu-custom-content'></div>").css("max-height", this.settings.dimensions.maxHeight || "").html(this.settings.utilitiesContentCreationFunction()).appendTo(innerContainer);
        return menuContent;
    });

}

UtilitiesMenu.prototype = new DynamicMenu();
UtilitiesMenu.prototype.constructor = DynamicMenu;

UtilitiesMenu.prototype.setIsRootMenu = function(isRoot) {
    if (typeof isRoot === "boolean") {
        if (!isRoot) {
            throw new Error("UtilitiesMenu can only be used as root menus");
        }
        else {
            this.m_rootMenuInd = isRoot;
        }
    }
};

UtilitiesMenu.prototype.setIsPersistent = function(isPersistent) {
    if (typeof isPersistent === "boolean") {
        if (!isPersistent) {
            throw new Error("UtilitiesMenu can only be used as a persistent menu");
        }
        else {
            this.m_isPersistent = isPersistent;
        }
    }
};

/**
 * Sets the function that will inject the custom menu content for the UtilitiesMenu
 * @param {function} contentFunction The function used to inject the custom content into this menu
 */
UtilitiesMenu.prototype.setUtilitiesContentCreationFunction = function(contentFunction) {
    if (contentFunction && typeof contentFunction === "function") {
        this.settings.utilitiesContentCreationFunction = contentFunction;
    }
};

/**
 * Sets the width of the UtilitiesMenu
 * @param {number} width How wide the menu is to be when first rendered
 */
UtilitiesMenu.prototype.setWidth = function(width) {
    if (width && typeof width === "number") {
        this.settings.dimensions.width = width;
    }
};
/**
 * Sets the maxHeight of the utilities menu
 * @param {number} width How wide the menu is to be when first rendered
 */
UtilitiesMenu.prototype.setMaxHeight = function(maxHeight) {
    if (maxHeight && typeof maxHeight === "number") {
        this.settings.dimensions.maxHeight = maxHeight;
    }
};

/* eslint no-inner-declarations:0, no-unneeded-ternary:0, curly:0, semi-spacing:0, no-warning-comments:0, no-lonely-if:0, no-loop-func:0, mp-camelcase:0, no-use-before-define:0, deprecated-functions:0, linebreak-style:0, valid-jsdoc:0, no-trailing-spaces: 0,no-multi-spaces: 0, no-mixed-spaces-and-tabs: 0, space-before-function-paren: 0, quotes: 0, comma-spacing: 0, object-curly-spacing: 0, array-bracket-spacing: 0, complexity: 0, brace-style: 0, key-spacing: 0, no-unused-vars: 0, new-cap: 0*/
var MP_DocumentViewerDialog = function () {
	var docViewerModalI18n = i18n.discernabu.document_viewer_modal;
	var DocumentViewerTabsIndex = {
		DOCUMENTS : 0,
		IMAGES : 1
	};
	var currentPage = DocumentViewerTabsIndex.DOCUMENTS;
	var tabNames = [];
	var eventGlobalId = 0;
	var docContentHTML = [];
	var reply = null;
	var patEncounterDetails = null;
	var image = "";
	var imageSelect = false;
	var enabled = false;
	var creds = "";
	var username = "";
	var pwd = "";
	var dm = "";
	var ajo;
	var ajo2;
	var patName = "";
	var patMRN = "";
	var patDOB = "";
	var resultType = "";
	var resultDate = "";
	var resultTitle = "";
	var performedBy = "";
	var resultStatus = "";
	var verifiedBy = "";
	var encounterInfo = "";
	var encntrFin = "";
	var encntrFacility = "";
	var encntrType = "";
	var encntrAdmitDate = "";
	var encntrDischargeDate = "";
	var printedBy = "";
	var emptyData = "--";
	var verifyCd = 0;
	var performCd = 0;
	var alteredCd = 0;
	var modifiedCd = 0;
	var unauthCd = 0;
	var authCd = 0;
	var docCd = 0;
	return {
		initDocumentViewer : function (patient_Id, enctr_Id, event_Id, display, docViewerType, pevent_Id, image_Url, provider_Id, image_Ind) {
			var docType = (docViewerType) ? docViewerType : "STANDARD";
			eventGlobalId = event_Id + ".0";
			patient_Id = patient_Id + ".0";
			provider_Id = provider_Id + ".0";
			image = image_Url;
			if(image_Ind === 1) {
				imageSelect = true;
			} else {
				imageSelect = false;
			}
			var docLoading = [];
			var docModalDialog = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
			if (!docModalDialog) {
				docModalDialog = new ModalDialog("docModalDialog");
				docModalDialog.setTopMarginPercentage(10).setBottomMarginPercentage(5).setIsBodySizeFixed(false);
				docModalDialog.setHeaderCloseFunction();
				docModalDialog.setHeaderTitle("<span class='documentwindow-title'>" + docViewerModalI18n.DOCUMENT_VIEWER + "</span>");
				MP_ModalDialog.addModalDialogObject(docModalDialog);
			}
			docModalDialog.setBodyDataFunction(function (docViewDlg) {
				var cclParams = [];
				cclParams.push("^MINE^", eventGlobalId, patient_Id, provider_Id, "^" + docType + "^");
				MP_DocumentViewerDialog.loadWithCBParameters("mp_get_doc_viewer_data", cclParams, MP_DocumentViewerDialog.renderDocViewer);
			});
			MP_ModalDialog.updateModalDialogObject(docModalDialog);
			MP_ModalDialog.showModalDialog(docModalDialog.getId());
			docLoading.push("<div class='doc-body-loading'><span class='document-loading'></span></div>");
			docModalDialog.setBodyHTML(docLoading.join(""));
			$("#docModalDialogbody").css("overflow", "hidden");
			$("#docModalDialogbody").css("height", "100%");
			$("#vwpModalDialogdocModalDialog").css("height", "100%");
			$("#vwpModalDialogdocModalDialog").css("position", "absolute");
		},
		init : function () {
			var url = "../../mpages/creds";
			ajo = MP_DocumentViewerDialog.getXMLHttpRequest();
			ajo.open("GET", url, false);
			ajo.onreadystatechange = MP_DocumentViewerDialog.processRequest;
			ajo.send();
		},
		getXMLHttpRequest : function () {
			var xmlHttp = null;
			try {
				if (window.XMLHttpRequest) {
					xmlHttp = new XMLHttpRequest();
				}
			} catch (e) {
				try {
					xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
				} catch (e2) {
					xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
				}
			}
			return xmlHttp;
		},
		processRequest : function () {
			try {
				if (ajo.readyState === 4) {
					if (ajo.status === 200) {
						var jObj = JSON.parse(ajo.responseText);
						username = jObj.un;
						pwd = jObj.pw;
						dm = jObj.dm;
						MP_DocumentViewerDialog.locateCmvWebapp();
					}
				} else {
					MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "processRequest");//eslint-disable-line new-cap
				}
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "processRequest");//eslint-disable-line new-cap
			}
		},
		webkit : function () {
			return new RegExp(" AppleWebKit/").test(navigator.userAgent);
		},
		ie8BrowserCheck : function () {
			var ua = navigator.userAgent.toLowerCase();
			var check = function (r) {
				return r.test(ua);
			};
			var isIE = check(/msie/);
			var isIE8 = isIE && check(/msie 8/);
			return isIE8;
		},
		ie9BrowserCheck : function () {
			var ua = navigator.userAgent.toLowerCase();
			var check = function (r) {
				return r.test(ua);
			};
			var isIE = check(/msie/);
			var isIE9 = isIE && check(/msie 9/);
			return isIE9;
		},
		ie10BrowserCheck : function () {
			var ua = navigator.userAgent.toLowerCase();
			var check = function (r) {
				return r.test(ua);
			};
			var isIE = check(/msie/);
			var isIE10 = isIE && check(/msie 10/);
			return isIE10;
		},
		locateCmvWebapp : function () {
			try {
				var fullCanonicalDomainName = reply.FULLCANONICALDOMAINNAME;
				ajo2 = MP_DocumentViewerDialog.getXMLHttpRequest();
				var userDomain = "";
				var url = window.location.protocol + "//" + window.location.host + "/mediaviewer/" + fullCanonicalDomainName + "/mom";
				if (MP_DocumentViewerDialog.webkit() === true) {
					userDomain = username + "%40" + dm;		 //Safari only accepts %40
				} else {
					userDomain = username + "@" + dm;		//IE only accepts @, but Chrome and FF do as well
				}					
				ajo2.open("GET", url, false, userDomain, pwd);				
				ajo2.send();
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "locateCmvWebapp");
			}
		},
		loadWithCBParameters : function (programName, cclParams, callBack) {
			try {
				var request = new MP_Core.ScriptRequest(this);
				request.setProgramName(programName);
				request.setParameters(cclParams);
				request.setAsync(true);
				MP_Core.XMLCCLRequestCallBack(null, request, callBack);
			} catch (err) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "loadWithCBParameters");
			}
		},
		buildDocHeaderInformation : function (replyRBList) {
			try {
				var actionListLen = replyRBList.EVENT_PRSNL_LIST.length;
				var actionListItem = null;
				var performedDate = null;
				var verifiedDate = null;
				var dateTime = new Date();
				var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);	
				
				patName = (patEncounterDetails.NAME_FULL_FORMATTED) ? patEncounterDetails.NAME_FULL_FORMATTED : "";
				patMRN = (patEncounterDetails.PAT_ALIAS) ? patEncounterDetails.PAT_ALIAS : emptyData;
				patDOB = (patEncounterDetails.BIRTH_DT_TM) ? df.formatISO8601(patEncounterDetails.BIRTH_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR) : emptyData;
				resultType = (patEncounterDetails.RESULT_TYPE) ? patEncounterDetails.RESULT_TYPE : emptyData;
				resultDate = (patEncounterDetails.RESULT_DATE) ? df.formatISO8601(patEncounterDetails.RESULT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR) : emptyData;
				resultTitle = (patEncounterDetails.RESULT_TITLE) ? patEncounterDetails.RESULT_TITLE : emptyData;
				if(resultTitle !==  emptyData ) { 
					resultTitle = resultTitle.replace(/'/g, "&#39").replace(/</g, "&#60").replace(/>/g, "&#62");
				}
				
				for (var alIndex = 0;alIndex < actionListLen;alIndex++) {
					actionListItem = replyRBList.EVENT_PRSNL_LIST[alIndex];
					if(actionListItem.ACTION_TYPE_CD === performCd)
					{
						performedDate = df.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
					}
					if(actionListItem.ACTION_TYPE_CD === verifyCd)
					{
						verifiedDate = df.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
					}
				}
				
				if (patEncounterDetails.PERFORMED_PRSNLID > 0) {
					performedBy = patEncounterDetails.PERFORMED_FULL;
					if (performedDate) {							
						performedBy = performedBy + "&nbsp" + docViewerModalI18n.ON + "&nbsp" + performedDate;
					}
				} else {
					performedBy = emptyData;
				}
				resultStatus = (patEncounterDetails.RESULT_STATUS) ? patEncounterDetails.RESULT_STATUS : emptyData;
				if (patEncounterDetails.VERIFIED_PRSNLID > 0) {
					verifiedBy = patEncounterDetails.VERIFIED_FULL;
					if (verifiedDate) {							
						verifiedBy = verifiedBy + "&nbsp" + docViewerModalI18n.ON + "&nbsp" + verifiedDate;
					}
				} else {
					verifiedBy = emptyData;
				}
				encntrFin = (patEncounterDetails.ENCNTR_ALIAS) ? patEncounterDetails.ENCNTR_ALIAS : "";
				encntrFacility = (patEncounterDetails.FACILITY_DISP) ? patEncounterDetails.FACILITY_DISP : "";
				encntrType = (patEncounterDetails.ENCNTR_TYPE) ? patEncounterDetails.ENCNTR_TYPE : "";					
				var admitDate = patEncounterDetails.REG_DT_TM.substr(6, 4);
				if (admitDate > 0) {						
					dateTime.setISO8601(patEncounterDetails.REG_DT_TM);
					encntrAdmitDate = dateTime.format(dateFormat.masks.mediumdate4yr);
				}
				else {
					encntrAdmitDate = "";
				}	
				var dischargeDate = patEncounterDetails.DISCH_DT_TM.substr(6, 4);
				if(dischargeDate > 0) {
					dateTime.setISO8601(patEncounterDetails.DISCH_DT_TM);
					encntrDischargeDate = dateTime.format(dateFormat.masks.mediumdate4yr);
				}
				else {
					encntrDischargeDate = "";
				}
				if (patEncounterDetails.REG_DATE && patEncounterDetails.DISCH_DATE === "") {
					encntrDischargeDate = "-";
				}
				if (patEncounterDetails.DISCH_DATE === "" && patEncounterDetails.REG_DATE === "") {
					encntrDischargeDate = "";
				}
				if (patEncounterDetails.DISCH_DATE && patEncounterDetails.REG_DATE === "") {
					encntrDischargeDate = "";
				}
				if (encntrFin === "" && encntrFacility === "" && encntrType === "" && encntrAdmitDate === "" && encntrDischargeDate === "") {
					encounterInfo = emptyData;
				}
				else if(encntrFin && encntrFacility && encntrType === "" && encntrAdmitDate === "" && encntrDischargeDate === "")
				{
					encounterInfo = encntrFin + ", " + encntrFacility + ", " + encntrType;
				}
				else 
				{
					encounterInfo = encntrFin + ", " + encntrFacility + ", " + encntrType + ", " + encntrAdmitDate + ", " + encntrDischargeDate;
				}
				printedBy = (patEncounterDetails.PROVIDER_NAME !== "") ? patEncounterDetails.PROVIDER_NAME : "";				
			}
			catch(e) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "buildHeaderInformation");
			}
		},
		buildDocBodyInformation : function (replyRBList) {
			try {
				var docNoteBlobListLength = reply.NOTE_BLOB.length;
				var docBlobContentLength = reply.BLOBS.length;
				var docBlobText = "";
				var docEventText = "";
				var docEventNoteText = "";
				var signLine = "";
				var docEventContent = [];
				docContentHTML = [];
				if ((replyRBList.RESULT_STATUS_CD === modifiedCd) || (replyRBList.RESULT_STATUS_CD === unauthCd)) {						
					for( var b = 0; b < docBlobContentLength; b++) {
						docEventText = reply.BLOBS[b].EVENT_TITLE_TEXT;							
						var blobHtmlItem = reply.BLOBS[b].BLOB_HTML;
						if (replyRBList.EVENT_CLASS_CD === docCd) {										
							while (blobHtmlItem.indexOf('text-decoration: line-through') !== -1) {
								blobHtmlItem = blobHtmlItem.replace('text-decoration: line-through', 'display: none');
							}
							docBlobText = blobHtmlItem;								
						} else {
							docBlobText = blobHtmlItem;								
						}
						docEventContent.push("<br><span class='document_event_title'> " + docEventText + " </span><br><span class='document_blob_text'> " + docBlobText + " </span>");
						if (reply.NOTE_BLOB[b]) {
							signLine = reply.NOTE_BLOB[b].NOTE_TITLE_TEXT;
							docEventNoteText = reply.NOTE_BLOB[b].NOTE_BLOB_HTML;									
							docEventContent.push("<br><br><span class='document_event_title'> " + signLine + " </span><br><span>" + docEventNoteText + "</span>");
						}
					}
				} else {
					for( var bc = 0; bc < docBlobContentLength; bc++) {
						docEventText = reply.BLOBS[bc].EVENT_TITLE_TEXT;
						docBlobText = reply.BLOBS[bc].BLOB_HTML;
						docEventContent.push("<br><span class='document_event_title'> " + docEventText + " </span><br><span class='document_blob_text'> " + docBlobText + " </span>");
					}
					for (var nb = 0; nb < docNoteBlobListLength; nb++) {
						signLine = reply.NOTE_BLOB[nb].NOTE_TITLE_TEXT;
						docEventNoteText = reply.NOTE_BLOB[nb].NOTE_BLOB_HTML;									
						docEventContent.push("<br><br><span class='document_event_title'> " + signLine + " </span><br><span>" + docEventNoteText + "</span>");
					}
				}	
				if (docEventContent.length) {
					docContentHTML.push(docEventContent.join(""));
				}
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "document_viewer_modal.js", "buildDocBodyInformation");
			}
		},
		renderDocViewer : function (replyObj) {
			try {
				var docModalDialogObject = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
				var documentsTab = docViewerModalI18n.DOCUMENTS;
				var imagesTab = docViewerModalI18n.IMAGES;
				var docRenderHtml = [];		
				var codesLength = 0;					
				reply = replyObj.getResponse();				
				
				if(reply && replyObj.getStatus() === "F") {						
					MP_Util.LogScriptCallError(null, this, "document_viewer.js", "renderDocViewer");							
					return;						
				}	
				
				tabNames[DocumentViewerTabsIndex.DOCUMENTS] = documentsTab;
				tabNames[DocumentViewerTabsIndex.IMAGES] = imagesTab;
				var codeArray = MP_Util.LoadCodeListJSON(reply.CODES);
				var replyRBList = reply.RB_LIST[0];	
				patEncounterDetails = reply.PAT_ENCNTR_DETAILS;
				
				//Establish code_values for action_type_cd and result_status_cd
				codesLength = codeArray.length;
				for (var cdIndex = 0;cdIndex < codesLength;cdIndex++) {
					if (codeArray[cdIndex].value.codeSet === 21) {
						if (codeArray[cdIndex].value.meaning === "VERIFY") {
							verifyCd = codeArray[cdIndex].value.codeValue;
						}
						else if (codeArray[cdIndex].value.meaning === "PERFORM") {
								performCd = codeArray[cdIndex].value.codeValue;
						}
					} else if (codeArray[cdIndex].value.codeSet === 8) {
						if (codeArray[cdIndex].value.meaning === "ALTERED") {
							alteredCd = codeArray[cdIndex].value.codeValue;
						}
						else if (codeArray[cdIndex].value.meaning === "MODIFIED") {
								modifiedCd = codeArray[cdIndex].value.codeValue;
						}
						else if (codeArray[cdIndex].value.meaning === "UNAUTH") {
								unauthCd = codeArray[cdIndex].value.codeValue;
						}
						else if (codeArray[cdIndex].value.meaning === "AUTH") {
								authCd = codeArray[cdIndex].value.codeValue;
						}
					} else if (codeArray[cdIndex].value.codeSet === 53) {
							if (codeArray[cdIndex].value.meaning === "DOC") {
								docCd = codeArray[cdIndex].value.codeValue;
							}
						}
				}
				MP_DocumentViewerDialog.buildDocHeaderInformation(replyRBList);
				MP_DocumentViewerDialog.buildDocBodyInformation(replyRBList);

				if (imageSelect === false) {
					currentPage = DocumentViewerTabsIndex.DOCUMENTS;
				} else if (imageSelect === true) {
						currentPage = DocumentViewerTabsIndex.IMAGES;
				}
				
				docRenderHtml.push(MP_DocumentViewerDialog.switchTab(currentPage));
				docModalDialogObject.setBodyHTML(docRenderHtml.join(""));
				$("#docModalDialogheader").css("border", "0px");
				$("#docModalDialogbody").css("border-bottom", "1px solid #ABADB3");
				$("#docModalDialogbody").css("border-left", "1px solid #ABADB3");
				$("#docModalDialogbody").css("border-right", "1px solid #ABADB3");
				if (imageSelect === true) {
					MP_DocumentViewerDialog.ImagesTabContent();
				}
				var allTabs = "#tabContainer .reachview-tabs ul li";
				$(allTabs).eq(currentPage).addClass("reachview-tab-active-header");
				$(allTabs).on("click", function () {
					var $activeTab = $(this.parentElement).find(".reachview-tab-active-header");
					var activeTabId = $activeTab.attr("id");
					var curTabId = this.id;
					$activeTab.removeClass("reachview-tab-active-header");
					$("#tab-sec-" + activeTabId.charAt(activeTabId.length - 1)).hide();
					$(this).addClass("reachview-tab-active-header");
					$("#curTabId").show();
					if (curTabId === "tabHeader_0") {
						MP_DocumentViewerDialog.DocumentsTabContent();
					} else if (curTabId === "tabHeader_1") {
							MP_DocumentViewerDialog.ImagesTabContent();
					}					
				});
			} catch (err) {
				MP_Util.LogJSError(err, this, "document_viewer_modal.js", "renderDocumentViewer");
			}
		},
		switchTab : function (tabIndex) {
			try {
				var docSwitchHTML = [];
				var numTabs;
				var showDetails = docViewerModalI18n.SHOW_DETAILS;
				var windowSize = $(window).width();
				docSwitchHTML.push("<div class='document-header'><div class='document-type-date'><dl class='document-note-type'><dt class='document-res-type'>" + docViewerModalI18n.RESULT_TYPE + "</dt><dd class='document-res-value'>" + resultType + "</dd></dl><dl class='document-note-type'><dt class='document-res-date'>" + docViewerModalI18n.RESULT_DATE + "</dt><dd class='document-res-value'>" + resultDate + "</dd></dl></div><div class='document-showdetails-link'><a onclick='javascript:MP_DocumentViewerDialog.ShowDetailsLink(); return false;' href='#'>" + showDetails + "</a></div><div class='document-separator'><dl class='document-note-type'><span class='doc-separator'>&nbsp;</span></dl></div><div class='document-print' id='printId'><dl class='document-note-type'><span class='document-print-icon' onmouseover='javascript:MP_DocumentViewerDialog.PrintMouseOver();' onmouseout='javascript:MP_DocumentViewerDialog.PrintMouseoff();' onclick='javascript:MP_DocumentViewerDialog.PrintDocument();'>&nbsp;</span></dl></div><div class='document-hdr-details'><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.RESULT_TITLE + "</dt><dd class='document-res-title-value'>" + resultTitle + "</dd></dl><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.PERFORMED_BY + "</dt><dd class='document-res-value'>" + performedBy + "</dd></dl><br><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.RESULT_STATUS + "</dt><dd class='document-res-value'>" + resultStatus + "</dd></dl><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.VERIFIED_BY + "</dt><dd class='document-res-value'>" + verifiedBy + "</dd></dl><br><dl class='document-note-type'><dt class='document-name'></dt><dd class='document-res-value'></dd></dl><dl class='document-note-type'><dt class='document-name'>" + docViewerModalI18n.ENCOUNTER_INFO + "</dt><dd class='document-res-value'>" + encounterInfo + "</dd></dl></div></div>");
				docSwitchHTML.push('<div class="doc-main-container" id="tabContainer">');
				if (image) {
					docSwitchHTML.push('<div class="reachview-tabs"><ul>');
					numTabs = tabNames.length;
				} else {
					numTabs = 0;
				}
				if (typeof tabIndex === "number") {
					currentPage = tabIndex;
				} else {
					tabIndex = currentPage;
				}
				var i;
				var iTabName,
				iCount;
				for (i = 0; i < numTabs; i++) {
					iTabName = tabNames[i];
					docSwitchHTML.push('<li id="tabHeader_', i, '"><span class="reachview-tab-left-edge">&nbsp;</span><span class="reachview-tab-text">', iTabName, '</span><span class="reachview-tab-right-edge">&nbsp;</span></li>');
				}
				if (image) {
					if (windowSize > 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie8-high-resolution" id="tabContent">');
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie9-high-resolution" id="tabContent">');
						} else if (MP_DocumentViewerDialog.ie10BrowserCheck()) {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie10-high-resolution" id="tabContent">');
						} else if (MP_DocumentViewerDialog.webkit()) {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-sfr-high-resolution" id="tabContent">');
						} else {
							docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-oth-high-resolution" id="tabContent">');
						}
					} else {
						if (windowSize > 768 && windowSize <= 1024) {
							if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie8-low-resolution" id="tabContent">');
							} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie9-low-resolution" id="tabContent">');
							} else if (MP_DocumentViewerDialog.ie10BrowserCheck()) {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-ie10-low-resolution" id="tabContent">');
							} else if (MP_DocumentViewerDialog.webkit()) {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-sfr-low-resolution" id="tabContent">');
							} else {
								docSwitchHTML.push('</ul></div><hr/><div class="doc-tabs-content-oth-low-resolution" id="tabContent">');
							}
						}
					}
					docSwitchHTML.push("</br>", docContentHTML, "</div><iframe id='image-section' class='doc-document-tab' src='" + image + "' width='100%'></iframe>");
					docSwitchHTML.push("</div>");
					MP_DocumentViewerDialog.init();
				} else {
					if (windowSize > 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							docSwitchHTML.push('<div class="doc-notabs-content-ie8-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							docSwitchHTML.push('<div class="doc-notabs-content-ie9-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						} else if (MP_DocumentViewerDialog.ie10BrowserCheck()) {
							docSwitchHTML.push('<div class="doc-notabs-content-ie10-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						} else if (MP_DocumentViewerDialog.webkit()) {
							docSwitchHTML.push('<div class="doc-notabs-content-sfr-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						} else {
							docSwitchHTML.push('<div class="doc-notabs-content-oth-high-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
						}
					} else {
						if (windowSize > 768 && windowSize <= 1024) {
							if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
								docSwitchHTML.push('<div class="doc-notabs-content-ie8-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
								docSwitchHTML.push('<div class="doc-notabs-content-ie9-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							} else if (MP_DocumentViewerDialog.ie10BrowserCheck()) {
								docSwitchHTML.push('<div class="doc-notabs-content-ie10-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							} else if (MP_DocumentViewerDialog.webkit()) {
								docSwitchHTML.push('<div class="doc-notabs-content-sfr-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							} else {
								docSwitchHTML.push('<div class="doc-notabs-content-oth-low-resolution" id="noTabContent"></br>', docContentHTML, "</div></div>");
							}
						}
					}
				}				
				return docSwitchHTML.join("");
			} catch (err) {
				MP_Util.LogJSError(err, this, "document_viewer_modal.js", "switchTab");
			}
		},
		PrintMouseOver : function () {
			try {
				$("#docModalDialogbody").find(".document-header").find(".document-print").find(".document-print-icon").removeClass("document-print-icon").addClass("document-print-mouseover");
			} catch (err) {
				MP_Util.LogJSError(err, this, "document_viewer_modal.js", "PrintMouseOver");
			}
		},
		PrintMouseoff : function () {
			try {
				$("#docModalDialogbody").find(".document-header").find(".document-print").find(".document-print-mouseover").removeClass("document-print-mouseover").addClass("document-print-icon");
			} catch (err) {
				MP_Util.LogJSError(err, this, "document_viewer_modal.js", "PrintMouseoff");
			}
		},
		PrintDocument : function () {
			var iframeObj = "";
			try {
				var htmlText = [];
				//String passed by browser as user-agent header. 
				var ua = window.navigator.userAgent;
				//Get the index of "MSIE" in the user-agent header. Else it returns -1.(For IE7 to IE10)
				var msie = ua.indexOf('MSIE ');
				//Get the index of "Trident/" in the user-agent header. Else it returns -1.(For IE11)
				var trident = ua.indexOf('Trident/');
				//Get the index of "Edge/" in the user-agent header. Else it returns -1.(For IE12)
				var edge = ua.indexOf('Edge/');
				var $style = $("<style type='text/css'>.document-print-label{display:inline;width:20%;}.document-print-font{font-size:14px;font-family:Arial;}.document-content-font{font-size:16px;font-family:Arial;}.document-print-bold{font-weight:bold;}.document-print-value {margin-right:10px;margin-left:4px;display:-moz-inline-stack;vertical-align:top;display:inline-block;zoom:1;*display:inline;}</style>");
				htmlText.push("<div id='printDiv' class='document-print-font'>");
				htmlText.push("<dl><dd class='document-print-value document-print-bold'>" + patName + "</dd>");
				htmlText.push("<dd class='document-print-value'>" + docViewerModalI18n.MRN + "</dd>");
				htmlText.push("<dd class='document-print-value'>" + patMRN + "</dd>");
				htmlText.push("<dd class='document-print-value'>" + docViewerModalI18n.DOB + "</dd>");
				htmlText.push("<dd class='document-print-value'>" + patDOB + "</dd></dl>");
				htmlText.push("<dl><dt class='document-print-label'>" + docViewerModalI18n.RESULT_TYPE + "</dt><dd class='document-print-value'>" + resultType + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.RESULT_DATE + "</dt><dd class='document-print-value'>" + resultDate + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.RESULT_STATUS + "</dt><dd class='document-print-value'>" + resultStatus + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.RESULT_TITLE + "</dt><dd class='document-print-value'>" + resultTitle + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.PERFORMED_BY + "</dt><dd class='document-print-value'>" + performedBy + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.VERIFIED_BY + "</dt><dd class='document-print-value'>" + verifiedBy + "</dd></dl><dl><dt class='document-print-label'>" + docViewerModalI18n.ENCOUNTER_INFO + "</dt><dd class='document-print-value'>" + encounterInfo + "</dd></dl></div></br></br>");
				htmlText.push("<div class='document-content-font'>" + docContentHTML.join("") + "</div>");
				htmlText.push("</br></br></br></br><div class='document-print-font'><span>" + docViewerModalI18n.PRINTED_BY + "</span><span>&nbsp" + printedBy + "</span></div>");
				iframeObj = document.createElement("iframe");
				$(iframeObj).css("display", "none");
				document.body.appendChild(iframeObj);
				var printWindow = iframeObj.contentWindow;
				var docObject = printWindow ? printWindow.document : null;
				if (docObject) {
					docObject.write(htmlText.join(""));
					docObject.close();
					$(iframeObj).show().contents().find("head").append($style);
					// Check if current browser is Internet Explorer. If yes then print the document with "Shrink to fit" setting disabled, otherwise print the content window of the iframe.
					if (msie !== -1 || trident !== -1 || edge !== -1) {
						docObject.execCommand( 'print', false, null ) ;
					}
					else{
						printWindow.focus();
						printWindow.print();
					}
					printWindow.location.reload();
					printWindow.close();
				}
			} catch (err) {
				if ($(iframeObj).length) {
					$(iframeObj).remove();
				}
				MP_Util.LogJSError(err, null, "document_viewer_modal.js", "PrintDocument");
				throw err;
			}
			finally {
				if ($(iframeObj).length) {
					$(iframeObj).remove();
				}
			}
		},
		DocumentsTabContent : function () {
			try {
				var modaldlg = null;
				modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
				var modaldlgId = modaldlg.getBodyElementId();
				$("#docModalDialogbody").find("#tabContent").show();
				$("#image-section").removeClass("doc-image-tab");
				$("#image-section").addClass("doc-document-tab");
			} catch (err) {
				MP_Util.LogJSError(err, null, "document_viewer_modal.js", "DocumentsTabContent");
			}
		},
		ImagesTabContent : function () {
			try {
				var modaldlg = null;
				modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
				var modaldlgId = modaldlg.getBodyElementId();
				$("#docModalDialogbody").find("#tabContent").hide();
				$("#image-section").removeClass("doc-document-tab");
				$("#image-section").addClass("doc-image-tab");
			} catch (err) {
				MP_Util.LogJSError(err, null, "document_viewer_modal.js", "ImagesTabContent");
			}
		},
		ShowDetailsLink : function () {
			try {
				var modaldlg = null;
				modaldlg = MP_ModalDialog.retrieveModalDialogObject("docModalDialog");
				var modaldlgId = modaldlg.getBodyElementId();
				var windowSize = $(window).width();
				var docModalDialogBodyObj = $("#docModalDialogbody");
				if (docModalDialogBodyObj.find(".document-showdetails-link").children("a").text() === "" + docViewerModalI18n.SHOW_DETAILS + "") {
					docModalDialogBodyObj.find(".document-showdetails-link").children("a").text("" + docViewerModalI18n.HIDE_DETAILS + "");
					docModalDialogBodyObj.find(".document-header").children("div").removeClass("document-hdr-details").addClass("document-hdr-show");
					if (windowSize > 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							$("#tabContent").css("height", "53%");
							$("#noTabContent").css("height", "395px");
							$("#image-section").css("height","385px");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							$("#tabContent").css("height", "445px");
							$("#noTabContent").css("height", "470px");
							$("#image-section").css("height","445px");
						} else if(MP_DocumentViewerDialog.ie10BrowserCheck()) {
							$("#tabContent").css("height", "480px");
							$("#noTabContent").css("height", "515px");
							$("#image-section").css("height","466px");
						} else if (MP_DocumentViewerDialog.webkit()) {
							$("#tabContent").css("height", "455px");
							$("#noTabContent").css("height", "480px");
							$("#image-section").css("height","487px");
						} else {
							$("#tabContent").css("height", "71%");
							$("#noTabContent").css("height", "400px");
							$("#image-section").css("height","400px");
						}
					} else if (windowSize > 768 && windowSize <= 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							$("#tabContent").css("height", "43%");
							$("#noTabContent").css("height", "230px");
							$("#image-section").css("height","230px");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							$("#tabContent").css("height", "310px");
							$("#noTabContent").css("height", "350px");
							$("#image-section").css("height","350px");
						} else if(MP_DocumentViewerDialog.ie10BrowserCheck()) {
							$("#tabContent").css("height", "350px");
							$("#noTabContent").css("height", "385px");
							$("#image-section").css("height","385px");
						} else if(MP_DocumentViewerDialog.webkit()) {
							$("#tabContent").css("height", "310px");
							$("#noTabContent").css("height", "360px");
							$("#image-section").css("height","360px");
						} else {
							$("#tabContent").css("height", "62%");
							$("#noTabContent").css("height", "370px");
							$("#image-section").css("height","370px");
						}
					}
				} else {
					docModalDialogBodyObj.find(".document-showdetails-link").children("a").text("" + docViewerModalI18n.SHOW_DETAILS + "");
					docModalDialogBodyObj.find(".document-header").children("div").removeClass("document-hdr-show").addClass("document-hdr-details");
					if (windowSize > 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							$("#tabContent").css("height", "65%");
							$("#noTabContent").css("height", "480px");
							$("#image-section").css("height","480px");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							$("#tabContent").css("height", "530px");
							$("#noTabContent").css("height", "560px");
							$("#image-section").css("height","530px");
						} else if(MP_DocumentViewerDialog.ie10BrowserCheck()) {
							$("#tabContent").css("height", "545px");
							$("#noTabContent").css("height", "580px");
							$("#image-section").css("height","532px");
						} else if(MP_DocumentViewerDialog.webkit()) {
							$("#tabContent").css("height", "520px");
							$("#noTabContent").css("height", "550px");
							$("#image-section").css("height","550px");
						} else {
							$("#tabContent").css("height", "82%");
							$("#noTabContent").css("height", "460px");
							$("#image-section").css("height","460px");
						}
					} else if (windowSize > 768 && windowSize <= 1024) {
						if (MP_DocumentViewerDialog.ie8BrowserCheck()) {
							$("#tabContent").css("height", "61%");
							$("#noTabContent").css("height", "360px");
							$("#image-section").css("height","360px");
						} else if (MP_DocumentViewerDialog.ie9BrowserCheck()) {
							$("#tabContent").css("height", "425px");
							$("#noTabContent").css("height", "460px");
							$("#image-section").css("height","460px");
						} else if(MP_DocumentViewerDialog.ie10BrowserCheck()) {
							$("#tabContent").css("height", "435px");
							$("#noTabContent").css("height", "470px");
							$("#image-section").css("height","454px");
						} else if(MP_DocumentViewerDialog.webkit()) {
							$("#tabContent").css("height", "410px");
							$("#noTabContent").css("height", "440px");
							$("#image-section").css("height","448px");
						} else {
							$("#tabContent").css("height", "80%");
							$("#noTabContent").css("height", "450px");
							$("#image-section").css("height","452px");
						}
					}
				}
			} catch (err) {
				MP_Util.LogJSError(err, null, "document_viewer_modal.js", "ShowDetailsLink");
			}
		}
	};
}
();
/* eslint no-inner-declarations:0, no-unneeded-ternary:0, curly:0, semi-spacing:0, no-warning-comments:0, no-lonely-if:0, no-loop-func:0, mp-camelcase:0, no-use-before-define:0, deprecated-functions:0, linebreak-style:0, valid-jsdoc:0, no-trailing-spaces: 0,no-multi-spaces: 0, no-mixed-spaces-and-tabs: 0, space-before-function-paren: 0, quotes: 0, comma-spacing: 0, object-curly-spacing: 0, array-bracket-spacing: 0, complexity: 0, brace-style: 0, key-spacing: 0, no-unused-vars: 0, new-cap: 0, no-undef: 0 */
 MD_microViewerDialog = function () {
	var micViewModalI18n = i18n.discernabu.micro_viewer_modal;
	var jsonResponse = null;
	var specimenFound = false;
	var commentsFound = false;
	var reportsFound = false;
	var suscepFound = false;
	var dateFormatter = null;
	var personnelArray = [];
	var resultType = 0;
	function AntibioticDetails() {
		this.m_description = "";
		this.m_footNoteInd = false;
		this.m_footNoteText = "";
	}
	AntibioticDetails.prototype.getAntiDescription = function () {
		return this.m_description;
	};

	AntibioticDetails.prototype.setAntiDescription = function (desc) {
		this.m_description = desc;
	};
	AntibioticDetails.prototype.getFootNoteInd = function () {
		return this.m_footNoteInd;
	};

	AntibioticDetails.prototype.setFootNoteInd = function (ftInd) {
		this.m_footNoteInd = ftInd;
	};
	AntibioticDetails.prototype.getFootNoteText = function () {
		return this.m_footNoteText;
	};

	AntibioticDetails.prototype.setFootNoteText = function (ftText) {
		this.m_footNoteText = ftText;
	};
	return {

		initMicroViewer : function (eventId, resultName) {
			var microViewerModalObj = MP_ModalDialog.retrieveModalDialogObject("microViewer");
			if (!microViewerModalObj) {
				microViewerModalObj = new ModalDialog("microViewer");
				var micViewerCloseBtn = new ModalButton("micViewerCloseBtn");
				micViewerCloseBtn.setText(micViewModalI18n.CLOSE);
				micViewerCloseBtn.setFocusInd(true);
				microViewerModalObj.setTopMarginPercentage(10).setRightMarginPercentage(15).setBottomMarginPercentage(15).setLeftMarginPercentage(15).setIsBodySizeFixed(false);
				microViewerModalObj.setHeaderTitle(micViewModalI18n.MIC_RESULT_DETAILS);
				microViewerModalObj.addFooterButton(micViewerCloseBtn);
				MP_ModalDialog.addModalDialogObject(microViewerModalObj);
			}

			microViewerModalObj.setBodyDataFunction(function (micModalObj) {
				MD_microViewerDialog.attachListeners();
				var cclParam = [];
				cclParam.push("^MINE^", eventId + ".0", 0, 1, 1);
				$("#microViewerbody").addClass("micview-loading");
				$("#microViewerbody").html("<div class = 'micview-jj'></div>");
				MD_microViewerDialog.loadWithCBParameters("mp_get_result_viewer_data", cclParam, MD_microViewerDialog.renderMicroViewer);
			});
			MP_ModalDialog.updateModalDialogObject(microViewerModalObj);
			MP_ModalDialog.showModalDialog("microViewer");
		},
		loadWithCBParameters : function (programName, params, callback) {
			var request = new MP_Core.ScriptRequest(this, "");
			request.setProgramName(programName);
			request.setParameters(params);
			request.setAsync(true);
			MP_Core.XMLCCLRequestCallBack(null, request, callback);
		},
		alertError : function (message, title, buttonText) {
			var modalObj = MP_Util.generateModalDialogBody("micViewerFailureAlert", "error", message, "");
			var modalButton = modalObj.getFooterButton("modalOkBtn");
			if (!modalButton) {
				modalButton = new ModalButton("modalOkBtn");
				modalButton.setText(buttonText);
				modalButton.setFocusInd(true).setOnClickFunction(function () {MP_ModalDialog.closeModalDialog("microViewer");});
				modalObj.addFooterButton(modalButton);
				modalObj.setShowCloseIcon(false);
			}
			modalObj.setHeaderTitle(title);
			modalObj.setFooterButtonText("modalOkBtn", buttonText);
			MP_ModalDialog.updateModalDialogObject(modalObj);
			MP_ModalDialog.showModalDialog("micViewerFailureAlert");
		},
		alertMicFootNoteWindow : function (message) {
			var modalObj = MP_Util.generateModalDialogBody("micMicFootNoteAlert", "", message, "");
			var modalButton = modalObj.getFooterButton("modalCloseBtn");
			if (!modalButton) {
				modalButton = new ModalButton("modalCloseBtn");
				modalButton.setText(micViewModalI18n.CLOSE);
				modalButton.setFocusInd(true).setOnClickFunction(function () {});
				modalObj.addFooterButton(modalButton);

			}
			modalObj.setHeaderTitle(micViewModalI18n.MIC_FOOTNOTE);
			modalObj.setFooterButtonText("modalCloseBtn", micViewModalI18n.CLOSE);
			MP_ModalDialog.updateModalDialogObject(modalObj);
			MP_ModalDialog.showModalDialog("micMicFootNoteAlert");
		},
		buildEventDetailSectionHTML : function (eventRBListObj) {
			var eventDetailHTML = [];
			eventDetailHTML.push("<div class='micview-detail' id='micViewDetail'>");
			eventDetailHTML.push("<div class='micview-controls' id='micViewControls'>");
			eventDetailHTML.push(MD_microViewerDialog.buildTabSectionHTML());
			eventDetailHTML.push("</div><div class='micview-tab-body ' id='micViewBody'>");
			eventDetailHTML.push("<div class='micview-body-container' id='micViewTabBodyId'>");
			if (reportsFound) {
				eventDetailHTML.push(MD_microViewerDialog.buildMicroRepotsTabHTML(eventRBListObj));
			}
			if (suscepFound) {
				eventDetailHTML.push(MD_microViewerDialog.buildSuscepTabHTML(eventRBListObj));
			}
			if (specimenFound) {
				eventDetailHTML.push(MD_microViewerDialog.buildSpecimenTabHTML(eventRBListObj));
			}			
			if (commentsFound) {
				eventDetailHTML.push(MD_microViewerDialog.buildCommentsTabHTML(eventRBListObj));
			}
			eventDetailHTML.push(MD_microViewerDialog.buildActionListTabHTML(eventRBListObj));

			eventDetailHTML.push("</div></div></div>");
			return eventDetailHTML.join("");
		},
		buildTabSectionHTML : function () {
			var tabHTML = [];
			var activeTabHTML = "<span class = 'micview-tab-active-left'></span><span class = 'micview-tab-active-center'>";
			var activeCloseHTML = "</span><span class = 'micview-tab-active-right'></span>";
			var tabActivateClass = " micview-tab-active";
			var tabActivateLbl = "micview-tab-active-label";
			var micSepVisible = " hidden";

			tabHTML.push("<span class = 'micview-tab-bg-left micview-tab-container'></span>");

			if (reportsFound) {

				tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "' id='micViewTab1' tabtext = '", micViewModalI18n.MIC_REPORT, "'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.MIC_REPORT, "</div>", activeCloseHTML, "</div><span id = 'rvDetSepId' class='micview-tab-sep", micSepVisible, "'></span>");
				activeTabHTML = "";
				activeCloseHTML = "";
				tabActivateClass = " micview-tab-inactive";
				tabActivateLbl = "micview-tab-inactive-label";
				micSepVisible = "";

			}

			if (suscepFound) {
				tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "'  id='micViewTab2' tabtext = '", micViewModalI18n.SUSCEPTABILITIES,
					"'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.SUSCEPTABILITIES, "</div>", activeCloseHTML, "</div><span id = 'rvSuscepSepId' class='micview-tab-sep", micSepVisible, "'></span>");
				activeTabHTML = "";
				activeCloseHTML = "";
				tabActivateClass = " micview-tab-inactive";
				tabActivateLbl = "micview-tab-inactive-label";
				micSepVisible = "";
			}

			if (specimenFound) {
				tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "' id='micViewTab3' tabtext = '", micViewModalI18n.SPECIMEN,
					"'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.SPECIMEN, "</div>", activeCloseHTML, "</div><span id = 'rvSpecimenSepId' class='micview-tab-sep", micSepVisible, "'></span>");
				activeTabHTML = "";
				activeCloseHTML = "";
				tabActivateClass = " micview-tab-inactive";
				tabActivateLbl = "micview-tab-inactive-label";
				micSepVisible = "";
			}		

			if (commentsFound) {
				tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "' id='micViewTab5' tabtext = '", micViewModalI18n.COMMENTS,
					"'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.COMMENTS, "</div>", activeCloseHTML, "</div><span id = 'rvCommentsSepId' class='micview-tab-sep", micSepVisible, "'></span>");
			}
			tabHTML.push("<div  class='micview-tab-container", tabActivateClass, "' id='micViewTab4' tabtext = '", micViewModalI18n.ACTION_LIST,
				"'>", activeTabHTML, "<div class='", tabActivateLbl, "'>", micViewModalI18n.ACTION_LIST, "</div>", activeCloseHTML, "</div><span id = 'rvActionSepId' class='micview-tab-sep", micSepVisible, "'></span>");
			return tabHTML.join("");
		},

		buildMicroRepotsTabHTML : function (eventRBListObj) {
			var micReportsTabHTML = [];
			var verifiedDtTm = "";
			var invalidDate = "/Date(0000-00-00T00:00:00.000+00:00)/";
			var micListItem = null;
			micReportsTabHTML.push("<div class ='micview-comments-info' id = 'rvMicRepoInfoId'>");
			micRptListLen = eventRBListObj.CHILD_EVENT_LIST.length;
			for (var rptIndex = 0;
				rptIndex < micRptListLen;
				rptIndex++) {
				micListItem = eventRBListObj.CHILD_EVENT_LIST[rptIndex];
				if(micListItem.VERIFIED_DT_TM !== invalidDate) {
					verifiedDtTm = dateFormatter.formatISO8601(micListItem.VERIFIED_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				micReportsTabHTML.push("<div class = 'micview-comment-text1'>", micListItem.EVENT_CD_DISP, " - ", verifiedDtTm, " - </div>");
				micReportsTabHTML.push("<div class = 'micview-comment-pad'>", micListItem.BLOB_RESULT[0].BLOB[0].BLOB_TEXT.replace("<", "&#60;").replace("/","&#47;").replace(">","&#62;"), "</div>");
			}
			micReportsTabHTML.push("</div>");

			return micReportsTabHTML.join("");
		},
		buildSuscepTabHTML : function (eventRBListObj) {
			var suscepTabHTML = [];
			var micListItem = null;
			var micSuscepListItem = null;
			var micListLen = 0;
			var suscepFTLen = 0;
			var suscepFTItem = null;
			var micSuscepListLen = 0;
			var firstColIndx = 1;
			var suscepColHeaders = [];
			var suscepTableHeaderCols = 0;
			var antibioticArray = [];
			var alphaChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
			var suscepVisible = reportsFound ? " hidden" : "";
			suscepTabHTML.push("<div class ='micview-comments-info", suscepVisible, "' id = 'rvSuscepInfoId'>");
			suscepTabHTML.push("<div class = 'micview-table-div'><table class='micview-suscep-table'><tr><th></th>");

			micListLen = eventRBListObj.MICROBIOLOGY_LIST.length;
			suscepColHeaders = new Array(micListLen);
			antibioticArray = new Array(micListLen);

			for (var micIndex = 0; micIndex < micListLen; micIndex++) {

				micListItem = eventRBListObj.MICROBIOLOGY_LIST[micIndex];
				micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;
				var tempArray = [];
				var tempAntibioticArray = [];
				var tempAntibioticObjectArr = [];

				for (var micSuscepIndex = 0; micSuscepIndex < micSuscepListLen; micSuscepIndex++) {

					micSuscepListItem = micListItem.SUSCEPTIBILITY_LIST[micSuscepIndex];

					var colName = micSuscepListItem.DETAIL_SUSCEPTIBILITY_CD_DISP;
					var antiBioticDisp = micSuscepListItem.ANTIBIOTIC_CD_DESC;
					if (tempArray.indexOf(colName) === -1) {
						tempArray.push(colName);
					}
					if (tempAntibioticArray.indexOf(antiBioticDisp) === -1) {
						var antibioticObject = new AntibioticDetails();
						antibioticObject.setAntiDescription(antiBioticDisp);
						suscepFTLen = eventRBListObj.SUSCEP_FOOTNOTE_R_LIST.length;
						for (var suscepFTIndex = 0; suscepFTIndex < suscepFTLen; suscepFTIndex++) {
							suscepFTItem = eventRBListObj.SUSCEP_FOOTNOTE_R_LIST[suscepFTIndex];
							var ftLen = suscepFTItem.SUSCEP_FOOTNOTE.length;
							for (var ftIndex = 0; ftIndex < ftLen; ftIndex++) {
								var ftItem = suscepFTItem.SUSCEP_FOOTNOTE[ftIndex];
								if (suscepFTItem.SUSCEP_SEQ_NBR === micSuscepListItem.SUSCEP_SEQ_NBR) {
									antibioticObject = new AntibioticDetails();
									antibioticObject.setFootNoteInd(true);
									antibioticObject.setAntiDescription(antiBioticDisp);
									antibioticObject.setFootNoteText(ftItem.LONG_TEXT);
								}

							}

						} //suscepFoot note
						tempAntibioticArray.push(antiBioticDisp);
						tempAntibioticObjectArr.push(antibioticObject);
					}

				} // end for suscep

				suscepColHeaders[micIndex] = tempArray;

				antibioticArray[micIndex] = tempAntibioticObjectArr;
				if (suscepColHeaders[micIndex].length > suscepTableHeaderCols) {
					suscepTableHeaderCols = suscepColHeaders[micIndex].length;
				}

			} //end for micro

			//Adding Suscep table coloumn headers
			for (suscepColIdx = 0; suscepColIdx < suscepTableHeaderCols + 1; suscepColIdx++) {
				suscepTabHTML.push("<th>", alphaChars.charAt(suscepColIdx), "</th>");
			}
			suscepTabHTML.push("</tr>");

			for (micIndex = 0; micIndex < micListLen; micIndex++) {
				micListItem = eventRBListObj.MICROBIOLOGY_LIST[micIndex];
				var micItemOrganismCDDesc = (micListItem.ORGANISM_OCCURRENCE_NBR === 1) ? micListItem.ORGANISM_CD_DESC : micListItem.ORGANISM_CD_DESC + " #" + micListItem.ORGANISM_OCCURRENCE_NBR;
				suscepTabHTML.push("<tr><th class = 'micview-suscep-firstcol'>", firstColIndx++, "</th><td class = 'micview-suscep-section'>", micItemOrganismCDDesc, "</td>");

				for (var i = 0; i < suscepColHeaders[micIndex].length; i++) {
					suscepTabHTML.push("<td  class = 'micview-suscep-section'></td>");
					if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
						suscepTabHTML.push("<td class = 'micview-suscep-cell'></td>");
					}
				}
				suscepTabHTML.push("</tr>");

				suscepTabHTML.push("<tr><th class = 'micview-suscep-firstcol'>", firstColIndx++, "</th><td class = 'micview-suscep-subsection'></td>");

				for (i = 0; i < suscepColHeaders[micIndex].length; i++) {
					suscepTabHTML.push("<td  class = 'micview-suscep-subsection'>", suscepColHeaders[micIndex][i], "</td>");
					if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
						suscepTabHTML.push("<td class = 'micview-suscep-cell'></td>");
					}
				}
				suscepTabHTML.push("</tr>");

				micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;

				for (var k = 0; k < antibioticArray[micIndex].length; k++) {
					var antobioticHTML = [];
					for (var j = 0; j < suscepColHeaders[micIndex].length; j++) {
						var suscepFound = false;//eslint-disable-line no-shadow

						for (micSuscepIndex = 0; micSuscepIndex < micSuscepListLen; micSuscepIndex++) {

							micSuscepListItem = micListItem.SUSCEPTIBILITY_LIST[micSuscepIndex];

							if (antibioticArray[micIndex][k].getAntiDescription() === micSuscepListItem.ANTIBIOTIC_CD_DESC &&
								suscepColHeaders[micIndex][j] === micSuscepListItem.DETAIL_SUSCEPTIBILITY_CD_DISP) {
								antobioticHTML.push("<td class = 'micview-suscep-cell'>", micSuscepListItem.RESULT_CD_DISP ? micSuscepListItem.RESULT_CD_DISP : micSuscepListItem.RESULT_NUMERIC_VALUE, "</td>");
								suscepFound = true;

								break;
							}
						}
						if (!suscepFound) {
							antobioticHTML.push("<td class = 'micview-suscep-cell'></td>");
						}

					}
					var footNoteClass = "'";
					var footNoteInd = antibioticArray[micIndex][k].getFootNoteInd();

					var antibioticText = footNoteInd ? antibioticArray[micIndex][k].getAntiDescription() + "*" : antibioticArray[micIndex][k].getAntiDescription();

					var micViewFNText = "\"" + antibioticArray[micIndex][k].getFootNoteText() + "\"";
					var micViewFNHeader = "\"" + micItemOrganismCDDesc + "\"";
					var micViewFNAnti = "\"" + antibioticArray[micIndex][k].getAntiDescription() + "\"";
					if (footNoteInd) {
						footNoteClass = " micview-footnote' onclick = 'MD_microViewerDialog.buildFootNoteHTML(" + micViewFNHeader + "," + micViewFNAnti + "," + micViewFNText + ")'";
					}
					if (suscepColHeaders[micIndex].length !== suscepTableHeaderCols) {
						antobioticHTML.push("<td  class = 'micview-suscep-cell'></td>");
					}

					suscepTabHTML.push("<tr><th class = 'micview-suscep-firstcol'>", firstColIndx++, "</th><td class = 'micview-suscep-cell'", footNoteClass,
						">", antibioticText, "</td>", antobioticHTML.join(""), "</tr>");

				}
				if (micIndex !== micListLen - 1) {
					suscepTabHTML.push("<tr><th class = 'micview-suscep-firstcol'>", firstColIndx++, "</th>");
					for (i = 0; i <= suscepTableHeaderCols; i++) {
						suscepTabHTML.push("<td class = 'micview-suscep-cell'></td>");
					}
					suscepTabHTML.push("</tr>");
				}
			}

			suscepTabHTML.push("</table></div></div>");

			return suscepTabHTML.join("");
		},

		buildActionListTabHTML : function (eventRBListObj) {
			var actionListTabHTML = [];
			var actionListLen = 0;
			var actionDtTm = "";
			var requestDtTm = "";
			var actionListItem = null;
			var emptyCell = "--";
			var provider = null;
			var actionProviderName = "";
			var requestedByName = "";
			var requestedBy = null;
			var proxyName = "";
			var proxy = null;
			var invalidDate = "/Date(0000-00-00T00:00:00.000+00:00)/";
			actionListTabHTML.push("<div class = 'micview-actionlist-info hidden' id = 'rvActionListInfoId'><div class = 'micview-table-div'><table class='micview-actionlist-table'><tr><th>", micViewModalI18n.ACTION, "</th><th>", micViewModalI18n.PERFORMED_BY, "</th><th>", micViewModalI18n.PERFORMED_DATE, "</th><th>", micViewModalI18n.ACTION_STATUS, "</th><th>", micViewModalI18n.COMMENT, "</th><th>", micViewModalI18n.PROXY_PERSONNEL, "</th><th>", micViewModalI18n.REQUESTED_BY, "</th><th>", micViewModalI18n.REQUESTED_DATE, "</th><th>", micViewModalI18n.REQUEST_COMMENT, "</th></tr>");
			actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
			for (var alIndex = 0;alIndex < actionListLen;alIndex++) {
				actionDtTm = "";
				requestDtTm = "";
				actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
				if (actionListItem.ACTION_DT_TM !== invalidDate) {
					actionDtTm = dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				if (actionListItem.REQUEST_DT_TM !== invalidDate) {
					requestDtTm = dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, personnelArray);
				actionProviderName = (provider === null) ? "" : provider.fullName;
				requestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, personnelArray);
				requestedByName = (requestedBy === null) ? "" : requestedBy.fullName;
				proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, personnelArray);
				proxyName = (proxy === null) ? "" : proxy.fullName;
				actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", requestedByName ? requestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
			}
			actionListTabHTML.push("</table></div></div>");
			return actionListTabHTML.join("");
		},
		buildSpecimenTabHTML : function (eventRBListObj) {
			var specimenTabHTML = [];
			var specimenCollObj = null;
			var specimenCollectedDtTm = "";
			var emptyCell = " --";
			var specimenVisible = (reportsFound || suscepFound) ? " hidden" : "";

			specimenCollObj = eventRBListObj.SPECIMEN_COLL[0];
			specimenCollectedDtTm = dateFormatter.formatISO8601(specimenCollObj.COLLECT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			specimenTabHTML.push("<div class ='micview-specimen-info", specimenVisible, "' id = 'rvSpecimenInfoId'><div class = 'micview-tt'><span><h2 class='micview-resval'><span class = 'micview-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span><span class='micview-pad", "'><span class='res-ind'></span>", eventRBListObj.RESULT_VAL, "</span></span></h2></span></div>");
			specimenTabHTML.push("<dl class = 'micview-event-info'><dd class = 'micview-event-hd'>", micViewModalI18n.SOURCE_TYPE, ":</dd><dd class = 'micview-event-data'>", specimenCollObj.SOURCE_TYPE_CD_DISP ? specimenCollObj.SOURCE_TYPE_CD_DISP : emptyCell, "</dd></dl>");
			specimenTabHTML.push("<dl class = 'micview-event-info'><dd class = 'micview-event-hd'>", micViewModalI18n.COLLECTED_ON, ":</dd><dd class = 'micview-event-data'>", specimenCollectedDtTm ? specimenCollectedDtTm : emptyCell, "</dd></dl>");
			specimenTabHTML.push("<dl class = 'micview-event-info'><dd class = 'micview-event-hd'>", micViewModalI18n.BODY_SITE, ":</dd><dd class = 'micview-event-data'>", specimenCollObj.BODY_SITE_CD_DISP ? specimenCollObj.BODY_SITE_CD_DISP : emptyCell, "</dd></dl>");

			specimenTabHTML.push("</div>");
			return specimenTabHTML.join("");
		},
		buildCommentsTabHTML : function (eventRBListObj) {
			var commentsTabHTML = [];
			var noteListItem = null;
			var provider = null;
			var commentProviderName = "";
			commentsTabHTML.push("<div class ='micview-comments-info hidden' id = 'rvCommentsInfoId'>");
			noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
			for (var noteIndex = 0;
				noteIndex < noteListLen;
				noteIndex++) {
				noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
				provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, personnelArray);
				commentProviderName = (provider === null) ? "" : provider.fullName;
				commentsTabHTML.push("<div class = 'micview-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", micViewModalI18n.BY, " ", commentProviderName, " ", micViewModalI18n.ON, " ", dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
				commentsTabHTML.push("<div class = 'micview-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
			}
			commentsTabHTML.push("</div>");
			return commentsTabHTML.join("");
		},
		renderMicroViewer : function (response) {
			var micViewModalBodyHTML = [];
			var micViewModalObject = MP_ModalDialog.retrieveModalDialogObject("microViewer");
			var micViewModalId = micViewModalObject.getBodyElementId();
			dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			jsonResponse = response.getResponse();
			if (jsonResponse) {
				if (response.getStatus() === "F") {
					MP_Util.LogScriptCallError(null, this, "micro_viewer.js", "renderMicroViewer");
					MD_microViewerDialog.alertError(micViewModalI18n.ERROR_RETRIEVE, micViewModalI18n.ERROR_TITLE, micViewModalI18n.OK);
					return;
				}
			}
			personnelArray = MP_Util.LoadPersonelListJSON(jsonResponse.PRSNL);
			specimenFound = false;
			commentsFound = false;
			suscepFound = false;
			reportsFound = false;
			if (jsonResponse.RB_LIST[0].SPECIMEN_COLL.length) {
				specimenFound = true;
			}
			if (jsonResponse.RB_LIST[0].EVENT_NOTE_LIST.length) {
				commentsFound = true;
			}
			if (jsonResponse.RB_LIST[0].CHILD_EVENT_LIST.length) {
				reportsFound = true;
			}
			if (jsonResponse.RB_LIST[0].MICROBIOLOGY_LIST.length) {
				for (var micIndex = 0; micIndex < jsonResponse.RB_LIST[0].MICROBIOLOGY_LIST.length; micIndex++) {
					var micListItem = jsonResponse.RB_LIST[0].MICROBIOLOGY_LIST[micIndex];
					var micSuscepListLen = micListItem.SUSCEPTIBILITY_LIST.length;
					if (micSuscepListLen) {
						suscepFound = true;
					}
				}
			}

			micViewModalBodyHTML.push("<div class='micview-container'>");
			micViewModalBodyHTML.push("<div class = 'micview-tt'><span><h2 class='micview-resval'><span class = 'micview-resname'>", jsonResponse.RB_LIST[0].EVENT_CD_DISP, " - ", micViewModalI18n.ACCESSION_NUMBER, ":</span><span><span class='micview-pad", "'>", jsonResponse.RB_LIST[0].ACCESSION_NBR, "</span></span></h2></span></div>");
			micViewModalBodyHTML.push(MD_microViewerDialog.buildEventDetailSectionHTML(jsonResponse.RB_LIST[0]));
			micViewModalBodyHTML.push("</div>");
			$("#microViewerbody").removeClass("micview-loading");
			$("#" + micViewModalId).html(micViewModalBodyHTML.join(""));
		},
		buildFootNoteHTML : function (fnOrganismDesc, fnAntiDesc, fnText) {

			var modalFootNoteHTML = "";
			modalFootNoteHTML = "<div><span class = 'micview-resname'>" + fnOrganismDesc + "<span><span class = 'micview-footnote-txt'> - " +
				fnAntiDesc + "</span></div><br><div class = 'micview-footnote-div'>" + fnText + "</div>";
			MD_microViewerDialog.alertMicFootNoteWindow(modalFootNoteHTML);

		},
		onTabChange : function (selectedTabObj) {
			var objTabActive = $(selectedTabObj).parent().find(".micview-tab-active");
			if (objTabActive.length) {
				if ($(objTabActive).attr("id") === $(selectedTabObj).attr("id")) {
					return;
				}
				$(objTabActive).empty();
				$(objTabActive).html("<div class='micview-tab-inactive-label'>" + $(objTabActive).attr("tabText") + "</div>");
				objTabActive.removeClass("micview-tab-active");
				objTabActive.addClass("micview-tab-inactive");
				$(objTabActive).next().removeClass("hidden");
				$(objTabActive).prev().removeClass("hidden");
			}
			$(selectedTabObj).removeClass("micview-tab-inactive");
			$(selectedTabObj).next().addClass("hidden");
			$(selectedTabObj).prev().addClass("hidden");
			$(selectedTabObj).addClass("micview-tab-active");
			$(selectedTabObj).html("<span class = 'micview-tab-active-left'></span><span class = 'micview-tab-active-center'><span class='micview-tab-active-label'>" + $(selectedTabObj).attr("tabText") + "</span></span><span class = 'micview-tab-active-right'></span>");
			$(selectedTabObj).removeClass("micview-tab-inactive");
			$(selectedTabObj).addClass("micview-tab-active");
		},
		attachListeners : function () {

			$(document).on("click", "#micViewTab1", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				$("#rvMicRepoInfoId").removeClass("hidden");
				$("#rvSuscepInfoId").addClass("hidden");
			});
			$(document).on("click", "#micViewTab2", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				$("#rvMicRepoInfoId").addClass("hidden");
				$("#rvSuscepInfoId").removeClass("hidden");
			});
			$(document).on("click", "#micViewTab3", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").removeClass("hidden");
				$("#rvMicRepoInfoId").addClass("hidden");
				$("#rvSuscepInfoId").addClass("hidden");
			});
			$(document).on("click", "#micViewTab4", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").removeClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				$("#rvMicRepoInfoId").addClass("hidden");
				$("#rvSuscepInfoId").addClass("hidden");
			});
			$(document).on("click", "#micViewTab5", function () {
				MD_microViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").removeClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				$("#rvMicRepoInfoId").addClass("hidden");
				$("#rvSuscepInfoId").addClass("hidden");
			});
		}
	};
}
();
/* eslint no-inner-declarations:0, no-unneeded-ternary:0, curly:0, semi-spacing:0, no-warning-comments:0, no-lonely-if:0, no-loop-func:0, mp-camelcase:0, no-use-before-define:0, deprecated-functions:0, linebreak-style:0, valid-jsdoc:0, no-trailing-spaces: 0,no-multi-spaces: 0, no-mixed-spaces-and-tabs: 0, space-before-function-paren: 0, quotes: 0, comma-spacing: 0, object-curly-spacing: 0, array-bracket-spacing: 0, complexity: 0, brace-style: 0, key-spacing: 0, no-unused-vars: 0, new-cap: 0, no-undef: 0 */
var MP_PathologyViewerDialog = function(){	
	var pathViewerModalI18n = i18n.discernabu.pathology_viewer_modal;
	var jsonResponse = null;
	var PathologyViewerTabsIndex = {
			REPORT: 0,
			IMAGES:1,
			ACTION_LIST: 2,
			COMMENTS: 3			
			};
	var currentPage = PathologyViewerTabsIndex.REPORT;
	var image = "";
	var imageFlag = false;
	var tabNames = [];	
	var enabled = false;
	var creds = "";
	var username = "";
	var pwd = "";
	var dm = "";
	var ajo;	
	var ajo2;
	var eventGlobalId = 0;
	var dateFormatter = null;
	var personnelArray = [];
	var requestedBy = "";
	var receivedDate = "";
	var verifiedDate = "";
	var patMRN = "";
	var rptCase = "";
	var rptRequestedBy = "";
	var rptCollected = "";
	var rptLocation = "";
	var rptReport = "";
	var rptVerified = "";
	var rptPerformedBy = "";
	var rptReceived = "";
	var rptStatus = "";
	var reportHTMLDisplay = [];
	var printedBy = "";
	
	return {
		
		initPathologyViewer: function (patient_Id, event_Id, docViewerType) {		
				var docType = (docViewerType) ? docViewerType : "STANDARD";
				var pathLoading = [];
				var pprCd = CERN_Platform.getCriterion().CRITERION.PPR_CD + ".0";
				var providerId = CERN_Platform.getCriterion().CRITERION.PRSNL_ID + ".0";
				eventGlobalId = event_Id + ".0";
				patient_Id = patient_Id + ".0";			

				var pathModalDialog = MP_ModalDialog.retrieveModalDialogObject("pathModalDialog");
				if(!pathModalDialog) {
					pathModalDialog = new ModalDialog("pathModalDialog");
					pathModalDialog.setTopMarginPercentage(10).setBottomMarginPercentage(5).setIsBodySizeFixed(false);
					pathModalDialog.setHeaderCloseFunction();
					pathModalDialog.setHeaderTitle("<span class='visitswindow-title'>" + pathViewerModalI18n.PATHOLOGY_TITLE + "</span>"); 
					MP_ModalDialog.addModalDialogObject(pathModalDialog);					
				}		
										  
				pathModalDialog.setBodyDataFunction(function(pathViewDlg)
				{
					var cclParams = [];
					cclParams.push("^MINE^", eventGlobalId, patient_Id, "^" + docType + "^", pprCd, providerId);
					MP_PathologyViewerDialog.loadWithCBParameters("mp_get_path_viewer_data", cclParams, MP_PathologyViewerDialog.renderPathViewer);																	
				});						
				  
				MP_ModalDialog.updateModalDialogObject(pathModalDialog);
				MP_ModalDialog.showModalDialog(pathModalDialog.getId());				
				pathLoading.push("<div class='path-body-loading'><span class='path-loading'></span></div>");				
				pathModalDialog.setBodyHTML( pathLoading.join(""));								
				$('#pathModalDialogbody').css("overflow","hidden");
				$("#pathModalDialogbody").css("height", "100%");			
				$("#vwpModalDialogpathModalDialog").css("height", "100%");
				$("#vwpModalDialogpathModalDialog").css("position", "absolute");
		},

		loadWithCBParameters : function(programName, cclParams, callBack) {
			try{
				var request = new MP_Core.ScriptRequest(this);
				request.setProgramName(programName);
				request.setParameters(cclParams);
				request.setAsync(true);				
				MP_Core.XMLCCLRequestCallBack(null, request, callBack);
				}
				catch(err)
				{
					MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "loadWithCBParameters");
				}
		},
		
		renderPathViewer : function(response) {
			try
			{					
				var pathModalBodyHTML = [];
				var pathModalObject = MP_ModalDialog.retrieveModalDialogObject("pathModalDialog");
				var pathModalId = pathModalObject.getBodyElementId();				
				var actionListTab = pathViewerModalI18n.ACTION_LIST;
				var commentsTab = pathViewerModalI18n.COMMENTS;
				var imagesTab = pathViewerModalI18n.IMAGES;
				dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);

				jsonResponse = response.getResponse();
				if(jsonResponse) {
					if(response.getStatus() === "F") {
						MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "renderPathViewer");							
						return;
					}
				}			
			
				tabNames[PathologyViewerTabsIndex.REPORT] = (jsonResponse.PAT_ENCNTR_DETAILS.RESULT_TITLE) ? jsonResponse.PAT_ENCNTR_DETAILS.RESULT_TITLE : "";
				tabNames[PathologyViewerTabsIndex.IMAGES] = imagesTab;
				tabNames[PathologyViewerTabsIndex.ACTION_LIST] = actionListTab;
				tabNames[PathologyViewerTabsIndex.COMMENTS] = commentsTab;				

				personnelArray = MP_Util.LoadPersonelListJSON(jsonResponse.PRSNL);
				pathModalBodyHTML.push(MP_PathologyViewerDialog.switchTab(currentPage));

				pathModalObject.setBodyHTML(pathModalBodyHTML.join(""));
				MP_PathologyViewerDialog.attachListeners();
				$('#pathModalDialogheader').css("border","0px");
				$("#pathModalDialogbody").css("border-bottom", "1px solid #ABADB3");
				$("#pathModalDialogbody").css("border-left", "1px solid #ABADB3");
				$("#pathModalDialogbody").css("border-right", "1px solid #ABADB3");
				
				var allTabs = "#tabContainer .reachview-tabs ul li";
				$(allTabs).eq(currentPage).addClass("reachview-tab-active-header");
				
				$(allTabs).on("click", function () {				
					var $activeTab = $(this.parentElement).find(".reachview-tab-active-header");
					var activeTabId = $activeTab.attr("id");
					var curTabId = this.id;

					$activeTab.removeClass("reachview-tab-active-header");
					$("#tab-sec-" + activeTabId.charAt(activeTabId.length - 1)).hide();
					$(this).addClass("reachview-tab-active-header");									
					$("#curTabId").show();
					var pathModalDialogBodyObj = $('#pathModalDialogbody');
					
					if (curTabId === "pathViewerTab_0") 
					{
						imageFlag = false;
						pathModalDialogBodyObj.find(".path-report-tab").show();
						pathModalDialogBodyObj.find(".path-actionlist-tab").hide();
						pathModalDialogBodyObj.find(".path-comments-tab").hide();
						pathModalDialogBodyObj.find(".path-image-tab").hide();
						$("#iframeImageId").css("visibility", "hidden");
					}
					else if (curTabId === "pathViewerTab_3") 
					{
						imageFlag = false;
						pathModalDialogBodyObj.find(".path-comments-tab").show();
						pathModalDialogBodyObj.find("path-comments-info").show();
						$("#pathCommentsInfoId").removeClass("hidden");
						pathModalDialogBodyObj.find(".path-report-tab").hide();
						pathModalDialogBodyObj.find(".path-actionlist-tab").hide();
						pathModalDialogBodyObj.find(".path-image-tab").hide();
						$("#iframeImageId").css("visibility", "hidden");
					}
					if(image)
					{
						if (curTabId === "pathViewerTab_1") 
						{
							if(imageFlag)
							{
								var iframeObj = document.getElementById('iframeImageId');								
								iframeObj.src = image;
								var url0 = iframeObj.src.split('?')[0];
								var q = "?";								
								var urlLen = iframeObj.src.split('?')[1].length;
								var url1 = iframeObj.src.split('?')[1].slice(1,urlLen);
								iframeObj.src = url0 + q + url1;
							}							
							pathModalDialogBodyObj.find(".path-report-tab").hide();
							pathModalDialogBodyObj.find(".path-comments-tab").hide();
							pathModalDialogBodyObj.find(".path-actionlist-tab").hide();
							pathModalDialogBodyObj.find(".path-image-tab").show();
							$("#iframeImageId").css("visibility", "visible");
						}
						else if (curTabId === "pathViewerTab_2") 
						{
							imageFlag = false;
							pathModalDialogBodyObj.find(".path-actionlist-tab").show();
							pathModalDialogBodyObj.find("path-actionlist-info").show();
							$("#pathActionListInfoId").removeClass("hidden");
							pathModalDialogBodyObj.find(".path-report-tab").hide();
							pathModalDialogBodyObj.find(".path-comments-tab").hide();
							pathModalDialogBodyObj.find(".path-image-tab").hide();
							$("#iframeImageId").css("visibility", "hidden");
						}
					}
					else
					{
						if (curTabId === "pathViewerTab_1") 
						{
							imageFlag = false;
							pathModalDialogBodyObj.find(".path-actionlist-tab").show();
							pathModalDialogBodyObj.find("path-actionlist-info").show();
							$("#pathActionListInfoId").removeClass("hidden");
							pathModalDialogBodyObj.find(".path-report-tab").hide();
							pathModalDialogBodyObj.find(".path-comments-tab").hide();
							pathModalDialogBodyObj.find(".path-image-tab").hide();
							$("#iframeImageId").css("visibility", "hidden");
						}
						else if (curTabId === "pathViewerTab_2") 
						{
							imageFlag = false;
							pathModalDialogBodyObj.find(".path-comments-tab").show();
							pathModalDialogBodyObj.find("path-comments-info").show();
							$("#pathCommentsInfoId").removeClass("hidden");
							pathModalDialogBodyObj.find(".path-report-tab").hide();
							pathModalDialogBodyObj.find(".path-actionlist-tab").hide();
							pathModalDialogBodyObj.find(".path-image-tab").hide();
							$("#iframeImageId").css("visibility", "hidden");
						}
					}					
				});
				}
				catch(err)
				{
					MP_Util.LogJSError(err, this, "pathology_viewer_modal.js", "renderPathologyViewer");
				}
			},
		
		buildActionListTabHTML : function (eventRBListObj) {
			var actionListTabHTML = [];
			var actionListLen = 0;
			var actionDtTm = "";
			var requestDtTm = "";
			var actionListItem = null;
			var emptyCell = "--";
			var provider = null;
			var actionProviderName = "";
			var actionListRequestedBy = null;
			var actionListRequestedByName = "";
			var proxy = null;
			var proxyName = "";
			var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			
			actionListTabHTML.push("<div class ='path-actionlist-info hidden' id = 'pathActionListInfoId'><div class = 'path-table-div'><table class='path-actionlist-table'><tr><th>", pathViewerModalI18n.ACTION, "</th><th>", pathViewerModalI18n.ACTION_PERFORMED_BY, "</th><th>", pathViewerModalI18n.PERFORMED_DATE, "</th><th>", pathViewerModalI18n.ACTION_STATUS, "</th><th>", pathViewerModalI18n.COMMENT, "</th><th>", pathViewerModalI18n.PROXY_PERSONNEL, "</th><th>", pathViewerModalI18n.ACTION_REQUESTED_BY, "</th><th>", pathViewerModalI18n.REQUESTED_DATE, "</th><th>", pathViewerModalI18n.REQUEST_COMMENT, "</th></tr>");
			actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
			for (var alIndex = 0;alIndex < actionListLen;alIndex++) {
				actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
				actionDtTm = "";
				requestDtTm = "";
				var actionDate = actionListItem.ACTION_DT_TM.substr(6,4);
				var reqDate = actionListItem.REQUEST_DT_TM.substr(6,4);				
				if(actionDate > 0){					
					actionDtTm = dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				if(reqDate > 0){					
					requestDtTm = dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);					
				}
				
				provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, personnelArray);
				actionProviderName = (provider === null) ? "" : provider.fullName;
				actionListRequestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, personnelArray);
				actionListRequestedByName = (actionListRequestedBy === null) ? "" : actionListRequestedBy.fullName;
				proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, personnelArray);
				proxyName = (proxy === null) ? "" : proxy.fullName;
				
				actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", actionListRequestedByName ? actionListRequestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
				if(actionListItem.ACTION_TYPE_CD === jsonResponse.ACTION_TYPE_CDS.ORDER_CD){
					requestedBy = actionProviderName;
					receivedDate = actionDtTm;
				}
				if(actionListItem.ACTION_TYPE_CD === jsonResponse.ACTION_TYPE_CDS.VERIFY_CD){
					verifiedDate = actionDtTm;
				}
			}
			actionListTabHTML.push("</table></div></div>");
			return actionListTabHTML.join("");
		},
		
		buildCommentsTabHTML : function (eventRBListObj) {
			var commentsTabHTML = [];
			var noteListItem = null;
			var provider = null;
			var commentProviderName = "";
			commentsTabHTML.push("<div class ='path-comments-info hidden' id = 'pathCommentsInfoId'>");
			noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
			if(noteListLen > 0){
				for (var noteIndex = 0;noteIndex < noteListLen;noteIndex++) {
					noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
					provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, personnelArray);
					commentProviderName = (provider === null) ? "" : provider.fullName;				
					commentsTabHTML.push("<div class = 'path-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", pathViewerModalI18n.BY, " ", commentProviderName, " ", pathViewerModalI18n.ON, " ", dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
					commentsTabHTML.push("<div class = 'path-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
				}
			} else {
				commentsTabHTML.push("<div class = 'path-nocomments-text'>" +  pathViewerModalI18n.NO_COMMENTS + "</div>");
			}
			return commentsTabHTML.join("");
		},
		
		init : function () {
			var url = "../../mpages/creds";
			ajo = MP_PathologyViewerDialog.getXMLHttpRequest();
			ajo.open("GET", url, false);
			ajo.onreadystatechange = MP_PathologyViewerDialog.processRequest;
			ajo.send();
		},
		
		getXMLHttpRequest : function () {
			var xmlHttp = null;
			try {
				if (window.XMLHttpRequest) {
					xmlHttp = new XMLHttpRequest();
				}
			} catch (e) {
				try {
					xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
				} catch (e2) {
					xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
				}
			}
			return xmlHttp;
		},
		
		processRequest : function () {
			try {
				if (ajo.readyState === 4) {
					if (ajo.status === 200) {
						var jObj = JSON.parse(ajo.responseText);
						username = jObj.un;
						pwd = jObj.pw;
						dm = jObj.dm;
						MP_PathologyViewerDialog.locateCmvWebapp();
					}
				} else {
					MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "processRequest");
				}
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "processRequest");
			}
		},
		
		webkit : function () {
			return new RegExp(" AppleWebKit/").test(navigator.userAgent);
		},
		
		locateCmvWebapp : function () {
			try {
				var fullCanonicalDomainName = jsonResponse.FULL_CANONICAL_DOMAIN_NAME; 			
				ajo2 = MP_PathologyViewerDialog.getXMLHttpRequest();
				var userDomain = "";
				var url = window.location.protocol + "//" + window.location.host +  "/mediaviewer/" + fullCanonicalDomainName + "/mom";
				if (MP_PathologyViewerDialog.webkit() === true) {
					userDomain = username + "%40" + dm;
				} else {
					userDomain = username + "@" + dm;
				}
				ajo2.open("GET", url, false, userDomain, pwd);			
				ajo2.send();
			} catch (e) {
				MP_Util.LogScriptCallError(null, this, "pathology_viewer_modal.js", "locateCmvWebapp");
			}
		},			
		
		switchTab : function(tabIndex) {
		try{
			var htmlArray = [];
			var jsonRBList = jsonResponse.RB_LIST[0];
			//sorting the CHILD_EVENT_LIST and BLOBS arrays on clinical_event_id for displaying the pathology reports headers and content in correct sequence
			jsonRBList.CHILD_EVENT_LIST.sort(function(a, b) {
				return parseFloat(a.CLINICAL_EVENT_ID) - parseFloat(b.CLINICAL_EVENT_ID);
			});
			jsonResponse.BLOBS.sort(function(a, b) {
				return parseFloat(a.CLINICAL_EVENT_ID) - parseFloat(b.CLINICAL_EVENT_ID);
			});
			var pathReportDetailsLength = jsonRBList.CHILD_EVENT_LIST.length;
			var blobsLength = jsonResponse.BLOBS.length;
			var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);			
			var reportHTML = [];
			var reportTitleLine = "";
			var reportNoteLine = "";
			var emptyData = "--";
			var rptActionList = [];
			var rptComments = [];
			image = (jsonResponse.PATH_IMAGES.IMAGE_URL) ? jsonResponse.PATH_IMAGES.IMAGE_URL : "";
			imageFlag = true;
			
			var jsonResultDetails = jsonResponse.PAT_ENCNTR_DETAILS;				
			
			rptActionList = MP_PathologyViewerDialog.buildActionListTabHTML(jsonRBList);
			rptComments = MP_PathologyViewerDialog.buildCommentsTabHTML(jsonRBList);
			patMRN = (jsonResultDetails.PAT_ALIAS) ? jsonResultDetails.PAT_ALIAS : emptyData;
			rptCase = (jsonResponse.CASE_ID) ? jsonResponse.CASE_ID : emptyData;				
			rptRequestedBy = (requestedBy) ? requestedBy : emptyData;
			rptCollected = (jsonResultDetails.RESULT_DATE) ? df.formatISO8601(jsonResultDetails.RESULT_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR) : emptyData;				
			rptLocation = (jsonResultDetails.INSTITUTION_DISP) ? jsonResultDetails.INSTITUTION_DISP : emptyData;				
			rptReport = (jsonResultDetails.RESULT_TITLE) ? jsonResultDetails.RESULT_TITLE : emptyData;				
			rptPerformedBy = (jsonResultDetails.VERIFIED_FULL) ? jsonResultDetails.VERIFIED_FULL : emptyData;				
			rptReceived = (receivedDate) ? receivedDate : emptyData;
			rptStatus = (jsonResultDetails.RESULT_STATUS) ? jsonResultDetails.RESULT_STATUS : emptyData;				
			rptVerified = (verifiedDate) ? verifiedDate : emptyData;
			printedBy = (jsonResultDetails.PROVIDER_NAME) ? jsonResultDetails.PROVIDER_NAME : "";

			if(blobsLength > 0) {
				for (var b = 0; b < blobsLength; b++) {
					var childNoteListLen = jsonRBList.CHILD_EVENT_LIST[b].EVENT_NOTE_LIST.length;
					reportTitleLine = jsonRBList.CHILD_EVENT_LIST[b].EVENT_TITLE_TEXT;
					reportHTML.push("<br><span class='path-blob-title'>" + reportTitleLine + "</span><br>");
					reportHTML.push(jsonResponse.BLOBS[b].BLOB_HTML);
					if(childNoteListLen > 0) {
					for(var n = 0; n < childNoteListLen; n++) {
						reportNoteLine = jsonRBList.CHILD_EVENT_LIST[b].EVENT_NOTE_LIST[0].LONG_BLOB;
						reportHTML.push("<br><span>" + reportNoteLine + "</span><br>");
						}
					}
					reportHTMLDisplay = reportHTML.join("");
				}
			}
			
			htmlArray.push("<div class='path-header'><dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.CASE + "</dt><dd class='path-res-value'>" + rptCase + 
			"</dd></dl><dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.REQUESTED_BY + "</dt><dd class='path-res-value'>" + rptRequestedBy + 
			"</dd></dl><dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.COLLECTED + "</dt><dd class='path-res-value'>" + rptCollected + 
			"</dd></dl><dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.VERIFIED + "</dt><dd class='path-res-value'>" + rptVerified + 
			"</dd><span class='path-print-icon' id='printPathRptId'></span></dl>" +
			"<dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.REPORT + "</dt><dd class='path-res-value'>" + rptReport + 
			"</dd></dl><dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.PERFORMED_BY + "</dt><dd class='path-res-value'>" + rptPerformedBy + 
			"</dd></dl><dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.RECEIVED + "</dt><dd class='path-res-value'>" + rptReceived + 
			"</dd></dl><dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.LOCATION + "</dt><dd class='path-res-value'>" + rptLocation + 
			"</dd></dl><dl class='path-note-type'><dt class='path-name'>" + pathViewerModalI18n.STATUS + "</dt><dd class='path-res-value'>" + rptStatus + "</dd></dl></div>");
			htmlArray.push('<div class="path-tabs-container" id="tabContainer"><div class="reachview-tabs"><ul>');

			var numTabs;
			if (image) {				
				numTabs = tabNames.length;
			} else {								
				tabNames.splice(1,1);
				numTabs = tabNames.length;
			}
			
			if(typeof tabIndex === "number"){
				currentPage = tabIndex;
			}else{
				tabIndex = currentPage;
			}
		
			var i;
			var iTabName;
			for ( i = 0; i < numTabs; i++) {				
				iTabName = tabNames[i];
				htmlArray.push('<li id="pathViewerTab_', i, '"><span class="reachview-tab-left-edge">&nbsp;</span><span class="reachview-tab-text">', iTabName, '</span><span class="reachview-tab-right-edge">&nbsp;</span></li>');
			}
			htmlArray.push('</ul></div><hr /><div class="path-tabs-content">');
			if(image){
				htmlArray.push("<div class='tabs'>" +
									"<ul>" +
										"<li id='tab1'></li>" +
										"<li id='tab2'></li>" +
										"<li id='tab3'></li>" +
										"<li id='tab4'></li>" +
									"</ul>" +
								"</div>" +
								
								"<div class='path-report-tab' id='tab-sec-1'>" +	
									"<dl class='path-smry-data'><dt class='path-res-type'></dt><dd class='path-smry-value'>" + reportHTMLDisplay + "</dd></dl>" +
								"</div>" +
								"<div class='path-image-tab' id='tab-sec-2'>" +
									"<iframe id='iframeImageId' style= 'visibility:hidden;' src='" + image + "' width='100%' height='700'></iframe>" +
								"</div>" +
								"<div class='path-actionlist-tab' id='tab-sec-3'>" , rptActionList, "</div>" +
								"<div class='path-comments-tab' id='tab-sec-4'>" , rptComments, "</div></div>");

				htmlArray.push('</div>');				
				htmlArray.push("</div></div>");				
				MP_PathologyViewerDialog.init();
			}
			else
			{
				htmlArray.push("<div class='tabs'>" +
								"<ul>" +
									"<li id='tab1'></li>" +
									"<li id='tab3'></li>" +
									"<li id='tab4'></li>" +									
								"</ul>" +
							"</div>" +
														
							"<div class='path-report-tab' id='tab-sec-1'>" +	
								"<dl class='path-smry-data'><dt class='path-res-type'></dt><dd class='path-smry-value'>" + reportHTMLDisplay + "</dd>" +
							"</div>" +
							
							"<div class='path-actionlist-tab' id='tab-sec-3'>" +								
								"<span class='path-tab-content'>" + rptActionList + "</span>" +
							"</div>" +
							
							"<div class='path-comments-tab' id='tab-sec-4'>" +
								"<span class='path-tab-content'>" + rptComments + "</span>" +	
							"</div>");
							
			htmlArray.push('</div>');			
			htmlArray.push("</div></div>");
			}
			var hxHTML = htmlArray.join("");
			return hxHTML;
		}
		catch(err)
		{
			MP_Util.LogJSError(err, this, "pathology_viewer_modal.js", "switchTab");
		}
		},
		printDocument : function () {
			var iframeObj = "";
			try {
				var htmlText = [];
				var ua = window.navigator.userAgent;
				var browserMsie = ua.indexOf("MSIE ");
				var browserTrident = ua.indexOf("Trident/");
				var browserEdge = ua.indexOf("Edge/");
				var docViewerModalI18n = i18n.discernabu.document_viewer_modal;
				var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
				var patName = CERN_Platform.getCriterion().CRITERION.PERSON_INFO.PERSON_NAME;
				var patDOB = CERN_Platform.getCriterion().CRITERION.PERSON_INFO.DOB;
				patName = patName ? patName : "";
				patDOB = patDOB ? df.formatISO8601(patDOB, mp_formatter.DateTimeFormatter.FULL_DATE_4YEAR) : "--";
				var $style = $("<style type='text/css'>.document-print-label{display:inline-block;text-align:right;width:15%;vertical-align:top;}" +
				".document-print-font{font-size:14px;font-family:Arial;}.document-content-font{font-size:16px;font-family:Arial;}" +
				".document-print-bold{font-weight:bold;}.document-print-value{display:-moz-inline-stack;" +
				"vertical-align:top;display:inline-block;zoom:1;*display:inline;width:15%;margin-left:4px;text-align:left;}</style>");
				htmlText.push("<div id='printDiv' class='document-print-font'>");
				htmlText.push("<dl><dt class='document-print-label document-print-bold'>" + patName + "</dt>");
				htmlText.push("<dd class='document-print-value'></dd>");
				htmlText.push("<dt class='document-print-label'>" + docViewerModalI18n.MRN + "</dt>");
				htmlText.push("<dd class='document-print-value'>" + patMRN + "</dd>");
				htmlText.push("<dt class='document-print-label'>" + docViewerModalI18n.DOB + "</dt>");
				htmlText.push("<dd class='document-print-value'>" + patDOB + "</dd></dl>");
				htmlText.push("<dl><dt class='document-print-label'>" + pathViewerModalI18n.CASE + "</dt><dd class='document-print-value'>" + rptCase + 
				"</dd><dt class='document-print-label'>" + pathViewerModalI18n.REQUESTED_BY + "</dt><dd class='document-print-value'>" + rptRequestedBy + 
				"</dd><dt class='document-print-label'>" + pathViewerModalI18n.COLLECTED + "</dt><dd class='document-print-value'>" + rptCollected +                
				"</dd></dl><dl><dt class='document-print-label'>" + pathViewerModalI18n.REPORT + "</dt><dd class='document-print-value'>" + rptReport + 
				"</dd><dt class='document-print-label'>" + pathViewerModalI18n.PERFORMED_BY + "</dt><dd class='document-print-value'>" + rptPerformedBy + 
				"</dd><dt class='document-print-label'>" + pathViewerModalI18n.RECEIVED + "</dt><dd class='document-print-value'>" + rptReceived + 
				"</dd></dl><dl><dt class='document-print-label'>" + pathViewerModalI18n.STATUS + "</dt><dd class='document-print-value'>" + rptStatus +
				"</dd><dt class='document-print-label'>" + pathViewerModalI18n.VERIFIED + "</dt><dd class='document-print-value'>" + rptVerified +
				"</dd><dt class='document-print-label'>" + pathViewerModalI18n.LOCATION + "</dt><dd class='document-print-value'>" + rptLocation +
				"</dd></dl></div></br></br>");


				htmlText.push("<div class='document-content-font'>" + reportHTMLDisplay + "</div>");
				htmlText.push("</br></br></br></br><div class='document-print-font'><span>" + docViewerModalI18n.PRINTED_BY + "</span><span>&nbsp" + printedBy + "</span></div>");
				iframeObj = document.createElement("iframe");
				$(iframeObj).addClass("hidden");
				document.body.appendChild(iframeObj);
				var printWindow = iframeObj.contentWindow;
				var docObject = printWindow ? printWindow.document : null;
				if (docObject) {
					docObject.write(htmlText.join(""));
					docObject.close();
					$(iframeObj).addClass("document-print-bold");
					$(iframeObj).show().contents().find("head").append($style);
					if (browserMsie !== -1 || browserTrident !== -1 || browserEdge !== -1) {
						docObject.execCommand("print", false, null);
					} else {
						printWindow.focus();
						printWindow.print();
					}
					printWindow.location.reload();
					printWindow.close();
				}
			} catch (err) {
				if ($(iframeObj).length) {
					$(iframeObj).remove();
				}
				MP_Util.LogJSError(err, null, "pathology_viewer_modal.js", "PrintDocument");
				throw err;
			}
			finally {
				if ($(iframeObj).length) {
					$(iframeObj).remove();
				}
			}
		},
		attachListeners : function () {
			$("#printPathRptId").on("mouseover", function() {
				$("#printPathRptId").addClass("path-print-mouseover");
				$("#printPathRptId").removeClass("path-print-icon");
			});
			$("#printPathRptId").on("mouseout", function() {
				$("#printPathRptId").addClass("path-print-icon");
				$("#printPathRptId").removeClass("path-print-mouseover");
			});
			$("#printPathRptId").on("click", function() {			
			MP_PathologyViewerDialog.printDocument();
			});
		}
	};
}();
/* eslint no-inner-declarations:0, no-unneeded-ternary:0, curly:0, semi-spacing:0, no-warning-comments:0, no-lonely-if:0, no-loop-func:0, mp-camelcase:0, no-use-before-define:0, deprecated-functions:0, linebreak-style:0, valid-jsdoc:0, no-trailing-spaces: 0,no-multi-spaces: 0, no-mixed-spaces-and-tabs: 0, space-before-function-paren: 0, quotes: 0, comma-spacing: 0, object-curly-spacing: 0, array-bracket-spacing: 0, complexity: 0, brace-style: 0, key-spacing: 0, no-unused-vars: 0, new-cap: 0, no-undef: 0, no-shadow:0 */
/* The namespace MD_reachViewerDialog has functions for Reach Viewer */	
	var MD_reachViewerDialog = function () {
		var m_personId = 0;
		var m_encounterId = 0;
		var m_peventId = 0;
		var m_providerId = 0;
		var m_eventId = 0;
		var m_viewerType = "";
		var m_imageUrl = "";
		var m_resultName = "";
		var m_imageClicked = 0;
		var m_docDisplay = "";
		var m_posCd = 0;
		var m_visitDate = "";		
				
	return {	
		LaunchReachGraphViewer: function(params){
		try{					
			MD_trendingGraphDialog.initTrendGraph(params);
		
		}
		catch (err) {
				MP_Util.LogJSError(err, null, "reach-viewer-core.js", "LaunchReachClinNoteViewer");
		
			}
		
		},
		
		/**
		 * Retrieves a document/result for viewing via the MPages Modal viewer
		 */		
		LaunchReachClinNoteViewer: function(m_personId,m_encounterId,m_eventId,m_docDisplay,m_viewerType,m_peventId,m_imageUrl,m_providerId,m_imageClicked,m_resultName) {		
			
			try {	
			
				switch (m_viewerType) {					
					case 'DOC':						
						MP_DocumentViewerDialog.initDocumentViewer(m_personId,m_encounterId,m_eventId,m_docDisplay,m_viewerType,m_peventId,m_imageUrl,m_providerId,m_imageClicked);
						break;
					case 'EVENT':						
						MD_resultViewerDialog.initResultViewer(m_eventId,m_resultName);
						break;					
					case 'MICRO':						
						MD_microViewerDialog.initMicroViewer(m_eventId,m_resultName);
						break;						
					case 'AP':
						MP_PathologyViewerDialog.initPathologyViewer(m_personId, m_eventId, m_viewerType);
						break;
				}
			}
			catch (err) {
				MP_Util.LogJSError(err, null, "reach-viewer-core.js", "LaunchReachClinNoteViewer");
		
			}

		},
		
		LaunchReachVisitsDetailViewer : function(m_personId, m_encounterId, m_providerId, m_posCd, m_visitDate) {
			try {					
					MP_VisitDetailDialog.initVisitViewer(m_personId, m_encounterId, m_providerId, m_posCd, m_visitDate);
				}
			catch (err) {
				MP_Util.LogJSError(err, null, "reach-viewer-core.js", "LaunchReachVisitsDetailViewer");		
			}
		}
		
	};
}
();
/* eslint no-inner-declarations:0, no-unneeded-ternary:0, curly:0, semi-spacing:0, no-warning-comments:0, no-lonely-if:0, no-loop-func:0, mp-camelcase:0, no-use-before-define:0, deprecated-functions:0, linebreak-style:0, valid-jsdoc:0, no-trailing-spaces: 0,no-multi-spaces: 0, no-mixed-spaces-and-tabs: 0, space-before-function-paren: 0, quotes: 0, comma-spacing: 0, object-curly-spacing: 0, array-bracket-spacing: 0, complexity: 0, brace-style: 0, key-spacing: 0, no-unused-vars: 0, new-cap: 0, no-undef: 0 */
var MD_resultViewerDialog = function () {
	var resViewModalI18n = i18n.discernabu.result_viewer_modal;
	var jsonResponse = null;
	var specimenFound = false;
	var commentsFound = false;
	var dateFormatter = null;
	var personnelArray = [];
	var resultType = 0;
	return {
		initResultViewer : function (eventId, resultName) {
			var resultViewerModalObj = MP_ModalDialog.retrieveModalDialogObject("resultViewer");
			if (!resultViewerModalObj) {
				resultViewerModalObj = new ModalDialog("resultViewer");
				var resViewerCloseBtn = new ModalButton("resViewerCloseBtn");
				resViewerCloseBtn.setText(resViewModalI18n.CLOSE);
				resViewerCloseBtn.setFocusInd(true);
				resultViewerModalObj.setTopMarginPercentage(10).setRightMarginPercentage(30).setBottomMarginPercentage(15).setLeftMarginPercentage(30).setIsBodySizeFixed(false);
				resultViewerModalObj.setHeaderTitle(resultName ? resultName : resViewModalI18n.RESULT_DETAILS);
				resultViewerModalObj.addFooterButton(resViewerCloseBtn);
				MP_ModalDialog.addModalDialogObject(resultViewerModalObj);
			}
		
			resultViewerModalObj.setHeaderTitle(resultName ? resultName : resViewModalI18n.RESULT_DETAILS);
			resultViewerModalObj.setBodyDataFunction(function (resultModalObj) {
				MD_resultViewerDialog.attachListeners();
				var cclParam = [];
				cclParam.push("^MINE^", eventId + ".0", 0, 1);
				$("#resultViewerbody").addClass("resview-loading");
				$("#resultViewerbody").html("<div class = 'resview-jj'></div>");
				MD_resultViewerDialog.loadWithCBParameters("mp_get_result_viewer_data", cclParam, MD_resultViewerDialog.renderResultViewer);
			});
			MP_ModalDialog.updateModalDialogObject(resultViewerModalObj);
			MP_ModalDialog.showModalDialog("resultViewer");
		},
		loadWithCBParameters : function (programName, params, callback) {
			var request = new MP_Core.ScriptRequest(this, "");
			request.setProgramName(programName);
			request.setParameters(params);
			request.setAsync(true);
			MP_Core.XMLCCLRequestCallBack(null, request, callback);
		},
		alertError : function (message, title, buttonText) {
			var modalObj = MP_Util.generateModalDialogBody("resViewerFailureAlert", "error", message, "");
			var modalButton = modalObj.getFooterButton("modalOkBtn");
			if (!modalButton) {
				modalButton = new ModalButton("modalOkBtn");
				modalButton.setText(buttonText);
				modalButton.setFocusInd(true).setOnClickFunction(function () {MP_ModalDialog.closeModalDialog("resultViewer");});
				modalObj.addFooterButton(modalButton);
				modalObj.setShowCloseIcon(false);
			}
			modalObj.setHeaderTitle(title);
			modalObj.setFooterButtonText("modalOkBtn", buttonText);
			MP_ModalDialog.updateModalDialogObject(modalObj);
			MP_ModalDialog.showModalDialog("resViewerFailureAlert");
		},
		buildEventHistorySectionHTML : function () {
			var eventHistoryHTML = [];
			var validFromDtTm = "";
			var validUntilDtTm = "";
			var normalcyClass = "";					 
			eventHistoryHTML.push("<div class = 'resview-history-label' id = 'resViewHistLblId'>", resViewModalI18n.HISTORY, "</div>");
			eventHistoryHTML.push("<div class ='resview-event-hist-info' id = 'resViewHistLblId'><div class = 'resview-hist-table-div'>");
			eventHistoryHTML.push("<table class='resview-actionlist-table'><tr><th>", resViewModalI18n.VALUE, "</th><th>", resViewModalI18n.VALID_FROM, "</th><th>", resViewModalI18n.VALID_UNTIL, "</th></tr>");
			var eventHistLength = jsonResponse.EVENT_HIST_LIST.length;
			var zebraClass = "odd ";
			var firstRow = "";
			var resultValColorClass = "";
			var resVal = "";
			for (var ehIndex = 0;
				ehIndex < eventHistLength;
				ehIndex++) {
				var eventHistItem = jsonResponse.RB_LIST[ehIndex];
				if (ehIndex === 0) {

					firstRow = "resview-hist-select resview-wht-text";
					resultValColorClass = "resview-wht-text ";
				} else {
					firstRow = "";
					resultValColorClass = "";
				}
				if (ehIndex % 2) {
					zebraClass = "even ";
				} else {
					zebraClass = "odd ";
				}
			
				validFromDtTm = dateFormatter.formatISO8601(eventHistItem.VALID_FROM_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				validUntilDtTm = dateFormatter.formatISO8601(eventHistItem.VALID_UNTIL_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				if (ehIndex === 0) {
					validUntilDtTm = "Current";
				}
				if (eventHistItem.DATE_RESULT.length) {
					resVal = dateFormatter.formatISO8601(eventHistItem.DATE_RESULT[0].RESULT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				} else {
					resVal = MD_resultViewerDialog.formatNumber(eventHistItem.RESULT_VAL);
				}
				normalcyClass = MD_resultViewerDialog.GetNormalcyClass(eventHistItem.NORMALCY_CD_MEAN);
				eventHistoryHTML.push("<tr class = 'resview-hist-info ", zebraClass, firstRow, "' eventRowIndex = ", ehIndex, "><td><span class='", resultValColorClass, normalcyClass, "'><span class='res-ind'></span>", resVal, "</span></td><td>", validFromDtTm, "</td><td>", validUntilDtTm, "</td>");
			}
			eventHistoryHTML.push("</table></div></div>");
			return eventHistoryHTML.join("");
		},
		
GetNormalcyClass : function(resultNormalcy) { 
	var normalcy = "res-normal";
	var normalcyMeaning = resultNormalcy;
	if (normalcyMeaning) {
		switch (normalcyMeaning) {
			case "NORMAL":
				normalcy = "res-normal";
				break;
			case "LOW":
				normalcy = "res-low";
				break;
			case "HIGH":
				normalcy = "res-high";
				break;
			case "ABNORMAL":
				normalcy = "res-abnormal";
				break;
			case "CRITICAL":
			case "EXTREMEHIGH":
			case "PANICHIGH":
			case "EXTREMELOW":
			case "PANICLOW":
			case "VABNORMAL":
			case "POSITIVE":
				normalcy = "res-severe";
				break;
		}
	}
	return normalcy;
},
formatNumber :function (value) {
	var nf = MP_Util.GetNumericFormatter();
	return mp_formatter._isNumber(value) ? nf.format(value, "^." + MP_Util.CalculatePrecision(value)) : value;//eslint-disable-line no-underscore-dangle
},


		buildEventDetailSectionHTML : function (eventRBListObj) {
			var eventDetailHTML = [];
			eventDetailHTML.push("<div class='resview-detail' id='resViewDetail'>");
			eventDetailHTML.push("<div class='resview-controls' id='resViewControls'>");
			eventDetailHTML.push(MD_resultViewerDialog.buildTabSectionHTML());			
			eventDetailHTML.push("</div><div class='resview-tab-body ' id='resViewBody'>");
			eventDetailHTML.push("<div class='resview-body-container' id='resViewTabBodyId'>");
			eventDetailHTML.push(MD_resultViewerDialog.buildDetailsTabHTML(eventRBListObj));
			eventDetailHTML.push(MD_resultViewerDialog.buildActionListTabHTML(eventRBListObj));
			if (specimenFound) {
				eventDetailHTML.push(MD_resultViewerDialog.buildSpecimenTabHTML(eventRBListObj));
			}
			if (commentsFound) {
				eventDetailHTML.push(MD_resultViewerDialog.buildCommentsTabHTML(eventRBListObj));
			}
			eventDetailHTML.push("</div></div></div>");
			return eventDetailHTML.join("");
		},
		buildTabSectionHTML : function () {
			var tabHTML = [];
			tabHTML.push("<span class = 'resview-tab-container'></span><div  class='resview-tab-container resview-tab-active' id='resViewTab1' tabtext = '", resViewModalI18n.DETAILS, "'><span class = 'resview-tab-active-left'></span><span class = 'resview-tab-active-center'><div class='resview-tab-active-label'>", resViewModalI18n.DETAILS, "</div></span><span class = 'resview-tab-active-right'></span></div><span id = 'rvDetSepId' class='resview-tab-sep hidden'></span>");
			if (specimenFound) {
				tabHTML.push("<div  class='resview-tab-container resview-tab-inactive' id='resViewTab2' tabtext = '", resViewModalI18n.SPECIMEN, "'><div class='resview-tab-inactive-label'>", resViewModalI18n.SPECIMEN, "</div></div><span id = 'rvSpecimenSepId' class='resview-tab-sep'></span>");
			}
			tabHTML.push("<div class='resview-tab-container resview-tab-inactive' id='resViewTab3' tabtext = '", resViewModalI18n.ACTION_LIST, "'><div class='resview-tab-inactive-label'>", resViewModalI18n.ACTION_LIST, "</div></div><span id = 'rvActionSepId' class='resview-tab-sep'></span>");
			if (commentsFound) {
				tabHTML.push("<div  class='resview-tab-container resview-tab-inactive' id='resViewTab4' tabtext = '", resViewModalI18n.COMMENTS, "'><div class='resview-tab-inactive-label'>", resViewModalI18n.COMMENTS, "</div></div><span id = 'rvCommentsSepId' class='resview-tab-sep'></span>");
			}
			
			return tabHTML.join("");
		},
		buildDetailsTabHTML : function (eventRBListObj) {
			var detailsTabHTML = [];
			var eventDtTm = "";
			var resVal = "";
			var normalcyClass = MD_resultViewerDialog.GetNormalcyClass(eventRBListObj.NORMALCY_CD_MEAN);	
			eventDtTm = dateFormatter.formatISO8601(eventRBListObj.EVENT_END_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			if (eventRBListObj.DATE_RESULT.length) {
				resVal = dateFormatter.formatISO8601(eventRBListObj.DATE_RESULT[0].RESULT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			} else {
				resVal = this.formatNumber(eventRBListObj.RESULT_VAL);
			}
			detailsTabHTML.push("<div class ='resview-details-info' id = 'rvDetailsInfoId'><div class = 'resview-tt'><span><h2 class='resview-resval'><span class = 'resview-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span class='resview-pad ", normalcyClass, "'><span class = 'res-ind'></span>", resVal, " ", "</span><span>", eventRBListObj.RESULT_UNITS_CD_DISP ? eventRBListObj.RESULT_UNITS_CD_DISP : "", "</span></h2></span></div>");
			detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.DATE_TIME, ":</dd><dd class = 'resview-event-data'>", eventDtTm, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.NORMAL_LOW, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.NORMAL_LOW, "</dd></dl>");
			detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.CONTRIBUTE_SYSTEM, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.CONTRIBUTOR_SYSTEM_CD_DISP, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.NORMAL_HIGH, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.NORMAL_HIGH, "</dd></dl>");
			if (specimenFound) {
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.ACCESSION_NUMBER, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.ACCESSION_NBR, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.CRITICAL_LOW, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.CRITICAL_LOW, "</dd></dl>");
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.SERVICE_RESOURCE, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.RESOURCE_CD_DISP, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.CRITICAL_HIGH, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.CRITICAL_HIGH, "</dd></dl>");
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.STATUS, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.RESULT_STATUS_CD_DISP, "</dd>");
			} else {
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.STATUS, ":</dd><dd class = 'resview-event-data'>", eventRBListObj.RESULT_STATUS_CD_DISP, "</dd><dd class = 'resview-limit-hd'>", resViewModalI18n.CRITICAL_LOW, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.CRITICAL_LOW, "</dd></dl>");
				detailsTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'></dd><dd class = 'resview-event-data'></dd><dd class = 'resview-limit-hd'>", resViewModalI18n.CRITICAL_HIGH, ":</dd><dd class = 'resview-limit-data'>", eventRBListObj.CRITICAL_HIGH, "</dd></dl>");
			}
			detailsTabHTML.push("</div>");
			return detailsTabHTML.join("");
		},
		buildActionListTabHTML : function (eventRBListObj) {
			var actionListTabHTML = [];
			var actionListLen = 0;
			var actionDtTm = "";
			var requestDtTm = "";
			var actionListItem = null;
			var emptyCell = "--";
			var provider = null;
			var actionProviderName = "";
			var requestedByName = "";
			var requestedBy = null;
			var proxyName = "";
			var proxy = null;
			var invalidDate = "/Date(0000-00-00T00:00:00.000+00:00)/";

			actionListTabHTML.push("<div class ='resview-actionlist-info hidden' id = 'rvActionListInfoId'><div class = 'resview-table-div'><table class='resview-actionlist-table'><tr><th>", resViewModalI18n.ACTION, "</th><th>", resViewModalI18n.PERFORMED_BY, "</th><th>", resViewModalI18n.PERFORMED_DATE, "</th><th>", resViewModalI18n.ACTION_STATUS, "</th><th>", resViewModalI18n.COMMENT, "</th><th>", resViewModalI18n.PROXY_PERSONNEL, "</th><th>", resViewModalI18n.REQUESTED_BY, "</th><th>", resViewModalI18n.REQUESTED_DATE, "</th><th>", resViewModalI18n.REQUEST_COMMENT, "</th></tr>");
			actionListLen = eventRBListObj.EVENT_PRSNL_LIST.length;
			for (var alIndex = 0;alIndex < actionListLen;alIndex++) {
				actionDtTm = "";
				requestDtTm = "";
				actionListItem = eventRBListObj.EVENT_PRSNL_LIST[alIndex];
				if (actionListItem.ACTION_DT_TM !== invalidDate) {
					actionDtTm = dateFormatter.formatISO8601(actionListItem.ACTION_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
				}
				if (actionListItem.REQUEST_DT_TM !== invalidDate) {
					requestDtTm = dateFormatter.formatISO8601(actionListItem.REQUEST_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);

				}
				provider = MP_Util.GetValueFromArray(actionListItem.ACTION_PRSNL_ID, personnelArray);
				actionProviderName = (provider === null) ? "" : provider.fullName;
				requestedBy = MP_Util.GetValueFromArray(actionListItem.REQUEST_PRSNL_ID, personnelArray);
				requestedByName = (requestedBy === null) ? "" : requestedBy.fullName;
				proxy = MP_Util.GetValueFromArray(actionListItem.PROXY_PRSNL_ID, personnelArray);
				proxyName = (proxy === null) ? "" : proxy.fullName;
				actionListTabHTML.push("<tr><td>", actionListItem.ACTION_TYPE_CD_DISP, "</td><td>", actionProviderName, "</td><td>", actionDtTm ? actionDtTm : emptyCell, "</td><td>", actionListItem.ACTION_STATUS_CD_DISP, "</td><td>", actionListItem.ACTION_COMMENT ? actionListItem.ACTION_COMMENT : emptyCell, "</td><td>", proxyName ? proxyName : emptyCell, "</td><td>", requestedByName ? requestedByName : emptyCell, "</td><td>", requestDtTm ? requestDtTm : emptyCell, "</td><td>", actionListItem.REQUEST_COMMENT ? actionListItem.REQUEST_COMMENT : emptyCell, "</td></tr>");
			}
			actionListTabHTML.push("</table></div></div>");
			return actionListTabHTML.join("");
		},
		buildSpecimenTabHTML : function (eventRBListObj) {
			var specimenTabHTML = [];
			var specimenCollObj = null;
			var specimenCollectedDtTm = "";
			var normalcyClass = MD_resultViewerDialog.GetNormalcyClass(eventRBListObj.NORMALCY_CD_MEAN);
			specimenCollObj = eventRBListObj.SPECIMEN_COLL[0];
			specimenCollectedDtTm = dateFormatter.formatISO8601(specimenCollObj.COLLECT_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
			specimenTabHTML.push("<div class ='resview-specimen-info hidden' id = 'rvSpecimenInfoId'><div class = 'resview-tt'><span><h2 class='resview-resval'><span class = 'resview-resname'>", eventRBListObj.EVENT_CD_DISP, "</span><span><span class='resview-pad ", normalcyClass, "'><span class='res-ind'></span>", eventRBListObj.RESULT_VAL, "</span></span></h2></span></div>");
			specimenTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.SOURCE_TYPE, ":</dd><dd class = 'resview-event-data'>", specimenCollObj.SOURCE_TYPE_CD_DISP, "</dd></dl>");
			specimenTabHTML.push("<dl class = 'resview-event-info'><dd class = 'resview-event-hd'>", resViewModalI18n.COLLECTED_ON, ":</dd><dd class = 'resview-event-data'>", specimenCollectedDtTm, "</dd></dl>");
			specimenTabHTML.push("</div>");
			return specimenTabHTML.join("");
		},
		buildCommentsTabHTML : function (eventRBListObj) {
			var commentsTabHTML = [];
			var noteListItem = null;
			var provider = null;
			var commentProviderName = "";
			commentsTabHTML.push("<div class ='resview-comments-info hidden' id = 'rvCommentsInfoId'>");
			noteListLen = eventRBListObj.EVENT_NOTE_LIST.length;
			for (var noteIndex = 0;
				noteIndex < noteListLen;
				noteIndex++) {
				noteListItem = eventRBListObj.EVENT_NOTE_LIST[noteIndex];
				provider = MP_Util.GetValueFromArray(noteListItem.NOTE_PRSNL_ID, personnelArray);
				commentProviderName = (provider === null) ? "" : provider.fullName;
				commentsTabHTML.push("<div class = 'resview-comment-hd-text'>", noteIndex + 1, ".) " + noteListItem.NOTE_TYPE_CD_DISP, " ", resViewModalI18n.BY, " ", commentProviderName, " ", resViewModalI18n.ON, " ", dateFormatter.formatISO8601(noteListItem.NOTE_DT_TM, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR), "</div>");
				commentsTabHTML.push("<div class = 'resview-comment-text'>", noteListItem.LONG_BLOB_TXT, "</div>");
			}
			return commentsTabHTML.join("");
		},
		renderResultViewer : function (response) {
			var resViewModalBodyHTML = [];
			var resViewModalObject = MP_ModalDialog.retrieveModalDialogObject("resultViewer");
			var resViewModalId = resViewModalObject.getBodyElementId();
			dateFormatter = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			jsonResponse = response.getResponse();
			if (jsonResponse) {
				if (response.getStatus() === "F") {
					MP_Util.LogScriptCallError(null, this, "result_viewer_modal.js", "renderResultViewer");
					MD_resultViewerDialog.alertError(resViewModalI18n.ERROR_RETRIEVE, resViewModalI18n.ERROR_TITLE, resViewModalI18n.OK);
					return;
				}
			}
			personnelArray = MP_Util.LoadPersonelListJSON(jsonResponse.PRSNL);	
			specimenFound = false;
			commentsFound = false;
			if (jsonResponse.RB_LIST[0].SPECIMEN_COLL.length) {
				specimenFound = true;
			}
			if (jsonResponse.RB_LIST[0].EVENT_NOTE_LIST.length) {
				commentsFound = true;
			}
			resViewModalBodyHTML.push("<div class='resview-container'>");
			resViewModalBodyHTML.push(MD_resultViewerDialog.buildEventHistorySectionHTML());
			resViewModalBodyHTML.push(MD_resultViewerDialog.buildEventDetailSectionHTML(jsonResponse.RB_LIST[0]));
			resViewModalBodyHTML.push("</div>");
			$("#resultViewerbody").removeClass("resview-loading");
			$("#" + resViewModalId).html(resViewModalBodyHTML.join(""));
		},
		onTabChange : function (selectedTabObj) {
			var objTabActive = $(selectedTabObj).parent().find(".resview-tab-active");
			if (objTabActive.length) {
				if ($(objTabActive).attr("id") === $(selectedTabObj).attr("id")) {
					return;
				}
				$(objTabActive).empty();
				$(objTabActive).html("<div class='resview-tab-inactive-label'>" + $(objTabActive).attr("tabText") + "</div>");

				objTabActive.removeClass("resview-tab-active");
				objTabActive.addClass("resview-tab-inactive");
				$(objTabActive).next().removeClass("hidden");
				$(objTabActive).prev().removeClass("hidden");
			}
			$(selectedTabObj).removeClass("resview-tab-inactive");
			$(selectedTabObj).next().addClass("hidden");
			$(selectedTabObj).prev().addClass("hidden");
			

			$(selectedTabObj).addClass("resview-tab-active");
			$(selectedTabObj).html("<span class = 'resview-tab-active-left'></span><span class = 'resview-tab-active-center'><span class='resview-tab-active-label'>" + $(selectedTabObj).attr("tabText") + "</span></span><span class = 'resview-tab-active-right'></span>");
			$(selectedTabObj).removeClass("resview-tab-inactive");
			$(selectedTabObj).addClass("resview-tab-active");
		},
		attachListeners : function () {
			$(document).on("click", ".resview-hist-info", function () {
				var objSelRow = $(this).parent().find(".resview-hist-select");
				var objSelRowResInd = $(objSelRow).find(".res-ind").parent();
				var eventRowIndex = $(this).attr("eventRowIndex");
				var eventRBListObj = null;
				var newTabHTML = [];
				if (objSelRow.length) {
					objSelRow.removeClass("resview-hist-select");
					objSelRow.removeClass("resview-wht-text");
					$(objSelRowResInd).removeClass("resview-wht-text");
				}
				$(this).addClass("resview-hist-select");
				$(this).addClass("resview-wht-text");
				$(this).find(".res-high").addClass("resview-wht-text");
				if (objSelRow.attr("eventRowIndex") !== eventRowIndex) {
					eventRBListObj = jsonResponse.RB_LIST[eventRowIndex];
					specimenFound = false;
					commentsFound = false;
					if (eventRBListObj.SPECIMEN_COLL.length) {
						specimenFound = true;
					}
					if (eventRBListObj.EVENT_NOTE_LIST.length) {
						commentsFound = true;
					}
					$("#resViewControls").html(MD_resultViewerDialog.buildTabSectionHTML());
					newTabHTML.push(MD_resultViewerDialog.buildDetailsTabHTML(eventRBListObj));
					newTabHTML.push(MD_resultViewerDialog.buildActionListTabHTML(eventRBListObj));
					if (specimenFound) {
						newTabHTML.push(MD_resultViewerDialog.buildSpecimenTabHTML(eventRBListObj));
					}
					if (commentsFound) {
						newTabHTML.push(MD_resultViewerDialog.buildCommentsTabHTML(eventRBListObj));
					}
					$("#resViewTabBodyId").html(newTabHTML.join(""));
					MD_resultViewerDialog.onTabChange($("#resViewTab1"));
					
				$("#rvDetailsInfoId").removeClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
				}
			});
			$(document).on("click", "#resViewTab1", function () {
				MD_resultViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").removeClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
			});
			$(document).on("click", "#resViewTab2", function () {
				MD_resultViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").removeClass("hidden");
			});
			$(document).on("click", "#resViewTab3", function () {
				MD_resultViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").removeClass("hidden");
				$("#rvCommentsInfoId").addClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
			});
			$(document).on("click", "#resViewTab4", function () {
				MD_resultViewerDialog.onTabChange($(this));
				$("#rvDetailsInfoId").addClass("hidden");
				$("#rvActionListInfoId").addClass("hidden");
				$("#rvCommentsInfoId").removeClass("hidden");
				$("#rvSpecimenInfoId").addClass("hidden");
			});
		}
	};
}
();
/* eslint no-inner-declarations:0, no-unneeded-ternary:0, curly:0, semi-spacing:0, no-warning-comments:0, no-lonely-if:0, no-loop-func:0, mp-camelcase:0, no-use-before-define:0, deprecated-functions:0, linebreak-style:0, valid-jsdoc:0, no-trailing-spaces: 0,no-multi-spaces: 0, no-mixed-spaces-and-tabs: 0, space-before-function-paren: 0, quotes: 0, comma-spacing: 0, object-curly-spacing: 0, array-bracket-spacing: 0, complexity: 0, brace-style: 0, key-spacing: 0, no-unused-vars: 0, new-cap: 0, no-undef: 0 */
var MD_trendingGraphDialog = function () {
	var trendGraphModalI18n = i18n.discernabu.trend_graph_modal;
	var iFrameTrendGraphObj = null;
	return {
		initTrendGraph : function (params) {
			var trendGraphModalObj = MP_ModalDialog.retrieveModalDialogObject("trendGraphModal");
			if (!trendGraphModalObj) {
				trendGraphModalObj = new ModalDialog("trendGraphModal");
				var trendGraphCloseBtn = new ModalButton("trendGraphCloseBtn");
				trendGraphCloseBtn.setText(trendGraphModalI18n.CLOSE).setFocusInd(true).setOnClickFunction(function () {
					MD_trendingGraphDialog.removeTrendGraphIframeObject();
				}).setCloseOnClick(true);
				trendGraphModalObj.setTopMarginPercentage(10).setRightMarginPercentage(9).setBottomMarginPercentage(15).setLeftMarginPercentage(9).setIsBodySizeFixed(false);
				trendGraphModalObj.setHeaderTitle("<span>" + trendGraphModalI18n.RESULT_TREND + "</span>").setHeaderCloseFunction(MD_trendingGraphDialog.removeTrendGraphIframeObject);
			}
			trendGraphModalObj.setBodyDataFunction(function (trendGraphObj) {
				var sendAr = [params];
				trendGraphObj.setBodyHTML(MD_trendingGraphDialog.loadWithCBParameters("mp_retrieve_graph_results", sendAr, MD_trendingGraphDialog.buildGraphHTML));
			});
			trendGraphModalObj.addFooterButton(trendGraphCloseBtn);
			MP_ModalDialog.addModalDialogObject(trendGraphModalObj);
			MP_ModalDialog.showModalDialog("trendGraphModal");
			$("#trendGraphModalbody").addClass("trend-graph-loading");
		},
		loadWithCBParameters : function (programName, params, callback) {
			var request = new MP_Core.ScriptRequest(this, "");
			request.setProgramName(programName);
			request.setParameters(params);
			request.setAsync(true);
			request.setRequiresRawData(true);
			MP_Core.XMLCCLRequestCallBack(null, request, callback);
		},
		buildGraphHTML : function (response) {
			var responseHTML = response.getResponse();
			var iFrameHeight = "100%";
			var iFrameWidth = "98%";
			var graphModalContent = null;
			var docObject = null;
			iFrameTrendGraphObj = document.createElement("iframe");
			iFrameTrendGraphObj.setAttribute("id", "iframeGraph");
			iFrameTrendGraphObj.setAttribute("height", iFrameHeight);
			iFrameTrendGraphObj.setAttribute("width", iFrameWidth);
			iFrameTrendGraphObj.setAttribute("frameborder", 0);
			$("#trendGraphModalbody").html(iFrameTrendGraphObj);
			graphModalContent = iFrameTrendGraphObj.contentWindow;
			docObject = graphModalContent ? graphModalContent.document : null;
			if (docObject) {
				docObject.write(responseHTML);
				docObject.close();
			}
			$("#trendGraphModalbody").removeClass("trend-graph-loading");
			setTimeout(function () {
				$("#iframeGraph").contents().find("#printGraph").remove();
				document.getElementById('iframeGraph').height  = 
					document.getElementById('iframeGraph').contentWindow.document.body.scrollHeight + 80 + "px";
					document.getElementById("iframeGraph").width = 
					document.getElementById("iframeGraph").contentWindow.document.body.scrollWidth + 100 + "px";
			    $("#trendGraphModalbody").removeClass("trend-graph-loading");
			}, 1100);
		},
		removeTrendGraphIframeObject : function () {
			$(iFrameTrendGraphObj).remove();
		}
	};
}
();
/* eslint no-inner-declarations:0, no-unneeded-ternary:0, curly:0, semi-spacing:0, no-warning-comments:0, no-lonely-if:0, no-loop-func:0, mp-camelcase:0, no-use-before-define:0, deprecated-functions:0, linebreak-style:0, valid-jsdoc:0, no-trailing-spaces: 0,no-multi-spaces: 0, no-mixed-spaces-and-tabs: 0, space-before-function-paren: 0, quotes: 0, comma-spacing: 0, object-curly-spacing: 0, array-bracket-spacing: 0, complexity: 0, brace-style: 0, key-spacing: 0, no-unused-vars: 0, new-cap: 0, no-undef: 0 */
var MP_VisitDetailDialog = function () {
	var visitDetailModalI18n = i18n.discernabu.visit_detail_modal;
	var jsonResponse = null;
	var VisitsDetailTabsIndex = {
		SUMMARY : 0,
		INSURANCE : 1,
		GUARANTOR : 2
	};
	var currentPage = VisitsDetailTabsIndex.SUMMARY;
	var tabNames = [];
	var secHPFlag = false;
	var terHPFlag = false;
	var secGuaFlag = false;
	var terGuaFlag = false;
	return {
		initVisitViewer : function (patient_Id, encntr_Id, provider_Id, pos_cd, visitDate) {			
			var visitLoading = [];
			var closebtn = visitDetailModalI18n.CLOSE;
			patient_Id = patient_Id + ".0";
			encntr_Id = encntr_Id + ".0";
			provider_Id = provider_Id + ".0";
			pos_cd = pos_cd + ".0";
			var encntrInd = 0;
			var visitModalDialog = MP_ModalDialog.retrieveModalDialogObject("visitModalDialog");
			if (!visitModalDialog) {
				visitModalDialog = new ModalDialog("visitModalDialog");
				visitModalDialog.setTopMarginPercentage(10).setRightMarginPercentage(30).setBottomMarginPercentage(5).setLeftMarginPercentage(30).setIsBodySizeFixed(false);
				visitModalDialog.setHeaderCloseFunction();
				visitModalDialog.setHeaderTitle("<span class='visitswindow-title'>" + visitDetailModalI18n.VISIT_DETAIL + "</span>");
				var visitViewerCloseBtn = new ModalButton("visitViewerCloseBtn");
				visitViewerCloseBtn.setText(closebtn);
				visitViewerCloseBtn.setFocusInd(true);
				visitModalDialog.addFooterButton(visitViewerCloseBtn);
				MP_ModalDialog.addModalDialogObject(visitModalDialog);
			}			
			visitModalDialog.setBodyDataFunction(function (visitViewDlg) {
				var cclParams = [];
				cclParams.push("^MINE^", patient_Id, provider_Id, pos_cd, encntrInd, "^" + visitDate + "^");
				MP_VisitDetailDialog.loadWithCBParameters("mp_get_visit_detail_data", cclParams, MP_VisitDetailDialog.renderVisitDetail);
			});
			MP_ModalDialog.updateModalDialogObject(visitModalDialog);
			MP_ModalDialog.showModalDialog(visitModalDialog.getId());
			visitLoading.push("<div class='visits-body-loading'><span class='visits-loading'></span></div>");
			visitModalDialog.setBodyHTML(visitLoading.join(""));
			$("#visitModalDialogbody").css("overflow", "hidden");			
		},
		
		loadWithCBParameters : function (programName, cclParams, callBack) {
			try {
				var request = new MP_Core.ScriptRequest(this);
				request.setProgramName(programName);
				request.setParameters(cclParams);
				request.setAsync(true);
				MP_Core.XMLCCLRequestCallBack(null, request, callBack);
			} catch (err) {
				MP_Util.LogScriptCallError(null, this, "visit_detail_modal.js", "loadWithCBParameters");
			}
		},
		renderVisitDetail : function (response) {
			try {
				var visitDetailModalBodyHTML = [];
				var visitDetailModalObject = MP_ModalDialog.retrieveModalDialogObject("visitModalDialog");
				var visitDetailModalId = visitDetailModalObject.getBodyElementId();
				var summaryTab = visitDetailModalI18n.SUMMARY;
				var insuranceTab = visitDetailModalI18n.INSURANCE;
				var guarantorTab = visitDetailModalI18n.GUARANTOR;
				jsonResponse = response.getResponse();
				if (jsonResponse) {
					if (response.getStatus() === "F") {
						MP_Util.LogScriptCallError(null, this, "visit_detail_modal.js", "renderVisitDetail");
						return;
					}
				}
				tabNames[VisitsDetailTabsIndex.SUMMARY] = summaryTab;
				tabNames[VisitsDetailTabsIndex.INSURANCE] = insuranceTab;
				tabNames[VisitsDetailTabsIndex.GUARANTOR] = guarantorTab;
				visitDetailModalBodyHTML.push(MP_VisitDetailDialog.switchTab(currentPage));
				visitDetailModalObject.setBodyHTML(visitDetailModalBodyHTML.join(""));
				var allTabs = "#tabContainer .reachview-tabs ul li";
				$(allTabs).eq(currentPage).addClass("reachview-tab-active-header");
				$(allTabs).on("click", function () {
					var $activeTab = $(this.parentElement).find(".reachview-tab-active-header");
					var activeTabId = $activeTab.attr("id");
					var curTabId = this.id;
					$activeTab.removeClass("reachview-tab-active-header");
					$("#tab-sec-" + activeTabId.charAt(activeTabId.length - 1)).hide();
					$(this).addClass("reachview-tab-active-header");
					$("#curTabId").show();
					var visitModalDialogBodyObj = $("#visitModalDialogbody");
					if (curTabId === "tabHeader_0") {
						visitModalDialogBodyObj.find(".visit-summary-tab-container").show();
						visitModalDialogBodyObj.find(".visit-insurance-tab-container").hide();
						visitModalDialogBodyObj.find(".visit-guarantor-tab-container").hide();
					} else {
						if (curTabId === "tabHeader_1") {
							if (secHPFlag === true) {
								visitModalDialogBodyObj.find("#secondaryIns").removeClass("visit-disp-none");
							}
							if (terHPFlag === true) {
								visitModalDialogBodyObj.find("#tertiaryIns").removeClass("visit-disp-none");
							}
							visitModalDialogBodyObj.find(".visit-insurance-tab-container").show();
							visitModalDialogBodyObj.find(".visit-summary-tab-container").hide();
							visitModalDialogBodyObj.find(".visit-guarantor-tab-container").hide();
						} else {
							if (curTabId === "tabHeader_2") {
								if (secGuaFlag === true) {
									visitModalDialogBodyObj.find("#secondaryGua").removeClass("visit-disp-none");
								}
								if (terGuaFlag === true) {
									visitModalDialogBodyObj.find("#tertiaryGua").removeClass("visit-disp-none");
								}
								visitModalDialogBodyObj.find(".visit-guarantor-tab-container").show();
								visitModalDialogBodyObj.find(".visit-summary-tab-container").hide();
								visitModalDialogBodyObj.find(".visit-insurance-tab-container").hide();
							}
						}
					}
				});
			} catch (err) {
				MP_Util.LogScriptCallError(null, this, "visit_detail_modal.js", "renderVisitDetail");
			}
		},
		switchTab : function (tabIndex) {
			try {
				var emptyData = "--";
				var encntrFin = jsonResponse.FIN;
				var encntrlocation = emptyData;
				var encntrOrg = emptyData;
				var encntrRegDt = emptyData;
				var encntrDischDt = emptyData;
				var encntrMedSer = emptyData;
				var admitProvider = emptyData;
				var attendProvider = emptyData;
				var primaryHealthPlan = emptyData;
				var primaryPolicy = emptyData;
				var primaryGuaName = emptyData;
				var primaryMemberNum = emptyData;
				var primaryType = emptyData;
				var primaryGroupNum = emptyData;
				var primaryFinClass = emptyData;
				var secHealthPlan = "";
				var secPolicy = "";
				var secGuaName = "";
				var secMemberNum = "";
				var secType = "";
				var secGroupNum = "";
				var secFinClass = "";
				var terHealthPlan = "";
				var terPolicy = "";
				var terGuaName = "";
				var terMemberNum = "";
				var terType = "";
				var terGroupNum = "";
				var terFinClass = "";
				var priPhonetest = emptyData;
				var priRltnspToPat = emptyData;

				var secPhonetest = "";
				var secRltnspToPat = "";

				var terPhonetest = "";
				var terRltnspToPat = "";
				var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
				var encntrHPLen = jsonResponse.HP_LIST.length;
				var encntrGuaLen = jsonResponse.GUARANTOR.length;
				var encounterSummary = jsonResponse.E_LIST[0];
				var encounterPriHPList = jsonResponse.HP_LIST[0];
				var encounterSecHPList = jsonResponse.HP_LIST[1];
				var encounterTerHPList = jsonResponse.HP_LIST[2];
				var encounterPriGuaList = jsonResponse.GUARANTOR[0];
				var encounterSecGuaList = jsonResponse.GUARANTOR[1];
				var encounterTerGuaList = jsonResponse.GUARANTOR[2];
				var addressListLen = "";
				var phoneListLen = "";
				var priAddHtml = [];
				var secAddHtml = [];
				var terAddHtml = [];
				var priPhoneHtml = [];
				var secPhoneHtml = [];
				var terPhoneHtml = [];
				secHPFlag = false;
				terHPFlag = false;
				secGuaFlag = false;
				terGuaFlag = false;
				priAddHtml = emptyData;
				priPhoneHtml = emptyData;
				if (jsonResponse.E_LIST.length > 0) {
					encntrRegDt = (encounterSummary.REG_DATE !== "") ? df.formatISO8601(encounterSummary.REG_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR) : emptyData;
					encntrDischDt = (encounterSummary.DISCH_DATE !== "") ? df.formatISO8601(encounterSummary.DISCH_DATE, mp_formatter.DateTimeFormatter.FULL_DATE_2YEAR) : emptyData;
					encntrlocation = (encounterSummary.LOCATION !== "") ? encounterSummary.LOCATION : emptyData;
					encntrOrg = (encounterSummary.ORG_NAME !== "") ? encounterSummary.ORG_NAME : emptyData;
					encntrMedSer = (encounterSummary.MED_SERVICE !== "") ? encounterSummary.MED_SERVICE : emptyData;
					admitProvider = (encounterSummary.ADMITTING_PROVIDER !== "") ? encounterSummary.ADMITTING_PROVIDER : emptyData;
					attendProvider = (encounterSummary.ATTENDING_PROVIDER !== "") ? encounterSummary.ATTENDING_PROVIDER : emptyData;
				}
				if (encntrHPLen > 0) {
					for (var h = 0;
						h < encntrHPLen;
						h++) {
						if (h === 0) {
							primaryHealthPlan = (encounterPriHPList.NAME !== "") ? encounterPriHPList.NAME : emptyData;
							primaryPolicy = (encounterPriHPList.POLICY_NUM !== "") ? encounterPriHPList.POLICY_NUM : emptyData;
							primaryMemberNum = (encounterPriHPList.MEMBER_NUM !== "") ? encounterPriHPList.MEMBER_NUM : emptyData;
							primaryType = (encounterPriHPList.TYPE !== "") ? encounterPriHPList.TYPE : emptyData;
							primaryGroupNum = (encounterPriHPList.GROUP_NUM !== "") ? encounterPriHPList.GROUP_NUM : emptyData;
							primaryFinClass = (encounterPriHPList.FIN_CLASS !== "") ? encounterPriHPList.FIN_CLASS : emptyData;
						}
						if (h === 1) {
							secHealthPlan = (encounterSecHPList.NAME !== "") ? encounterSecHPList.NAME : emptyData;
							secPolicy = (encounterSecHPList.POLICY_NUM !== "") ? encounterSecHPList.POLICY_NUM : emptyData;
							secMemberNum = (encounterSecHPList.MEMBER_NUM !== "") ? encounterSecHPList.MEMBER_NUM : emptyData;
							secType = (encounterSecHPList.TYPE !== "") ? encounterSecHPList.TYPE : emptyData;
							secGroupNum = (encounterSecHPList.GROUP_NUM !== "") ? encounterSecHPList.GROUP_NUM : emptyData;
							secFinClass = (encounterSecHPList.FIN_CLASS !== "") ? encounterSecHPList.FIN_CLASS : emptyData;
							secHPFlag = true;
						}
						if (h === 2) {
							terHealthPlan = (encounterTerHPList.NAME !== "") ? encounterTerHPList.NAME : emptyData;
							terPolicy = (encounterTerHPList.POLICY_NUM !== "") ? encounterTerHPList.POLICY_NUM : emptyData;
							terMemberNum = (encounterTerHPList.MEMBER_NUM !== "") ? encounterTerHPList.MEMBER_NUM : emptyData;
							terType = (encounterTerHPList.TYPE !== "") ? encounterTerHPList.TYPE : emptyData;
							terGroupNum = (encounterTerHPList.GROUP_NUM !== "") ? encounterTerHPList.GROUP_NUM : emptyData;
							terFinClass = (encounterTerHPList.FIN_CLASS !== "") ? encounterTerHPList.FIN_CLASS : emptyData;
							terHPFlag = true;
						}
					}
				}
				if (encntrGuaLen > 0) {
					for (var g = 0;
						g < encntrGuaLen;
						g++) {
						if (g === 0) {
							primaryGuaName = (encounterPriGuaList.NAME !== "") ? encounterPriGuaList.NAME : emptyData;
							priRltnspToPat = (encounterPriGuaList.TYPE !== "") ? encounterPriGuaList.TYPE : emptyData;
							addressListLen = jsonResponse.GUARANTOR[g].ADDRESS_LIST.length;
							phoneListLen = jsonResponse.GUARANTOR[g].PHONE_LIST.length;
							var priAddress = (addressListLen > 0) ? jsonResponse.GUARANTOR[g].ADDRESS_LIST : "";
							priAddHtml = "";
							if (priAddress !== "") {
								for (var ap = 0;
									ap < addressListLen;
									ap++) {
									priAddHtml += "<span>" + priAddress[ap].LINE1 + "</span></br><span>" + priAddress[ap].LINE2 + "</span></br>";
								}
							} else {
								priAddHtml = emptyData;
							}
							var priPhone = (phoneListLen > 0) ? jsonResponse.GUARANTOR[g].PHONE_LIST : "";
							priPhoneHtml = "";
							if (priPhone !== "") {
								for (var pp = 0;
									pp < phoneListLen;
									pp++) {
									priPhoneHtml += "<span>" + priPhone[pp].NUMBER + "</span></br>";
								}
							} else {
								priPhoneHtml = emptyData;
							}
						}
						if (g === 1) {
							secGuaFlag = true;
							secGuaName = (encounterSecGuaList.NAME !== "") ? encounterSecGuaList.NAME : emptyData;
							secRltnspToPat = (encounterSecGuaList.TYPE !== "") ? encounterSecGuaList.TYPE : emptyData;
							addressListLen = jsonResponse.GUARANTOR[1].ADDRESS_LIST.length;
							phoneListLen = jsonResponse.GUARANTOR[1].PHONE_LIST.length;
							var secAddress = (addressListLen > 0) ? jsonResponse.GUARANTOR[g].ADDRESS_LIST : "";
							secAddHtml = "";
							if (secAddress !== "") {
								for (var as = 0;
									as < addressListLen;
									as++) {
									secAddHtml += "<span class='visit-gua-address'>" + secAddress[as].LINE1 + "</span></br><span class='visit-gua-address'>" + secAddress[as].LINE2 + "</span></br>";
								}
							} else {
								secAddHtml = emptyData;
							}
							var secPhone = (phoneListLen > 0) ? jsonResponse.GUARANTOR[g].PHONE_LIST : "";
							secPhoneHtml = "";
							if (secPhone !== "") {
								for (var ps = 0;
									ps < phoneListLen;
									ps++) {
									secPhoneHtml += "<span>" + secPhone[ps].NUMBER + "</span></br>";
								}
							} else {
								secPhoneHtml = emptyData;
							}
						}
						if (g === 2) {
							terGuaFlag = true;
							terGuaName = (encounterTerGuaList.NAME !== "") ? encounterTerGuaList.NAME : emptyData;
							terRltnspToPat = (encounterTerGuaList.TYPE !== "") ? encounterTerGuaList.TYPE : emptyData;
							addressListLen = jsonResponse.GUARANTOR[2].ADDRESS_LIST.length;
							phoneListLen = jsonResponse.GUARANTOR[2].PHONE_LIST.length;
							var terAddress = (addressListLen > 0) ? jsonResponse.GUARANTOR[g].ADDRESS_LIST : "";
							terAddHtml = "";
							if (terAddress !== "") {
								for (var at = 0;
									at < addressListLen;
									at++) {
									terAddHtml += "<span>" + terAddress[at].LINE1 + "</span></br><span>" + terAddress[at].LINE2 + "</span></br>";
								}
							} else {
								terAddHtml = emptyData;
							}
							var terPhone = (phoneListLen > 0) ? jsonResponse.GUARANTOR[g].PHONE_LIST : "";
							terPhoneHtml = "";
							if (terPhone !== "") {
								for (var pt = 0;
									pt < phoneListLen;
									pt++) {
									terPhoneHtml += "<span>" + terPhone[pt].NUMBER + "</span></br>";
								}
							} else {
								terPhoneHtml = emptyData;
							}
						}
					}
				}
				var htmlArray = ['<div class="reachview-tab-container" id="tabContainer"><div class="reachview-tabs"><ul>'];
				var numTabs = tabNames.length;
				if (typeof tabIndex === "number") {
					currentPage = tabIndex;
				} else {
					tabIndex = currentPage;
				}
				var i;
				var iTabName,
				iCount;
				for (i = 0;
					i < numTabs;
					i++) {
					iTabName = tabNames[i];
					htmlArray.push('<li id="tabHeader_', i, '"><span class="reachview-tab-left-edge">&nbsp;</span><span class="reachview-tab-text">', iTabName, '</span><span class="reachview-tab-right-edge">&nbsp;</span></li>');
				}
				htmlArray.push('</ul></div><hr /><div class="visit-tabs-content">');
				var visitDiagLen = jsonResponse.DIAG.length;
				var visitDiags = (visitDiagLen > 0) ? jsonResponse.DIAG : "";
				var visitDiagHtml = "";
				if (visitDiags !== "") {
					for (var d = 0;
						d < visitDiagLen;
						d++) {
						visitDiagHtml += "<span>" + visitDiags[d].TEXT + "&nbsp</span><span class='visit-diag-code'>(" + visitDiags[d].CODE + ")</span><br>";
					}
				} else {
					visitDiagHtml = emptyData;
				}
				htmlArray.push("<div class='tabs'><ul><li id='tab1'></li><li id='tab2'></li><li id='tab3'></li></ul></div><div class='visit-summary-tab-container' id='tab-sec-1'><dl class='visit-smry-data'><dt class='visit-res-type'></dt><dd class='visit-smry-value'></dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.FIN + "&nbsp</dt><dd class='visit-smry-value'>" + encntrFin + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.REG_DATE + "&nbsp</dt><dd class='visit-smry-value'>" + encntrRegDt + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.DISCH_DATE + "&nbsp</dt><dd class='visit-smry-value'>" + encntrDischDt + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.LOCATION + "&nbsp</dt><dd class='visit-smry-value'>" + encntrlocation + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.ORG_NAME + "&nbsp</dt><dd class='visit-smry-value'>" + encntrOrg + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.MED_SER + "&nbsp</dt><dd class='visit-smry-value'>" + encntrMedSer + "</dd></dl><dl class='visit-smry-separator'></dl><dl class='visit-smry-empty'></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.ADMIT_PROVIDER + "&nbsp</dt><dd class='visit-smry-value'>" + admitProvider + "</dd></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.ATTEND_PROVIDER + "&nbsp</dt><dd class='visit-smry-value'>" + attendProvider + "</dd></dl><dl class='visit-smry-separator'></dl><dl class='visit-smry-empty'></dl><dl class='visit-smry-data'><dt class='visit-res-type'>" + visitDetailModalI18n.VISIT_DIAG + "&nbsp</dt><dd class='visit-smry-value'>" + visitDiagHtml + "</dd></dl></div><div class='visit-insurance-tab-container' id='tab-sec-2'><div class='visit-hp-primary' id='primaryIns'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.PRIMARY + "&nbsp</span></h2></span><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.HEALTH_PLAN + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryHealthPlan + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.POLICY + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryPolicy + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GUARANTOR_NAME + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryGuaName + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.MEMBER + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryMemberNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.TYPE + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryType + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GROUP + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryGroupNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.FIN_CLASS + "&nbsp</dt><dd class='visit-ins-hp-value'>" + primaryFinClass + "</dd></dl></div><div class='visit-disp-none' id='secondaryIns'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.SECONDARY + "&nbsp</span></h2></span><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.HEALTH_PLAN + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secHealthPlan + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.POLICY + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secPolicy + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GUARANTOR_NAME + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secGuaName + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.MEMBER + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secMemberNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.TYPE + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secType + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GROUP + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secGroupNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.FIN_CLASS + "&nbsp</dt><dd class='visit-ins-hp-value'>" + secFinClass + "</dd></dl></div><div class='visit-disp-none' id='tertiaryIns'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.TERTIARY + "&nbsp</span></h2></span><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.HEALTH_PLAN + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terHealthPlan + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.POLICY + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terPolicy + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GUARANTOR_NAME + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terGuaName + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.MEMBER + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terMemberNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.TYPE + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terType + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.GROUP + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terGroupNum + "</dd></dl><dl class='visit-ins-hp-data'><dt class='visit-res-hp-type'>" + visitDetailModalI18n.FIN_CLASS + "&nbsp</dt><dd class='visit-ins-hp-value'>" + terFinClass + "</dd></dl></div></div><div class='visit-guarantor-tab-container' id='tab-sec-3'><div class='visit-gr-primary' id='primaryGua'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.PRIMARY + "&nbsp</span></h2></span><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.NAME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + primaryGuaName + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.ADDRESS + "&nbsp</dt><dd class='visit-ins-gua-value'>" + priAddHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.PHONE_HOME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + priPhoneHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-gua-rp-type'>" + visitDetailModalI18n.REL_TO_PAT + "&nbsp</dt><dd class='visit-gua-rp-value'>" + priRltnspToPat + "</dd></dl></div><div class='visit-disp-none' id='secondaryGua'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.SECONDARY + "&nbsp</span></h2></span><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.NAME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + secGuaName + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.ADDRESS + "&nbsp</dt><dd class='visit-ins-gua-value'>" + secAddHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.PHONE_HOME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + secPhoneHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-gua-rp-type'>" + visitDetailModalI18n.REL_TO_PAT + "&nbsp</dt><dd class='visit-gua-rp-value'>" + secRltnspToPat + "</dd></dl></div><div class='visit-disp-none' id='tertiaryGua'><span><h2 class='visit-ins-line'><span class='visit-ins-res-type'>" + visitDetailModalI18n.TERTIARY + "&nbsp</span></h2></span><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.NAME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + terGuaName + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.ADDRESS + "&nbsp</dt><dd class='visit-ins-gua-value'>" + terAddHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-res-gua-type'>" + visitDetailModalI18n.PHONE_HOME + "&nbsp</dt><dd class='visit-ins-gua-value'>" + terPhoneHtml + "</dd></dl><dl class='visit-ins-gua-data'><dt class='visit-gua-rp-type'>" + visitDetailModalI18n.REL_TO_PAT + "&nbsp</dt><dd class='visit-gua-rp-value'>" + terRltnspToPat + "</dd></dl></div></div>");
				htmlArray.push("</div></div>");
				var hxHTML = htmlArray.join("");
				return hxHTML;
			} catch (err) {
				MP_Util.LogJSError(err, this, "visit_detail_modal.js", "switchTab");
			}
		}
	};
}
();

/**
 * The StructureOrganizerBuilder class.
 * @constructor
 * @author Will Reynolds
 * @description This class is used to help construct StructureOrganizer objects as the process is very complex. It
 * benefits by separating the construction logic from the StructureOrganizer object itself.
 */
function StructureOrganizerBuilder() {
    this.m_structureOrganizer = null;                 //The StructureOrganizer object being constructed.
    this.m_nodeCount = 0;                             //The number of nodes that belong to the StructureOrganizer object.
    this.m_namespace = "";                            //A DOM namespace for the StructureOrganizer object.
}

/**
 * Get the namespace used when constructing the StructureOrganizer object.
 * @return {string} the namespace for the StructureOrganizer objects being created.
 */
StructureOrganizerBuilder.prototype.getNamespace = function() {
    return this.m_namespace;
};

/**
 * Sets the namespace used when constructing the StructureOrganizer object. This namespace must be unique as it
 * will provide the objects with a unique DOM id.
 * @param namespace the namespace to be used when constructing the StructureOrganizer object.
 */
StructureOrganizerBuilder.prototype.setNamespace = function(namespace) {
	if(typeof namespace !== "string") {
		throw new Error("Attempted to call StructureOrganizerBuilder.prototype.setNamespace with invalid parameter.");
	}
    this.m_namespace = namespace;
	return this;
};

/**
 * Gets the node count for the StructureOrganizer object.
 * @return {number} the number of nodes in the StructureOrganizer object.
 */
StructureOrganizerBuilder.prototype.getNodeCount = function(){
    return this.m_nodeCount;
};

/**
 * Sets the node count for the StructureOrganizer object.
 * @param nodeCount the number of nodes belonging to the StructureOrganizer object.
 */
StructureOrganizerBuilder.prototype.setNodeCount = function(nodeCount) {
    if(typeof nodeCount !== "number") {
        throw new Error("Attempted to call StructureOrganizerBuilder.prototype.setNodeCount with invalid parameter.");
    }
    this.m_nodeCount = nodeCount;
	return this;
};

/**
 * Gets the StructureOrganizer object that has been constructed. Note that this method must be called after
 * the construct method has been called.
 * @return {StructureOrganizer} the StructureOrganizer object that was built.
 */
StructureOrganizerBuilder.prototype.getStructureOrganizer = function () {
    return this.m_structureOrganizer;
};

/**
 * Starts a new instance of a StructureOrganizer object. This method must be called before beginning construction
 * of a StructureOrganizer object.
 */
StructureOrganizerBuilder.prototype.startNewStructureOrganizer = function () {
    this.m_structureOrganizer = new StructureOrganizer();
    this.m_structureOrganizer.setNamespace(this.getNamespace());
    this.m_structureOrganizer.setId(""+this.m_nodeCount++);
};

/**
 * Interface method for building the navigator object.
 */
StructureOrganizerBuilder.prototype.buildNavigator = function() {
	throw new Error("Attempted to call StructureOrganizerBuilder.prototype.buildNavigator. This function must be implemented by a sub-class");
};

/**
 * The JSONStructureOrganizerBuilder class.
 * @constructor
 * @description This class extends the StructureOrganizerBuilder class. This class specifically uses JSON to create
 * the StructureOrganizer system.
 */
function JSONStructureOrganizerBuilder() {
    this.m_structureJSON = null;                      //The JSON being used to create the StructureOrganizer object.
}
JSONStructureOrganizerBuilder.prototype = new StructureOrganizerBuilder();
JSONStructureOrganizerBuilder.prototype.constructor = StructureOrganizerBuilder;

/**
 * Gets the JSON being used to construct the StructureOrganizer object.
 * @return {Object} the JSON being used to construct the StructureOrganizer object.
 */
JSONStructureOrganizerBuilder.prototype.getStructureJSON = function () {
    return this.m_structureJSON;
};

/**
 * Sets the JSON being used to construct the StructureOrganizer object.
 * @param structureJSON the JSON being used to construct the StructureOrganizer object.
 */
JSONStructureOrganizerBuilder.prototype.setStructureJSON = function (structureJSON) {
    this.m_structureJSON = structureJSON;
	return this;
};

/**
 * Constructs a structured documentation tree data structure based on the JSON that was retrieved by the
 * dynamic documentation services. It first constructs a root (SECTION -> StructureOrganizer) node, then parses
 * through the JSON, building the necessary objects and adding them to the tree.
 * @returns {StructureOrganizer} The root structured documentation node.
 */
JSONStructureOrganizerBuilder.prototype.buildStructureTree = function() {
    this.m_nodeCount = 0;
    var structureJSON = this.m_structureJSON;
    var root = new StructureOrganizer();
    this.m_structureOrganizer = root;
    root.setTemplateRelations(structureJSON.template_rltns);
    root.setReferenceSectionId(structureJSON.dd_sref_section_id);
    root.setNamespace(this.getNamespace());
    root.setId(""+this.m_nodeCount++);
    root.setOrganizer(root);
    this.traverse(structureJSON, root);
    this.handleMultiSectionStructure();
    //Only build the navigator for the root if it is not a multi-section tree.
    if(!root.isMultiSection()) {
        root.setNavigator(this.buildNavigatorForSection(root));
    }
    return root;
};

/**
 * Helper function that handles the possibility of a structure tree containing multiple sections (subsections). When
 * this occurs, a flag is set indicating that the root section is a multi-section tree. Additionally, a navigator
 * is built for each sub-section. The first subsection is set as the active section of the root.
 */
JSONStructureOrganizerBuilder.prototype.handleMultiSectionStructure = function() {
    var root = this.m_structureOrganizer;
    var children = root.getChildren();
    var childrenCount = children.length;
    var child = null;
    for(var i = 0; i < childrenCount; i++) {
        child = children[i];
        if(StructureOrganizer.prototype.isPrototypeOf(child)) {
            //You have multiple sections
            root.setIsMultiSection(true);
            child.setNavigator(this.buildNavigatorForSection(child));
            //Keep track of the active section (it starts as the first section).
            if(!root.m_activeSection) {
                root.setActiveSection(child);
            }
        }
    }
};

/**
 * Constructs a structured documentation navigator for the provided section (StructureOrganizer) node.
 * @param {StructureOrganizer} section - The section for which a navigator object will be constructed.
 * @returns {Navigator} The navigator that was constructed for the provided section.
 */
JSONStructureOrganizerBuilder.prototype.buildNavigatorForSection = function(section) {
    var navigator = new Navigator();
    navigator.setId(this.getNamespace() + ":structureNavigator:" + section.getId());
    var groups = section.getChildren();
    var group = null;
    var groupCount = groups.length;
    var namespace = this.m_namespace;
    for(var i = 0; i < groupCount; i++) {
        group = groups[i];
        var navigation = new StructureNavigation();
        navigation.setContainerId(namespace + ":organizer:CONTENT:" + section.getId());
        navigation.setAnchorId(namespace + ":group:ROOT:" + group.getId());
        navigation.setLabel(group.getTitle().replace(":", ""));
        navigation.setId(namespace + ":structureNavigation:" + group.getId());
        navigation.setNode(group);
        navigator.addNavigation(navigation);
    }
    return navigator;
};

/**
 * Builds the navigator object that represents the navigation section of the structured documentation view.
 * 
 * @returns {Navigator} navigator object that represents the navigation section
 */
JSONStructureOrganizerBuilder.prototype.buildNavigator = function() {
	var navigator = new Navigator();
	navigator.setId(this.getNamespace()+":structureNavigator");
	var groups = this.m_structureOrganizer.getChildren();
	var group = null;
	var groupCount = groups.length;
	for(var i = 0; i < groupCount; i++) {
		group = groups[i];
		var navigation = new StructureNavigation();
		navigation.setContainerId(this.getNamespace() + ":organizer:CONTENT:" + this.m_structureOrganizer.getId());
		navigation.setAnchorId(this.getNamespace() + ":group:ROOT:" + group.getId());
		navigation.setLabel(group.getTitle().replace(":", ""));
		navigation.setId(this.getNamespace()+":structureNavigation:"+group.getId());
		navigator.addNavigation(navigation);
	}
	return navigator;
};



/**
 * This is a recursive method that traverses the structure JSON, creating the associated JavaScript objects and
 * creating the necessary tree structure.
 * @param node the JSON node we are processing.
 * @param owner The parent JavaScript object is passed down a level of recursion so the new nodes can be correctly
 * added to their corresponding parent.
 */
JSONStructureOrganizerBuilder.prototype.traverse = function (node, owner) {
    var child;
    //We don't care about non-object types, so skip them.
    if (!(node instanceof Object)) {
        return;
    }
    //Go through the child JSON nodes
    for (child in node) {
        //If this is a valid node.
        if (node.hasOwnProperty(child)) {
            //Skip any non-object JSON nodes.
            if (!(node[child] instanceof  Object)) {
                continue;
            }
            //If we found an array, go through each item, processing it accordingly
            if (Array.prototype.isPrototypeOf(node[child])) {
                var childArr = node[child];
                for (var i = 0; i < childArr.length; i++) {
                    //Create a node based on the JSON
                    var structureNode = this.buildNode(child, childArr[i], owner);
                    
                    	// Check if the child node has items to expand.
					if (child === "attribute_menu_items" && (childArr[i].ui_type === "EXPAND" || childArr[i].ui_type === "TABLE")) {
						// Extract the matching children.
						this.extractMatchingChildren(childArr, i);
					}
                    //Go a level deeper, using the newly created structureNode as the new owner.
                    this.traverse(childArr[i], structureNode);
                }
            } else {
                //If we didn't find an array, just go down a level deeper, passing through the owner.
                this.traverse(node[child], owner);
            }
        }
    }
};

/**
 * This function extracts the children by CHILD_LABELID and add it to the node which has the same LABELID.
 * @param attrMenuItems - parent of the node which contains the attribute menu items
 * @param index - current node's index  in attrMenuItems.
 */
JSONStructureOrganizerBuilder.prototype.extractMatchingChildren = function(attrMenuItems, index) {
    var childIndex = 0;
    var node = attrMenuItems[index];
    var totalItems = attrMenuItems.length;
    // Iterate through the attribute items. Start validating from the next node from current node.
    for (var i = index + 1; i < totalItems; i++) {
        // Check if the node has children with same labelId and group all child nodes together.
        var attrMenuItem = attrMenuItems[i];
        if (node.label_id && attrMenuItem.child_label_id && (node.label_id === attrMenuItem.child_label_id)) {
            
            // The child node may have children, so recursively validate and group them.
            if(attrMenuItem.label_id){
                totalItems = this.extractMatchingChildren(attrMenuItems, i);
            }

            // The node has children, so initialize "attribute_menu_items".
            if ( typeof node.attribute_menu_items === "undefined") {
                node.attribute_menu_items = [];
            }
            //Add matched children into "attribute_menu_items".
            node.attribute_menu_items[childIndex++] = attrMenuItem;
            //Remove matched children from the attrMenuItems
            attrMenuItems.splice(i, 1);
            totalItems--;
            i--;
        }
    }
    return totalItems;
}; 

/**
 * A big nasty builder method that creates JavaScript structure objects based on their node type.
 * @param nodeType the type of node.
 * @param nodeJSON the corresponding node JSON.
 * @param owner the parent of this new StructureNode object.
 * @return {StructureNode} the newly created StructureNode.
 */
JSONStructureOrganizerBuilder.prototype.buildNode = function(nodeType, nodeJSON, owner) {
    var node = null;
    if(nodeType === "subsections") {
        node = new StructureOrganizer();
        node.setReferenceSectionId(nodeJSON.dd_sref_section_id);
        node.setTemplateRelations(nodeJSON.template_rltns);
    } else if(nodeType === "groupbys") {
        node = new StructureGroup();
    } else if(nodeType === "subgroupbys") {
        node = new StructureSubGroup();
    } else if(nodeType === "items") {
        node = new StructureItemGroup();
    } else if(nodeType === "attributes") {
        node = this.buildStructureTermGroupNode(nodeJSON);
    } else if(nodeType === "attribute_menu_items") {
        if(nodeJSON.user_input) {
            if(nodeJSON.ui_type === "FREE_TEXT") {
                node = this.buildFreeTextNode(nodeJSON);
            } else {
                node = this.buildInputNode(nodeJSON);
            }
        } else {
            if(nodeJSON.ui_type ==="LINE") {
                node = new LineStructureTerm();
            } else if(nodeJSON.ui_type ==="EXPAND") {
            	node =  new ExpandStructureTermGroup();
            	this.addNormality(node, nodeJSON);
            } else if(nodeJSON.ui_type ==="TABLE") {
                node = this.buildTableStructureTermGroupNode(nodeJSON);
            } else {
                node = this.buildCycleNode(nodeJSON, owner);
            }
        }
        node.setCaption(nodeJSON.caption || "");
        node.setDisplayPosition(nodeJSON.display_seq);
        node.setUIValue(nodeJSON.ui_value);
        node.setPriority(nodeJSON.priority);
    } else {
        // the traverse function checks every attribute on the JSON
        // so there will be times where it will be called on something that doesn't
        // translate into a node that can be built, like "CODE"
        return null;
    }
    //Set the display flag for the node
    if(typeof nodeJSON.displayflag !== "undefined") {
        node.setShouldRender(nodeJSON.displayflag ? true : false);
    }
    //Give the node the namespace so it will have a unique DOM existence
    node.setNamespace(this.getNamespace());
    //Set the OCID for the node if it has one, otherwise it's null
    //TODO: Figure out if no OCID means "" or null
    node.setOCID(nodeJSON.ocid || "");
    //Store the node type
    node.setType(nodeType);
    //Set the title of the node, this is either the value or name property in the JSON
    node.setTitle(nodeJSON.label || nodeJSON.value || nodeJSON.name || nodeJSON.section_label || "");
    //Use a count variable to give each node a unique numerical identifier
    node.setId((this.m_nodeCount++)+"");
    //Associate the current organizer to the node
    node.setOrganizer(this.getStructureOrganizer());
    //Add the node to the lookup so we can access it later via the DOM id
    this.m_structureOrganizer.addTermToLookup(node);
    //Add the new node to the parent
    owner.addChild(node);
    return node;
};

/**
 * Creates a StructureTermGroup object based on the attrib_type json field. This will either construct a
 * Single, Multiple, or YesNo grouping.
 * @param nodeJSON the node's JSON.
 * @return {StructureTermGroup} a "Single" -> SingleStructureTermGroup, "Multiple" -> MultiStructureTermGroup,
 * "YesNo" -> YesNoStructureTermGroup.
 */
JSONStructureOrganizerBuilder.prototype.buildStructureTermGroupNode = function(nodeJSON) {
    switch(nodeJSON.attrib_type) {
        case "Single":
            return new SingleStructureTermGroup();
        case "Multiple":
            return new MultiStructureTermGroup();
        case "YesNo":
            return new YesNoStructureTermGroup();
        default:
            throw new Error("Attempted to call JSONStructureOrganizerBuilder.prototype.buildStructureTermGroupNode with" +
				" unsupported ATTRIB_TYPE");
    }
};

/**
 * Creates an InputStructureTerm object. Based on the data type, the object will be given validators to verify correct
 * input has been provided.
 * @param nodeJSON
 * @return {InputStructureTerm}
 */
JSONStructureOrganizerBuilder.prototype.buildInputNode = function(nodeJSON) {
    var node = new InputStructureTerm();
    node.setDataType(nodeJSON.data_type);
    node.setActiveState(new TermState().setCSSClass((nodeJSON.normalfinding === "Abnormal") ? "documented-abnormal" : "documented").setValue(true));
    node.setInactiveState(new TermState().setCSSClass("undocumented").setValue(null));
    node.setInitialState(node.getInactiveState());
    if(nodeJSON.data_type === "NUMERIC") {
        if(nodeJSON.min_value === 0.0 && nodeJSON.max_value === 0.0) {
            //Just add the default since it accepts any number
            node.addValidator(new DataRangeValidator());
        } else {
            node.addValidator(new DataRangeValidator().setMinValue(nodeJSON.min_value).setMaxValue(nodeJSON.max_value));
        }
    }

    node.addValidator(new DataTypeValidator().setDataType(nodeJSON.data_type));

    return node;
};

/**
 * Creates a FreeTextStructureTerm object. This object is always an ALPHA (plus more).
 * @return {FreeTextStructureTerm} the FreeTextStructureTerm object that was constructed.
 */
JSONStructureOrganizerBuilder.prototype.buildFreeTextNode = function(nodeJSON) {
    var node = new FreeTextStructureTerm();
    node.setDataType(nodeJSON.data_type);
    node.setActiveState(new TermState().setCSSClass(nodeJSON.normalfinding === "Abnormal" ? "documented-abnormal" : "documented").setValue(true));
    node.setInactiveState(new TermState().setCSSClass("undocumented").setValue(null));
    node.setInitialState(node.getInactiveState());
    return node;
};

/**
 * Creates a TableStructureTermGroup object.
 * @param  {JSON} nodeJSON JSON representation of the Table Group to be generated
 * @return {TableStructureTermGroup} the TableStructureTermGroup object what was constructed.
 */
JSONStructureOrganizerBuilder.prototype.buildTableStructureTermGroupNode = function(nodeJSON) {
    var node = new TableStructureTermGroup();
    this.addNormality(node, nodeJSON);
    return node;
};


/**
 * Creates a CycleStructureTerm object.
 * @param nodeJSON the JSON representation of the node.
 * @param owner the parent of this CycleStructureTerm. It is necessary to know the owner of this term because
 * if it exists within a YesNo StructureTermGroup, it will be given an additional no-state.
 * @return {CycleStructureTerm} the CycleStructureTerm object that was created.
 */
JSONStructureOrganizerBuilder.prototype.buildCycleNode = function(nodeJSON, owner) {
    var node = null;
    var nodeUIType = nodeJSON.ui_type;
    // Yes/No terms have 2 documented states. The first documented state is "Yes", the second documented state is "No". It should not be NONE term.
    var isYesNo = YesNoStructureTermGroup.prototype.isPrototypeOf(owner) && nodeUIType !== "NONE";
    if(isYesNo) {
        node = new YesNoStructureTerm();
    } else if(nodeUIType === "NONE"){
		node = new NoneStructureTerm();			
	} else if(TableStructureTermGroup.prototype.isPrototypeOf(owner)){
        node = new TableStructureTerm();
    }
    else {
        node = new CycleStructureTerm();
    }
    this.addNormality(node, nodeJSON);

    return node;
};

/**
 * Adds states to the passed node based on the normality
 * @param {StructureNode}  node  The node to associate the normality to
 * @param {JSON}  nodeJSON JSON containing node details (including normality)
 */
JSONStructureOrganizerBuilder.prototype.addNormality = function(node, nodeJSON) {
    // Check if node is a YesNo node (to determine whether or not to add 3rd state)
    var isYesNo = YesNoStructureTerm.prototype.isPrototypeOf(node);
    var normality = nodeJSON.normalfinding;
    // add the undocumented state
    node.addState(new TermState().setCSSClass("undocumented").setValue(null));

    // add the documented state(s)
    // Yes/No terms have 2 documented states. The first documented state is "Yes", the second documented state is "No".
    switch(normality) {
        case "Neutral":
            node.addState(new TermState().setCSSClass("documented").setValue(true));
            if (isYesNo) {
                // add second/No state for the Yes/No term
                node.addState(new TermState().setCSSClass("documented").setValue(false));
            }
            break;
        case "Normal":
            node.addState(new TermState().setCSSClass("documented").setValue(true));
            if (isYesNo) {
                // add second/No state for the Yes/No term... where answering "No" to something normal = abnormal
                node.addState(new TermState().setCSSClass("documented-abnormal").setValue(false));
            }
            break;
        case "Abnormal":
            node.addState(new TermState().setCSSClass("documented-abnormal").setValue(true));
            if (isYesNo) {
                // add second/No state for the Yes/No term... where answersing "No" to something abnormal = normal
                node.addState(new TermState().setCSSClass("documented").setValue(false));
            }
            break;
        default:
            throw new Error("Unexpected normal finding value in the JSON: " + normality);
    }

    node.setInitialState(node.getStates()[0]);
    return node;
};


/**
 * Overrides the StructureOrganizerBuilder update method. It initiates the update process by starting a
 * recursive travel through the JSON, updating the associated JavaScript objects.
 *
 * @param organizer The StrutureOrganizer being updated.
 * @param activityJson the JSON object that contains activity data.
 */
JSONStructureOrganizerBuilder.prototype.update = function (organizer, activityJson) {
	organizer.setActivityId(activityJson.dd_section_id);
	this.updateTraverse(activityJson, organizer);
};

/**
 * This is a recursive method that traverses the structure JSON, creating the associated JavaScript objects and
 * creating the necessary tree structure.
 * @param node the JSON node we are processing.
 * @param owner The parent JavaScript object is passed down a level of recursion so the new nodes can be correctly
 * added to their corresponding parent.
 */
JSONStructureOrganizerBuilder.prototype.updateTraverse = function (node, owner) {
    var child;
    //We don't care about non-object types, so skip them.
    if (!(node instanceof Object)) {
        return;
    }
    //Go through the child JSON nodes
    for (child in node) {
        //If this is a valid node.
        if (node.hasOwnProperty(child)) {
            //Skip any non-object JSON nodes.
            if (!(node[child] instanceof  Object)) {
                continue;
            }
            //If we found an array, go through each item, processing it accordingly
            if (Array.prototype.isPrototypeOf(node[child])) {
                var childArr = node[child];
                for (var i = 0; i < childArr.length; i++) {
                    //Create a node based on the JSON
                    var structureNode = this.updateNode(child, childArr[i], owner);

                    if (structureNode) {
                        //Go a level deeper, using the newly created structureNode as the new owner.
                        this.updateTraverse(childArr[i], structureNode);
                    }
                }
            } else {
                //If we didn't find an array, just go down a level deeper, passing through the owner.
                this.updateTraverse(node[child], owner);
            }
        }
    }
};

/**
 * A big nasty update method that updates JavaScript structure objects based on their node type.
 * @param nodeType the type of node.
 * @param nodeJSON the corresponding node JSON.
 * @param owner the parent of this new StructureNode object.
 * @return {StructureNode} the newly created StructureNode.
 */
JSONStructureOrganizerBuilder.prototype.updateNode = function(nodeType, nodeJSON, owner) {
	var node = null;
	var children = owner.getChildren();
	var i;
	var currentNode;
	// find the correct node
	// and set its activity id
	if(nodeType === "subsections") {
		for(i = 0; i < children.length; i++) {
			currentNode = children[i];
			if(this.matchesSubsection(children[i], nodeJSON)) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_section_id);
				break;
			}
		}
	} else if(nodeType === "groupbys") {
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];
			if (nodeJSON.label === currentNode.getTitle()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_groupby_id);
				break;
			}
		}
	} else if(nodeType === "subgroupbys") {
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];
			if (nodeJSON.label === currentNode.getTitle()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_sgroupby_id);
				break;
			}
		}
	} else if(nodeType === "items") {
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];
			if (nodeJSON.ocid === currentNode.getOCID()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_item_id);
				break;
			}
		}
	} else if(nodeType === "attributes") {
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];
			if (nodeJSON.ocid === currentNode.getOCID()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_attribute_id);
				break;
			}
		}
	} else if(nodeType === "attribute_menu_items") {
		// Loop through to find the correct JSON child
		for (i = 0; i < children.length; i++) {
			currentNode = children[i];

            // Ensure to search lower levels if this is an attribute_menu_item with children (Expand/Table)
            if (currentNode.getChildren().length > 0) {
                this.updateNode(nodeType, nodeJSON, currentNode);
            }

			if (nodeJSON.ocid === currentNode.getOCID() && nodeJSON.display_seq === currentNode.getDisplayPosition()) {
				node = currentNode;
				node.setActivityId(nodeJSON.dd_attr_menu_item_id);
				//builds and displays comment if the node JSON has comment
				if(nodeJSON.comment) {				
					node.displayComment(nodeJSON.comment);
				}
				// update state/value based on type of term
				if (node instanceof InputStructureTerm) {
					//Store the current text value on the term
					node.setCurrentValue(nodeJSON.value_text ? node.unescapePlaintextAsHtml(nodeJSON.value_text) : nodeJSON.value_number + "");
					//Update the term (may have a visual update as well)
					node.update();
				} else if (node instanceof CycleStructureTerm) {
					node.jumpToState(nodeJSON.truth_state_mean === "T" ? 1 : 2);
				}

				break;
			}
		}
	}

	return node;
};

/**
 * Determines if an existing subsection structure node matches the provided subsection JSON. This is so we can match up
 * activity data to the corresponding subsection object. The subsection node and JSON are considered a match only if all
 * of the template_rltns match.
 * @param {StructureOrganizer} subsectionNode - The subsection structure node against which we are comparing the
 * provided JSON to determine if it matches.
 * @param { { "dd_section_id" : number, ..., "template_rltns" : [ ... ]} } subsectionJSON - A subsection JSON against
 * which we are comparing the provided subsection node to determine if it matches.
 * @returns {boolean} True if the subsection node matches the subsection JSON, otherwise false.
 */
JSONStructureOrganizerBuilder.prototype.matchesSubsection = function(subsectionNode, subsectionJSON) {
	var subsectionTemplateRelations = subsectionNode.getTemplateRelations();
	var activityTemplateRelations = subsectionJSON.template_rltns;
	var subsectionTemplateRelationCount = subsectionTemplateRelations.length;
	var activityTemplateRelationCount = activityTemplateRelations.length;
	var subsectionTemplateRelation = null;
	var activityTemplateRelation = null;
	var matchedRelation = false;
	if(subsectionTemplateRelationCount !== activityTemplateRelationCount) {
		return false;
	}
	for(var i = 0; i < subsectionTemplateRelationCount; i++) {
		subsectionTemplateRelation = subsectionTemplateRelations[i];
		matchedRelation = false;
		for(var j = 0; j < activityTemplateRelationCount; j++) {
			activityTemplateRelation = activityTemplateRelations[j];
			if(subsectionTemplateRelation.dd_sref_chf_cmplnt_crit_id === activityTemplateRelation.dd_sref_chf_cmplnt_crit_id &&
				subsectionTemplateRelation.dd_sref_templ_instance_ident === activityTemplateRelation.dd_sref_templ_instance_ident &&
				subsectionTemplateRelation.parent_entity_id === activityTemplateRelation.parent_entity_id &&
				subsectionTemplateRelation.parent_entity_name === activityTemplateRelation.parent_entity_name) {
				matchedRelation = true;
				break;
			}
		}
		if(!matchedRelation) {
			return false;
		}
	}
	return true;
};

/**
 * Generates the question set object which is used to display structure template questions.
 * @param {Object} questionData - The JSON question data which is translated into the associated
 * StructureQuestionSet object.
 * @returns {StructureQuestionSet} The structure question set object generated from the provided JSON.
 */
JSONStructureOrganizerBuilder.prototype.buildQuestionSet = function(questionData) {
	var rawQuestion = null;
	var rawAnswers = null;
	var rawAnswer = null;
	var rawAnswerCount = null;

	var questionCount = questionData.length;
	var questionSet = new StructureQuestionSet();
	var question = null;
	var answer = null;

	var nodeCount = 0;

	questionSet.setNamespace(this.m_namespace);
	var lookup = questionSet.getLookup();

	//Loop through the data and generate the question objects
	for(var i = 0; i < questionCount; i++) {
		rawQuestion = questionData[i];
		question = new StructureQuestion();
		question.setId(++nodeCount + "");
		question.setNamespace(this.m_namespace);
		question.setQuestionDisplay(rawQuestion.label);
		question.setParentEntityId(rawQuestion.parent_entity_id);
		question.setParentEntityName(rawQuestion.parent_entity_name);

		rawAnswers = rawQuestion.choices;
		rawAnswerCount = rawAnswers.length;
		for(var j = 0; j < rawAnswerCount; j++) {
			rawAnswer = rawAnswers[j];
			answer = new StructureAnswer();
			answer.setAnswerDisplay(rawAnswer.label);
			answer.setTemplateId(rawAnswer.dd_sref_chf_cmplnt_crit_id);
			answer.setId(++nodeCount + "");
			answer.setNamespace(this.m_namespace);
			//Add the answer to the lookup.
			lookup[answer.getId()] = answer;
			question.addChild(answer);
		}
		questionSet.addChild(question);
	}
	return questionSet;
};

/**
 * This argument will be used to have individual methods of a child class inherit from a parent class
 * @param  {Class} childClass  The class that will 'inherit' methods
 * @param  {Class} parentClass The class that's methods will be 'inherited'
 * @param  {Array<String>} methods An array of methods (as strings) to inherit.  Will be added to child class to call parent method.
 * @return {undefined}
 */
JSONStructureOrganizerBuilder.extendClassMethods = function(childClass, parentClass, methods) {
    var methodCnt = methods.length;
    for (var i = 0; i < methodCnt; i++){
        (function(x){
            //Create method on child class that calls the parent class method with child context.
            childClass.prototype[methods[x]] = function(args) {
                return parentClass.prototype[methods[x]].apply(this, arguments);
            };
        })(i);
    }
};
/**
 * StructureNode
 * This class represents the very base level node concept for structure documentation. This node allows for
 * construction of an (n)ary tree. All base functionality, within reason, for structure nodes is encapsulated in
 * this base class.
 * @constructor
 */
function StructureNode() {
	this.m_activityId = 0.0;			//The id that links to activity data, as opposed to reference data
	this.m_children = null;				//The child nodes of this node
	this.m_dirty = false;				//The dirty status of the node (whether is has been modified since load)
	this.m_displayPosition = 0;			//The display position of the node
	this.m_id = "";						//A unique identifier for the node.
	this.m_initialState = null;			//The starting state of the node (on creation)
	this.m_namespace = "";				//The namespace for the node (useful for giving unique DOM ids)
	this.m_numberDocumented = 0;		//The number of child nodes that have been documented
	this.m_ocid = "";					//The OCID of the node (not always present)
	this.m_parent = null;				//The parent of this node (root node will have null parent)
	this.m_previousState = null;		//The previous state of the node
	this.m_rootElement = null;			//The root element of the node (if available)
	this.m_shouldRender = true;			//Whether the node should ever be rendered or not.
	this.m_isDefaultDisplayed = true;	//Whether the node should be displayed (rendered) initially
	this.m_state = null;				//What state the node is in (documented or not, etc)
	this.m_title = "";					//The title of the node (not always visible)
	this.m_type = "";					//The node type (json key value)
	this.m_inNavigateStructureTree = true; //The node should be default searched for in the structure tree
	this.m_shouldSave = true;			//The node will be defaulted to be included when saving
}

/**
 * Returns the activityId of the StructureNode.
 * @returns {number} activity id
 */
StructureNode.prototype.getActivityId = function () {
	return this.m_activityId;
};
/**
 * Sets the activityId of the StructureNode.
 * @param {string} id - The id of the StructureNode.
 */
StructureNode.prototype.setActivityId = function (activityId) {
	if (typeof activityId !== "number") {
		throw new Error("Called setActivityId on StructureNode with invalid parameter for activityId");
	}
	this.m_activityId = activityId;
	return this;
};

/**
 * Returns the Array of children for this StructureNode.
 * @returns {Array<StructureNode>}
 */
StructureNode.prototype.getChildren = function () {
	if (!this.m_children) {
		this.m_children = [];
	}
	return this.m_children;
};

/**
 * Returns the dirty state of this StructureNode.
 * @returns {boolean}
 */
StructureNode.prototype.isDirty = function () {
	return this.m_dirty;
};

/**
 * Sets the dirty state of this StructureNode.
 * @param {boolean} dirty - The dirty state of this StructureNode. True if dirty, otherwise false.
 * @returns {StructureNode}
 */
StructureNode.prototype.setIsDirty = function (dirty) {
	if (typeof dirty !== "boolean") {
		throw new Error("Called setIsDirty on StructureNode with invalid dirty parameter.");
	}
	this.m_dirty = dirty;
	return this;
};

/**
 * Returns the displayPosition value of the StructureNode.
 * @returns {number}
 */
StructureNode.prototype.getDisplayPosition = function () {
	return this.m_displayPosition;
};

/**
 * Sets the displayPosition value of the StructureNode.
 * @param {number} displayPosition - The displayPosition value of the StructureNode.
 */
StructureNode.prototype.setDisplayPosition = function (displayPosition) {
	if(typeof displayPosition !== "number") {
		throw new Error("Attempted to call StructureNode.prototype.setDisplayPosition with invalid parameter.");
	}
	this.m_displayPosition = displayPosition;
	return this;
};

/**
 * Returns the id of the StructureNode.
 * @return {string}
 */
StructureNode.prototype.getId = function () {
	return this.m_id;
};
/**
 * Sets the id of the StructureNode.
 * @param {string} id - The id of the StructureNode. This will give the node a unique presence on the DOM.
 * @returns {StructureNode}
 */
StructureNode.prototype.setId = function (id) {
	if (typeof id !== "string") {
		throw new Error("Called setId on StructureNode with invalid parameter for id");
	}
	this.m_id = id;
	return this;
};

/**
 * Returns the initial TermState of this StructureNode. This is the state since the last save.
 * @returns {TermState}
 */
StructureNode.prototype.getInitialState = function () {
	return this.m_initialState;
};

/**
 * Sets the initial TermState of this StructureNode. This is the state since the last save.
 * @param {TermState} initialState - The TermState since the last save operation.
 * @returns {StructureNode}
 */
StructureNode.prototype.setInitialState = function (initialState) {
	if (!TermState.prototype.isPrototypeOf(initialState)) {
		throw new Error("Called setInitialState on StructureNode with invalid initialState parameter.");
	}
	this.m_initialState = initialState;
	return this;
};

/**
 * Returns the namespace of this StructureNode. Namespaces are used to provide unique html identification across
 * multiple instances of structured documentation.
 * @returns {string}
 */
StructureNode.prototype.getNamespace = function () {
	return this.m_namespace;
};

/**
 * Sets the namespace of this StructureNode. Namespaces are used to provide unique html identification across
 * multiple instances of structured documentation.
 * @param {string} namespace - The namespace of this StructureNode.
 * @returns {StructureNode}
 */
StructureNode.prototype.setNamespace = function (namespace) {
	if (typeof namespace !== "string") {
		throw new Error("Called setNamespace on StructureNode with invalid namespace parameter.");
	}
	this.m_namespace = namespace;
	return this;
};

/**
 * Returns the number of children that are documented.
 * @returns {number}
 */
StructureNode.prototype.getNumberOfDocumentedChildren = function () {
	return this.m_numberDocumented;
};

/**
 * Returns the OCID of this StructureNode.
 * @returns {string}
 */
StructureNode.prototype.getOCID = function () {
	return this.m_ocid;
};

/**
 * Sets the OCID of this StructureNode.
 * @param {string} ocid - The OCID of this StructureNode.
 */
StructureNode.prototype.setOCID = function (ocid) {
	if(typeof ocid !== "string") {
		throw new Error("Attempted to call StructureNode.prototype.setOCID with invalid parameter.");
	}
	this.m_ocid = ocid;
	return this;
};

/**
 * Returns the parent of this StructureNode, if there is one.
 * @returns {StructureNode}
 */
StructureNode.prototype.getParent = function () {
	return this.m_parent;
};

/**
 * Sets the parent of this StructureNode.
 * @param {StructureNode} parent - The StructureNode that is the parent of this StructureNode.
 * @returns {StructureNode}
 */
StructureNode.prototype.setParent = function (parent) {
	if (!StructureNode.prototype.isPrototypeOf(parent)) {
		throw new Error("Called setParent on StructureNode with invalid parent parameter.");
	}
	this.m_parent = parent;
	return this;
};

/**
 * Returns the previous TermState of this StructureNode. This is the TermState since the last state change.
 * @returns {TermState}
 */
StructureNode.prototype.getPreviousState = function () {
	return this.m_previousState;
};

/**
 * Sets the previous TermState of this StructureNode.
 * @param {TermState} previousState - The TermState since the last state change.
 */
StructureNode.prototype.setPreviousState = function (previousState) {
	if(!TermState.prototype.isPrototypeOf(previousState) && previousState !== null) {
		throw new Error("Attempted to call StructureNode.prototype.setPreviousState with invalid parameter.");
	}
	this.m_previousState = previousState;
	return this;
};

StructureNode.prototype.getRootElement = function () {
	return this.m_rootElement;
};

/**
 * Returns whether or not this StructureNode should render its contents. This is simply a display flag.
 * @returns {boolean}
 */
StructureNode.prototype.getShouldRender = function () {
	return this.m_shouldRender;
};

/**
 * Sets whether or not this StructureNode should render its contents. This is simply a display flag. Note that
 * this flag has no effect on the children. If this node is invisible, its children may still render.
 * @param {boolean} shouldRender - Whether this StructureNode should render its contents.
 */
StructureNode.prototype.setShouldRender = function (shouldRender) {
	if (typeof shouldRender !== "boolean") {
		throw new Error("Called setShouldRender on StructureNode with invalid shouldRender parameter.");
	}
	this.m_shouldRender = shouldRender;
	return this;
};


/**
 * Method used for determining whether or not a node is in the correct position in the navigation-data coming from cernstructure plugin.
 * This is utilized to handle how the nodes heirarchy is searched to match a node based on label/ocid details from the cernstructure.
 * Certain nodes (Table/Expand) are not in the correct tree structure in the structured plugin due to linearization of AMIs there.
 * Nodes that should be ignored when searching (due to the linearized AMIs from cernstructure node heirarchy) will return false here.
 * By default, Nodes will be included when searching through the structure tree.
 * @return {Boolean} Returns true if the node should be considered when searching the structure tree
 */
StructureNode.prototype.inNavigationStructureTree = function() {
	return this.m_inNavigateStructureTree;
};

/**
 * Returns whether or not the details of the current node should be added to the JSON on save
 * @return {Boolean} Whether the current node should be included in the JSON to save
 */
StructureNode.prototype.shouldSave = function() {
	return this.m_shouldSave;
};

/**
 * Returns whether or not this StructureNode should render on initial structure render.  
 * This differs from getShouldRender as it only affects whether the node is rendered on the initial render.
 * The intent of this function is to limit the nodes that are displayed (and rendered) initially for performance reasons.
 * @return {Boolean} Returns true if the node should be displayed on the initial page load
 */
StructureNode.prototype.isDefaultDisplayed = function() {
	return this.m_isDefaultDisplayed;
};

/**
 * Sets whether or not this StructureNode should render on the initial structure tab render
 * @param {Boolean} defaultDisplayed - Whether this StructureNode should render initially
 */
StructureNode.prototype.setIsDefaultDisplayed = function(defaultDisplayed){
	if (typeof defaultDisplayed !== "boolean") {
		throw new Error("Called setIsDefaultDisplayed on StructureNode with invalid defaultDisplayed paramater");
	}
	this.m_isDefaultDisplayed = defaultDisplayed;
	return this;
};

/**
 * Method to be implemented by child nodes.  Returns whether or not the node is currently displayed on the page.
 * This function is intended to be used to ensure that a node is visible on the page before performing certain operations
 * @return {Boolean} Returns true if the node is currently displayed on the page
 */
StructureNode.prototype.isCurrentlyDisplayed = function() {
	return true;
};

/**
 * Method to be implemented by child nodes.  Performs updates to ensure that the node is displayed on the page.
 */
StructureNode.prototype.displayNode = function() {
	throw new Error("displayNode is abstract, to be implemented by children");
};

/**
 * Returns the TermState this StructureNode is in.
 * @returns {TermState}
 */
StructureNode.prototype.getState = function () {
	return this.m_state;
};

/**
 * Sets the TermState this StructureNode is in.
 * @param {TermState} state - The current TermState this StructureNode is in.
 */
StructureNode.prototype.setState = function (state) {
	if(!TermState.prototype.isPrototypeOf(state)) {
		throw new Error("Attempted to call StructureNode.prototype.setState with invalid parameter.");
	}
	this.m_state = state;
	return this;
};

/**
 * Returns the title of this StructureNode. This is the value that will display in the markup.
 * @returns {string}
 */
StructureNode.prototype.getTitle = function () {
	return this.m_title;
};

/**
 * Sets the title of this StructureNode. This is the value that will display in the markup.
 * @param {string} title - The title of this StructureNode.
 */
StructureNode.prototype.setTitle = function (title) {
	if(typeof title !== "string") {
		throw new Error("Attempted to call StructureNode.prototype.setTitle with invalid parameter.");
	}
	this.m_title = title;
	return this;
};

/**
 * Returns the type of this StructureNode.
 * @returns {string}
 */
StructureNode.prototype.getType = function () {
	return this.m_type;
};

/**
 * Sets the type of this StructureNode.
 * @param {string} type - The type of this StructureNode.
 */
StructureNode.prototype.setType = function (type) {
	if(typeof type !== "string") {
		throw new Error("Attempted to call StructureNode.prototype.setType with invalid parameter.");
	}
	this.m_type = type;
	return this;
};

/**
 * This method allows a node to notify another node that it is dirty. The base implementation is to simply pass
 * this notification up the chain of parents. If a sub-class needs to perform some functionality, this method should
 * be overridden.
 * @param {StructureNode} node - The StructureNode that is informing of a dirty change.
 */
StructureNode.prototype.notifyDirty = function (node) {
	if (this.getParent()) {
		this.getParent().notifyDirty(node);
	}
};

/**
 * This method simply restores the StructureNode to a non-dirty state by setting the dirty member variable to false.
 */
StructureNode.prototype.resetDirty = function () {
	this.m_dirty = false;
};

/**
 * This turns a StructureNode into the JSON necessary for the save function
 * @return {string} a JSON string representation of the activity data of the node
 */
StructureNode.prototype.convertToJSON = function () {
	return {};
};

/**
 * This returns the parent organizer (SectionNode) of the current node (or null if not found)
 * @return {StructureOrganizer} The parent StructureOrganizer of the current node
 */
StructureNode.prototype.getOrganizer = function() {
	return this.m_organizer;
};

/**
 * Sets the StructureOrganizer associated with the current node
 * @param {StructureOrganizer} organizer - StructureOrganizer associated with the node
 */
StructureNode.prototype.setOrganizer = function(organizer) {
	if(!StructureOrganizer.prototype.isPrototypeOf(organizer)) {
		throw new Error("StructureOrganizer.prototype.setOrganizer expects a StructureOrganizer object.");
	}
	this.m_organizer = organizer;
};

/**
 * Returns the closest StructureOrganizer ancestor of the current node
 * @return {StructureOrganizer} The StructureOrganizer node that the current node descends from
 */
StructureNode.prototype.getParentSectionNode = function() {
	var currentNode = this;
	var sectionNode = null;
	//Find the section node that is the parent to the provided node
	while(currentNode !== null && !StructureOrganizer.prototype.isPrototypeOf(currentNode)) {
		currentNode = currentNode.getParent();
	}
	sectionNode = currentNode;
	return sectionNode;
};

/**
 * Returns the element that should be updated when the node should be highlighted
 * @return {undefined}
 */
StructureNode.prototype.getHighlightElement = function() {
	return this.getRootElement();
};

/**
 * Handles actions necessary after the initial rendering of a Structured tab.
 * @return {undefined} 
 */
StructureNode.prototype.postProcessing = function () {
	//Allow to be overwritten by children
};

/**
 * Add the children's json into the supplied array.
 *
 * @param {Array<JSON>} jsonArray - The array to push the children's json into
 */
StructureNode.prototype.addChildrenJSON = function (jsonArray) {
	// prep children json
	var children = this.getChildren();
	this.addNodesToJSON(children, jsonArray);
};

/**
 * Adds specified nodes to the given JSON
 * @param {Array<StructureNode>} nodes  StructureNodes to add to JSON
 * @param {Array<JSON>} jsonArray The array to push the children's json into
 */
StructureNode.prototype.addNodesToJSON = function (nodes, jsonArray) {
	var childrenMap = {};
	// map the children's json to their type, eg. "ITEM" => ["{....}", ... ]
	for (var i = 0; i < nodes.length; i++) {
		var child = nodes[i];
		var stateTruth = (child.getState() ? child.getState().getValue() : null);
		//If the node is not in a documented state then skip it unless it is a subsection node.
		//Subsection nodes must always be added, regardless of documented state.
		//Nodes that shouldn't be saved will be skipped
		if (stateTruth === null && child.getType() !== "subsections" || !child.shouldSave()) {
			continue;
		}

		// create the initial array if it doesn't exist
		if (!childrenMap[child.getType()]) {
			childrenMap[child.getType()] = [];
		}

		// convert the child into a json string and push into the array
		var childJSON = child.convertToJSON();
		childrenMap[child.getType()].push(childJSON);
	}

	// push the child into the section json
	for (var type in childrenMap) {
		jsonArray.push('"' + type + '": [' + childrenMap[type].join(',') + ']');
	}
};

/**
 * Adds all descendents of the current node to a passed array
 * @param  {Array} childList Array to add descendent StructureNodes to
 * @return {Array} Returns the passed array with added descendents
 */
StructureNode.prototype.getAllDescendents = function(childList) {
	var children = this.getChildren();
	var childCnt = children.length;
	var child;
	for (var i = 0; i < childCnt; i++){
		child = children[i];
		childList.push(child);
		child.getAllDescendents(childList);
	}
	return childList;
};

/**
 * Adds the descendent's json into the supplied array.  This is utilized when children AMI nodes 
 * exist at multiple levels in the structure tree (i.e. EXPAND/TABLE).  This handles adding converting
 * the tree structure into a linear JSON array.
 * @param {Array<JSON>} jsonArray The array to push the descendents' json into
 */
StructureNode.prototype.addDescendentJSON = function(jsonArray) {
	var descendents = this.getAllDescendents([]);
	this.addNodesToJSON(descendents, jsonArray);
};

/**
 * Escapes the special characters in the supplied string as HTML to make it safe for CCL and JSON.
 *
 * Special characters escaped:
 *	& - &#38;
 *	" - &#34;
 *	' - &#39;
 *	< - &#60;
 *	> - &#62;
 *	\ - &#92;
 *	^ - &#94;
 *	~ - &#126;
 *	\t - "&#9;
 *	\r - &#10;
 * 	\n - &#13;
 *
 * @param {string} plaintext - plain text, could be something like a free text comment
 * @returns {string} plain text that is represented as html, and is safe for to be handled by CCL and as part of a JSON string
 */
StructureNode.prototype.escapePlaintextAsHtml = function (plaintext) {
	// NOTE: always replace ampersand (&) first!
	return plaintext.replace(/\&/g, "&#38;").replace(/\"/g, "&#34;").replace(/\'/g, "&#39;").replace(/\</g, "&#60;").replace(/\>/g, "&#62;")
		.replace(/\\/g, "&#92;").replace(/\^/g, "&#94;").replace(/\~/g, "&#126;").replace(/\t/g, "&#9;").replace(/\r/g, "&#10;").replace(/\n/g, "&#13;");
};

/**
 * Converts HTML escapes back to plain text by
 * undoing the escapes performed by the escapePlaintextAsHtml() method.
 *
 * Special characters un-escaped:
 *	& - &#38;
 *	" - &#34;
 *	' - &#39;
 *	< - &#60;
 *	> - &#62;
 *	\ - &#92;
 *	^ - &#94;
 *	~ - &#126;
 *	\t - "&#9;
 *	\r - &#10;
 * 	\n - &#13;
 * 
 * @param {string} html - text as html with special character that needs to be unescaped back into plain text
 * @returns {string} regular plain text without any escapes for HTML/CCL/JSON
 */
StructureNode.prototype.unescapePlaintextAsHtml = function (html) {
	// NOTE: always unescape ampersand (&) last!
	return html.replace(/\&\#34\;/g, '"').replace(/\&\#39\;/g, "'").replace(/\&\#60\;/g, '<').replace(/\&\#62\;/g, '>').replace(/\&\#92\;/g, "\\")
		.replace(/\&\#94\;/g, "^").replace(/\&\#126\;/g, "~").replace(/\&\#9\;/g, "\t").replace(/\&\#10\;/g, "\r").replace(/\&\#13\;/g, "\n").replace(/\&\#38\;/g, "&");
};


/**
 * This method acts as a notification of a state change in a child node. Certain parent nodes need to know the
 * state of their children and perform actions accordingly. This base method simply keeps track of the number of
 * children nodes that are documented.
 * @param {StructureNode} node - The StructureNode child that is informing of a state change event.
 */
StructureNode.prototype.notifyStateChange = function (node) {
	var currentState = node.getState();
	var previousState = node.getPreviousState();
	if (previousState && currentState.getValue() === previousState.getValue()) {
		return;
	}
	var previousNumber = this.m_numberDocumented;
	if (currentState.getValue() === null) {
		this.m_numberDocumented = Math.max(0, this.m_numberDocumented - 1);
	} else if ((!node.getPreviousState() || node.getPreviousState().getValue() === null) && currentState.getValue() !== null) {
		this.m_numberDocumented = Math.min(this.m_children.length, this.m_numberDocumented + 1);
	}
	if (this.m_numberDocumented === 0) {
		this.updateState(new TermState().setValue(null).setKey("NULL"));
	} else if (this.m_numberDocumented > 0 && previousNumber === 0) {
		this.updateState(new TermState().setValue(true).setKey("TRUE"));
	}
};

/**
 * This method performs the necessary actions to update the state of the StructureNode. If the state being updated
 * to is different than the current state, a notification of state change is sent to the parent. The node is then
 * refreshed and the new state is stored.
 * @param {TermState} state - The state the StructureNode should be updated to.
 */
StructureNode.prototype.updateState = function (state) {
	var currentState = this.getState();
	if (state !== currentState) {
//		this.m_state = state;
		this.setState(state);
		this.setPreviousState(currentState);
		//If the node has a parent, notify of the state change
		if (this.getParent()) {
			this.getParent().notifyStateChange(this);
		}
	}

	// refresh anyways, something else (like whether the node is valid) may have changed while keeping the state the same
	this.refresh();
};

/**
 * Base refresh method for a StructureNode. This is simply an interface. This method should be implemented by
 * sub-classes of StructureNode.
 */
StructureNode.prototype.refresh = function () {
};

/**
 * Adds a child node to this StructureNode. This also performs the necessary operation of linking the child to this
 * node as the parent.
 * @param {StructureNode} child - The StructureNode that is to become a child of this StructureNode.
 */
StructureNode.prototype.addChild = function (child) {
	if (child.getParent() !== this) {
		child.setParent(this);
	}
	this.getChildren().push(child);
};

/**
 * The base render method. Any subclasses of StructureNode should provide their implementation of the render method.
 * @param {StructureHtml} structureHtml - The StructureHtml package to which any html content will be appended.
 */
StructureNode.prototype.render = function (structureHtml) {
	return;
};

/**
 * Clears the node and its decendents of all data, effectively resetting them to the state of being freshly created.
 *
 */
StructureNode.prototype.clear = function () {
	var children = this.getChildren();
	var i;
	for (i = 0; i < children.length; i++) {
		children[i].clear();
	}

	this.clearSelf();
};

/**
 * Clears only this node, effectively resetting itself to the state of being freshly created.
 *
 * Subclasses are to override this method as the implementation will vary with each subclass.
 * Generally, for all subclasses, clearing the activity id is the first thing that needs to happen.
 */
StructureNode.prototype.clearSelf = function () {
	this.setActivityId(0);
	this.m_previousState = null;
	this.m_state = null;
	this.m_numberDocumented = 0;
};
/**
 * StructureHtml
 * A very simple class which just encapsulates an html string. This is necessary as structured documentation html
 * is recursively generated. A string is pass-by-value, thus it is impossible to recursively generate a string using
 * a string object. This encapsulation allows for said recursive html generation.
 * @constructor
 */
function StructureHtml() {
	this.m_html = "";
}

/**
 * Returns the html package.
 * @returns {string} the html string
 */
StructureHtml.prototype.getHtml = function () {
	return this.m_html;
};

/**
 * Appends the provided html string to the current html member variable.
 * @param {string} html - An html string to be appended.
 * @returns {StructureHtml} self, for chaining
 */
StructureHtml.prototype.append = function (html) {
	this.m_html += html;
	return this;
};
/**
 * StructureOrganizer
 * This class represents a structured documentation SECTION node. This class is largely responsible for providing
 * the interface between the user and the underlying object structure. This class should eventually be refactored
 * into something called StructureSection, serving only as a data object. The rendering, navigation, and event
 * attachment should then be moved into a true StructureOrganizer object.
 * @constructor
 */
function StructureOrganizer() {
	this.m_lookup = null;
	this.m_navigator = null;
	this.m_referenceSectionId = null;
	this.m_type = "SECTION";

	this.m_templateIds = {};
	this.m_templateRelations = null;
	this.m_rootElement = null;
	this.m_contentElement = null;
	this.m_navigatorElement = null;
	this.m_resizeFunction = null;
	this.m_dirtyNodeList = null;
	this.m_onDirtyChangeCallback = null;
	this.m_previousHighlightedNode = null;
	this.m_rendered = false;
	this.m_isPriorityEnabled = true;
	
	//Multi-section variables
	this.m_isMultiSection = false;
	this.m_activeSection = null;
}
StructureOrganizer.prototype = new StructureNode();
StructureOrganizer.prototype.constructor = StructureNode;

/**
 * Sets whether or not the section has been rendered.
 * @param {boolean} rendered - A boolean indicating whether the section has been rendered or not.
 * @returns {StructureOrganizer} Returns self to allow chainin.
 */
StructureOrganizer.prototype.setIsRendered = function(rendered) {
	if(typeof rendered !== "boolean") {
		throw new Error("StructureOrganizer.prototype.setIsRendered expects a boolean.");
	}
	this.m_rendered = rendered;
	return this;
};

/**
 * Retrieves whether or not the section has been rendered.
 * @returns {boolean} True if the section has been rendered, otherwise false.
 */
StructureOrganizer.prototype.isRendered = function() {
	return this.m_rendered;
};

/**
 * Sets the template relations for the section.
 * @param {Array<Object>} templateRelations - The template relations for the section.
 */
StructureOrganizer.prototype.setTemplateRelations = function(templateRelations) {
	this.m_templateRelations = templateRelations;
	return this;
};

/**
 * Retrieves the list of template relations for the section.
 * @returns {Array<Object>} The template relations for the section.
 */
StructureOrganizer.prototype.getTemplateRelations = function() {
	return this.m_templateRelations;
};


/**
 * Sets the active section for the parent
 * @param {StructureOrganizer} activeSection - Sets the active section.
 * @returns {StructureOrganizer} The active section.
 */
StructureOrganizer.prototype.setActiveSection = function(activeSection) {
	if(!StructureOrganizer.prototype.isPrototypeOf(activeSection)) {
		throw new Error("StructureOrganizer.prototype.setActiveSection expects a jQuery element.");
	}
	this.m_activeSection = activeSection;
	return this;
};

/**
 * Retrieves the active section.
 * @returns {StructureOrganizer} Retrieves the active section.
 */
StructureOrganizer.prototype.getActiveSection = function() {
	return this.m_activeSection;
};

/**
 * Retrieves whether or not the section has subsections (multi section).
 * @returns {boolean} True if this section is multi section (has subsection children).
 */
StructureOrganizer.prototype.isMultiSection = function() {
	return this.m_isMultiSection;
};

/**
 * Sets whether the organizer is considered multi-section or not.
 * @param {boolean} multiSection - An indicator specifying whether an organizer is considered multi-section or not.
 * @returns {StructureOrganizer} Returns self to allow chaining.
 */
StructureOrganizer.prototype.setIsMultiSection = function(multiSection) {
	if(typeof multiSection !== "boolean") {
		throw new Error("StructureOrganizer.prototype.setIsMultiSection expects a boolean.");
	}
	this.m_isMultiSection = multiSection;
	return this;
};

/**
 * Returns whether AMI prioritization is enabled
 * @return {Boolean} Returns true if AMI priotization is enabled for child nodes
 */
StructureOrganizer.prototype.isPriorityEnabled = function(){
	return this.m_isPriorityEnabled;
};

/**
 * Sets whether the AMI prioritization is enabled
 * @param {Boolean} priorityEnabled True if AMI priotiziation (Show More) is on, False otherwise
 */
StructureOrganizer.prototype.setIsPriorityEnabled = function(priorityEnabled){
	if(typeof priorityEnabled !== "boolean") {
		throw new Error("StructureOrganizer.prototype.setIsPriorityEnabled expects a boolean.");
	}
	this.m_isPriorityEnabled = priorityEnabled;
};

/**
 * Sets the function that is called when the dirty state changes at the organizer level.
 * @param {function} onDirtyChangeCallback - The function to be called when the dirty state changes at
 * the organizer level.
 */
StructureOrganizer.prototype.setOnDirtyChangeCallback = function (onDirtyChangeCallback) {
	if (typeof onDirtyChangeCallback !== "function") {
		throw new Error("Attempted to call StructureOrganizer.prototype.setOnDirtyChangeCallback with invalid parameter.");
	}
	this.m_onDirtyChangeCallback = onDirtyChangeCallback;
	return this;
};

/**
 * Overrides the base notifyDirty method from the StructureNode class. The organizer keeps track of a list of
 * dirty nodes via a hashmap.
 * @param {StructureNode} node - The structure node that has sent the notification about it's dirty state.
 */
StructureOrganizer.prototype.notifyDirty = function (node) {
	var parent = this.getParent();
	//A section can potentially have a parent section...
	if(parent) {
		parent.notifyDirty(node);
	}
	//If this is the root element, handle the dirty node list
	if(!parent) {
		if (node.isDirty()) {
			this.addNodeToDirtyList(node);
		}
		else {
			this.removeNodeFromDirtyList(node);
		}
		this.updateDirty();
	}
};

/**
 * Overrides the base resetDirty method. This will go through the stored dirty nodes and call their resetDirty method.
 * This will also clear out the mapping of dirty nodes.
 */
StructureOrganizer.prototype.resetDirty = function () {
	StructureNode.prototype.resetDirty.call(this);
	var dirtyNodeList = this.getDirtyNodeList();
	for (var key in dirtyNodeList) {
		if (dirtyNodeList.hasOwnProperty(key)) {
			this.m_lookup[key].resetDirty();
		}
	}
	this.m_dirtyNodeList = {};
};

/**
 * Returns the dirty node list which is a mapping of node id to true/false values. The advantage of this
 * over a flat array is that when a node updates its dirty state, the cost to update this list is
 * essentially nothing.
 * @returns {Map<string,boolean>} a map/object of node id and their dirty state as boolean
 */
StructureOrganizer.prototype.getDirtyNodeList = function () {
	if (!this.m_dirtyNodeList) {
		this.m_dirtyNodeList = {};
	}
	return this.m_dirtyNodeList;
};

/**
 * Removes a node from the dirty list by updating its true/false value in the map.
 * @param {StructureNode} node - The node to be removed from the dirty list.
 */
StructureOrganizer.prototype.removeNodeFromDirtyList = function (node) {
	this.getDirtyNodeList()[node.getId()] = false;
};

/**
 * Adds a node to the dirty list by updating its true/false value in the map to true.
 * @param {StructureNode} node - The node to be added to the dirty list.
 */
StructureOrganizer.prototype.addNodeToDirtyList = function (node) {
	this.getDirtyNodeList()[node.getId()] = true;
};

/**
 * Returns the root element of the structure organizer and caches it.
 * @returns {object} jQuery object of the organizer root element
 */
StructureOrganizer.prototype.getRootElement = function () {
	if (!this.m_rootElement || !this.m_rootElement.length) {
		if(this.m_isMultiSection) {
			this.m_rootElement = $("#" + this.getNamespace() + "\\:parentOrganizer\\:ROOT\\:" + this.getId());
		} else {
			this.m_rootElement = $("#" + this.getNamespace() + "\\:organizer\\:ROOT\\:" + this.getId());
		}
	}
	return this.m_rootElement;
};

/**
 * Returns the custom resize function to be called when the organizer is resized. This should be provided by
 * the consumer as there is no guarantee where this artifact will exist.
 * @returns {function} resize function
 */
StructureOrganizer.prototype.getResizeFunction = function () {
	return this.m_resizeFunction;
};

/**
 * Sets the custom resize function to be called when the organizer is resized. This should be provided by the
 * consumer as there is not guarantee where this artifact will exist.
 * @param {function} resizeFunction - The custom resize function.
 */
StructureOrganizer.prototype.setResizeFunction = function (resizeFunction) {
	if (typeof resizeFunction !== "function") {
		throw new Error("Called setResizeFunction on StructureOrganizer with invalid parameter resizeFunction");
	}
	this.m_resizeFunction = resizeFunction;
	return this;
};

/**
 * Returns the structure navigator element and caches it.
 * @returns {object} jQuery object of the navigator html element
 */
StructureOrganizer.prototype.getNavigatorElement = function () {
	if (!this.m_navigatorElement) {
		this.m_navigatorElement = $("#" + this.getNamespace() + "\\:navigatorPanel\\:" + this.getId());
	}
	return this.m_navigatorElement;
};

/**
 * Navigates to the particular element in the structure view
 * @param navigationData - JSON data which contains the element details to navigate to
 */
StructureOrganizer.prototype.navigateToNode = function(navigationData) {
	var desiredString = "";
	var jsonData = JSON.parse(navigationData);
	//Build a navigation string that uniquely identifies the node we are searching for.
	for (var i = 0; i < jsonData.length; i++) {
		var value = jsonData[i];
		if (value.label) {
			desiredString = desiredString + "label:" + value.label;
		} else if (value.ocid) {
			desiredString = desiredString + ", ocid:" + value.ocid;
		}
	}
	//Using the identification string, find the corresponding structure node in the tree
	var returnNode = this.findNode(this, this.m_ocid, desiredString);
	this.goToNode(returnNode, true, true);
};

/**
 * Updates the scroll position to navigate to the given node on the page.  No navigation is performed if already visible.
 * @param destinationNode {StructureNode} The node to navigate to 
 * @param highlightNode {Boolean} True iff the node to navigate to should be highlighted
 * @param alwaysNavigate {Boolean} True iff the scroll postion should always be updated to navigate to the selected node
 */
StructureOrganizer.prototype.goToNode = function(destinationNode, highlightNode, alwaysNavigate){
	var sectionNode = null;
	var contentOffsetTop;
	var nodeOffsetTop;
	var nodeOffsetBottom;
	var contentHeight;
	var $contentElement;
	var $nodeRootElement;
	//If the desired node could not be found in the structure tree, log an error and exit.
	if(!destinationNode) {
		logger.logWarning("StructureOrganizer.prototype.navigateToNode: unable to find the specified node");
		return;
	}

	//Find the section node that is the parent to the provided node
	sectionNode = destinationNode.getParentSectionNode();

	//If a section node was not found as an ancestor to the node we are navigating to.
	if(!sectionNode || !StructureOrganizer.prototype.isPrototypeOf(sectionNode)) {
		logger.logWarning("StructureOrganizer.prototype.navigateToNode: unable to find a section node that is parent to the node that was navigated to.");
		return;
	}

	//If this is a multi-section tree, first navigate to the appropriate tab
	if(this.isMultiSection() && (this.getActiveSection() !== sectionNode)) {
		$("#" + this.getNamespace() + "\\:tab\\:" + sectionNode.getId()).click();
	}

	//If node is not currently displayed on the page, update accordingly before attempting to scroll
	if(!destinationNode.isCurrentlyDisplayed()){
		destinationNode.displayNode();
	}
	
	//The body element of the active section
	$contentElement = sectionNode.getContentElement();
	//The first rendered element out of the node and its ancestors
	$nodeRootElement = this.findRenderedRootHighlightElement(destinationNode);
	//If an element was successfully found, navigate the content body (via scroll) to the node and highlight it.
	if($nodeRootElement && $nodeRootElement.length) {
		//Updating highlighting if turned on 
		if(highlightNode){
			$nodeRootElement.addClass('highlight-navigation');
			this.m_previousHighlightedNode = $nodeRootElement;
		}

		contentOffsetTop = $contentElement.offset().top;
		nodeOffsetTop = $nodeRootElement.offset().top;
		nodeOffsetBottom = nodeOffsetTop + $nodeRootElement.height();
		contentHeight = $contentElement.height() || null;
		//Only update scroll positioning if the node is not in view
		if(alwaysNavigate || !((nodeOffsetBottom - contentOffsetTop > 0) && (nodeOffsetBottom - contentOffsetTop <= contentHeight))){
			$contentElement.scrollTop((nodeOffsetTop - contentOffsetTop + $contentElement.scrollTop()) - ((contentHeight / 2) - $nodeRootElement.height() / 2));
		}
	}
};

/**
 * Function to find the node from Organizer tree which matches the navigation data
 * @param currentNode - current node - intially the organizer
 * @param currentString - contains the formation of ocids and label of the node
 * @param desiredString - which contains the formation of ocids and labels of the node navigates to
 */
StructureOrganizer.prototype.findNode = function(currentNode, currentString, desiredString) {
	if (desiredString === currentString) {
		return currentNode;
	} else {
		for (var i = 0; i < currentNode.getChildren().length; i++) {
			var childNode = currentNode.m_children[i];
			var node;
			//If the Node is not in its correct position in the cern-structure plugin tree, check children
			if(!childNode.inNavigationStructureTree()){
				node = this.findNode(childNode, currentString, desiredString);
			}
			else {
				var labelText = currentString + "label:" + childNode.m_title;
				var ocidText = childNode.m_ocid ? currentString + ", ocid:" + childNode.m_ocid : currentString;
				node = this.findNode(childNode, childNode.m_type === "groupbys" || childNode.m_type === "subgroupbys" || childNode.m_type === "subsections" ? labelText : ocidText, desiredString);
			}
			if (node) {
				return node;
			}
		}
		return null;
	}
};

/**
* returns the rendered root highlight element
* @returns(rootElement)- rendered Root Element
*/
StructureOrganizer.prototype.findRenderedRootHighlightElement = function(returnedNode) {
	if (returnedNode.getShouldRender()) {
		return returnedNode.getHighlightElement();
	}
	var rootElement = this.findRenderedRootHighlightElement(returnedNode.getParent());
	if (rootElement) {
		return rootElement;
	} else {
		return null;
	}
};

/**
 * Function to clear the highliter for the previous selected elements on navigation to structure view
 */
StructureOrganizer.prototype.clearHighlighter = function () {
	var node = this.m_previousHighlightedNode;
	if(node) {
		node.removeClass('highlight-navigation');
	}	
};

/**
 * Wraps the resize functionality of the structure organizer. It checks to see if the
 * consumer has provided a custom resize function. If so, call that function and pass the
 * necessary elements.
 */
StructureOrganizer.prototype.resize = function () {
	if (this.m_resizeFunction) {
		this.m_resizeFunction({
			"rootElement": this.getRootElement(),
			"navigatorElement": this.getNavigatorElement(),
			"contentElement": this.getContentElement()
		});
	}
};

/**
 * Returns the content element and caches it.
 * @returns {object} jQuery object of the content html element
 */
StructureOrganizer.prototype.getContentElement = function () {
	if (!this.m_contentElement) {
		this.m_contentElement = $("#" + this.getNamespace() + "\\:organizer\\:CONTENT\\:" + this.getId());
	}
	return this.m_contentElement;
};

/**
 * Returns the navigator object associated to the StructureOrganizer.
 * @returns {Navigator} the navigator object/model that represents the navigator pane
 */
StructureOrganizer.prototype.getNavigator = function () {
	return this.m_navigator;
};

/**
 * Sets the navigator object associated to the StructureOrganizer.
 * @param {Navigator} navigator - The navigator associated to the StructureOrganizer.
 */
StructureOrganizer.prototype.setNavigator = function (navigator) {
	if (!Navigator.prototype.isPrototypeOf(navigator)) {
		throw new Error("Attempted to call StructureOrganizer.prototype.setNavigator with invalid parameter.");
	}
	this.m_navigator = navigator;
	return this;
};

/**
 * This method performs the check to see if the StructureOrganizer is in a dirty state. The StructureOrganizer
 * is considered dirty when at least one child, or term, is dirty.
 * @returns {boolean} true, if the organizer is dirty
 */
StructureOrganizer.prototype.checkIsDirty = function () {
	var dirtyNodeList = this.getDirtyNodeList();
	for (var key in dirtyNodeList) {
		if (dirtyNodeList.hasOwnProperty(key)) {
			if (dirtyNodeList[key]) {
				return true;
			}
		}
	}
	return false;
};

/**
 * Overrides the base updateDirty method. If the dirty state of the organizer has changed, there is a callback
 * provided, and the organizer has at least 1 documented child, the m_onDirtyChangeCallback function is called.
 */
StructureOrganizer.prototype.updateDirty = function () {
	var wasDirty = this.m_dirty;
	this.m_dirty = this.checkIsDirty();
	if (wasDirty !== this.m_dirty && this.m_onDirtyChangeCallback) {
		this.m_onDirtyChangeCallback(this.m_dirty);
	}
	// clears the previous highlighted node when a change happen to the structure
	if(this.m_previousHighlightedNode) {
		this.clearHighlighter();
	}
};

/**
 * Returns a list of template ids associated with the StructureOrganizer.
 * @returns {List<string>} a list of ids of the templates associated with the organizer
 */
StructureOrganizer.prototype.getTemplateIds = function () {
	return this.m_templateIds;
};

/**
 * Sets the list of template ids associated with the StructureOrganizer.
 * @param {List<string>} templateIds - The list of template ids associated with the StructureOrganizer.
 */
StructureOrganizer.prototype.setTemplateIds = function (templateIds) {
	if (!Array.prototype.isPrototypeOf(templateIds)) {
		throw new Error("Attempted to call StructureOrganizer.prototype.setTemplateIds with invalid parameter");
	}
	this.m_templateIds = templateIds;
	return this;
};

/**
 * Returns the reference section id associated with the StructureOrganizer.
 * @returns {number} reference section id
 */
StructureOrganizer.prototype.getReferenceSectionId = function () {
	return this.m_referenceSectionId;
};

/**
 * Sets the reference section id associated with the StructureOrganizer.
 * @param {number} referenceId - The reference section id associated with the StructureOrganizer.
 */
StructureOrganizer.prototype.setReferenceSectionId = function (referenceId) {
	if (typeof referenceId !== "number") {
		throw new Error("Attempted to call StructureOrganizer.prototype.setReferenceSectionId with invalid parameter");
	}
	this.m_referenceSectionId = referenceId;
	return this;
};

/**
 * Helper method to parse a structure element id and obtain the node id.
 * @param {string} id - The DOM element id of the StructureNode to be parsed.
 * @returns {string} the node id
 */
StructureOrganizer.prototype.parseIdForLookup = function (id) {
	return id.split(":")[3];
};

/**
 * Adds a StructureNode (typically a StructureTerm) to a lookup hashmap.
 * @param {StructureNode} term - The StructureNode to be added to the lookup.
 */
StructureOrganizer.prototype.addTermToLookup = function (term) {
	this.getLookup()[term.getId()] = term;
};

/**
 * Returns the StructureNode lookup hashmap. This is a hashmap that maps the StructureNode id to the actual
 * StructureNode object.
 * @returns {Map<string, StructureNode>} a map of the node id to the node object
 */
StructureOrganizer.prototype.getLookup = function () {
	if (!this.m_lookup) {
		this.m_lookup = {};
	}
	return this.m_lookup;
};

/**
 * Overrides the base render method. This will render the StructureOrganizer object as an html string and return
 * the html.
 * @returns {string} the organizer rendered as html string
 */
StructureOrganizer.prototype.render = function (structureHtml) {
	var children = this.getChildren();
	var childrenCount = children.length;
	var namespace = this.m_namespace;
	var child = null;
	var childId = "";
	var tabDisplay = "";
	var id = this.getId();
	//If this is a multi-section node, the child sections (subsections) must be rendered into tabs.
	if(this.m_isMultiSection) {
		structureHtml.append("<div id='" + namespace + ":parentOrganizer:ROOT:" + this.getId() + "' class='structure-organizer-parent structure-multi-section'>");
		structureHtml.append("<div id='" + namespace + "StructureTabParent' class='structure-tab-parent'>");
		structureHtml.append("<div id='" + namespace + "StructureTabBlock' class='structure-tab-block'>");
		structureHtml.append("<div id='" + namespace + "StructureTabGroupWrapper' class='structure-tab-wrapper'>");
		//Tabs for each sub-section
		structureHtml.append("<ul id='" + namespace + "StructureTabGroup' class='structure-tab-group'>");
		for(var i = 0; i < childrenCount; i++) {
			child = children[i];
			childId = child.getId();
			structureHtml.append(
				"<li class='structure-tab'>" +
					"<span id='" + namespace + ":tab:" + childId + "' data-lookup='"+childId+"' class='structure-tab-display" + ((i === 0) ? " structure-tab-active" : "") + "' title='" + child.getTitle().replace(":", "") + "'>" + child.getTitle().replace(":", "") + "</span>" +
				"</li>"
			);
		}
		structureHtml.append("</ul></div><li id='" + namespace + "StructureTabMenuButton' class='structure-tab structure-add-tab'><span>&nbsp;</span></li></div><div class='structure-tab-bottom'></div></div>");
		structureHtml.append("<div id='" + namespace + "StructureTabContents' class='structure-tab-contents'>");
		//Loop through the sub-sections and create a tab container for each of them. Only the first is displayed.
		for(var i = 0; i < childrenCount; i++) {
			//Only show the first tab by default.
			if(i > 0) {
				tabDisplay = "style='display:none;'";
			}
			structureHtml.append("<div id='" + namespace + ":tabContent:" + children[i].getId() + "' class='structure-tab-content' "+tabDisplay+">");
			if(i === 0) {
				children[i].render(structureHtml, true);
				children[i].setIsRendered(true);
			}
			structureHtml.append("</div>");
		}
		structureHtml.append("</div>");
		structureHtml.append("</div>");
	} else {
		structureHtml.append("<div id='" + namespace + ":organizer:ROOT:" + id + "' class='structure-organizer' data-lookup='" + id + "'>" +
			"<div id='" + namespace + ":navigatorPanel:" + id + "' class='structure-navigator-panel'>" +
			"<div class='structure-navigator-label'>" + i18n.discernabu.mpage_structured_documentation.NAVIGATION + "</div>" +
			this.getNavigator().render() + "</div><div id='" + namespace + ":organizer:CONTENT:" + id + "' class='structure-body structure-section-body' data-lookup='" + id + "'>"
		);
		//Force the organizer to render all of the children
		for (var i = 0; i < childrenCount; i++) {
			children[i].render(structureHtml, true);
		}
		//Close off any remaining elements
		structureHtml.append("<div id='" + namespace + ":structureHeightAdjust:" + id + "' class='structure-height-adjust'></div></div></div>");
	}
	return structureHtml.getHtml();
};

/**
 * This function renders the StructureOrganizer as an HTML string.
 * @returns {string} The StructureOrganizer rendered as an HTML string.
 */
StructureOrganizer.prototype.renderHtml = function() {
	var html = new StructureHtml();
	this.render(html);
	return html.getHtml();
};

/**
 * This finalize method will attach the event handlers. This must be called after render.
 */
StructureOrganizer.prototype.finalize = function () {
	var now = new Date().getTime();
	var last = new Date().getTime();
	var threshold = 150; //(milliseconds)
	var self = this;
	var scrollTimeout = null;
	var groupInView = null;

	/**
	 * Helper function which attempts to find the group in view and activate it, if found.
	 */
	function attemptGroupActivation() {
		groupInView = self.findGroupInView();
		if (groupInView) {
			self.updateActiveGroup(groupInView);
		}
	}
	//If the section has subsections, finalize each of them separately
	if(this.m_isMultiSection) {
		var children = this.getChildren();
		var childrenCount = children.length;
		for(var i = 0; i < childrenCount; i++) {
			if(children[i].isRendered()) {
				children[i].finalize();
			}
		}
	} else {
		$("#" + this.getNamespace() + "\\:organizer\\:CONTENT\\:" + this.getId()).on("scroll", function () {
			now = new Date().getTime();
			if (scrollTimeout) {
				clearTimeout(scrollTimeout);
			}
			//Use a timeout to ensure that after scrolling has stopped, we perform at least one more update.
			scrollTimeout = setTimeout(function () {
				last = now;
				attemptGroupActivation();
			}, 200);
			//If we have hit our threshold, then process the scroll event. This throttles the event to prevent rapid
			//DOM querying.
			if ((now - last) >= threshold) {
				last = now;
				attemptGroupActivation();
			}
		});
		this.getNavigator().finalize();
		this.adjustContentHeight();
		//If the organizer has children, activate the first child (group).
		if (this.getChildren().length) {
			this.updateActiveGroup(this.getChildren()[0]);
		}
		//Perform any additional post-processing necessary
		this.performNodePostProcessing();
	}
};

/**
 * Perfoms post-processing on all organizer child nodes after node finalized
 * @return {undefined}
 */
StructureOrganizer.prototype.performNodePostProcessing = function () {
	var postProcess = function(node){
		if(node){
			node.postProcessing();
		}
		//Recursively process children
		var childNodes = node.getChildren();
		var childCnt = childNodes.length;
		for(var i = 0; i < childCnt; i++){
			postProcess(childNodes[i]);
		}
	}
	postProcess(this);
};

/**
 * This method will adjust the height of the content within the scrollable area to ensure that the last
 * group can scroll up to its header.
 */
StructureOrganizer.prototype.adjustContentHeight = function () {
	var groups = this.getChildren();
	if (!groups.length) {
		return;
	}
	var $contentElement = this.getContentElement();
	if(!$contentElement || !$contentElement.length) {
		return;
	}
	var rawContentElement = $contentElement[0];
	var contentHeight = rawContentElement.offsetHeight;
	var $heightAdjustElement = $("#" + this.getNamespace() + "\\:structureHeightAdjust\\:" + this.getId());
	var lastGroup = groups[groups.length - 1];
	var lastGroupHeight = lastGroup.getRootElement().height();
	var miscPadding = 12;
	$heightAdjustElement.height(Math.max(0, (contentHeight - lastGroupHeight) - miscPadding));
};

/**
 * This method will update the currently active group. It calls on the Navigator object to ensure the
 * navigation item corresponding to the group is highlighted.
 * @param {StructureGroup} group - The currently active group.
 */
StructureOrganizer.prototype.updateActiveGroup = function (group) {
	this.m_navigator.updateActiveNavigation(this.getNamespace() + ":structureNavigation:" + group.getId());
};

/**
 * This method will iterate over the groups (the children of the organizer) to determine which group is in view.
 * The logic assumes a viewport that is broken into 2 zones, an upper and lower zone. If the top of the group lies
 * within the upper zone, it is assumed to be in view. If the top of the group lies within the bottom zone, it is
 * then assumed that the group above it is in view. Finally, if the group encompasses the entire viewport (both the
 * upper and lower zones) it is also assumed to be in view.
 * @returns {StructureGroup} If a group is found to be in view, that group is returned. If no group is found,
 * null is returned.
 */
StructureOrganizer.prototype.findGroupInView = function () {
	var group = null;
	var rootGroupElement = null;
	var rootGroupTop = null;
	var groups = this.getChildren();
	var groupCount = groups.length;
	var $contentElement = this.getContentElement();
	var rawContentElement = $contentElement[0];
	var contentHeight = rawContentElement.offsetHeight;
	var contentTop = $contentElement.position().top;
	var totalContentHeight = rawContentElement.scrollHeight;
	var scrollPosition = rawContentElement.scrollTop;
	var scrollPercentage = scrollPosition / totalContentHeight;
	var groupInView = null;

	/**
	 * Helper function to check if groupTop lies between zoneTop and zoneBottom
	 * @param {Number} zoneTop - The top y position of the zone.
	 * @param {Number} zoneBottom - The bottom y position of the zone.
	 * @param {Number} groupTop - The y position of the top of the group.
	 * @returns {boolean} True if the groupTop lies between zoneTop and zoneBottom, otherwise false.
	 */
	function isWithinZone(zoneTop, zoneBottom, groupTop) {
		return groupTop >= zoneTop && groupTop <= zoneBottom;
	}

	/**
	 * Helper function to determine if a group takes up the entire zone.
	 * @param {Number} zoneTop - The top y position of the zone.
	 * @param {Number} zoneBottom - The bottom y position of the zone.
	 * @param {Number} groupTop - The top y position of the group.
	 * @param {Number} groupBottom - The bottom y position of the group.
	 * @returns {boolean} True if the group takes up the entire viewable area.
	 */
	function isCompletelyInView(zoneTop, zoneBottom, groupTop, groupBottom) {
		return groupTop <= zoneTop && groupBottom >= (zoneBottom - 12);
	}

	/**
	 * Helper function which performs the necessary boundary checks to see if a group is in view.
	 * @param {Number} index - The index in the list of groups at which we are checking.
	 * @returns {StructureGroup|false} - If the group at the specified index is in view, returns that group. Otherwise
	 * false is returned.
	 */
	function isGroupInView(index) {
		group = groups[index];
		rootGroupElement = group.getRootElement();
		rootGroupTop = rootGroupElement.position().top;
		if (isWithinZone(contentDimensions.midpoint, contentDimensions.bottom, rootGroupTop)) {
			return groups[i - 1];
		}
		if (isWithinZone(contentDimensions.top, contentDimensions.midpoint, rootGroupTop)) {
			return group;
		}
		if (isCompletelyInView(contentDimensions.top, contentDimensions.bottom, rootGroupTop, rootGroupTop + rootGroupElement.height())) {
			return group;
		}
		return null;
	}

	var contentDimensions = { top: contentTop, midpoint: (contentTop + contentHeight / 2), bottom: contentTop + contentHeight };

	for (var i = 0; i < groupCount; i++) {
		groupInView = isGroupInView(i);
		if (groupInView) {
			return groupInView;
		}
	}
	//If this is reached, no group was found (this should never occur)
	return null;
};

/**
 * Generates a JSON string representation of the activity data.
 *
 * @returns {string} a JSON string representation of the activity data that is safe and compatible with CCL.
 * Example:
 * section_act: {
 * 		"dd_section_id" : 123.0,
 * 		"dd_sref_section_id" : 456.0,
 *		"template_rltns" : [],
 		"subsections" : [],
 		"groupbys": []
 * }
 */
StructureOrganizer.prototype.convertToJSON = function () {
	var saveJSON = [];
	//Begin section json
	saveJSON.push('"section_act": {');

	var sectionJson = [];
	sectionJson.push('"dd_section_id": ' + this.getActivityId() + '.0');
	sectionJson.push('"dd_sref_section_id": ' + this.getReferenceSectionId() + '.0');

	//Add templates json
	var templateRelations = this.getTemplateRelations() || [];
	var templateRelationJSON = [];
	for (var i = 0; i < templateRelations.length; i++) {
		templateRelationJSON.push(
			'{' +
			'"dd_sref_chf_cmplnt_crit_id": ' + templateRelations[i].dd_sref_chf_cmplnt_crit_id + ".0" +
			',"dd_sref_templ_instance_ident": "' + templateRelations[i].dd_sref_templ_instance_ident + '"' +
			',"parent_entity_id": ' + templateRelations[i].parent_entity_id + ".0" +
			',"parent_entity_name": "' + templateRelations[i].parent_entity_name +
			'"}'
		);
	}
	//Push template relations JSON
	sectionJson.push('"template_rltns": [' + templateRelationJSON.join(',') + ']');

	this.addChildrenJSON(sectionJson);

	//If this is a subsection node, some additional fields must be populated. Furthermore, just short-circuit and
	//return the basic JSON. The parent section is responsible for packaging up the entire contents as the section_act
	//JSON.
	if(this.getType() === "subsections") {
		sectionJson.push('"parent_section_id": ' + this.getParent().getActivityId() + '.0');
		return '{' + sectionJson.join(',') + '}';
	}

	//Finalize and add in section json
	saveJSON.push(sectionJson.join(','));

	//End save json
	saveJSON.push('}');

	return saveJSON.join('');
};
/**
 * StructureGroup
 * This class represents the concept of a structure documentation group. It is simply a node which has child nodes.
 * @constructor
 */
function StructureGroup() {
}

StructureGroup.prototype = new StructureNode();
StructureGroup.prototype.constructor = StructureNode;

/**
 * This method retrieves the root element of the StructureGroup.
 * @returns {*|jQuery|HTMLElement}
 */
StructureGroup.prototype.getRootElement = function () {
	if (!this.m_rootElement) {
		this.m_rootElement = $("#" + this.getNamespace() + "\\:group\\:ROOT\\:" + this.getId());
	}
	return this.m_rootElement;
};

/**
 * Overrides the parent convertToJSON method.
 * @return {string} the save/activity JSON representation of the group.
 */
StructureGroup.prototype.convertToJSON = function () {
	var json = [];
	json.push('"dd_groupby_id": ' + this.getActivityId() + '.0');
	json.push('"label": "' + this.getTitle() + '"');
	json.push('"truth_state_mean": "T"');

	this.addChildrenJSON(json);

	return '{' + json.join(',') + '}';
};

/**
 * This method handles notification of a state change in a child node.
 * Updates the corresponding navigational item in the navigation pane to reflect the documented status of this StructureGroup.
 *
 * @param {StructureNode} node - The StructureNode child that is informing of a state change event.
 */
StructureGroup.prototype.notifyStateChange = function (node) {
	StructureNode.prototype.notifyStateChange.call(this, node);
	var navigationElement = $("#" + this.getNamespace() + "\\:structureNavigation\\:" + this.getId());
	if(this.getType() !== "groupbys") {
		return;
	}
	//If this is a top-level group and has children documented, add a documented class to the associated navigation
	//element, otherwise remove the documented class from the navigator element.
	(this.m_numberDocumented) && (navigationElement.addClass("navigation-documented")) || (navigationElement.removeClass("navigation-documented"));
};

/**
 * Overrides the base refresh method.
 */
StructureGroup.prototype.refresh = function () {
	if (this.getState() && this.getState().getValue()) {
		$("#" + this.getNamespace() + "\\:group\\:ROOT\\:" + this.getId()).addClass("documented");
	} else {
		$("#" + this.getNamespace() + "\\:group\\:ROOT\\:" + this.getId()).removeClass("documented");
	}
};

/**
 * Retrieve the children nodes that should be rendered on initial load
 * @return {Array<StructureNode>} Array of children nodes that should be rendered
 */
StructureGroup.prototype.getDefaultRenderChildren = function() {
	var children = this.getChildren();
	var childCnt = children.length;
	var defaultChildren = [];
	var child = null;
	// Gather child nodes that should be initially rendered
	for (var i = 0; i < childCnt; i++){
		child = children[i];
		if(child.isDefaultDisplayed()){
			defaultChildren.push(child);
		}
	}
	return defaultChildren;
};

/**
 * Handles rendering of children for StructureGroup objects. It determines the rendering strategy. Children should
 * either be rendered into columns, or simply rendered. This is to handle maximizing the use of the white-space and
 * ensure columns are created at the best level in the tree.
 * @param {StructureHtml } structureHtml - The structure html package object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureGroup.prototype.renderChildren = function (structureHtml, shouldRenderColumns) {
	var children = this.getDefaultRenderChildren();
	var childrenCount = children.length;
	//If columns should be created at this level in the tree, otherwise just render the children.
	if (shouldRenderColumns && childrenCount > 1) {
		var maxColumns = 3;
		var numberColumns = (childrenCount / maxColumns) >= 1 ? maxColumns : childrenCount;
		var childrenPerColumn = Math.floor(childrenCount / numberColumns);
		var remainingChildren = childrenCount % numberColumns;
		var currentIndex = 0;
		var columnWidth = (100 / numberColumns) + "%";
		//Distribute the children of the group evenly among the columns.
		for (var i = 0; i < numberColumns; i++) {
			structureHtml.append("<div class='structure-column' style='width: " + columnWidth + ";'>");          //Open column
			var numberToRender = remainingChildren ? (childrenPerColumn + 1) : childrenPerColumn;
			for (var j = 0; j < numberToRender; j++) {
				var child = children[j + currentIndex];
				//Don't create additional subcolumns for children
				child.render(structureHtml, false);
			}
			currentIndex = currentIndex + j;
			remainingChildren = Math.max(0, remainingChildren - 1);
			structureHtml.append("</div>");                                 //Close column
		}
	} else {
		for (var i = 0; i < childrenCount; i++) {
			//If only one column exists at current level, allow possibility of rendering columns for children
			children[i].render(structureHtml, shouldRenderColumns);
		}
	}
};

/**
 * Overrides the StructureNode render method. If this node is supposed to be rendered, it will render its necessary
 * html as well as the children html beneath it. Otherwise, it will bypass its own html and simply render its children.
 * @param {StructureHtml} structureHtml - The structure html packaged object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureGroup.prototype.render = function (structureHtml, shouldRenderColumns) {
	//If this node should render, render the header grouping, otherwise skip it
	//TODO: stop forcing groups to render when WK updates their content
	if (true || this.getShouldRender()) {
		structureHtml.append(
			"<div id='" + this.getNamespace() + ":group:ROOT:" + this.getId() + "' class='structure-group group expanded'>"+
			"<div class='structure-group-header'>" +
			"<div class='structure-group-title-wrapper'>" +
			"<span class='structure-group-title'>" + this.getTitle().replace(":", "") + "</span>" +
			"</div>" +
			"</div>" +
			"<div class='structure-group-children'>"
		);
	}
	this.renderChildren(structureHtml, shouldRenderColumns);
	// TODO: stop forcing groups to render when WK updates their content
	if (true || this.getShouldRender()) {
		structureHtml.append("</div></div>");
	}
};

/**
 *Checks whether the current Group node is expanded or not. 
 */
StructureGroup.prototype.isExpanded = function () {
	var root = this.getRootElement();
	return root.hasClass("expanded");
};

/*
 * Toggles the state of a html node between expand and collapse.
 */
StructureGroup.prototype.toggleExpand = function(){
	var root = this.getRootElement();
	var addRemoveClass = root.hasClass("expanded") ? {"add" : "collapsed", "remove" : "expanded"} : {"add" : "expanded", "remove" : "collapsed"};
    root.addClass(addRemoveClass.add).removeClass(addRemoveClass.remove);
    this.onToggleExpand();
};

/**
 * Method that gets executed when a group is expand toggled.  To be implemented by children.
 * @return {undefined}
 */
StructureGroup.prototype.onToggleExpand = function() {
	return;
};

/**
 * StructureItemGroup
 * This class represents a sub-level structure documentation group. Its function is almost exactly identical to
 * that of a StructureGroup but has slightly different html markup when rendered.
 * @constructor
 */
function StructureItemGroup() {
}
StructureItemGroup.prototype = new StructureGroup();
StructureItemGroup.prototype.constructor = StructureGroup;

/**
 * Overrides the parent convertToJSON method. This is the JSON used when saving.
 * @return {string} a save/activity JSON representation
 */
StructureItemGroup.prototype.convertToJSON = function () {
	var json = [];
	json.push('"dd_item_id": ' + this.getActivityId() + '.0');
	json.push('"ocid": "' + this.getOCID() + '"');
	json.push('"truth_state_mean": "T"');

	this.addChildrenJSON(json);

	return '{' + json.join(',') + '}';
};

/**
 * returns the root element from the node.
 * @returns {m_rootElement}
 */
StructureItemGroup.prototype.getRootElement = function() {
   if(!this.m_rootElement || !this.m_rootElement.length) {
      this.m_rootElement = $("#" + this.getNamespace() + "\\:group\\:ROOT\\:" + this.getId());
   }
   return this.m_rootElement;
};

/**
 * Overrides the StructureNode render method. If this node is supposed to be rendered, it will render its necessary
 * html as well as the children html beneath it. Otherwise, it will bypass its own html and simply render its children.
 * @param {StructureHtml} structureHtml - The structure html packaged object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureItemGroup.prototype.render = function (structureHtml, shouldRenderColumns) {
	if (this.getShouldRender()) {
		structureHtml.append(
				"<div id='" + this.getNamespace() + ":group:ROOT:" + this.getId() + "' class='structure-group item expanded'>" +
				"<div class='structure-group-header item'>" +
				"<span class='structure-component-toggle'></span>" +
				"<span class='structure-group-title'>" + this.getTitle().replace(":", "") + "</span>" +
				"</div>" +
				"<div class='structure-group-children'>"
		);
	}
	this.renderChildren(structureHtml, shouldRenderColumns);
	if (this.getShouldRender()) {
		structureHtml.append("</div></div>");
	}
};

/**
 * StructureSubGroup
 * This class represents a sub-level structure documentation group. Its function is almost exactly identical to
 * that of a StructureGroup but has slightly different html markup when rendered.
 * @constructor
 */
function StructureSubGroup() {
}
StructureSubGroup.prototype = new StructureGroup();
StructureSubGroup.prototype.constructor = StructureGroup;
/**
 * Overrides the parent convertToJSON method. This is the JSON used when saving.
 * @returns {string} a JSON representation of the activity data
 */
StructureSubGroup.prototype.convertToJSON = function () {
	var json = [];
	json.push('"dd_sgroupby_id": ' + this.getActivityId() + '.0');
	json.push('"label": "' + this.getTitle() + '"');
	json.push('"truth_state_mean": "T"');

	this.addChildrenJSON(json);

	return '{' + json.join(',') + '}';
};

/**
 * returns the root element from the node.
 * @returns {m_rootElement}
 */
StructureSubGroup.prototype.getRootElement = function() {
   if(!this.m_rootElement) {
      this.m_rootElement = $("#" + this.getNamespace() + "\\:subgroup\\:ROOT\\:" + this.getId());
   }
   return this.m_rootElement;
};

/**
 * Overrides the StructureNode render method. If this node is supposed to be rendered, it will render its necessary
 * html as well as the children html beneath it. Otherwise, it will bypass its own html and simply render its children.
 * @param {StructureHtml} structureHtml - The structure html packaged object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureSubGroup.prototype.render = function (structureHtml, shouldRenderColumns) {
	if (this.getShouldRender()) {
		structureHtml.append(
				"<div id='" + this.getNamespace() + ":subgroup:ROOT:" + this.getId() + "' class='structure-group sub-group expanded'>" +
				"<div class='structure-group-header'>" +
				"<span class='structure-group-title sub-group'>" + this.getTitle().replace(":", "") + "</span>" +
				"</div>" +
				"<div class='structure-group-children'>"
		);
	}
	this.renderChildren(structureHtml, shouldRenderColumns);
	if (this.getShouldRender()) {
		structureHtml.append("</div></div>");
	}
};
/**
 * A model that represents a group of StructureTerms.
 */
function StructureTermGroup() {
	this.m_activeTerm = null;
	this.m_previousActiveTerm = null;
	this.m_isShowMore = false; // Default to Show Less
	return this;
}
StructureTermGroup.prototype = new StructureGroup();
StructureTermGroup.prototype.constructor = StructureGroup;

/**
 * Gets the active term.
 * @returns {StructureTerm} the active term
 */
StructureTermGroup.prototype.getActiveTerm = function () {
	return this.m_activeTerm;
};
/**
 * Sets the active term.
 * @param {StructureTerm} activeTerm - the active term
 */
StructureTermGroup.prototype.setActiveTerm = function (activeTerm) {
	if (!StructureTerm.prototype.isPrototypeOf(activeTerm)) {
		throw new Error("Called setActiveTerm on StructureTermGroup with invalid activeTerm parameter.");
	}
	this.m_activeTerm = activeTerm;
	return this;
};

/**
 * Gets the previous active term.
 * @returns {StructureTerm} the active term
 */
StructureTermGroup.prototype.getPreviousActiveTerm = function () {
	return this.m_previousActiveTerm;
};
/**
 * Sets the previous active term.
 * @param {StructureTerm} activeTerm - the active term
 */
StructureTermGroup.prototype.setPreviousActiveTerm = function (activeTerm) {
	if (!StructureTerm.prototype.isPrototypeOf(activeTerm)) {
		throw new Error("Called setPreviousActiveTerm on StructureTermGroup with invalid activeTerm parameter.");
	}
	this.m_previousActiveTerm = activeTerm;
	return this;
};


/**
 * Returns a JSON string representation of the StructureTermGroup used for saving purposes
 * @returns {string} JSON string representation of the activity data
 */
StructureTermGroup.prototype.convertToJSON = function () {
	var json = [];
	json.push('"dd_attribute_id": ' + this.getActivityId() + '.0');
	json.push('"ocid": "' + this.getOCID() + '"');
	json.push('"truth_state_mean": "T"');

	this.addDescendentJSON(json);

	return '{' + json.join(',') + '}';
};

/**
 * Returns a Boolean indicating whether the term group is showing all terms
 * @return {Boolean} True iff the term group should be showing all terms
 */
StructureTermGroup.prototype.isShowMore = function() {
	return this.m_isShowMore;
};

/**
 * Sets the indicator for whether a term group should be displaying all terms
 * @param {Boolean} showMore True if all terms should be displayed, false if only prioritized terms should show
 */
StructureTermGroup.prototype.setIsShowMore = function(showMore) {
	if (typeof showMore !== "boolean") {
		throw new Error("Called setIsShowMore on StructureNode with invalid showMore paramater");
	}
	this.m_isShowMore = showMore;
};

/**
 * Returns a Boolean indicating whether or not this term group has previously shown all terms.
 * Utilized to avoid re-rendering if the unprioritized terms have previously been rendered
 * @return {Boolean} True if all terms have been previously displayed (Show More has been clicked)
 */
StructureTermGroup.prototype.hasShownMore = function(){
	return this.m_hasShownMore;
};

/**
 * Sets the indicator for whether a term group has previously displayed all terms
 * @param {Boolean} hasShownMore True if all terms have been displayed
 */
StructureTermGroup.prototype.setHasShownMore = function(hasShownMore){
	if (typeof hasShownMore !== "boolean") {
		throw new Error("Called setHasShownMore on StructureNode with invalid hasShownMore paramater");
	}
	this.m_hasShownMore = hasShownMore;
};

/**
 * Retrieves an array of StructureTerms with the given priority
 * @param  {Number} priority - The priority of terms to retireve
 * @return {Array<StructureTerm>} Array of StructureTerms with the given priority
 */
StructureTermGroup.prototype.getChildrenWithPriority = function(priority){
	var children = this.getChildren();
	var childrenWithPriority = [];
	childrenWithPriority = $.grep(children, (function(term, i){
		return term.getPriority && (term.getPriority() === priority);
	}));
	return childrenWithPriority;
};

/**
 * This method acts as a notification of a state change in a child node. Certain parent nodes need to know the
 * state of their children and perform actions accordingly. This base method simply keeps track of the number of
 * children nodes that are documented.
 * @param {StructureNode} node - The node that is informing of a state change event.
 */
StructureTermGroup.prototype.notifyStateChange = function (node) {
	StructureNode.prototype.notifyStateChange.call(this, node);
	this.handleTermActivity(node);
};

/*
 * Method to handle activity on a term group only if it has a None term as the first child and
 * if the current selected term has a valid state.
 * @param {StructureTerm} term - the term being switched to, or being selected
*/
StructureTermGroup.prototype.handleTermActivity = function (term) {	
	//Perform updates related to None-term functionality
	this.performNoneTermUpdates(term);
};

StructureTermGroup.prototype.performNoneTermUpdates = function (term) {
	var noneTerm = this.getNoneTerm();
	var freeTextTerms = null;
	var stateOfFreeText = null;
	var self = this;
	var noneTermHasValidState = null;
	// Don't perform any actions if none-term not found
	if (!noneTerm) {
		return;
	}
	noneTermHasValidState = noneTerm.getState() && noneTerm.getState().getValue();
	//If term other than none term has been documented, deactive the none term
	if (term !== noneTerm && term.getState() && term.getState().getValue() && noneTermHasValidState){
		noneTerm.deactivate();
	}
	else if (noneTermHasValidState){
		//Filter the free text object from the current term group
		//If free text object exists within the current active terms.
		//call the launchRemoveFreeTextWarning
		freeTextTerms = this.getActiveFreeTextTerm();
		if (!freeTextTerms.length) {//if free text object does not exist, just loop over all the active terms and deactivate them
			this.deactivateTerms();
		} else {
			var stateOfFreeText = freeTextTerms[0].getState().getValue();
			if (stateOfFreeText) {
				this.setPreviousActiveTerm(this.m_activeTerm);
				this.launchRemoveFreeTextWarning(function() {
					self.deactivateTerms();
				});
			}
		}	
	}
	this.m_activeTerm = term;
};

/**
 * Returns the number of document terms that are not currently being displayed due to prioritization
 * @return {Number} Number of undocumented terms that are not being displayed by default
 */
StructureTermGroup.prototype.getUnshownDocumentedCount = function() {
	var unshownChildren = this.getChildrenWithPriority(2);
	var unshownChildCnt = unshownChildren.length;
	var unshownDocumentedCount = 0;
	// Add up number of documented children for all unshown descendents
	for(var i = 0; i < unshownChildCnt; i++){
		var unshownChild = unshownChildren[i];
		//If term has children return number of documented children
		if(unshownChild.getChildren().length){
			unshownDocumentedCount += unshownChild.getNumberOfDocumentedChildren();
		}
		//Otherwise check if current term is documented
		else if(unshownChild.getState() && unshownChild.getState().getValue()){
			unshownDocumentedCount++;
		}
	}
	return unshownDocumentedCount;
};

/**
 * Updates the documented count for the term group
 * @return {undefined}
 */
StructureTermGroup.prototype.updateUnshownDocumentedCount = function() {
	var $undocumentedCount = this.getDocumentedCountContainer();
	var undocumentedCount = this.getUnshownDocumentedCount();
	// Display documented count when "Show Less" and has documented terms
	if (undocumentedCount && !this.isShowMore()){
		$undocumentedCount.html(undocumentedCount);
		$undocumentedCount.addClass("shown");
	}
	else {
		$undocumentedCount.empty();
		$undocumentedCount.removeClass("shown");
	}
};

/**
 * Returns the container for the documented count
 * @return {jQuery} jQuery element container of the documented
 */
StructureTermGroup.prototype.getDocumentedCountContainer = function() {
	if (!this.m_documentedCountContainer || !this.m_documentedCountContainer.length){
		this.m_documentedCountContainer = $("#documentedCountContainer" + this.getId());
	}
	return this.m_documentedCountContainer;
};


/**
 *Gets the currently active FreeText term in the section/term group. 
 */
StructureTermGroup.prototype.getActiveFreeTextTerm = function (term) {	
		var freeTextTerms = this.filterTerms(function(obj){
			return FreeTextStructureTerm.prototype.isPrototypeOf(obj) && obj.getState() ? obj.getState().getValue() !== null : false;
		});
		return freeTextTerms;
};

/**
 *Gets the none term from the current section/term group. 
 */
StructureTermGroup.prototype.getNoneTerm = function(term) {
	if (!this.m_noneTerm){
		this.m_noneTerm = this.filterTerms(function(obj){
			return NoneStructureTerm.prototype.isPrototypeOf(obj);
		})[0];
	}
	return this.m_noneTerm;
};
/**
 * Changes the state of all the active/documented terms in the group 
 * to undocumented by calling deactivate method on non input type terms and 
 * setting the current value of the free text term to  empty string.
 */
StructureTermGroup.prototype.deactivateTerms = function(){
	var activeTerms = this.filterTerms(function(obj) {
		return !NoneStructureTerm.prototype.isPrototypeOf(obj) && obj.getState() ? obj.getState().getValue() !== null : false;
	});
	for (var t = 0; t < activeTerms.length; t++) {
		var currentTerm = activeTerms[t];
		currentTerm.deactivate();
	}
};

/**
 * Method to filter terms based on the filter function provided. 
 */
StructureTermGroup.prototype.filterTerms = function(func) {
	if(typeof func !== "function") {
		throw new Error("Called filterTerms on the StructureTermGroup with an invalid callback function");
	}
	var terms = [];
	var childrenTerms = this.getAllDescendents([]);
	for(var i=0;i<childrenTerms.length;i++){
		if(func(childrenTerms[i])){
			terms.push(childrenTerms[i]);			
		}
	}
	return terms;
};

/**
 * Builds and launches a Modal Dialog that will act as a prompt when 
 * a active free text term is being cleared by clicking a None term. It prompts with two actions
 * 1. Remove to continue clearing the free text
 * 2. Cancel to prevent clearing of the free text and other active terms. 
 */
StructureTermGroup.prototype.launchRemoveFreeTextWarning = function(removeBtnClickFunc){
		
		if(typeof removeBtnClickFunc !== "function"){
			throw new Error("Called launchRemoveFreeTextWarning on the StructureTermGroup with an invalid callback function");
		}
		var self = this;
		var modalId = "removeFreeText" + this.getId();
		var cancelModalBtn = null;
		var removeModalBtn = null;
		var removeFreeTextModal = MP_ModalDialog.retrieveModalDialogObject(modalId);		
		if(!removeFreeTextModal){
			removeFreeTextModal = new ModalDialog(modalId);		
			removeFreeTextModal.setShowCloseIcon(false);
			removeFreeTextModal.setHeaderTitle(i18n.discernabu.mpage_structured_documentation.REMOVE_FREE_TEXT_HEADER);
			//Apply the proper margins for User informational messages
			removeFreeTextModal.setLeftMarginPercentage(35).setRightMarginPercentage(35).setTopMarginPercentage(20).setIsBodySizeFixed(false).setIsFooterAlwaysShown(true);
			//Create the modal remove button
			removeModalBtn = new ModalButton("removeModal");
			removeModalBtn.setFocusInd(true).setCloseOnClick(true);
			removeModalBtn.setOnClickFunction(removeBtnClickFunc);			
			removeModalBtn.setText(i18n.discernabu.mpage_structured_documentation.REMOVE);
			removeFreeTextModal.addFooterButton(removeModalBtn);		
			//Create the modal cancel button
			cancelModalBtn = new ModalButton("cnlModal");
			cancelModalBtn.setText(i18n.discernabu.mpage_structured_documentation.CANCEL);
			
			cancelModalBtn.setOnClickFunction(function(){
				self.cancelFreeTextBtnCallback();
			});			
			removeFreeTextModal.addFooterButton(cancelModalBtn);			
			removeFreeTextModal.setBodyDataFunction(function(modalObj){
					modalObj.setBodyHTML("<div class='structure-remove-free-text-warning'><span>"+i18n.discernabu.mpage_structured_documentation.REMOVE_FREE_TEXT_WARNING+"</span>" + "</div>");
			});			
			MP_ModalDialog.addModalDialogObject(removeFreeTextModal);
		}					
		MP_ModalDialog.showModalDialog(modalId);
};

/**
 * Handles canceling a remove free text action
 * @return {[type]} [description]
 */
StructureTermGroup.prototype.cancelFreeTextBtnCallback = function(){
	var modalId = "removeFreeText" + this.getId();
	this.getActiveTerm().jumpToState(0);
	this.setActiveTerm(this.getPreviousActiveTerm());
	MP_ModalDialog.closeModalDialog(modalId);
	MP_ModalDialog.deleteModalDialogObject(modalId);
};

/**
 * Overrides the StructureNode render method. If this node is supposed to be rendered, it will render its necessary
 * html as well as the children html beneath it. Otherwise, it will bypass its own html and simply render its children.
 * @param {StructureHtml} structureHtml - The structure html packaged object.
 * @param {boolean} shouldRenderColumns - If this node should render columns.
 */
StructureTermGroup.prototype.render = function (structureHtml, shouldRenderColumns) {
	if (this.getShouldRender()) {
		structureHtml.append(
				"<div id='" + this.getNamespace() + ":group:ROOT:" + this.getId() + "' class='structure-group item expanded'>" +
				"<div class='structure-group-header item'>" +
				"<span class='structure-group-title'>" + this.getTitle() + "</span>" +
				"</div>" +
				"<div class='structure-group-children'>"
		);
	}
	this.renderChildren(structureHtml, shouldRenderColumns);
	if (this.getShouldRender()) {
		//Handle rendering Show More link/Unprioritized terms if necessary
		structureHtml.append("</div>");
		this.renderShowMore(structureHtml);
		structureHtml.append("</div>");
	}
};

/**
 * Renders the 'Show More' link html as well as unprioritized API terms if the 
 * current term group should show more terms
 * @param  {StructureHtml} structureHtml - The structure html package object
 */
StructureTermGroup.prototype.renderShowMore = function(structureHtml){
	var docI18n = i18n.discernabu.mpage_structured_documentation;
	var organizer = this.getOrganizer();
	if (organizer.isPriorityEnabled()){
		var showMoreText = docI18n.SHOW_MORE;
		// Display link only when unprioritized terms exist
		if(this.getChildrenWithPriority(2).length){
			structureHtml.append("<div class='show-more-link-container'><a id='showMoreLink" + this.getId() + "' class='show-more-link'>" + showMoreText + "</a>" + "<div id='documentedCountContainer" + this.getId() + "' class='documented-count'></div></div>");
		}		
	}
	else{
		//All terms are shown if API prioritization is off
		this.setIsShowMore(true);
	}
};

StructureTermGroup.prototype.getUnprioritizedContentContainer = function() {
	if (!this.m_unprioritizedContent || !this.m_unprioritizedContent.length){
		this.m_unprioritizedContent = $("#unprioritizedContent" + this.getId());
	}
	return this.m_unprioritizedContent;
};

StructureTermGroup.prototype.getShowMoreLinkContainer = function() {
	if (!this.m_showMoreLinkContainer || !this.m_showMoreLinkContainer.length){
		this.m_showMoreLinkContainer = $("#showMoreLink" + this.getId());
	}
	return this.m_showMoreLinkContainer;
};
/**
 * Displays all terms in the term group independent of priority
 */
StructureTermGroup.prototype.showMore = function () {
	var docI18n = i18n.discernabu.mpage_structured_documentation;
	var $root = $(this.getRootElement());
	var $unprioritizedTerms = this.getUnprioritizedContentContainer();
	var defaultRenderedChildren = this.getDefaultRenderChildren();
	var defaultChildrenLen = defaultRenderedChildren.length;
	var lastTerm = defaultChildrenLen ? defaultRenderedChildren[defaultChildrenLen-1] : null;
	var $lastTerm =  null;
	
	if (lastTerm){
		$lastTerm = $(lastTerm.getRootElement());	
	}
	if($root.length){
		if (this.hasShownMore()){
			$unprioritizedTerms.show();
		}
		else{		
			var structureHtml = new StructureHtml();
			this.renderUnprioritizedSectionHtml(structureHtml);
			if($lastTerm && $lastTerm.length){
				$lastTerm.after(structureHtml.getHtml());
			}
			else{				
				$root.find('.structure-group-children').prepend(structureHtml.getHtml());
			}
			this.setHasShownMore(true);
		}	
		this.getShowMoreLinkContainer().text(docI18n.SHOW_LESS);
		this.setIsShowMore(true);
	}
};

/**
 * Hides unprioritized (priority 2) terms within the term group
 */
StructureTermGroup.prototype.showLess = function () {
	var docI18n = i18n.discernabu.mpage_structured_documentation;
	var $unprioritizedTerms = this.getUnprioritizedContentContainer();

	$unprioritizedTerms.hide();
	this.getShowMoreLinkContainer().text(docI18n.SHOW_MORE);
	this.setIsShowMore(false);
	var organizer = this.getOrganizer();
	//Navigate to node if out of view
	organizer.goToNode(this, false);
};

/**
 * Toggles whether all terms are shown or only prioritized terms
 */
StructureTermGroup.prototype.toggleShowMore = function () {
	if (this.isShowMore()){
		this.showLess();
	}
	else{
		this.showMore();
	}
	//Update whether or not the documented count is displayed
	this.updateUnshownDocumentedCount();
};

/**
 * Renders the section containing unprioritized (priority 2) API terms when all terms should be shown
 * @param  {StructureHtml} structureHtml - The structure html package object
 */
StructureTermGroup.prototype.renderUnprioritizedSectionHtml = function(structureHtml){
	var children = this.getChildrenWithPriority(2);
	var childrenCnt = children.length;
	var hasOtherShownClass = "";
	if (childrenCnt !== this.getChildren().length){
		hasOtherShownClass = "structured-has-shown-terms";
	}
	if(childrenCnt){
		structureHtml.append("<div id='unprioritizedContent" + this.getId() + "' class='unprioritized-terms " + hasOtherShownClass + "'>");

		for (var i = 0; i < childrenCnt; i++){
			children[i].render(structureHtml, false);
		}
		structureHtml.append("</div>");
	}
};


/**
 * A model that represents a group of terms that is single-select.
 */
function SingleStructureTermGroup() {
}
SingleStructureTermGroup.prototype = new StructureTermGroup();
SingleStructureTermGroup.prototype.constructor = StructureTermGroup;

/**
 * Handles additional process on the group when the user chooses a different term in the term group.
 * @param {StructureTerm} term - the term being switched to, or being selected
 */
SingleStructureTermGroup.prototype.handleTermActivity = function (term) {
	StructureTermGroup.prototype.handleTermActivity.call(this, term);
	var isValidState = term.getState().getValue();
	var self = this;
	var freeTextTerm = this.getActiveFreeTextTerm();
	if(isValidState) {
		if (term !== this.m_activeTerm && this.m_activeTerm) {
			if(freeTextTerm.length && freeTextTerm[0] === this.m_activeTerm) {
				this.setPreviousActiveTerm(this.m_activeTerm);		
				self.launchRemoveFreeTextWarning(function() {
					freeTextTerm[0].deactivate();
				});
			} else {
				this.m_activeTerm.deactivate();		
			}
		}
		this.m_activeTerm = term;	
	}
};

/**
 * Clears only this SingleStructureTermGroup by resetting its active term to null.
 */
SingleStructureTermGroup.prototype.clearSelf = function () {
	StructureTermGroup.prototype.clearSelf.call(this);
	this.m_activeTerm = null;
};

/**
 * A model that represents a multi-select group of terms
 */
function MultiStructureTermGroup() {
}
MultiStructureTermGroup.prototype = new StructureTermGroup();
MultiStructureTermGroup.prototype.constructor = StructureTermGroup;

/**
 * A model that represents a group of Yes/No terms
 */
function YesNoStructureTermGroup() {
}
YesNoStructureTermGroup.prototype = new StructureTermGroup();
YesNoStructureTermGroup.prototype.constructor = StructureTermGroup;

/**
 * A model that represents a table containing multiple cycle terms.
 * Inherits from SingleStructureTermGroup for allowing only a single child term to be selected at time.
 * Inherits CycleStructureterm methods for allowing 'states' and 'comments' and other AMI functionality
 */
function TableStructureTermGroup() {
	this.m_comment = "";						//Ensure no comment is associated by default
	this.m_inNavigateStructureTree = false; 	// Don't search for Table node when searching tree from cern-structured
	this.m_shouldSave = false;					// Table grouping terms are not saved.  Child terms are saved.
	SingleStructureTermGroup.call(this);
	CycleStructureTerm.call(this);
}

TableStructureTermGroup.prototype = new SingleStructureTermGroup();
TableStructureTermGroup.prototype.constructor = TableStructureTermGroup;
JSONStructureOrganizerBuilder.extendClassMethods(TableStructureTermGroup, CycleStructureTerm, ["setCaption", "getCaption", "addState", "getCurrentState", "setCurrentState", "getStates", "cycleState", "jumpToState", "deactivate", "refresh", "getComment", "setComment", "setSavedComment", "buildTextArea", "displayComment", "checkIsDirty", "getRootElement", "getSavedComment", "resetDirty", "setPriority", "getPriority", "setUIValue", "getUIValue", "displayNode", "isDefaultDisplayed", "isCurrentlyDisplayed"]);

/**
 * Overrides checkIsDirty to ensure that the TableStructureTermGroup isn't marked as dirty. Only child terms can be dirty.
 * @return {Boolean}  False as "TABLE" alone cannot be dirty
 */
TableStructureTermGroup.prototype.checkIsDirty = function () {
	return false;
};

/**
 * Returns JSON representation of TableStructureTerm.  Doesn't return JSON as the "TABLE" term is not saved (only child terms are).
 * @return {undefined}
 */
TableStructureTermGroup.prototype.convertToJSON = function() {
	return;
};

/**
 * Override default render method to render out table group.
 * Handles rendering child terms and associated comment.
 * @param  {StructureHtml} structureHtml The StructureHtml object to append "html" string to
 * @return {undefined} 
 */
TableStructureTermGroup.prototype.render = function(structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";
	// create a comment section when the term has a comment and the term is documented
	if(this.getComment()) {
		commentHTML = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		commentClass = "comment"+ " ";
	}
	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item table-group-term " + commentClass + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			"<span class='structure-term-title'>" + this.getTitle() + "</span>" +
			"<span class='structure-comment'>&nbsp;</span>" + 
			"</div>" +
			"<div class='structure-table-group-terms'>"
	);
	this.renderChildren(structureHtml, false);
	structureHtml.append("</div>"  + commentHTML + "</div>");
};


/**
 * Handles additional process on the group when the user chooses a different term in the term group.
 * Updates styling of the table appropriately.
 * @param {StructureTerm} term - the term being switched to, or being selected
 */
TableStructureTermGroup.prototype.handleTermActivity = function (term) {
	SingleStructureTermGroup.prototype.handleTermActivity.call(this, term);
	var activeTerm = this.getActiveTerm();
	var termGroupState = activeTerm ? activeTerm.getState() : null;
	if (termGroupState){
		//Use the active child term's state if present
		this.updateState(termGroupState);		
	}
	else{
		//If no active term, use default undocumented state
		this.jumpToState(0);
	}
	this.refresh();
};


/**
 * Override notifyStateChange to notify parent group of updated child terms.
 * This is used so that the parent group can handle Single Select and None terms.
 * @param  {SturctureNode} node The StructureNode that has been updated
 * @return {undefined}
 */
TableStructureTermGroup.prototype.notifyStateChange = function(node) {
	StructureTermGroup.prototype.notifyStateChange.call(this, node);
	if (this.getParent()){
		this.getParent().notifyStateChange(node);
	}
};


/**
 * Overriding updateState as to not trigger parent notification on updates
 * @param {TermState} state - The state the StructureNode should be updated to.
 */
TableStructureTermGroup.prototype.updateState = function (state) {
	var currentState = this.getState();
	if (state !== currentState) {
		this.setState(state);
		this.setPreviousState(currentState);
	}
	// refresh anyways, something else (like whether the node is valid) may have changed while keeping the state the same
	this.refresh();
};

/**
 * Overriding clearSelf to ensure that both state is updated for both active term and styling
 * @return {undefined}
 */
TableStructureTermGroup.prototype.clearSelf = function() {
	SingleStructureTermGroup.prototype.clearSelf.call(this);
	CycleStructureTerm.prototype.clearSelf.call(this);
};

/**
 * A model that represents the expand attribute menu item. It functions likes a TermGroup 
 * and has children terms grouped together. 
 * Inherits attribute level grouping logic from StructureTermGroup
 * Extends some methods from the CycleStructureTerm model in order to perform interactive term(AMI) level functionality 
 * and TableStructureTermGroup model which overrides parent (attribute level) term group logic.
 * @constructor
 */
function ExpandStructureTermGroup() {
	this.m_inNavigateStructureTree = false; 	// Don't search for Table node when searching tree from cern-structured
	this.m_shouldSave = false;
	StructureTermGroup.call(this);
	CycleStructureTerm.call(this);
}
ExpandStructureTermGroup.prototype = new StructureTermGroup();
ExpandStructureTermGroup.prototype.constructor = ExpandStructureTermGroup;
JSONStructureOrganizerBuilder.extendClassMethods(ExpandStructureTermGroup, CycleStructureTerm, ["setCaption", "getCaption", "addState", "getCurrentState", "setCurrentState", "getStates", "cycleState", "jumpToState", "deactivate", "refresh", "checkIsDirty", "getRootElement", "resetDirty", "setPriority", "getPriority","displayNode", "isDefaultDisplayed", "isCurrentlyDisplayed","setUIValue", "getUIValue","postProcessing"]);
JSONStructureOrganizerBuilder.extendClassMethods(ExpandStructureTermGroup, TableStructureTermGroup, ["convertToJSON", "updateState", "notifyStateChange", "checkIsDirty"]);

/**
 * Overrides the base StructureTermGroup render method. It renders the ExpandStructureTermGroup object as an html string
 * and appends it to the structure html parameter.
 * @param {StructureHtml} structureHtml Ta- A StructureHtml package object. All html shall be appended to this object.
 */
ExpandStructureTermGroup.prototype.render = function (structureHtml) {	
	structureHtml.append(
			"<div class ='structure-group expand-group collapsed' id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "'>" +
			"<div class ='structure-group-header'> " + 
			"<span class='structure-component-toggle'></span>" +
			"<span class='structure-group-title' title ='"+this.getCaption()+"'>"+ this.getTitle() + "</span>" +
			"<div id='documentedExpandCountContainer" + this.getId() + "' class='documented-count'></div></div>" +
			"<div class='structure-group-children'>"
			);
	// passing false to make sure it does not create a new column for the children
	this.renderChildren(structureHtml, false); 	
	if (this.getShouldRender() && this.getDefaultRenderChildren() !== this.getChildren()) {
		//Handle rendering Show More link/Unprioritized terms if necessary		
		this.renderShowMore(structureHtml);		
	}
	structureHtml.append("</div></div>");
};

/**
 * Overrides the base getDefaultRenderChildren method and returns all the children with the priority 2 
 * if there only priortiy 2 terms. If it contains a mixture of both priorities, it returns only priority 1 terms.
 */
ExpandStructureTermGroup.prototype.getDefaultRenderChildren = function(){
	var defaultRenderedChildren = StructureGroup.prototype.getDefaultRenderChildren.call(this);
	if(!defaultRenderedChildren.length){
		defaultRenderedChildren = this.getChildren();
		this.setIsShowMore(true);
	}
	return defaultRenderedChildren;
};



/**
 * Updates the count displayed next to the expand title
 * @return {undefined}
 */
ExpandStructureTermGroup.prototype.updateExpandDocumentedCount = function() {
	var $documentedCntContainer = this.getDocumentedExpandCountContainer();
	var documentedCnt = this.getNumberOfDocumentedChildren();
	// Don't display count if no documented terms within or if expanded
	if (this.isExpanded() || !documentedCnt){
		$documentedCntContainer.empty();
		$documentedCntContainer.removeClass("shown");
	}
	else{
		$documentedCntContainer.html(documentedCnt);
		$documentedCntContainer.addClass("shown");
	}
};

/**
 * Returns the container for the expand documented count
 * @return {jQuery} jQuery element container of the expand documented count
 */
ExpandStructureTermGroup.prototype.getDocumentedExpandCountContainer = function() {
	if (!this.m_documentedExpandCountContainer || !this.m_documentedExpandCountContainer.length){
		this.m_documentedExpandCountContainer = $("#documentedExpandCountContainer" + this.getId());
	}
	return this.m_documentedExpandCountContainer;
};

/**
 * Override onToggleExpand to update the documented count next to expand (displays only when collapsed and documented terms present)
 * @return {undefined}
 */
ExpandStructureTermGroup.prototype.onToggleExpand = function() {
	this.updateExpandDocumentedCount();
};
/**
 * The TermState object
 * @return {TermState} returns self to allow chaining
 * @constructor
 * @author Will Reynolds
 */
function TermState() {
	this.m_value = null;                          //The state value (true / false / null)
	this.m_cssClass = "";                         //The associated css class for the state (not always necessary)
	this.m_key = "";                              //An identifier for the state ("NEUTRAL", "NULL", "TRUE", "FALSE")
	this.m_data = {};                             //Any additional data can be stored in the state
	return this;                                //Return a reference to self so you can do constructor chaining
}

/**
 * Get the state value (true / false / null)
 * @return {*} returns the value of the state, either (true / false / null)
 */
TermState.prototype.getValue = function () {
	return this.m_value;
};

/**
 * Sets the value of the state, either (true / false / null)
 * @param value the value of the state
 * @return {TermState} returns self.
 */
TermState.prototype.setValue = function (value) {
	this.m_value = value;
	return this;
};

/**
 * Gets the CSS class for the state (if any). This is used for StructureTerm objects as they have styling based
 * on which state they are in.
 * @return {string} the css class associated with the state.
 */
TermState.prototype.getCSSClass = function () {
	return this.m_cssClass;
};

/**
 * Sets the CSS class for the state (if any). This is used for StructureTerm objects as they have styling based
 * on which state they are in.
 * @param cssClass the css class associated with the state (if any).
 * @return {TermState} returns self
 */
TermState.prototype.setCSSClass = function (cssClass) {
	if(typeof cssClass !== "string") {
		throw new Error("Attempted to call TermState.prototype.setCSSClass with invalid parameter.");
	}
	this.m_cssClass = cssClass;
	return this;
};

/**
 * Get the state key. This is a string identifier for the state.
 * @return {string} the string identifier for the state.
 */
TermState.prototype.getKey = function () {
	return this.m_key;
};

/**
 * Set the state key. This is a string identifier for the state.
 * @param key the string identifier for the state.
 * @return {TermState} returns self.
 */
TermState.prototype.setKey = function (key) {
	this.m_key = key;
	return this;
};

/**
 * Gets the data package tied to the state. This is not always necessary.
 * @return {Object} a JSON data package tied to the state.
 */
TermState.prototype.getData = function () {
	return this.m_data;
};

/**
 * Sets the data package tied to the state. This is not always necessary.
 * @param data the JSON data package tied to the state.
 * @return {TermState} returns self.
 */
TermState.prototype.setData = function (data) {
	this.m_data = data;
	return this;
};

/**
 * Adds a piece of data to the JSON data package tied to the state.
 * @param key the key value in which to store the new data.
 * @param dataPack the piece of data to be added into the state data at the key value. (ex. { key : dataPack })
 * @return {TermState} returns self.
 */
TermState.prototype.addData = function (key, dataPack) {
	this.m_data[key] = dataPack;
	return this;
};

/**
 * Get a piece of data at the key value.
 * @param key the key at which to obtain the data. (ex. { key : value}). You are retrieving value.
 * @return {Object} the data at the key value.
 */
TermState.prototype.getDataValue = function (key) {
	if (!this.m_data[key]) {
		this.m_data[key] = {};
	}
	return this.m_data[key];
};
/**
 * StructureTerm
 * The base StructureTerm object. This represents the individual answers users can interract with inside
 * structured documentation. Any new answer types should inherit from this base class.
 * @returns {StructureTerm}
 * @constructor
 */
function StructureTerm() {
	this.m_caption = "";
	this.m_comment = "";
	//stores already saved comment
	this.m_savedComment = "";
	return this;
}

StructureTerm.prototype = new StructureNode();
StructureTerm.prototype.constructor = StructureNode;

/**
 * Gets the comment of the StructureTerm.
 * @returns {string}
 */
StructureTerm.prototype.getComment = function () {
	return this.m_comment;
};

/**
 * Sets the comment of the StructureTerm.
 * @param {string} comment - The comment of the StructureTerm.
 * @returns {StructureTerm}
 */
StructureTerm.prototype.setComment = function (comment) {
	if (typeof comment !== "string") {
		throw new Error("Attempted to call StructureTerm.prototype.setComment with invalid parameter.");
	}
	this.m_comment = comment;
	return this;
};

/**
 * Returns the priority of a StructureTerm (API)
 * @return {Number} 1 - If term should be shown, 2 - If should be hidden on initial load
 */
StructureTerm.prototype.getPriority = function () {
	return this.m_priority;
};

/**
 * Returns whether or not a term is shown by default based on its priority
 * @return {Boolean} True iff the term should be shown by default
 */
StructureTerm.prototype.isDefaultDisplayed = function () {
	var DONT_SHOW_PRIORITY = 2;
	var priority = this.getPriority();
	var organizer = this.getOrganizer();
	//Always display if AMI prioritization is off
	if(organizer && organizer.isPriorityEnabled()){
		//Default terms to be displayed if priority not 2
		return ( priority === DONT_SHOW_PRIORITY) ? false : true;
	}
	else{
		return true;
	}
};

/**
 * Returns whether or not the term is currently displayed based on API prioritization or whether it is already displayed
 * @return {Boolean} True iff the term is currently displayed on the page
 */
StructureTerm.prototype.isCurrentlyDisplayed = function() {
	var termGroup = this.getParent();
	var DONT_SHOW_PRIORITY = 2;
	var priority = this.getPriority();	
	//Validates on the parent's visibility or its siblings based on the value returned by isCurrentlyDisplayed or showMore of the parent. 	
	//For terms within an expand, checks whether the expanded it is expanded or collapsed.
	if ((StructureTermGroup.prototype.isPrototypeOf(termGroup) && 
		(!termGroup.isCurrentlyDisplayed() || !termGroup.isShowMore()) && 
			priority === DONT_SHOW_PRIORITY)|| 
			(ExpandStructureTermGroup.prototype.isPrototypeOf(termGroup) && !termGroup.isExpanded())){
		return false;
	}
	else{
		return true;
	}
};

/**
 * Ensure that the current node is displayed by displaying hidden unprioritized nodes.
 * @return {[type]} [description]
 */
StructureTerm.prototype.displayNode = function() {
	var termGroup = this.getParent();
	if (StructureTermGroup.prototype.isPrototypeOf(termGroup) && !termGroup.isShowMore()) {
		termGroup.toggleShowMore();
	}
	if (!termGroup.isCurrentlyDisplayed()) {
		termGroup.displayNode();
	}
	if (ExpandStructureTermGroup.prototype.isPrototypeOf(termGroup) && !termGroup.isExpanded()) {
		termGroup.toggleExpand();
	}
};

/**
 * Ensure that the node is displayed after postProcessing is completed
 * @return {undefined}
 */
StructureTerm.prototype.postProcessing = function () {
	var node = this;
    // If there is documented value for a term, ensure it is displayed
    if (node.getState() && node.getState().getValue() && !node.isCurrentlyDisplayed()){
    	node.displayNode();
    }
};

/**
 * Sets the priority of the structure term 
 * @param {Number} priority The priority to set the API term as
 */
StructureTerm.prototype.setPriority = function (priority) {
	if (typeof priority !== "number") {
		throw new Error("Attempted to call StructureTerm.prototype.setPriority with invalid paramater.");
	}
	this.m_priority = priority;
};

/**
 * Sets the UI Value of the structure term (e.g. Expand/Table)
 * @param {String} uiValue The UI value to be associated with the structure term
 */
StructureTerm.prototype.setUIValue = function(uiValue){
	this.m_uiValue = uiValue;
};

/**
 * Returns the UI value associated to the structure term
 * @return {String} The term's associated UI value
 */
StructureTerm.prototype.getUIValue = function() {
	return this.m_uiValue;
};

/**
 * Gets the comment of the StructureTerm.
 * @returns {string}
 */
StructureTerm.prototype.getSavedComment = function () {
	return this.m_savedComment;
};

/**
 * Sets the comment of the StructureTerm.
 * @param {string} comment - The comment of the StructureTerm.
 * @returns {StructureTerm}
 */
StructureTerm.prototype.setSavedComment = function (comment) {
	if (typeof comment !== "string") {
		throw new Error("Attempted to call StructureTerm.prototype.setComment with invalid parameter.");
	}
	this.m_savedComment = comment;
	return this;
};

/**
 * Builds the text area
 * @returns {HTML String}- raw HTMl string of the text area
 */	
StructureTerm.prototype.buildTextArea = function() {
	var textArea = "<textarea id='" + "comment" + this.getNamespace() + this.getId() + "' class='term-textarea textarea-fill' type='text' title='Add Comment' placeholder='Add Comment'>" + this.getComment() + "</textarea>";
	return textArea;
};

/**
 * Displays comment for the term
 * @param {string} comment - The comment of the StructureTerm.
 */
StructureTerm.prototype.displayComment = function(comment) {
	// validates the comment received and covert them to the actual text
	var validatedComment = comment ? this.unescapePlaintextAsHtml(comment) : comment + "";
	// sets comment to the term
	this.setComment(validatedComment);
	this.setSavedComment(validatedComment);
	//builds the comment section with comment
	var termContainer = this.getRootElement();
	var commentSection = termContainer.children("div.structure-term-comment-wrapper");
	//checks if the comment section is not already build then build the comment section
	if (termContainer.length > 0 && commentSection.length < 1) {
		commentSection = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		termContainer.append(commentSection);
	}
	termContainer.addClass("comment");
};
	
/**
 * Gets the caption (html title) of the StructureTerm.
 * @returns {string}
 */
StructureTerm.prototype.getCaption = function () {
	return this.m_caption;
};

/**
 * Sets the caption (html title) of the StructureTerm.
 * @param {string} caption - The html title of the StructureTerm.
 * @returns {StructureTerm}
 */
StructureTerm.prototype.setCaption = function (caption) {
	if (typeof caption !== "string") {
		throw new Error("Attempted to call StructureTerm.prototype.setCaption with invalid parameter.");
	}
	this.m_caption = caption;
	return this;
};

/**
 * Returns a JSON string representation of the StructureTerm used for saving purposes
 * @returns {string}
 */
StructureTerm.prototype.convertToJSON = function () {
	var comment = this.getComment();
	var json = [];
	json.push('"dd_attr_menu_item_id": ' + this.getActivityId() + '.0');
	json.push('"ocid": "' + this.getOCID() + '"');
	json.push('"display_seq": ' + this.getDisplayPosition());
	json.push('"truth_state_mean": "' + ((this.getState().getValue()) ? "T" : "F") + '"');
	json.push('"comment": "' 
		//escape special characters in comment
		+ (comment ? this.escapePlaintextAsHtml(comment) : comment) 
		+ '"');
	json.push('"comment_format_mean": "XHTML"');
	json.push('"value_text": ""');
	json.push('"value_text_format_mean": "XHTML"');
	json.push('"value_number": 0.0');

	return '{' + json.join(',') + '}';
};


/**
 * Updates the StructureTerm to the specified state.
 * @param {TermState} state - The state the StructureTerm is in.
 */
StructureTerm.prototype.updateState = function (state) {
	StructureNode.prototype.updateState.call(this, state);
	this.updateDirty();
};

/**
 * returns the root element from the node.
 * @returns {m_rootElement}
 */
StructureTerm.prototype.getRootElement = function() {
   if(!this.m_rootElement || !this.m_rootElement.length) {
      this.m_rootElement = $("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId());
   }
   return this.m_rootElement;
};

/**
 * Performs a check to see if the StructureTerm is considered dirty. This simply checks if the
 * current state is not equal to the initial state.
 * @returns {boolean}
 */
StructureTerm.prototype.checkIsDirty = function () {
	return this.getState() !== this.getInitialState();
};

/**
 * Updates the dirty state of the StructureTerm. First, we set the dirty state based on the check
 * for dirty. After this occurs, a dirty class is added to the structure term root level. Finally,
 * the organizer node is found and informed that a term's dirty state has changed.
 */
StructureTerm.prototype.updateDirty = function () {
	var wasDirty = this.m_dirty;
	this.m_dirty = this.checkIsDirty();
	if (wasDirty !== this.m_dirty) {
		this.getParent().notifyDirty(this);
	}
};

/**
 * This simply resets the dirty state of the StructureTerm by setting the initial state to the current state.
 * This occurs when the tree is saved.
 */
StructureTerm.prototype.resetDirty = function () {
	StructureNode.prototype.resetDirty.call(this);
	this.setInitialState(this.getState());
};

/**
 * Renders the StructureTerm as an html string. Currently this base StructureTerm is just a div with a title. It is
 * up to sub-classes of StructureTerm to override this method and provide html.
 * @param {StructureHtml} structureHtml - The structure html package to which this term will be appended.
 */
StructureTerm.prototype.render = function (structureHtml) {
	structureHtml.append("<div>" + this.getTitle() + "</div>");
};

/**
 * Base deactivate method for the StructureTerm. This method should be implemented by any sub-classes of StructureTerm.
 */
StructureTerm.prototype.deactivate = function () {
	return;
};

/**
 * The base refresh method for StructureTerm objects. This removes the CSS class of the previous state and adds the
 * CSS class of the current state.
 */
StructureTerm.prototype.refresh = function () {
	if (this.m_state !== this.m_previousState) {
		$("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId()).removeClass((this.m_previousState) ? this.m_previousState.getCSSClass() : "").addClass(this.m_state.getCSSClass());
	}
};

/**
 * LineStructureTerm
 * This term has no user-interaction and is simply a placeholder term, designed to delineate regions within
 * structured documentation.
 * @returns {LineStructureTerm}
 * @constructor
 */
function LineStructureTerm() {
	this.m_type = "LINE";
	return this;
}
LineStructureTerm.prototype = new StructureTerm();
LineStructureTerm.prototype.constructor = StructureTerm;

/**
 * Overrides the base StructureTerm render method. It renders the LineStructureTerm object as an html string
 * and appends it to the structure html parameter.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
LineStructureTerm.prototype.render = function (structureHtml) {
	structureHtml.append("<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item line-term'></div>");
};

/**
 * CycleStructureTerm
 * This term represents a structured documentation answer with multiple states that can be cycled through via clicking.
 * This term can have any number of states.
 * @returns {CycleStructureTerm}
 * @constructor
 */
function CycleStructureTerm() {
	this.m_currentState = 0;                  //A state counter to know which state index we sit at
	this.m_states = null;                     //A list of states that will be cycled through
	return this;                            //Return a reference to self to allow chaining
}
CycleStructureTerm.prototype = new StructureTerm();
CycleStructureTerm.prototype.constructor = StructureTerm;

/**
 * Returns the index of the current state.
 * @returns {number}
 */
CycleStructureTerm.prototype.getCurrentState = function () {
	return this.m_currentState;
};

/**
 * Sets the state index.
 * @param {number} currentState - The current state of the term. This value must be within the bounds of the
 * number of states. (0 -> # states).
 * @return {CycleStructureTerm}
 */
CycleStructureTerm.prototype.setCurrentState = function (currentState) {
	if (typeof currentState !== "number") {
		throw new Error("Called setCurrentState on CycleStructureTerm with invalid currentState parameter.");
	}
	if (currentState < 0 || currentState >= this.m_states.length) {
		throw new Error("Called setCurrentState on CycleStructureTerm with an invalid state index.");
	}
	this.m_currentState = currentState;
	return this;
};

/**
 * Adds a TermState to the list of available states for the CycleStructureTerm.
 * @param {TermState} state - A TermState to be added to the CycleStructureTerm.
 * @returns {CycleStructureTerm}
 */
CycleStructureTerm.prototype.addState = function (state) {
	if (!TermState.prototype.isPrototypeOf(state)) {
		throw new Error("Called addState on CycleStructureTerm with invalid state parameter.");
	}
	this.getStates().push(state);
	return this;
};

/**
 * Returns the list of states available on the CycleStructureTerm.
 * @return {List<TermState>}
 */
CycleStructureTerm.prototype.getStates = function () {
	if (!this.m_states) {
		this.m_states = [];
	}
	return this.m_states;
};

/**
 * Increments the state by one and calls the updateState method which will handle state change functionality.
 */
CycleStructureTerm.prototype.cycleState = function () {
	this.m_currentState = (this.m_currentState + 1) % this.m_states.length;
	this.updateState(this.m_states[this.m_currentState]);
};

/**
 * Jumps immediately to the specified state. If the number provided is out of bounds, it will
 * mod the number to make it work.
 * @param {number} stateNumber - The index of the state to jump to.
 */
CycleStructureTerm.prototype.jumpToState = function (stateNumber) {
	this.m_currentState = stateNumber % this.m_states.length;
	this.updateState(this.m_states[this.m_currentState]);
};

/**
 * Overrides the deactivation method. This will simply jump to the 0 state, which is expected to be the NULL
 * state.
 */
CycleStructureTerm.prototype.deactivate = function () {
	this.m_currentState = 0;
	this.updateState(this.m_states[this.m_currentState]);
};

/**
 * Overrides the render method.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
CycleStructureTerm.prototype.render = function (structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";
	// create a comment section when the term has a comment and the term is documented
	if(this.getComment()) {
		commentHTML = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		commentClass = "comment"+ " ";
	}	
	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item cycle-term " + commentClass + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			"<span class='structure-term-title'>" + this.getTitle() + "</span>" +
			"<span class='structure-comment'>&nbsp;</span>" + 
			"</div>" +
			"<div class='structure-documented-icon-area'></div>" +
			commentHTML +
			"</div>"
	);
};

/**
 * Clear the term of activity data and restores its state back to a freshly created state
 */
CycleStructureTerm.prototype.clearSelf = function () {
	StructureTerm.prototype.clearSelf.call(this);
	this.deactivate();
};

/**
 * YesNoStructureTerm
 * This represents a structured documentation answer which has two state; Yes and No. Thus, this class
 * inherits from the CycleStructureTerm and enforces the use of a yes and no state.
 * @returns {YesNoStructureTerm}
 * @constructor
 */
function YesNoStructureTerm() {
	return this;
}
YesNoStructureTerm.prototype = new CycleStructureTerm();
YesNoStructureTerm.prototype.constructor = CycleStructureTerm;

/**
 * Overrides the render method.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
YesNoStructureTerm.prototype.render = function (structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var stateClass = this.m_state ? (this.m_state.getCSSClass() + " " + this.getYesNoValue()) : "";
	// create a comment section when the term has a comment and the term is documented
	if(this.getComment()) {
		commentHTML = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		commentClass = "comment"+ " ";
	}	
	structureHtml.append("<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item cycle-term yes-no " + commentClass + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			"<span class='structure-term-title'>" + this.getTitle() + "</span>" +
			"<span class='structure-comment'>&nbsp;</span>" + 
			"</div>" +
			"<div id='" + this.getNamespace() + ":term:YES:" + this.getId() + "' class='structure-yes-no-icon structure-yes'>Y</div>" +
			"<div id='" + this.getNamespace() + ":term:NO:" + this.getId() + "' class='structure-yes-no-icon structure-no'>N</div>" +
			commentHTML +
			"</div>"
	);
};

/**
 * Simply returns the yes or no string value of the term. If the state value is true, return yes, otherwise return false.
 * @returns {string}
 */
YesNoStructureTerm.prototype.getYesNoValue = function () {
	if (!this.m_state || this.m_state.getValue() === null) {
		return "";
	}
	if (this.m_state.getValue()) {
		return "yes";
	}
	return "no";
};

/**
 * Overrides the refresh method, handling the 'Y' and 'N' displays.
 */
YesNoStructureTerm.prototype.refresh = function () {
	StructureTerm.prototype.refresh.call(this);
	var root = $("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId());
	if (this.getState() && this.getState().getValue() === true) {
		root.addClass("yes").removeClass("no");
	} else if (this.getState() && this.getState().getValue() === false) {
		root.addClass("no").removeClass("yes");
	} else {
		root.removeClass("yes").removeClass("no");
	}
};

/**
 * InputStructureTerm
 * This represents a structured documentation answer which allows user input via a textbox.
 * @returns {InputStructureTerm}
 * @constructor
 */
function InputStructureTerm() {
	this.m_dataType = "";                 //Which types of data the input term accepts (alpha/alphanumeric, or numeric)
	this.m_currentValue = "";             //The value the user has currently entered in the available input
	this.m_previousValue = "";            //The value since the last save
	this.m_validators = null;
	this.m_activeState = null;
	this.m_inactiveState = null;
	// indicates whether the input is valid, true by default/blank
	this.m_isValid = true;

	return this;
}

InputStructureTerm.prototype = new StructureTerm();
InputStructureTerm.prototype.constructor = StructureTerm;

/**
 * Gets the data type for the InputStructureTerm.
 * @return {string} the data type for the InputStructureTerm.
 */
InputStructureTerm.prototype.getDataType = function () {
	return this.m_dataType;
};

/**
 * Sets the data type for the InputStructureTerm.
 * @param dataType the data type for the InputStructureTerm.
 * @return {InputStructureTerm} returns self.
 */
InputStructureTerm.prototype.setDataType = function (dataType) {
	if (typeof dataType !== "string") {
		throw new Error("Called setDataType on InputStructureTerm with invalid dataType parameter.");
	}
	this.m_dataType = dataType;
	return this;
};

/**
 * Returns the previous text value that was input in the InputStructureTerm.
 * @returns {string}
 */
InputStructureTerm.prototype.getPreviousValue = function () {
	return this.m_previousValue;
};

/**
 * Overrides the resetDirty method. This calls the base resetDirty method, then sets the previousValue to the
 * currentValue.
 */
InputStructureTerm.prototype.resetDirty = function () {
	StructureTerm.prototype.resetDirty.call(this);
	this.m_previousValue = this.m_currentValue;
};

/**
 * Overrides the checkIsDirty method. InputSructureTerm has a complicated system for determining dirty state. There
 * are three scenarios which guarantee dirty state.
 * 1). If the term was active and is currently inactive.
 * 2). If the term was inactive and is currently active.
 * 3). If the term was active, is currently active, but the previousValue and currentValue are not equal.
 * @returns {boolean}
 */
InputStructureTerm.prototype.checkIsDirty = function () {
	var currentlyActive = this.getState() === this.getActiveState();
	var wasInactive = this.getInitialState() === this.getInactiveState();
	var currentValue = this.getCurrentValue();
	var previousValue = this.getPreviousValue();
	//If it was not active and is currently active, it's dirty. If it was active and is currently inactive, it's dirty. Or
	//if it was active and is still currently active, but the text value is different, it's dirty.
	return (wasInactive && currentlyActive) || (!wasInactive && currentlyActive && currentValue !== previousValue) || (!wasInactive && !currentlyActive);
};

/**
 * Overrides the convertToJSON method.
 * @return {Object} the JSON version of this term.
 */
InputStructureTerm.prototype.convertToJSON = function () {
	var currentValue = this.getCurrentValue();
	var comment = this.getComment();

	var json = [];
	json.push('"dd_attr_menu_item_id": ' + this.getActivityId() + '.0');
	json.push('"ocid": "' + this.getOCID() + '"');
	json.push('"display_seq": ' + this.getDisplayPosition());
	json.push('"truth_state_mean": "' + ((this.getState().getValue()) ? "T" : "F") + '"');
	json.push('"comment": "' 
		//escape special characters in comment
		+ (comment ? this.escapePlaintextAsHtml(comment) : comment) 
		+ '"');
	json.push('"comment_format_mean": "XHTML"');
	json.push('"value_text": "'
		// escape value text
		+ (currentValue ? this.escapePlaintextAsHtml(currentValue) : currentValue)
		+ '"');
	json.push('"value_text_format_mean": "XHTML"');

	if (this.m_dataType === "NUMERIC") {
		currentValue = parseFloat(this.getCurrentValue());

		// append a .0 if it is a whole number
		if (currentValue % 1 === 0) {
			currentValue = currentValue + ".0";
		}

		json.push('"value_number": ' + currentValue);

	} else {
		json.push('"value_number": 0.0');
	}

	return '{' + json.join(',') + '}';
};


/**
 * Gets the current value (in the textbox) for the InputStructureTerm.
 * @return {string} the current value in the textbox.
 */
InputStructureTerm.prototype.getCurrentValue = function () {
	return this.m_currentValue;
};

/**
 * Updates the validity and the state of the term based on the current value of the term.
 * Should be called after a change in the current value of the term.
 */
InputStructureTerm.prototype.update = function () {
	if (this.validate()) {
		this.m_isValid = true;

		if (this.m_currentValue !== "") {
			this.getActiveState().addData("value", this.m_currentValue);
			this.updateState(this.m_activeState);
		} else {
			this.updateState(this.m_inactiveState);
		}
	} else {
		this.m_isValid = false;

		this.updateState(this.m_inactiveState);
	}
};

/**
 * Overrides the refresh method to update the input displays/UI based on the current value.
 */
InputStructureTerm.prototype.refresh = function () {
	StructureTerm.prototype.refresh.call(this);

	// update input value with the current value
	var input = $("#" + this.getNamespace() + "\\:term\\:INPUT\\:" + this.getId());
	if (this.getCurrentValue() !== input.val()) {
		input.val(this.getCurrentValue());
	}

	// if the input is in an invalid state, we are going to add an "invalid" class to the term
	if (!this.m_isValid) {
		$("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId()).addClass("invalid");
	} else {
		$("#" + this.getNamespace() + "\\:term\\:ROOT\\:" + this.getId()).removeClass("invalid");
	}
};


/**
 * Sets the current text value within the InputStructureTerm.
 * @param {string} currentValue - The current value within the InputStructureTerm.
 * @returns {InputStructureTerm}
 */
InputStructureTerm.prototype.setCurrentValue = function (currentValue) {
	if (typeof currentValue !== "string") {
		throw new Error("Called setCurrentValue on InputStructureTerm with invalid type: expected {String}");
	}
	this.m_currentValue = currentValue;
	return this;
};

/**
 * This method forces the InputStructureTerm into the inactive state.
 */
InputStructureTerm.prototype.deactivate = function () {
	this.setCurrentValue("");
	this.updateState(this.m_inactiveState);
};

/**
 * Clear the term of activity data and restores its state back to a freshly created state
 */
InputStructureTerm.prototype.clearSelf = function () {
	StructureTerm.prototype.clearSelf.call(this);
	this.deactivate();
};

/**
 * Returns a list of validators associated to the InputStructureTerm.
 * @returns {Array<InputValidator>}
 */
InputStructureTerm.prototype.getValidators = function () {
	if (!this.m_validators) {
		this.m_validators = [];
	}
	return this.m_validators;
};

/**
 * Add an InputValidator to the InputStructureTerm.
 * @param {InputValidator} validator - A validator to be associated to the InputStructureTerm.
 * @returns {InputStructureTerm}
 */
InputStructureTerm.prototype.addValidator = function (validator) {
	if (!InputValidator.prototype.isPrototypeOf(validator)) {
		throw new Error("Called addValidator on InputStructureTerm with invalid type, expected InputValidator");
	}
	this.getValidators().push(validator);
	return this;
};

/**
 * Simply returns a boolean as for whether or not the currentValue on the InputStructureTerm matches the data type
 * required.
 * @return {Boolean}
 */
InputStructureTerm.prototype.validate = function () {
	//If nothing has been entered, we consider that valid (nothing entered)
	var currentValue = this.getCurrentValue();
	if (currentValue == "") {
		return true;
	}
	//Iterate over each of the validators and ensure they evaluate to true
	var validators = this.getValidators();
	var numberValidators = validators.length;
	for (var i = 0; i < numberValidators; i++) {
		if (!validators[i].validate(currentValue)) {
			return false;
		}
	}
	//If we have made it this far, the input term has successfully validated
	return true;
};

/**
 * Renders the InputStructureTerm object as an html string.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
InputStructureTerm.prototype.render = function (structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var titleText = this.getTitle();
	var itemWidth = "45%";

	// escape current value plain text to be safe for html
	var currentValueHtml = this.escapePlaintextAsHtml(this.m_currentValue);

	var inputElement = "<input style='width: " + itemWidth + ";' type='text' id='" + this.getNamespace() + ":term:INPUT:" + this.getId() + "' value='" + currentValueHtml + "'>";
	//If somehow the input term does not contain the _ character, add one at the end by default.
	if(titleText.indexOf("_") === -1) {
		titleText += "_";
	}
	if (titleText.indexOf("_") === 0) {
		titleText = inputElement + "<span class='structure-term-title' style='width: " + itemWidth + ";'>" + titleText.replace(/_/g, "") + "</span>";
	} else if (titleText.lastIndexOf("_") === (titleText.length - 1)) {
		titleText = "<span class='structure-term-title' style='width: " + itemWidth + ";'>" + titleText.replace(/_/g, "") + "</span>" + inputElement;
	} else {
		var textSplit = titleText.split(/_+/g);
		var numberOfNonBlank = 0;
		var i = 0;
		for (i = 0; i < textSplit.length; i++) {
			(textSplit[i]) && numberOfNonBlank++;
		}
		itemWidth = (90 / (numberOfNonBlank + 1)) + "%";
		inputElement = "<input style='width: " + itemWidth + ";' type='text' id='" + this.getNamespace() + ":term:INPUT:" + this.getId() + "' value='" + currentValueHtml + "'>";
		for (i = 0; i < textSplit.length; i++) {
			if (textSplit[i]) {
				textSplit[i] = ("<span class='structure-term-title' style='width: " + itemWidth + ";'>" + textSplit[i] + "</span>");
			}
		}
		titleText = textSplit.join(inputElement);
	}
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";
	// create a comment section when the term has a comment and the term is documented
	if(this.getComment()) {
		commentHTML = "<div class='structure-term-comment-wrapper'>" + this.buildTextArea() + "</div>";
		commentClass = "comment"+ " ";
	}
	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item input-term " + commentClass + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			titleText +
			"<span class='structure-comment'>&nbsp;</span>" + 
			"</div>" +
			"<div class='structure-documented-icon-area'></div>" +
			commentHTML +
			"</div>"
	);
};

/**
 * Gets the active state for the term
 * @returns {TermState} a TermState object that represents the active state
 */
InputStructureTerm.prototype.getActiveState = function () {
	return this.m_activeState;
};

/**
 * Sets the active state for the term
 * @param {TermState} activeState - a TermState object that represents the active state
 */
InputStructureTerm.prototype.setActiveState = function (activeState) {
	if(!TermState.prototype.isPrototypeOf(activeState)) {
		throw new Error("Attempted to call InputStructureTerm.prototype.setActiveState with invalid parameter");
	}
	this.m_activeState = activeState;
	return this;
};

/**
 * Gets the inactive state for the term
 * @returns {TermState} a TermState object that represents the inactive state
 */
InputStructureTerm.prototype.getInactiveState = function () {
	return this.m_inactiveState;
};

/**
 * Sets the inactive state for the term.
 * @param {TermState}inactiveState
 * @returns {InputStructureTerm}
 */
InputStructureTerm.prototype.setInactiveState = function (inactiveState) {
	if(!TermState.prototype.isPrototypeOf(inactiveState)) {
		throw new Error("Attempted to call InputStructureTerm.prototype.setInactiveState with invalid parameter.");
	}
	this.m_inactiveState = inactiveState;
	return this;
};

/**
 * FreeTextStructureTerm
 * @returns {FreeTextStructureTerm}
 * @constructor
 */
function FreeTextStructureTerm() {
	return this;
}

FreeTextStructureTerm.prototype = new InputStructureTerm();
FreeTextStructureTerm.prototype.constructor = InputStructureTerm;

/**
 * Renders the freetext term as html and appends it to the supplied html
 * @param {StructureHtml} structureHtml - existing html to append the rendered freetext term onto
 */
FreeTextStructureTerm.prototype.render = function (structureHtml) {
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";

	// escape current value plain text to be safe for html
	var currentValueHtml = this.escapePlaintextAsHtml(this.m_currentValue);

	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='structure-term-item input-term freetext-term " + stateClass + "' title='" + this.getCaption() + "'>" +
			"<div class='structure-term-info-wrapper'>" +
			"<input type='text' id='" + this.getNamespace() + ":term:INPUT:" + this.getId() + "' value='" + currentValueHtml + "' placeholder='" + i18n.discernabu.mpage_structured_documentation.ADD_FREE_TEXT_TERM + "'>" +
			"</div>" +
			"</div>"
	);
};

/**
 * NoneStructureTerm
 * This represents a structured documentation answer that reflects None
 * @returns {NoneStructureTerm}
 * @constructor 
 */
function NoneStructureTerm (){
	return this;
}
NoneStructureTerm.prototype = new CycleStructureTerm();
NoneStructureTerm.prototype.constructor = CycleStructureTerm;

/**
 * TableStructureTerm
 * This represents a structured documentation term within a Table (R/L/Bi)
 * @returns {TableStructureTerm}
 * @constructore
 */
function TableStructureTerm () {
	return this;
}

TableStructureTerm.prototype = new CycleStructureTerm();
TableStructureTerm.prototype.constructor = CycleStructureTerm;

/**
 * Overrides the render method.
 * @param {StructureHtml} structureHtml - A StructureHtml package object. All html shall be appended to this object.
 */
TableStructureTerm.prototype.render = function (structureHtml) {
	var commentClass = "";
	var commentHTML = "";
	var stateClass = this.m_state ? this.m_state.getCSSClass() : "";
	var columnWidth = (100 / this.getParent().getChildren().length) + "%";

	structureHtml.append(
			"<div id='" + this.getNamespace() + ":term:ROOT:" + this.getId() + "' class='table-term " + stateClass + "' title='" + this.getCaption() +  "'  style='width: " + columnWidth + ";'>" +
			"<div class='structure-documented-icon-area'>" + this.getUIValue() + "</div>" +
			"</div>"
	);
};

/**
 * Implements isDefaultDisplayed term for TableStructureTerm.  Returns true as the term should always
 * be displayed independent of priority if that parent Table is displayed
 * @return {Boolean} Returns true if the node should be rendered by default
 */
TableStructureTerm.prototype.isDefaultDisplayed = function() {
	return true;
};

/**
 * Override the getComment function, to retrieve comment from the Table level. 
 * This is because the comment on the front-end is associated to the table, but to the term on the back-end.
 * @return {String} The comment associated to the term/table
 */
TableStructureTerm.prototype.getComment = function() {
	var tableGroupTerm = this.getParent();
	var tableGroupTermComment = tableGroupTerm.getComment();
	//If current tem is active, return associated comment
	if(tableGroupTerm.getActiveTerm() === this){
		this.setComment(tableGroupTermComment);
		return tableGroupTermComment;
	}
	//Otherwise, remove comment from current table item
	else {
		this.setComment("");
		return "";
	}
};

/**
 * Override getSaveComment to return parent table's saved comment
 * @return {String} The comment saved in the table
 */
TableStructureTerm.prototype.getSavedComment = function() {
	var tableGroupTerm = this.getParent();
	return tableGroupTerm.getSavedComment();
};

/**
 * Displays comment for the term
 * @param {string} comment - The comment of the StructureTerm.
 */
TableStructureTerm.prototype.displayComment = function(comment) {
	// validates the comment received and covert them to the actual text
	var validatedComment = comment ? this.unescapePlaintextAsHtml(comment) : comment + "";
	// sets comment to the term
	this.setComment(validatedComment);
	this.setSavedComment(validatedComment);

	var tableTermGroup = this.getParent();
	tableTermGroup.displayComment(comment);
};

/**
 * Override default getHighlightElement to return highLightElement of parent table.
 * @return {undefined}
 */
TableStructureTerm.prototype.getHighlightElement = function() {
	var tableGroupTerm = this.getParent();
	return tableGroupTerm.getHighlightElement();
};

/**
 * Overiding isDefaultDisplayed such that term is always default rendered when parent is rendered
 * @return {Boolean} True iff the term should be shown by default
 */
TableStructureTerm.prototype.isDefaultDisplayed = function () {
	return true;
};

/**
 * Overiding isCurrentlyDisplayed as term will always be displayed if parent table is displayed
 * @return {Boolean} True iff the term is currently displayed on the page
 */
TableStructureTerm.prototype.isCurrentlyDisplayed = function() {
	var parentTable = this.getParent();
	return parentTable.isCurrentlyDisplayed();
};

/**
 * Overriding displayNode to display parent table when node is not displayed
 * @return {[type]} [description]
 */
TableStructureTerm.prototype.displayNode = function() {
	var table = this.getParent();
	table.displayNode();
};
/**
 * Navigator
 * This class serves as a standard navigation bar which simply displays a list of navigation options
 * @returns {Navigator}
 * @constructor
 */
function Navigator() {
	this.m_activeNavigation = null;
	this.m_clickCallback = null;
	this.m_id = "";
	this.m_navigationMap = null;
	this.m_navigations = null;
	this.m_skin = "";
	return this;
}

/**
 * Returns the click callback function. To execute the callback, it must be called as getClickCallback()().
 * @returns {null | function}
 */
Navigator.prototype.getClickCallback = function () {
	return this.m_clickCallback;
};

/**
 * Sets the callback that is executed when a navigation item is selected.
 * @param {function} callback - The callback function to be executed when a navigation item is selected from the
 * navigator. This function must be in the following format.
 * function(navigationItem) { ... }.
 */
Navigator.prototype.setClickCallback = function (callback) {
	if (typeof callback !== "function") {
		throw new Error("Attempted to call setClickCallback with invalid parameter");
	}
	this.m_clickCallback = callback;
	return this;
};

/**
 * Applies a custom CSS skin to the root level of the navigator.
 * @param {string} skin - The CSS skin to be applied to the root level of the navigator.
 * @returns {Navigator}
 */
Navigator.prototype.applyCustomSkin = function (skin) {
	if (typeof skin !== "string") {
		throw new Error("Attempted to call applyCustomSkin with invalid parameter.");
	}
	this.m_skin = skin;
	return this;
};

/**
 * Returns the custom CSS skin that will be applied to the root level of the navigator.
 * @returns {string}
 */
Navigator.prototype.getCustomSkin = function () {
	return this.m_skin;
};

/**
 * Returns the Navigation item that is currently active within the Navigator.
 * @returns {null|Navigation}
 */
Navigator.prototype.getActiveNavigation = function () {
	return this.m_activeNavigation;
};

/**
 * Sets the Navigation item that is currently active within the Navigator.
 * @param {Navigation} activeNavigation - The Navigation item that is currently active within the Navigator.
 * @returns {Navigator}
 */
Navigator.prototype.setActiveNavigation = function (activeNavigation) {
	if (!Navigation.prototype.isPrototypeOf(activeNavigation)) {
		throw new Error("Attempted to call setActiveNavigation with invalid parameter.");
	}
	this.m_activeNavigation = activeNavigation;
	return this;
};

/**
 * Returns the id of the Navigator element.
 * @returns {string}
 */
Navigator.prototype.getId = function () {
	return this.m_id;
};

/**
 * Sets the id of the Navigator element.
 * @param {string} id - The id of the Navigator element.
 * @returns {Navigator}
 */
Navigator.prototype.setId = function (id) {
	if (typeof id !== "string") {
		throw new Error("Attempted to call setId with invalid parameter.");
	}
	this.m_id = id;
	return this;
};

/**
 * Returns the list of Navigation items associated to the Navigator.
 * @returns {Array<Navigation>}
 */
Navigator.prototype.getNavigations = function () {
	if (!this.m_navigations) {
		this.m_navigations = [];
	}
	return this.m_navigations;
};

/**
 * Sets the list of Navigation items associated to the Navigator.
 * @param {Array<Navigation>} navigations - The list of Navigation items to be associated to the Navigator
 * @returns {Navigator}
 */
Navigator.prototype.setNavigations = function (navigations) {
	if (!Array.prototype.isPrototypeOf(navigations)) {
		throw new Error("Attempted to call setNavigations with invalid parameter.");
	}
	this.m_navigations = navigations;
	return this;
};

/**
 * Adds a Navigation item to the list of Navigation items associated to the Navigator.
 * The Navigation item is put in a flat list as well as a map which maps from the Navigation id to the object.
 * @param {Navigation} navigation - A single Navigation item to be associated to the Navigator.
 * @returns {Navigator}
 */
Navigator.prototype.addNavigation = function (navigation) {
	if (!Navigation.prototype.isPrototypeOf(navigation)) {
		throw new Error("Attempted to call addNavigation with invalid parameter.");
	}
	this.getNavigations().push(navigation);
	this.getNavigationMap()[navigation.getId()] = navigation;
	return this;
};

/**
 * Returns the Navigation map which is an association of Navigation ids to objects.
 * @returns {null|Object}
 */
Navigator.prototype.getNavigationMap = function () {
	if (!this.m_navigationMap) {
		this.m_navigationMap = {};
	}
	return this.m_navigationMap;
};

/**
 * Renders the Navigator object as an html string which is to be appended to the DOM. This method will render the
 * shell of the Navigator as well as render each individual Navigation item.
 * @returns {string}
 */
Navigator.prototype.render = function () {
	var html = "";
	var navigationList = this.getNavigations();
	var navigationCount = navigationList.length;
	html += "<div id='" + this.getId() + "' class='" + this.getCustomSkin() + " structure-navigator'>";
	for (var i = 0; i < navigationCount; i++) {
		html += navigationList[i].render();
	}
	html += "</div>";
	return html;
};

/**
 * Finalizes the Navigator object. This attaches a click delegate at the root level to listen for click events
 * on the individual Navigation items. When an item is clicked, it is activated and the onSelect method is called.
 * The currently active Navigation item is deselected.
 */
Navigator.prototype.finalize = function () {
	var self = this;
	var elementId = this.getId().replace(/:/g, "\\:");
	//Attach a delegate and listen for clicks on any of the navigation items
	$("#" + elementId).on('click', '.navigator-button', function () {
		self.handleNavigationSelection(this.id);
	});
};

Navigator.prototype.updateActiveNavigation = function (navigationId) {
	var navigationItem = this.getNavigationMap()[navigationId];
	if (!navigationItem || navigationItem === this.getActiveNavigation()) {
		return;
	}
	//If there is a currently active Navigation item, deselect it first
	if (this.getActiveNavigation()) {
		this.getActiveNavigation().deselect();
	}
	navigationItem.getElement().addClass("active");
	this.setActiveNavigation(navigationItem);
};

Navigator.prototype.handleNavigationSelection = function (navigationId) {
	//Using the id of the element, look up the Navigation object in the navigation map
	var navigationItem = this.getNavigationMap()[navigationId];
	if (!navigationItem || navigationItem === this.getActiveNavigation()) {
		return;
	}
	//If there is a currently active Navigation item, deselect it first
	if (this.getActiveNavigation()) {
		this.getActiveNavigation().deselect();
	}
	this.setActiveNavigation(navigationItem);
	navigationItem.onSelect();
	if (this.m_clickCallback) {
		this.m_clickCallback(navigationItem);
	}
};


/**
 * Navigation
 * This class serves as the base Navigation object which is meant to be added into a Navigator.
 * @returns {Navigation}
 * @constructor
 */
function Navigation() {
	this.m_id = "";
	this.m_label = "";
	this.m_element = null;
	return this;
}

/**
 * Returns the Navigation DOM element.
 * @returns {Object}
 */
Navigation.prototype.getElement = function () {
	if (!this.m_element) {
		this.m_element = $("#" + this.getId().replace(/\:/g, "\\:"));
	}
	return this.m_element;
};

/**
 * Returns the id of the Navigation element.
 * @returns {string}
 */
Navigation.prototype.getId = function () {
	return this.m_id;
};

/**
 * Sets the id of the Navigation element.
 * @param {string} id - The id of the Navigation element.
 * @returns {Navigation}
 */
Navigation.prototype.setId = function (id) {
	if (typeof id !== "string") {
		throw new Error("Attempted to call Navigation.prototype.setId with invalid parameter.");
	}
	this.m_id = id;
	return this;
};

/**
 * Returns the label of the Navigation element.
 * @returns {string}
 */
Navigation.prototype.getLabel = function () {
	return this.m_label;
};

/**
 * Sets the label of the Navigation element.
 * @param {string} label - The label of the Navigation element.
 * @returns {Navigation}
 */
Navigation.prototype.setLabel = function (label) {
	if (typeof label !== "string") {
		throw new Error("Attempted to call Navigation.prototype.setLabel with invalid parameter.");
	}
	this.m_label = label;
	return this;
};

/**
 * This method performs the base onSelect operations. Any sub-class that overrides this method should call this
 * base method.
 */
Navigation.prototype.onSelect = function () {
	this.getElement().addClass("active");
};

/**
 * This method deselects the Navigation item.
 */
Navigation.prototype.deselect = function () {
	this.getElement().removeClass("active").blur();
};

/**
 * This method renders the Navigation item. Note that it uses the standard button implementation and applies a custom
 * skin to the button.
 * @returns {string}
 */
Navigation.prototype.render = function () {
	return "<button id='" + this.getId() + "' class='navigator-button'>" + this.getLabel() + "</button>";
};

/**
 * ScrollNavigation
 * This class inherits from the base Navigation item. Its purpose is to scroll some other element to a specified
 * anchor.
 * @returns {ScrollNavigation}
 * @constructor
 */
function ScrollNavigation() {
	this.m_anchorId = "";
	this.m_anchorElement = null;
	this.m_containerId = "";
	this.m_containerElement = null;
	return this;
}
ScrollNavigation.prototype = new Navigation();
ScrollNavigation.prototype.constructor = Navigation;

/**
 * Returns the id of the anchor element. The anchor element is the anchor to which the container element will be
 * scrolled.
 * @returns {string}
 */
ScrollNavigation.prototype.getAnchorId = function () {
	return this.m_anchorId;
};

/**
 * Sets the id of the anchor element. The anchor element is the anchor to which the container element will be scrolled.
 * @param {string} anchorId - The id of the element to which the container element will be scrolled.
 * @returns {ScrollNavigation}
 */
ScrollNavigation.prototype.setAnchorId = function (anchorId) {
	if (typeof anchorId !== "string") {
		throw new Error("Attempted to call ScrollNavigation.prototype.setAnchorId with invalid parameter.");
	}
	this.m_anchorId = anchorId;
	return this;
};

/**
 * Returns the anchor element jQuery object. The anchor element is the anchor to which the container element will be
 * scrolled.
 * @returns {Object}
 */
ScrollNavigation.prototype.getAnchorElement = function () {
	if (!this.m_anchorElement) {
		this.m_anchorElement = $("#" + this.getAnchorId().replace(/:/g, "\\:"));
	}
	return this.m_anchorElement;
};

/**
 * Returns the id of the container element. The container element is the element which will be scrolled to the specified
 * anchor.
 * @returns {string}
 */
ScrollNavigation.prototype.getContainerId = function () {
	return this.m_containerId;
};

/**
 * Sets the id of the container element. The container element is the element which will be scrolled to the specified
 * anchor.
 * @param {string} containerId - The id of the container element.
 * @returns {ScrollNavigation}
 */
ScrollNavigation.prototype.setContainerId = function (containerId) {
	if (typeof containerId !== "string") {
		throw new Error("Attempted to call ScrollNavigation.prototype.setContainerId with invalid parameter.");
	}
	this.m_containerId = containerId;
	return this;
};

/**
 * Returns the container element jQuery object. The container element is the element which will be scrolled to the
 * specified anchor.
 * @returns {Object}
 */
ScrollNavigation.prototype.getContainerElement = function () {
	if (!this.m_containerElement) {
		this.m_containerElement = $("#" + this.getContainerId().replace(/:/g, "\\:"));
	}
	return this.m_containerElement;
};

/**
 * This method overrides the base Navigation onSelect method. It calls the base onSelect method then scrolls the
 * container element to the anchor element.
 */
ScrollNavigation.prototype.onSelect = function () {
	Navigation.prototype.onSelect.call(this);
	var containerElement = this.getContainerElement();
	var anchorElement = this.getAnchorElement();
	containerElement.scrollTop(anchorElement.offset().top - containerElement.offset().top + containerElement.scrollTop());
};

/**
 * CallbackNavigation
 * This class inherits from the base Navigation item. Its purpose is to provide a simple entry point to a Navigation
 * item which allows a user to provide a callback when the item is selected. The functionality is mostly left to the
 * developer.
 * @returns {CallbackNavigation}
 * @constructor
 */
function CallbackNavigation() {
	this.m_onSelect = null;
	return this;
}
CallbackNavigation.prototype = new Navigation();
CallbackNavigation.prototype.constructor = Navigation;

/**
 * Sets the callback function to be run when the CallbackNavigation item is selected in the Navigator.
 * @param {function} onSelect - The callback function to be run when the CallbackNavigation item is selected in the
 * Navigator.
 * @returns {CallbackNavigation}
 */
CallbackNavigation.prototype.setOnSelect = function (onSelect) {
	if(typeof onSelect !== "function") {
		throw new Error("Attempted to call CallbackNavigation.prototype.setOnSelect with invalid parameter.");
	}
	this.m_onSelect = onSelect;
	return this;
};

/**
 * Overrides the base onSelect method. This will call the on select callback if one is provided.
 */
CallbackNavigation.prototype.onSelect = function () {
	Navigation.prototype.onSelect.call(this);
	if (this.m_onSelect) {
		this.m_onSelect();
	}
};

/**
 * StructureNavigation
 * This class inherits from the CallbackNavigation item. Its purpose is to integrate with structured documentation.
 * The structured documentation functionality requires a navigation item for each group. When a navigation item
 * is selected, it is necessary to know which StructureNode it is associated with. Thus, this class keeps a reference
 * to the associated StructureNode.
 * @constructor
 */
function StructureNavigation() {
	this.m_node = null;
}
StructureNavigation.prototype = new ScrollNavigation();
StructureNavigation.prototype.constructor = ScrollNavigation;

/**
 * Set the node that the navigation is associated to.
 * @param {StructureNode} node - The node that the navigation is associated to.
 * @returns {StructureNavigation} Returns self to allow chaining.
 */
StructureNavigation.prototype.setNode = function(node) {
	this.m_node = node;
	return this;
};

/**
 * Renders the structure navigation as an html string
 * @returns {string} structure navigation html string
 */
StructureNavigation.prototype.render = function () {
	var documentedClass = (this.m_node && this.m_node.getNumberOfDocumentedChildren() > 0) ? " navigation-documented" : "";
	return "<div id='" + this.getId() + "' class='navigator-button structure-navigator-button" + documentedClass + "'><span>" + this.getLabel() + "</span><div class='navigation-documented-icon'></div></div>";
};
/**
 * The StructureQuestionSet class.
 * This class is used to group a set of structure questions so they can be handled as a unit.
 * @constructor
 */
function StructureQuestionSet() {
	this.m_onCompleteCallback = null;
	this.m_lookup = null;
}

StructureQuestionSet.prototype = new StructureGroup();
StructureQuestionSet.prototype.constructor = StructureGroup;

/**
 * Gets the lookup hashmap for child nodes of the StructureQuestionSet. This should only contain StructureAnswer
 * objects.
 * @returns {HashMap<string, StructureNode>} A hashmap of node ids to StructureNode objects.
 */
StructureQuestionSet.prototype.getLookup = function() {
	if(!this.m_lookup) {
		this.m_lookup = {};
	}
	return this.m_lookup;
};

/**
 * Goes through the answers and finds all that have been answered (or checked). The answers are pushed into an array
 * then serialized as a JSON string.
 * @returns {string} The answers as a serialized array (in string format).
 */
StructureQuestionSet.prototype.getAnswers = function() {
	var answered = [];

	var questions = this.getChildren();
	var questionCount = questions.length;
	var question = null;

	var answers = null;
	var answerCount = null;
	var answer = null;
	for(var i = 0; i < questionCount; i++) {
		question = questions[i];
		answers = question.getChildren();
		answerCount = answers.length;
		for(var j = 0; j < answerCount; j++) {
			answer = answers[j];
			//This answer has been chosen
			if(answer.getState().getValue()) {
				answered.push({
					"parent_entity_id" : question.getParentEntityId() + ".0",
					"parent_entity_name" : question.getParentEntityName(),
					"dd_sref_chf_cmplnt_crit_id" : answer.getTemplateId() + ".0"
				});
			}
		}
	}
	return JSON.stringify(answered);
};

/**
 * Sets the callback function that is triggered when all questions in the set have been answered.
 * @param {function} onCompleteCallback - The callback function.
 * @returns {StructureQuestionSet} Returns self to allow chaining.
 */
StructureQuestionSet.prototype.setOnCompleteCallback = function(onCompleteCallback) {
	if(typeof onCompleteCallback !== "function") {
		throw new Error("StructureQuestionSet.prototype.setOnCompleteCallback expects a function");
	}
	this.m_onCompleteCallback = onCompleteCallback;
	return this;
};

/**
 * Retrieves the root element of the question set.
 * @returns {jQuery|HTMLElement} The root element of the question set.
 */
StructureQuestionSet.prototype.getRootElement = function() {
	if(!this.m_rootElement || !this.m_rootElement.length) {
		this.m_rootElement = $("#" + this.m_namespace + "StructureQuestionSet");
	}
	return this.m_rootElement;
};

/**
 * Override the notifyStateChange function. For a structure question set, we need to know when all questions of the
 * question set have been answered in some fashion. When this occurs, we can trigger the callback.
 * @param {StructureQuestion} node - The StructureQuestion (or node) that changed state.
 */
StructureQuestionSet.prototype.notifyStateChange = function(node) {
	StructureNode.prototype.notifyStateChange.call(this, node);
	if(this.m_numberDocumented === this.m_children.length) {
		if(this.m_onCompleteCallback) {
			this.m_onCompleteCallback(true);
		}
	} else {
		this.m_onCompleteCallback(false);
	}
};

/**
 * First assign unique ids and namespace to the nodes then create the HTML representation of the question set.
 * @returns {string} The question set rendered as an HTML string.
 */
StructureQuestionSet.prototype.render = function() {
	var structureHtml = new StructureHtml();
	structureHtml.append("<div id='"+this.m_namespace+"StructureQuestionSet' class='structure-question-set' data-lookup='"+this.m_id+"'>");
	this.renderChildren(structureHtml, false);
	structureHtml.append("</div>");
	return structureHtml.getHtml();
};

/**
 * The StructureQuestion class.
 * This represents a single structure question. It inherits from the MultiStructureTermGroup which means that any number
 * of its children can be documented at once.
 * @constructor
 */
function StructureQuestion() {
	this.m_questionDisplay = "";
	this.m_diagnosisGroup = 0.0;

	//Question data
	this.m_parentEntityId = 0.0;
	this.m_parentEntityName = "";
}

StructureQuestion.prototype = new MultiStructureTermGroup();
StructureQuestion.prototype.constructor = MultiStructureTermGroup;

/**
 * Sets the parent entity id of the structure question.
 * @param {number} parentEntityId - The parent entity id of the structure question.
 * @returns {StructureQuestion} Returns self to allow chaining.
 */
StructureQuestion.prototype.setParentEntityId = function(parentEntityId) {
	if(typeof parentEntityId !== "number") {
		throw new Error("StructureQuestion.prototype.setParentEntityId expects a number.");
	}
	this.m_parentEntityId = parentEntityId;
	return this;
};

/**
 * Sets the parent entity name of the structure question.
 * @param {string} parentEntityName - The parent entity name of the structure question.
 * @returns {StructureQuestion} Returns self to allow chaining.
 */
StructureQuestion.prototype.setParentEntityName = function(parentEntityName) {
	if(typeof parentEntityName !== "string") {
		throw new Error("StructureQuestion.prototype.setParentEntityName expects a string.");
	}
	this.m_parentEntityName = parentEntityName;
	return this;
};

/**
 * Retrieves the structure question parent entity id.
 * @returns {number} The structure question parent entity id.
 */
StructureQuestion.prototype.getParentEntityId = function() {
	return this.m_parentEntityId;
};

/**
 * Retrieves the structure question parent entity name.
 * @returns {string} The structure question parent entity name.
 */
StructureQuestion.prototype.getParentEntityName = function() {
	return this.m_parentEntityName;
};

/**
 * Sets the question display.
 * @param {string} questionDisplay - The question display.
 * @returns {StructureQuestion} Returns self to allow chaining.
 */
StructureQuestion.prototype.setQuestionDisplay = function(questionDisplay) {
	if(typeof questionDisplay !== "string") {
		throw new Error("StructureQuestion.prototype.setQuestionDisplay expects a string.");
	}
	this.m_questionDisplay = questionDisplay;
	return this;
};

/**
 * Sets the diagnosis group for the structure question.
 * @param {number} diagnosisGroup - The (double) diagnosis group value.
 * @returns {StructureQuestion} Returns self to allow chaining.
 */
StructureQuestion.prototype.setDiagnosisGroup = function(diagnosisGroup) {
	if(typeof diagnosisGroup !== "number") {
		throw new Error("StructureQuestion.prototype.setDiagnosisGroup expects a number.");
	}
	this.m_diagnosisGroup = diagnosisGroup;
	return this;
};

/**
 * Renders the StructureQuestion out as an HTML string.
 * @param {StructureHtml} structureHtml - The packaged HTML passed through the recursive rendering.
 * @param {boolean} shouldRenderColumns - Unused boolean determining if the node should render columns.
 */
StructureQuestion.prototype.render = function(structureHtml, shouldRenderColumns) {
	structureHtml.append("<div class='structure-question' data-lookup='"+this.m_id+"'>");
	structureHtml.append("<div>" + this.m_questionDisplay + "</div>");
	this.renderChildren(structureHtml, false);
	structureHtml.append("</div>");
};

/**
 * The StructureAnswer class.
 * This represents an answer to a StructureQuestion. A StructureAnswer always has two states: undocumented (null)
 * and documented (true). The default state is undocumented.
 * @returns {StructureAnswer} Returns self to allow chaining.
 * @constructor
 */
function StructureAnswer() {
	this.m_answerDisplay = "";
	this.m_templateId = 0.0;
	this.addState(new TermState().setValue(null).setCSSClass(""));
	this.addState(new TermState().setValue(true).setCSSClass("structure-answer-yes"));
	this.setInitialState(this.m_states[0]);
	this.m_state = this.m_states[0];
	return this;
}
StructureAnswer.prototype = new CycleStructureTerm();
StructureAnswer.prototype.constructor = CycleStructureTerm;

/**
 * Sets tha id of the answer, this id must be unique.
 * @param {number} templateId - The id of the answer.
 * @returns {StructureAnswer} Returns self to allow chaining.
 */
StructureAnswer.prototype.setTemplateId = function(templateId) {
	if(typeof templateId !== "number") {
		throw new Error("StructureAnswer.prototype.setAnswerId expects a number.");
	}
	this.m_templateId = templateId;
	return this;
};

/**
 * Retrieves the answer template id.
 * @returns {number} The answer template id.
 */
StructureAnswer.prototype.getTemplateId = function() {
	return this.m_templateId;
};

/**
 * Returns the root rendered HTML element of a single structure answer.
 * @returns {jQuery|HTMLElement} The root HTML element of the structure answer.
 */
StructureAnswer.prototype.getRootElement = function() {
	if(!this.m_rootElement || !this.m_rootElement.length) {
		this.m_rootElement = $("#" + this.m_namespace + "Answer" + this.m_id);
	}
	return this.m_rootElement;
};

/**
 * Handles the refresh of the structure answer.
 */
StructureAnswer.prototype.refresh = function() {
	if(this.m_state !== this.m_previousState) {
		this.getRootElement().removeClass(this.m_previousState.getCSSClass()).addClass(this.m_state.getCSSClass());
	}
};

/**
 * Sets the answer display of the StructureAnswer.
 * @param {string} answerDisplay - The answer disaplay.
 * @returns {StructureAnswer} Returns self to allow chaining.
 */
StructureAnswer.prototype.setAnswerDisplay = function(answerDisplay) {
	if(typeof answerDisplay !== "string") {
		throw new Error("");
	}
	this.m_answerDisplay = answerDisplay;
	return this;
};

/**
 * Renders the StructureAnswer as an HTML string.
 * @param {StructureHtml} structureHtml - The packaged HTML passed through the recursive rendering.
 * @param {boolean} shouldRenderColumns - Unused boolean determining if the node should render columns.
 */
StructureAnswer.prototype.render = function(structureHtml, shouldRenderColumns) {
	structureHtml.append(
		"<div id='"+this.m_namespace +"Answer"+this.m_id+"' class='structure-answer' data-lookup='"+this.m_id+"'>" +
			"<input class='structure-answer-box' type='checkbox' data-lookup='"+this.m_id+"'>"+
			"<span class='structure-answer-display' data-lookup='" + this.m_id + "'>" + this.m_answerDisplay + "</span>"+
		"</div>"
	);
};


/**
 * StructureTermController
 * This class represents the base interface for a StructureTermController. It simply encapsulates the necessary
 * event attachment which allows for StructureTerms to behave correctly.
 * @constructor
 */
function StructureTermController() {
}

/**
 * This is an interface method in which you will attach events to the root of the organizer.
 * @param organizer the organizer for which you are attaching the events.
 */
StructureTermController.prototype.attach = function(organizer) {
    throw new Error("Attempted to call StructureTermController.prototype.attach, method must be implemented by sub-class");
};

/**
 * InputStructureTermController
 * This is the controller for the InputStructureTerm object. It attaches and handles event delegation
 * for input terms.
 * @constructor
 */
function InputStructureTermController() {
}
InputStructureTermController.prototype = new StructureTermController();
InputStructureTermController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach both a keyup and a click event to the inputs in order to handle
 * user interaction with them.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
InputStructureTermController.prototype.attach = function(organizer) {
    //Cache the root object since we're going to call it twice.
    var organizerRoot = organizer.getRootElement();
    //Handle keyup events on input terms
    organizerRoot.on("keyup", "div.input-term input", function(){
        //Grab the term from the organizer lookup table
        var term = organizer.getLookup()[organizer.parseIdForLookup($(this).attr("id"))];
        //Store the current text value on the term
        term.setCurrentValue($(this).val());
        //Update the term (may have a visual update as well)
        term.update();
    });
    //Handle click events on the input terms.
    organizerRoot.on("click", "div.input-term input", function(){
        //Grab the term from the organizer lookup table
        var term = organizer.getLookup()[organizer.parseIdForLookup($(this).attr("id"))];
        //If there is nothing in the text field, do nothing
        if(!$(this).val()) {
            return;
        }
        term.update();
    });
};

/**
 * CycleStructureTermController
 * This is the controller for the CycleStructureTerm object. It attaches and handles event delegation for any
 * CycleStructureTerm objects.
 * @constructor
 */
function CycleStructureTermController(){
}
CycleStructureTermController.prototype = new StructureTermController();
CycleStructureTermController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach an event delegate for clicking on CycleStructureTerm elements. When
 * the event is triggered, cycleState will be called on the associated CycleStructureTerm object.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
CycleStructureTermController.prototype.attach = function(organizer) {
	var rootElement = organizer.getRootElement();
	//Handle click events on cycle structure terms.
	rootElement.on("click", "div.cycle-term >.structure-documented-icon-area, div.cycle-term >.structure-term-info-wrapper", function(event) {
		// ignore click events originating from comment icon
		if ($(event.target).hasClass('structure-comment')) {
			return;
		}
		//Grab the term from the lookup table
		var term = organizer.getLookup()[organizer.parseIdForLookup($(this).closest(".structure-term-item").attr("id"))];
		//Cycle the state of the term
		term.cycleState();
		var termContainer = $(this).closest(".structure-term-item");
		//display/create the comments section if term has comment.
		if (term.getComment()) {
			// checking if the comment section is already available for the term. 
			var commentSection = $(this).siblings("div.structure-term-comment-wrapper");
			termContainer.addClass("comment");		
			if (commentSection.length < 1) {
				commentSection = "<div class='structure-term-comment-wrapper'>" + term.buildTextArea() + "</div>";
				termContainer.append(commentSection);
			}				
		} else {
			termContainer.removeClass("comment");	
		}	
	});
	//Handles the click event on structure comment icon
	rootElement.on("click", "span.structure-comment", function(event) {
		var termInfoSection = $(this).closest(".structure-term-info-wrapper");
		var commentSection = $(termInfoSection).siblings("div.structure-term-comment-wrapper");
		var termContainer = $(this).closest(".structure-term-item");
		termContainer.addClass("comment");
		// builds comment section if it is not available for the particular term
		if (commentSection.length < 1) {
			// create new comment section
			var term = organizer.getLookup()[organizer.parseIdForLookup($(this).closest(".structure-term-item").attr("id"))];
			commentSection = "<div class='structure-term-comment-wrapper'>" + term.buildTextArea() + "</div>";
			termContainer.append(commentSection);
		}
		//setting on focus to the comment section text area
		$(termContainer).find('textarea')[0].focus();		
		});
	//Handles the focus out event on text area of the comment section
	rootElement.on("focusout", "div.structure-term-comment-wrapper", function(event) {
		var term = organizer.getLookup()[organizer.parseIdForLookup($(this).closest(".structure-term-item").attr("id"))];
		var comment = $(this).find("textarea").val();
		var termContainer = $(this).closest(".structure-term-item");
		//check if the text input is empty, if empty then hide the comment section by removing comment class, if it has a value set it to the concern term(AMI)
		if (comment === "") {
			termContainer.removeClass("comment");			
		}
		// setting comment to the term 
		term.setComment(comment);
		// notify the term as dirty to enable the save button
		if (!term.checkIsDirty()) {
			if (term.getComment() !== term.getSavedComment()) {
				term.m_dirty = true;
				term.notifyDirty(term);
			} else {
				term.m_dirty = false;
				term.notifyDirty(term);
			}
		}
	});
}; 

/**
 * YesNoStructureTermController
 * This is the controller for the YesNoStructureTerm object. It attaches and handles event delegation for any
 * YesNoStructureTerm objects.
 * @constructor
 */
function YesNoStructureTermController(){
}
YesNoStructureTermController.prototype = new StructureTermController();
YesNoStructureTermController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach an event delegate for clicking the 'Y' and 'N' on
 * YesNoStructureTerm elements. This allows users to quickly jump from a 'Y' and 'N' state without having to rely
 * on cycling the state.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
YesNoStructureTermController.prototype.attach = function(organizer) {
	organizer.getRootElement().on("click", "div.structure-yes, div.structure-no", function(event) {
		//Grab the term from the lookup table
		var term = organizer.getLookup()[organizer.parseIdForLookup($(this).attr("id"))];
		//Cycle the state of the term
		var parent = term.getParent();
		var noneTerm = parent.getChildren()[0];
		
		if(NoneStructureTerm.prototype.isPrototypeOf(noneTerm) && noneTerm === term){
			noneTerm.jumpToState(0);
		}
		var jumpTo = $(this).hasClass("structure-yes") ? 1 : 2;
		var current = term.getCurrentState();
		term.jumpToState(jumpTo === current ? 0 : jumpTo);
		var termContainer = $(this).closest(".structure-term-item");
		if (term.getComment()) {
			//create or display the comments sections if the term has comment
			var commentSection = $(this).siblings("div.structure-term-comment-wrapper");
			//add class comment to display the comment section			
			termContainer.addClass("comment");
			// builds comment section if it is not available for the particular term
			if (commentSection.length < 1) {
				commentSection = "<div class='structure-term-comment-wrapper'>" + term.buildTextArea() + "</div>";
				termContainer.append(commentSection);
			}
		} else {
			termContainer.removeClass("comment");	
		}	
	});
};

/**
 * StructureGroupController
 * This is the controller for the StructureGroup object. It attaches and handles event delegation for any
 * StructureGroup objects.
 * @constructor
 */
function StructureGroupController(){
}
StructureGroupController.prototype = new StructureTermController();
StructureGroupController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach an event delegate for clicking the toggle controls on
 * StructureGroup elements.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
StructureGroupController.prototype.attach = function(organizer){
    organizer.getRootElement().on("click", ".structure-component-toggle, .structure-component-toggle + .structure-group-title", function(event){
        var group = $(this).parents(".structure-group").first();
        var groupNode = organizer.getLookup()[organizer.parseIdForLookup($(group).attr("id"))];
		groupNode.toggleExpand();
    });
};

/**
 * TableTermConstructor
 * This is the controller for the TableStructureTerm object. It attaches and handles event delegation for any
 * TableStructureTerm objects.
 * @constructor
 */
function TableTermController(){
}
TableTermController.prototype = new StructureTermController();
TableTermController.prototype.constructor = StructureTermController;

/**
 * Overrides the base attach method. This will attach an event delegate for clicking on TableStructureTerm elements. When
 * the event is triggered, cycleState will be called on the associated TableStructureTerm object.
 * @param {StructureOrganizer} organizer - The StructureOrganizer for which the events will be attached.
 */
TableTermController.prototype.attach = function(organizer) {
	var rootElement = organizer.getRootElement();
	//Handle click events on cycle structure terms.
	rootElement.on("click", "div.table-term >.structure-documented-icon-area", function(event) {
		//Grab the term from the lookup table
		var term = organizer.getLookup()[organizer.parseIdForLookup($(this).closest(".table-term").attr("id"))];
		//Cycle the state of the term
		term.cycleState();
	});

}; 
/**
 * The StructureTabControll class.
 * This will handle attaching events for structured documentation tabs. This occurs when there are subsections
 * present in a section.
 * @constructor
 */
function StructureTabController() {
	this.m_scrollMap = {};
	this.m_organizer = null;

	this.m_$structureTabGroup = null;
	this.m_$structureTabParent = null;
	this.m_$structureTabWrapper = null;
	this.m_$structureTabMenuButton = null;
}

StructureTabController.prototype = new StructureTermController();
StructureTabController.prototype.constructor = StructureTermController;

/**
 * Retrieves the tab group jQuery element.
 * @returns {jQuery} The tab group jQuery element.
 */
StructureTabController.prototype.getStructureTabGroup = function () {
	if (!this.m_$structureTabGroup || !this.m_$structureTabGroup.length) {
		this.m_$structureTabGroup = $("#" + this.m_organizer.getNamespace() + "StructureTabGroup");
	}
	return this.m_$structureTabGroup;
};

/**
 * Retrieves the tab parent jQuery element.
 * @returns {jQuery} The tab parent element.
 */
StructureTabController.prototype.getStructureTabParent = function () {
	if (!this.m_$structureTabParent || !this.m_$structureTabParent.length) {
		this.m_$structureTabParent = $("#" + this.m_organizer.getNamespace() + "StructureTabParent");
	}
	return this.m_$structureTabParent;
};

/**
 * Retrieves the tab wrapper jQuery element.
 * @returns {jQuery} The tab group wrapper element.
 */
StructureTabController.prototype.getStructureTabWrapper = function () {
	if (!this.m_$structureTabWrapper || !this.m_$structureTabWrapper.length) {
		this.m_$structureTabWrapper = $("#" + this.m_organizer.getNamespace() + "StructureTabGroupWrapper");
	}
	return this.m_$structureTabWrapper;
};

/**
 * Retrieves the structure tab menu button jQuery element.
 * @returns {jQuery} The structure tab menu button jQuery element.
 */
StructureTabController.prototype.getStructureTabMenuButton = function () {
	if (!this.m_$structureTabMenuButton || !this.m_$structureTabMenuButton.length) {
		this.m_$structureTabMenuButton = $("#" + this.m_organizer.getNamespace() + "StructureTabMenuButton");
	}
	return this.m_$structureTabMenuButton;
};

/**
 * Resize function to handle hiding/showing the tab menu icon.
 */
StructureTabController.prototype.resize = function () {
	var $structureTabParent = this.getStructureTabParent();
	var $structureTabWrapper = this.getStructureTabWrapper();
	var structureTabWrapperRaw = $structureTabWrapper[0];
	var $structureTabMenuButton = this.getStructureTabMenuButton();
	var miscPadding = 8;
	structureTabWrapperRaw.style.width = (($structureTabParent[0].offsetWidth - $structureTabMenuButton[0].offsetWidth) - miscPadding) + "px";
};

/**
 * Disables the active tab.
 * @param {StructureOrganizer} organizer - The organizer to which this controller is bound.
 * @param {jQuery} $activeTab - The active tab jQuery element.
 */
StructureTabController.prototype.disableActiveTab = function (organizer, $activeTab) {
	$activeTab.removeClass("structure-tab-active");
	var activeNode = organizer.getLookup()[$activeTab.attr("data-lookup")];
	//If we find the active node, find the closest tab contents (a direct ancestor to the node's root element) and hide it.
	if (activeNode) {
		//Remember the scroll position so it can be restored later
		this.m_scrollMap[activeNode.getId()] = activeNode.getContentElement().scrollTop();
		activeNode.getRootElement().closest(".structure-tab-content").hide();
	}
};

/**
 * Restores the scroll position for the specified node. This is expected to be a StructureOrganizer (section) node.
 * @param {StructureOrganizer} node - The node for which the scroll position is to be restored.
 */
StructureTabController.prototype.restoreScrollPosition = function (node) {
	var scrollTop = this.m_scrollMap[node.getId()];
	//If the scroll-top has not been stored for the node, just return.
	if (typeof scrollTop === "undefined") {
		return;
	}
	node.getContentElement().scrollTop(scrollTop);
};

/**
 * Overrides the attach function in the base StructureTermController class.
 * @param {StructureOrganizer} organizer - The organizer object which is considered the root of the structured
 * documentation tree.
 */
StructureTabController.prototype.attach = function (organizer) {
	this.m_organizer = organizer;
	var namespace = organizer.getNamespace();
	var menuItem = null;
	var $structureTabGroup = $("#" + namespace + "StructureTabGroup");
	var $structureTabs = $structureTabGroup.find(".structure-tab-display");
	var $structureTabWrapper = this.getStructureTabWrapper();
	var previousSelection = null;
	var self = this;
	var tabSelectionMenu = null;
	var menuItemArray = null;
	var selectedTabIndex = 0;
	var $contentBody = organizer.getRootElement().closest(".structured-documentation-view");
	var miscPadding = 8;

	//Make sure to resize up-front.
	this.resize();

	//This function is used when an element is selected in the component selection menu.
	var createSelectionFunc = function (index) {
		return function () {
			var $selectedTab = $structureTabs.eq(index);
			$selectedTab.click();

			var tabPosition = $selectedTab.closest(".structure-tab").position().left + $structureTabWrapper.scrollLeft();
			$structureTabWrapper.scrollLeft(tabPosition - miscPadding);
		};
	};
	//Attach a click event for the structure tabs.
	organizer.getRootElement().on("click", ".structure-tab-group .structure-tab .structure-tab-display", function (event) {
		var node = organizer.getLookup()[$(this).attr("data-lookup")];
		if (!node) {
			return;
		}
		if(node === organizer.getActiveSection()) {
			return;
		}
		//Prevent overflow when switching tabs (it will create a scrollbar on the right and throw off widths)
		$contentBody.css("overflow-y", "hidden");
		//If the section has not been rendered (lazy rendering of tabs)
		if(!node.isRendered()) {
			var $tabContentContainer = $("#" + namespace + "\\:tabContent\\:" + node.getId());
			$tabContentContainer.html(node.renderHtml());
			node.finalize();
			node.setIsRendered(true);
			node.getParent().resize();
		}
		//Show the content of the selected tab
		node.getRootElement().closest(".structure-tab-content").show();
		//Disable the currently active tab.
		self.disableActiveTab(organizer, $structureTabGroup.find(".structure-tab-active"));

		$(this).addClass("structure-tab-active");

		//The height adjustment can become invalid when switching views and resizing, so adjust.
		node.adjustContentHeight();

		//Store off the active section.
		organizer.setActiveSection(node);

		//Attempt to restore the scroll position.
		self.restoreScrollPosition(node);

		//Find the tab in the menu and make sure it is selected.
		selectedTabIndex = $(this).closest(".structure-tab").index();

		//Check that the menu and menu items exist (user may switch tabs before loading the menu).
		if(tabSelectionMenu && menuItemArray) {
			menuItemArray[selectedTabIndex].setIsSelected(true);
			if(previousSelection) {
				previousSelection.setIsSelected(false);
			}
			previousSelection = menuItemArray[selectedTabIndex];
		}
		$contentBody.css("overflow-y", "auto");
	});
	//Attach the click event for the extra tab menu. On first click, the menu will be created.
	organizer.getRootElement().on("click", ".structure-add-tab", function (event) {
		tabSelectionMenu = MP_MenuManager.getMenuObject(namespace + "structureAddTab");
		//Make sure this is a fresh menu. The organizer may have added children, so we cannot cache the menu.
		if(tabSelectionMenu) {
			MP_MenuManager.deleteMenuObject(namespace + "structureAddTab");
		}
		tabSelectionMenu = new Menu(namespace + "structureAddTab");
		tabSelectionMenu.setTypeClass("menu-page-menu structure-tab-menu");
		tabSelectionMenu.setIsRootMenu(true);
		tabSelectionMenu.setAnchorElementId(namespace + "StructureTabMenuButton");
		tabSelectionMenu.setAnchorConnectionCorner(["bottom", "right"]);
		tabSelectionMenu.setContentConnectionCorner(["top", "right"]);
		tabSelectionMenu.setLabel("");

		var children = organizer.getChildren();
		var childrenCount = children.length;
		var child = null;
		for (var i = 0; i < childrenCount; i++) {
			child = children[i];
			menuItem = new MenuSelection(namespace + "structureSectionTab" + child.getId());
			menuItem.setLabel(child.getTitle());
			menuItem.setCloseOnClick(true);
			menuItem.setClickFunction(createSelectionFunc(i));
			//Default the selected menu item to the tab that is currently selected.
			if(i === selectedTabIndex) {
				menuItem.setIsSelected(true);
				previousSelection = menuItem;
			}
			tabSelectionMenu.addMenuItem(menuItem);
		}
		//Keep reference to the array of menu items.
		menuItemArray = tabSelectionMenu.getMenuItemArray();
		MP_MenuManager.addMenuObject(tabSelectionMenu);
		MP_MenuManager.showMenu(namespace + "structureAddTab");
	});
};/**
 * StructureTermGroupController
 * This class represents the base interface for a StructureTermGroupController. It simply encapsulates the necessary
 * event attachment which allows for StructureTermGroups to behave correctly.
 * @constructor
 */
function StructureTermGroupController() {
}

/**
 * This is an interface method in which you will attach events to the root of the organizer.
 * @param {StructureOrganizer} organizer the organizer for which you are attaching the events.
 */
StructureTermGroupController.prototype.attach = function(organizer) {
	var organizerRoot = organizer.getRootElement();
	//Handle click event on Show More/Show Less link
	organizerRoot.on("click", "a.show-more-link", function(){
		var $sourceTermGroup = $(this).closest(".structure-group");
		var termGroup = organizer.getLookup()[organizer.parseIdForLookup($sourceTermGroup.attr("id"))];
		termGroup.toggleShowMore();
	});
};function StructureManager() {
	//JSON data
	this.m_replyData = null;
	this.m_referenceData = null;
	this.m_activityData = null;
	this.m_questionData = null;
	this.m_status = "";

	//Structure objects
	this.m_organizer = null;
	this.m_resizeFunction = null;
	this.m_tabController = null;
	this.m_questionSet = null;
	this.m_openExistingCheckFunction = null;
	this.m_answers = null;
	this.m_openExistingFunction = null;
	this.m_queryTemplateFunction = null;
	this.m_onDirtyChangeCallback = null;

	//Element cache
	this.m_$structureManagerContainer = null;
	this.m_$structureContainer = null;
	this.m_$structureOrganizerContents = null;
	this.m_$questionContainer = null;
	this.m_$questionContents = null;
	this.m_$messageContainer = null;
	this.m_$addTemplateButton = null;

	this.m_namespace = "";
}

/**
 * Sets the namespace of the structured documentation manager. This will provide unique DOM ids for any generated
 * elements.
 * @param {string} namespace - The namespace for all generated DOM elements.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setNamespace = function(namespace) {
	if(typeof namespace !== "string") {
		throw new Error("StructureManager.prototype.setNamespace expects a string.");
	}
	this.m_namespace = namespace;
	return this;
};

/**
 * Sets the dirty change callback function that is triggered when the structure organizer is considered dirty.
 * @param {function} dirtyChangeCallback - The callback function to be triggered when the structured documentation
 * content changes dirty state.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setOnDirtyChangeCallback = function(dirtyChangeCallback) {
	if(typeof dirtyChangeCallback !== "function") {
		throw new Error("StructureManager.prototype.setOnDirtyChangeCallback expects a function.");
	}
	this.m_onDirtyChangeCallback = dirtyChangeCallback;
	return this;
};

/**
 * Sets the callback function which is expected to perform the open existing operation. This will flex depending on the
 * consumer of the artifact.
 * @param {function} openExistingFunction - The provided callback function which is expected to perform the open
 * existing operation. This function must be of the form...
 * exampleManager.setOpenExistingFunction(function(structureData, postOpenCallback){
 * 		//Perform open existing operation
 * 		//After open existing operation, call callback with response data...
 * });
 * The consumer must call the postQueryCallback function with the following information...
 * postOpenCallback({
 * 		"status" : "S/F/Z",
 * 		"section_ref" : [...]
 * 		"section_act" : [...],
 * 		"user_options" : [...]
 * });
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setOpenExistingFunction = function(openExistingFunction) {
	if(typeof openExistingFunction !== "function") {
		throw new Error("StructureManager.prototype.setOpenExistingFunction expects a function.");
	}
	this.m_openExistingFunction = openExistingFunction;
	return this;
};

/**
 * Sets the callback function which is expected to perform the query template operation. This will flex depending on the
 * consumer of the artifact.
 * @param {function} queryTemplateFunction - The provided callback function which is expected to perform the query
 * template operation. This function must be of the form...
 * exampleManager.setQueryTemplateFunction(function(structureData, postQueryCallback){
 * 		//Perform query template operation
 * 		//After query template operation, call callback with response data...
 * });
 * The consumer must call the postQueryCallback function with the following information...
 * postQueryCallback({
 * 		"status" : "S/F/Z",
 * 		"section_ref" : [...]
 * 		"section_act" : [...],
 * 		"user_options" : [...]
 * });
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setQueryTemplateFunction = function(queryTemplateFunction) {
	if(typeof queryTemplateFunction !== "function") {
		throw new Error("StructureManager.prototype.setQueryTemplateFunction expects a function.");
	}
	this.m_queryTemplateFunction = queryTemplateFunction;
	return this;
};

/**
 * Sets the callback function which is expected to determine if the StructureManager needs to perform the open existing
 * operation. If this function returns true, the manager will open-existing on refresh, otherwise it will perform the
 * query template operation.
 * @param {function} openExistingCheckFunction - The callback function which will determine if the manager should perform
 * the open existing or query template operation. It must be of the form...
 * manager.setOpenExistingCheckFunction(function(){
 * 		//Perform necessary checks to determine if open existing should be performed.
 * 		return true/false;
 * });
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setOpenExistingCheckFunction = function(openExistingCheckFunction) {
	if(typeof openExistingCheckFunction !== "function") {
		throw new Error("StructureManager.prototype.setOpenExistingCheckFunction expects a function.");
	}
	this.m_openExistingCheckFunction = openExistingCheckFunction;
	return this;
};

/**
 * Sets the resize function which is passed to the m_organizer object (when built).
 * @param resizeFunction
 * @returns {StructureManager}
 */
StructureManager.prototype.setOrganizerResizeFunction = function(resizeFunction) {
	if(typeof resizeFunction !== "function") {
		throw new Error("StructureManager.prototype.setResizeFunction expects a function");
	}
	this.m_resizeFunction = resizeFunction;
	return this;
};

/**
 * Resizes structured documentation. First calls resize on the organizer then subsequently resizes
 * the tab controller if there is one.
 */
StructureManager.prototype.resize = function() {
	var self = this;
	setTimeout(function(){
		if(self.m_organizer) {
			self.m_organizer.resize();
		}
		if(self.m_tabController) {
			self.m_tabController.resize();
		}
	}, 100);
};

/**
 * Handles the event when the user clicks the Add Template(s) button. This will obtain and store the set of answers that
 * the user chose from the question set and make a call to refresh the structure manager.
 */
StructureManager.prototype.onAddTemplateClick = function() {
	this.m_$addTemplateButton.prop("disabled", true);
	this.m_answers = this.m_questionSet.getAnswers();
	this.completeRefresh();
};

/**
 * Determines if structured documentation should make a call to open existing structured content or not. This
 * relies on the m_openExistingCheckFunction which is provided by the consumer of this artifact. The aforementioned
 * callback function must return a boolean indicating true or false.
 * @returns {boolean} True if the callback function indicates, otherwise false.
 */
StructureManager.prototype.shouldOpenExisting = function() {
	if(!this.m_openExistingCheckFunction) {
		throw new Error("StructureManager.prototype.shouldOpenExisting function expects you to have set an open existing check function.");
	}
	return this.m_openExistingCheckFunction();
};

/**
 * Performs a complete refresh of the structured documentation. It will either make the call to open existing or
 * query template.
 */
StructureManager.prototype.completeRefresh = function() {
	this.resetReplyData();
	if(this.shouldOpenExisting()) {
		this.openExisting();
	} else {
		this.queryTemplate();
	}
};

/**
 * This renders the shell of the structure manager.
 * @returns {*|jQuery|HTMLElement} The structure manager shell.
 */
StructureManager.prototype.render = function() {
	var self = this;
	var namespace = this.m_namespace;

	//Wrapper
	var $structureView = $("<div id='" + namespace +"StructureView' class='structured-documentation-view content-body'></div>");
	this.m_$structureManagerContainer = $structureView;

	//Questions
	var $questionContainer = $("<div id='" + namespace + "QuestionContainer' class='structure-question-container'></div>").hide();
	this.m_$questionContainer = $questionContainer;
	var $addTemplateButton = $("<button id='" + namespace + "AddTemplateButton' class='structure-add-template-btn' disabled>Add Template(s)</button>");
	$addTemplateButton.click(function(){
		self.onAddTemplateClick();
	});
	this.m_$addTemplateButton = $addTemplateButton;
	$questionContainer.append($addTemplateButton);
	$questionContainer.append($("<div class='structure-question-info-icon'></div>"));
	var $questionContents = $("<div id='" + namespace + "QuestionContents' class='structure-question-contents'></div>");
	$questionContainer.append($questionContents);
	this.m_$questionContents = $questionContents;
	$structureView.append($questionContainer);

	//Structure Organizer
	//The structure content container, structure content is injected here.
	var $structureContainer = $("<div id='" + namespace + "StructureContainer'></div>").hide();
	this.m_$structureContainer = $structureContainer;

	var $structureOrganizerContents = $("<div id='" + namespace + "StructureOrganizerContents'></div>");
	this.m_$structureOrganizerContents = $structureOrganizerContents;
	$structureContainer.append($structureOrganizerContents);

	$structureView.append($structureContainer);

	//Message
	var $messageContainer = $("<div id='" + namespace + "StructureMessageContainer'></div>").hide();
	this.m_$messageContainer = $messageContainer;
	$structureView.append($messageContainer);

	//Perform initial render based on the reply data we were supplied.
	if(this.m_status !== "S") {
		this.showStructureErrorMessage(i18n.discernabu.documentation_base.STRUCTURED_DOC_UNAVAILABLE);
		return $structureView;
	}
	if(this.hasQuestions()) {
		this.showQuestions();
	} else if(this.hasStructuredContent()) {
		this.showStructure();
	} else {
		this.showStructureErrorMessage(i18n.discernabu.documentation_base.STRUCTURED_TEMPLATES_NOT_FOUND);
	}
	return $structureView;
};

/**
 * Renders the structured content into the specified element.
 * @param {jQuery} $destinationElement - The element into which structure shall be rendered.
 */
StructureManager.prototype.renderInto = function($destinationElement) {
	$destinationElement.append(this.render());
	this.attachQuestionDelegates();
	this.mergeActivity();
	this.finalizeStructure();
};

/**
 * This function attaches the necessary question delegates. This currently attaches events for
 * clicking on the checkbox or the title of an answer.
 */
StructureManager.prototype.attachQuestionDelegates = function() {
	var self = this;
	//Attach the delegate for answering questions.
	this.m_$questionContainer.on("change", ".structure-answer-box", function(event){
		var nodeId = $(this).attr("data-lookup");
		var node = self.m_questionSet.getLookup()[nodeId];
		if(!node) {
			logger.logWarning("StructureDocumentationView.prototype.finalizeQuestions: could not find answer node with id = " + nodeId);
			return;
		}
		node.cycleState();
	});
	//Attach a delegate for clicking on the answer display which will trigger the click event on the checkbox.
	this.m_$questionContainer.on("click", ".structure-answer-display", function(event){
		var nodeId = $(this).attr("data-lookup");
		var node = self.m_questionSet.getLookup()[nodeId];
		if(!node) {
			logger.logWarning("StructureDocumentationView.prototype.finalizeQuestions: could not find answer node with id = " + nodeId);
			return;
		}
		node.cycleState();
		//Now ensure that the checkbox is updated according to the state of the answer.
		$(this).siblings(".structure-answer-box").prop("checked", (node.getState().getValue() ? true : false));
	});
};

/**
 * This function refresh the structure manager. This must only be called post-render, in other words, structure has
 * already been shown and is being refreshed.
 */
StructureManager.prototype.refresh = function() {
	if(this.m_status !== "S") {
		this.m_$structureContainer.hide();
		this.m_$questionContainer.hide();
		this.showStructureErrorMessage(i18n.discernabu.documentation_base.STRUCTURED_DOC_UNAVAILABLE);
		return;
	}
	if(this.hasQuestions()) {
		this.m_$structureContainer.hide();
		this.m_$messageContainer.hide();
		this.showQuestions();
	} else if(this.hasStructuredContent()) {
		this.m_$questionContainer.hide();
		this.m_$messageContainer.hide();
		this.showStructure();
		this.mergeActivity();
		this.finalizeStructure();
	} else {
		this.m_$structureContainer.hide();
		this.m_$questionContainer.hide();
		this.showStructureErrorMessage(i18n.discernabu.documentation_base.STRUCTURED_TEMPLATES_NOT_FOUND);
	}
};

/**
 * Wrapper call to navigate structured documentation to the specified node.
 * @param {Object} navigationData - The navigation data that is used to find a node within the structured
 * documentation tree and navigate to it.
 */
StructureManager.prototype.navigateToNode = function(navigationData) {
	if(!navigationData) {
		logger.logWarning("StructureManager.prototype.navigateToNode expects navigation data.");
		return;
	}
	if(!this.m_organizer) {
		logger.logWarning("StructureManager.prototype.navigateToNode: attempted to navigate to node without a structure organizer object.");
		return;
	}
	this.m_organizer.navigateToNode(navigationData);
};

/**
 * Attaches necessary controllers to the structure organizer as well as other customized events such as the dirty handler
 * and a resize function.
 */
StructureManager.prototype.finalizeStructure = function() {
	var organizer = this.m_organizer;
	if(!organizer) {
		return;
	}
	//Set the resize function on the organizer
	organizer.setResizeFunction(this.m_resizeFunction);
	//Set the dirty change callback.
	organizer.setOnDirtyChangeCallback(this.m_onDirtyChangeCallback);
	//Finalize the structure object.
	organizer.finalize();
	//Attach the interaction controllers.
	(new CycleStructureTermController()).attach(organizer);
	(new InputStructureTermController()).attach(organizer);
	(new StructureGroupController()).attach(organizer);
	(new YesNoStructureTermController()).attach(organizer);
	(new TableTermController()).attach(organizer);
	(new StructureTermGroupController()).attach(organizer);
	//Only attach the tab controller if it is a multi-section structure.
	if(organizer.isMultiSection()) {
		var tabController = new StructureTabController();
		tabController.attach(organizer);
		//Keep reference to the tab controller since it requires some resize logic later.
		this.m_tabController = tabController;
	}
};

/**
 * Simple check to determine if the data received from the server has provided reference data for structured documentation.
 * This should come back from the server in the form of section_ref[].
 * @returns {boolean} True if the data received contains structured reference data, otherwise false.
 */
StructureManager.prototype.hasStructuredContent = function() {
	return (this.m_referenceData !== null) && this.m_referenceData.length > 0;
};

/**
 * Determines if the data received from the server has provided question data. This should come back from the server
 * in the form of user_options: [].
 * @returns {boolean} True if the data received contains questions, otherwise false.
 */
StructureManager.prototype.hasQuestions = function() {
	return this.m_questionData !== null;
};

/**
 * Uses the JSONStructureOrganizerBuilder to build a set of questions.
 * @returns {StructureQuestionSet} A question set built from the question data received.
 */
StructureManager.prototype.generateQuestionSet = function() {
	var self = this;
	var questionData = this.m_questionData;
	this.m_questionSet = (new JSONStructureOrganizerBuilder().setNamespace(this.m_namespace)).buildQuestionSet(questionData);
	this.m_questionSet.setOnCompleteCallback(function(complete){
		self.m_$addTemplateButton.prop("disabled", !complete);
	});
	return this.m_questionSet;
};

/**
 * Helper function to attach necessary events.
 */
StructureManager.prototype.finalize = function() {
	this.finalizeStructure();
	this.attachQuestionDelegates();
};

/**
 * Shows the question container and injects the question set into the question contents wrapper. It also defaults the
 * add templates button to being disabled until the question set is considered complete.
 */
StructureManager.prototype.showQuestions = function() {
	var $questionContainer = this.m_$questionContainer;
	$questionContainer.show();
	//Generate the question set
	var questionSet = this.generateQuestionSet();
	this.m_$questionContents.html(questionSet.render());
	this.m_$addTemplateButton.prop("disabled", true);
};

/**
 * Shows the structure container and injects the structured documentation html into the contents wrapper. It first builds
 * the structure content based on the data retrieved from the server.
 */
StructureManager.prototype.showStructure = function() {
	this.m_$structureContainer.show();
	var $structureOrganizerContents = this.m_$structureOrganizerContents;
	var builder = new JSONStructureOrganizerBuilder();
	builder.setNamespace(this.m_namespace);
	builder.setStructureJSON(this.m_referenceData[0]);
	var organizer = builder.buildStructureTree();
	this.m_organizer = organizer;
	//Append the organizer html
	$structureOrganizerContents.html(organizer.renderHtml());
};

/**
 * Shows a structured documentation error message in the message container element.
 * @param {string} message - The message to be shown.
 */
StructureManager.prototype.showStructureErrorMessage = function(message) {
	this.m_$messageContainer.html(message);
	this.m_$messageContainer.show();
};


/**
 * Sets the reply information based on the data retrieval response. This data must be of the form...
 * {
 * 		"status" : "S/F/Z",
 * 		"section_ref" : [...],
 * 		"section_act" : {},
 		"user_options" : [...]
 * }
 * @param replyData - The information received from a call to retrieve structured documentation data. This information
 * can be retrieved by either query template or open existing.
 */
StructureManager.prototype.setReplyData = function(replyData) {
	this.setStatus(replyData.status || "F");
	this.setReferenceData(replyData.section_ref || null);
	this.setActivityData(replyData.section_act || null);
	if(replyData.user_options && replyData.user_options.length) {
		this.setQuestionData(replyData.user_options);
	} else {
		this.setQuestionData(null);
	}
};

/**
 * Simple passthrough function which calls resetDirty on the structure organizer.
 */
StructureManager.prototype.resetDirty = function() {
	if(this.m_organizer) {
		this.m_organizer.resetDirty();
	}
};

/**
 * Resets all of the service-retrieved field back to their defauls. Take note that the status is
 * defaulted to 'F', so failure is assumed until proven otherwise by the services that retrieve the
 * data.
 */
StructureManager.prototype.resetReplyData = function() {
	this.m_replyData = null;
	this.m_referenceData = null;
	this.m_activityData = null;
	this.m_questionData = null;
	this.m_status = "F";
};

/**
 * Sets the status of the service call to query template or open existing.
 * @param {string} status - The status of the service call. This is either successful, failure,
 * or a Z status.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setStatus = function(status) {
	if(typeof status !== "string") {
		throw new Error("StructureManager.prototype.setStatus expects a string (S/F/Z)");
	}
	this.m_status = status;
	return this;
};

/**
 * Sets the reference data retrieved from the call to query template or open existing.
 * @param {Object} referenceData - The reference data (section_ref) retrieved from the service call
 * to open existing or query template.
 * @returns {StructureManager} returns self to allow chaining.
 */
StructureManager.prototype.setReferenceData = function(referenceData) {
	this.m_referenceData = referenceData;
	return this;
};

/**
 * Sets the activity data retrieved from the call to query template or open existing.
 * @param {Object} activityData - The activity data (section_act) retrieved from the service call
 * to open existing or query template.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setActivityData = function(activityData) {
	this.m_activityData = activityData;
	return this;
};

/**
 * Sets the question data retrieved from the call to query template or open existing.
 * @param {Object} questionData - The user options (user_options) retrieved from the service call
 * to open existing or query template.
 * @returns {StructureManager} Returns self to allow chaining.
 */
StructureManager.prototype.setQuestionData = function(questionData) {
	this.m_questionData = questionData;
	return this;
};

/**
 * Handles merging activity data (section_act) into the pre-constructed structure tree. This function
 * will do nothing if there is no structure tree (structure organizer) or there is no activity data.
 */
StructureManager.prototype.mergeActivity = function() {
	if(!this.m_organizer || !this.m_activityData) {
		return;
	}
	var updater = new JSONStructureOrganizerBuilder();
	updater.update(this.m_organizer, this.m_activityData);
	this.resetDirty();
};

/**
 * Exposes a function for querying template in structured documentation. It is expected that the consumer has provided
 * the m_queryTemplateFunction which makes a call to query template and calls the callback with the response data.
 */
StructureManager.prototype.queryTemplate = function() {
	if(!this.m_queryTemplateFunction) {
		logger.logError("StructureManager.prototype.queryTemplate: No query template function provided.");
		return;
	}
	var self = this;
	var requestData = {
		"USER_OPTION_RESPONSES" : this.m_answers
	};
	this.m_queryTemplateFunction(requestData, function(reply){
		self.m_answers = null;
		self.setReplyData(reply);
		self.refresh();
	});
};

/**
 * Exposes a function for opening existing structured documentation sections. It is expected that the consumer has
 * provided the m_openExistingFunction which makes a call to open existing and calls the callback with the response
 * data.
 */
StructureManager.prototype.openExisting = function() {
	if(!this.m_openExistingFunction) {
		logger.logError("StructureManager.prototype.openExisting: No open existing function provided.");
		return;
	}
	var self = this;
	var requestData = {
		"USER_OPTION_RESPONSES" : this.m_answers
	};
	this.m_openExistingFunction(requestData, function(reply){
		self.m_answers = null;
		self.setReplyData(reply);
		self.refresh();
	});
};
/**
 * Base class for validators that validates input
 */
function InputValidator() {
}

InputValidator.prototype.validate = function (input) {
	return true;
};

InputValidator.prototype.getMessage = function () {
	return "";
};

/**
 * DataTypeValidator
 * This class is for validating specified data types. The supported data types are ALPHA,
 * NUMERIC. Depending on the data type, a specific regular expression will
 * be created.
 * @returns {DataTypeValidator}
 * @constructor
 */
function DataTypeValidator() {
	this.m_dataType = DataTypeValidator.ALPHA_TYPE;
	this.m_dataRegex = DataTypeValidator.ALPHA_REGEX;
	return this;
}

/**
 * The string constant that denotes an alpha data type
 * 
 * @constant {string}
 * @static
 */
DataTypeValidator.ALPHA_TYPE = "ALPHA";

/**
 * The regular expression regular expression for validating the alpha data type.
 * The alpha type consists of alphanumerics and symbols.
 * 
 * Allowed symbols: `~!@#$%^&*()_+-=,.<>?;:''"{}|\/[]
 * 
 * TODO: revisit to support other languages/regions
 * 
 * @constant {RegExp}
 * @static
 */
DataTypeValidator.ALPHA_REGEX = /^[a-zA-Z0-9 `~!@#$%^&*()_+-=,.<>?;:''"{}|\\\/\[\]]*$/;

/**
 * The string constant that denotes an numeric data type
 * 
 * TODO: revisit to support other languages/regions
 * 
 * @constant {string}
 * @static
 */
DataTypeValidator.NUMERIC_TYPE = "NUMERIC";

/**
 * The regular expression regular expression for validating the numeric data type.
 * The numeric type allows for positive and negative integers.
 *  
 * @constant {RegExp}
 * @static
 */
DataTypeValidator.NUMERIC_REGEX = /^[-]?[0-9]*[.]?[0-9]*$/;

/**
 * The string constant that denotes an alpha data type
 * 
 * @constant {string}
 * @static
 */
DataTypeValidator.prototype = new InputValidator();
DataTypeValidator.prototype.constructor = InputValidator;

/**
 * Gets the data type for this validator.
 * 
 * @returns {string} The data type for this validator
 */
DataTypeValidator.prototype.getDataType = function () {
	return this.m_dataType;
};

/**
 * Sets the data type for the DataTypeValidator. This data type will determine the regular
 * expression that is created.
 * 
 * @param {string} dataType - The data type that this DataTypeValidator should expect. This can
 * be "ALPHA" or "NUMERIC". The default is "ALPHA" values.
 * @returns {DataTypeValidator}
 */
DataTypeValidator.prototype.setDataType = function (dataType) {
	this.m_dataType = dataType;
	switch (dataType) {
		case DataTypeValidator.NUMERIC_TYPE:
			this.m_dataRegex = DataTypeValidator.NUMERIC_REGEX;
			break;
		// ALPH includes alphanumerics and it is the default as well
		case DataTypeValidator.ALPHA_TYPE:
		default:
			this.m_dataType = DataTypeValidator.ALPHA_TYPE;
			this.m_dataRegex = DataTypeValidator.ALPHA_REGEX;
	}
	return this;
};

/**
 * Overrides the base getMessage function. This generates a message informing
 * what values this validator expects.
 * @returns {string} The message explaining what types this validator accepts.
 */
DataTypeValidator.prototype.getMessage = function () {
	var message = '';
	
	switch (this.m_dataType) {
		case DataTypeValidator.NUMERIC_TYPE:
			message = "Number (+- 0-9)";
			break;
		case DataTypeValidator.ALPHA_TYPE:
		default:
			message = "Alphabetical and Numeric";
	}

	return "<span class='term-info-item'>This field accepts only {0} characters</span>".replace("{0}", message);
};

DataTypeValidator.prototype.validate = function (input) {
	return this.m_dataRegex.test(input);
};

DataTypeValidator.prototype.getDataRegex = function () {
	return this.m_dataRegex;
};

DataTypeValidator.prototype.setDataRegex = function (dataRegex) {
	if (!RegExp.prototype.isPrototypeOf(dataRegex)) {
		throw new Error("Cannot set regex with non regex type");
	}
	this.m_dataRegex = dataRegex;
	return this;
};

function DataRangeValidator() {
	this.m_minValue = Number.NEGATIVE_INFINITY;
	this.m_maxValue = Number.POSITIVE_INFINITY;
	return this;
}

DataRangeValidator.prototype = new InputValidator();
DataRangeValidator.prototype.constructor = InputValidator;

DataRangeValidator.prototype.getMessage = function () {
	return "<span class='term-info-item'>Number must be between {0} and {1}</span>".replace("{0}", this.m_minValue).replace("{1}", this.m_maxValue);
};

DataRangeValidator.prototype.validate = function (input) {
	try {
		var numericValue = parseFloat(input);
		if (isNaN(numericValue)) {
			throw new Error("Input is not a number type, cannot validate");
		}
		return (numericValue <= this.m_maxValue && numericValue >= this.m_minValue);
	} catch (exe) {
		return false;
	}
};

DataRangeValidator.prototype.setMinValue = function (minValue) {
	if (typeof minValue !== "number") {
		throw new Error("Cannot setMinValue with non number type");
	}
	if (minValue > this.m_maxValue) {
		throw new Error("Cannot set a minValue greater than the max value");
	}
	this.m_minValue = minValue;
	return this;
};

DataRangeValidator.prototype.setMaxValue = function (maxValue) {
	if (typeof maxValue !== "number") {
		throw new Error("Cannot setMaxValue with non number type");
	}
	if (maxValue < this.m_minValue) {
		throw new Error("Cannot set a maxValue less than the min value");
	}
	this.m_maxValue = maxValue;
	return this;
};

TemplateEngine={};
(function(ns,$){ns.getHtmlTags=function(){var tags=["html","span","head","body","pre","h1","h2","h3","h4","h5","h6","b","i","em","strong","font","a","p","br","dl","dt","dd","ol","ul","li","div","img","hr","table","th","tr","td","tbody","thead","form","option","input","textarea","button"];
var result={};
result=ns.getTags(tags);
return result;
};
ns.getTags=function(tags){var result={};
$.each(tags,function(i,tagname){result[tagname]=ns.tag(tagname);
});
return result;
};
ns.tag=function(tagname){return function(){var args=[].slice.call(arguments);
args.unshift(tagname);
var tagObj=new ns.Tag(tagname);
ns.Tag.apply(tagObj,args);
return tagObj;
};
};
ns.button=function(attributes){attributes.type="button";
return new ns.Tag("input",attributes,null);
};
ns.textbox=function(attributes){attributes.type="text";
return new ns.Tag("input",attributes,null);
};
ns.Tag=function(name,args){this.name=name;
this.parent=null;
this.element=null;
this.content="";
this.attributes={};
if(arguments.length==1){return;
}var arg2=arguments[1];
var contentOffset=1;
if(arg2 instanceof Object&&!(arg2 instanceof ns.Tag)&&!(arg2 instanceof String)&&!(arg2 instanceof Array)){this.attributes=arg2;
contentOffset=2;
}if(arguments.length==2&&contentOffset==2){return;
}var contentArr=[];
for(var i=contentOffset;
i<arguments.length;
i++){if(arguments[i] instanceof Array){$.merge(contentArr,arguments[i]);
}else{contentArr.push(arguments[i]);
}}this.content=contentArr;
};
ns.Tag.prototype.render=function(){this.makeElement();
this.makeContent();
return this.element;
};
ns.Tag.prototype.makeElement=function(){var element=$("<"+this.name+"></"+this.name+">");
$.each(this.attributes,function(key,value){if(!value){value="";
}element.attr(key,value);
});
this.element=element;
return element;
};
ns.Tag.traverse=function(content,parentTag){if(!content){return;
}if(content instanceof ns.Tag){content.parent=parentTag;
parentTag.element.append(content.render());
return;
}if(!(content instanceof Array)){parentTag.element.append(content);
return;
}$.each(content,function(key,value){ns.Tag.traverse(value,parentTag);
});
};
ns.Tag.prototype.makeContent=function(){ns.Tag.traverse(this.content,this);
};
ns.Template=function(templateFunction){this.m_function=templateFunction;
this.m_factory=null;
};
ns.Template.prototype.render=function(context){var scope=new ns.ScopeManager();
if(this.m_factory){this.m_factory.before(scope);
}var rootTag=this.m_function(context);
if(!(rootTag instanceof ns.Tag)){alert("The template function does not return a Tag instance.");
}var rendered=rootTag.render();
scope.clean();
if(this.m_factory){this.m_factory.after(scope);
}return rendered;
};
ns.TemplateFactory=function(templates){var self=this;
$.each(templates,function(k,v){if(k!="before"&&k!="after"){self[k]=new ns.Template(v);
self[k].m_factory=self;
}else{self[k]=v;
}});
};
ns.TemplateFactory.prototype.before=function(){};
ns.TemplateFactory.prototype.after=function(){};
ns.ScopeManager=function(){this.m_originalScope={};
};
ns.ScopeManager.prototype.use=function(objects){var self=this;
$.each(objects,function(k,v){if(window[k]!==undefined){self.m_originalScope[k]=window[k];
}window[k]=v;
});
};
ns.ScopeManager.prototype.clean=function(){var self=this;
$.each(this.m_originalScope,function(k,v){window[k]=v;
});
};
}(TemplateEngine,jQuery));
/* eslint mp-camelcase:0, indent: 0 */
/**
 * The getDstSwitches function has been obtained from a third party source which can be found in the link below:
 * http://www.codeproject.com/Articles/58728/JavaScript-code-to-determine-when-DayLight-Savings
 * License for it can be found here: http://www.codeproject.com/info/cpol10.aspx
 */
/**
 * This TimeZone object will be used to store the respective information about each timezone.
 * It will determine the correct abbreviation on basis of whether DST is observed in a timezone.
 * It will also store the DST transition information for any particular year.
 * @param {String} name The unique timezone name from JSTimeZoneDetect library
 * @param {String} abbr The abbreviation to be displayed when in Standard Time
 * @param {String} dst_abbr The abbreviation to be displayed when in Daylight Time
 * @param {Object} info The transition time information for the timezone
 * @param {Number} tz_index The time zone index value from srvcalendars
 * @returns {undefined}
 */
var TimeZone = function(name, abbr, dst_abbr, info, tz_index){
	this.m_name = name;
	this.m_abbr = abbr;
	this.m_dst_abbr = dst_abbr;
	this.m_dst_info = info;
	this.m_tz_index = tz_index;
};

/**
 * Returns the time zone index value
 * @returns {Number} The TimeZone index value
 */
TimeZone.prototype.getTzIndex = function(){
	return this.m_tz_index;
};

/**
 * Returns the unique name assigned to the TimeZone
 * @returns {String} The TimeZones unique name
 */
TimeZone.prototype.getName = function(){
	return this.m_name;
};

/**
 * Set the unique name for the TimeZone Object
 * @param {String} name The unique name to be given to the TimeZone
 * @returns {undefined}
 */
TimeZone.prototype.setName = function(name){
	if(typeof name !== "string"){
		throw new Error("TimeZone: Invalid timezone name");
	}
	this.m_name = name;
};

/**
 * Returns the standard time abbreviation of the TimeZone
 * @returns {String} The TimeZones standard abbreviation
 */
TimeZone.prototype.getStandardAbbreviation = function() {
	return this.m_abbr;
};

/**
 * Set the Standard time abbreviation for the TimeZone
 * @param {String} abbr The standard abbreviation to be set for the TimeZone
 * @returns {undefined}
 */
TimeZone.prototype.setStandardAbbreviation = function(abbr){
	if(typeof abbr !== "string"){
		throw new Error("TimeZone: Invalid standard timezone abbreviation");
	}
	this.m_abbr = abbr;
};

/**
 * Returns the daylight time abbreviation of the TimeZone
 * @returns {String} The TimeZones daylight abbreviation
 */
TimeZone.prototype.getDaylightAbbreviation = function() {
	return this.m_dst_abbr;
};

/**
 * Set the Daylight time abbreviation for the TimeZone
 * @param {String} abbr The daylight abbreviation to be set for the TimeZone
 * @returns {undefined} This function does not return a value.
 */
TimeZone.prototype.setDaylightAbbreviation = function(abbr){
	if(typeof abbr !== "string"){
		throw new Error("TimeZone: Invalid daylight timezone abbreviation");
	}
	this.m_dst_abbr = abbr;
};

/**
 * Return the DST transition information of a TimeZone
 * @returns {object} Returns the DST information for a timezone.
 */
TimeZone.prototype.getDSTInfo = function(){
	return this.m_dst_info;
};

/**
 * Set the Daylight time information for the TimeZone
 * @param {String} key The key for the hashmap usually a year
 * @param {Object} value The value to be set for corresponding key
 * @returns {undefined} This function does not return a value.
 */
TimeZone.prototype.setDSTInfo = function(key, value){
	this.m_dst_info[key] = value;
};

/**
 * Create mappings of TimeZone object for each unique value that can be returned by the
 * JSTimeZoneDetect library.
 */
var timezones = {};
timezones.mapping = {
	"Etc/GMT+12": new TimeZone("Etc/GMT+12", "DST", "DST", {}, 1),
	"Pacific/Pago_Pago": new TimeZone("Pacific/Pago_Pago", "SST", "SST", {}, 7),
	"America/Adak": new TimeZone("America/Adak", "HAST", "HADT", {}, 10),
	"Pacific/Apia": new TimeZone("Pacific/Apia", "WST", "WST", {}, 4),
	"Pacific/Honolulu": new TimeZone("Pacific/Honolulu", "HAST", "HAST", {}, 15),
	"Pacific/Marquesas": new TimeZone("Pacific/Marquesas", "MART", "MART", {}, 22),
	"Pacific/Gambier": new TimeZone("Pacific/Gambier", "GAMT", "GAMT", {}, 29),
	"America/Anchorage": new TimeZone("America/Anchorage", "AKST", "AKDT", {}, 24),
	"America/Los_Angeles": new TimeZone("America/Los_Angeles", "PST", "PDT", {}, 35),
	"America/Santa_Isabel": new TimeZone("America/Santa_Isabel", "PST", "PDT", {}, 607),
	"Pacific/Pitcairn": new TimeZone("Pacific/Pitcairn", "PST", "PST", {}, 45),
	"America/Phoenix": new TimeZone("America/Phoenix", "MST", "MST", {}, 59),
	"America/Denver": new TimeZone("America/Denver", "MST", "MDT", {}, 54),
	"America/Mazatlan": new TimeZone("America/Mazatlan", "MST", "MDT", {}, 58),
	"America/Guatemala": new TimeZone("America/Guatemala", "CST", "CST", {}, 78),
	"America/Chicago": new TimeZone("America/Chicago", "CST", "CDT", {}, 75),
	"America/Mexico_City": new TimeZone("America/Mexico_City", "CST", "CDT", {}, 82),
	"Pacific/Easter": new TimeZone("Pacific/Easter", "EAST", "EASST", {}, 99),
	"America/Bogota": new TimeZone("America/Bogota", "COT", "COT", {}, 104),
	"America/New_York": new TimeZone("America/New_York", "EST", "EDT", {}, 126),
	"America/Havana": new TimeZone("America/Havana", "CST", "CDT", {}, 111),
	"America/Caracas": new TimeZone("America/Caracas", "VET", "VET", {}, 154),
	"America/Halifax": new TimeZone("America/Halifax", "AST", "ADT", {}, 163),
	"America/Goose_Bay": new TimeZone("America/Goose_Bay", "AST", "ADT", {}, 159),
	"America/Santo_Domingo": new TimeZone("America/Santo_Domingo", "AST", "AST", {}, 172),
	"America/Asuncion": new TimeZone("America/Asuncion", "PYT", "PYST", {}, 151),
	"America/Santiago": new TimeZone("America/Santiago", "CLT", "CLST", {}, 171),
	"America/Campo_Grande": new TimeZone("America/Campo_Grande", "AMT", "AMST", {}, 573),
	"America/St_Johns": new TimeZone("America/St_Johns", "NST", "NDT", {}, 190),
	"America/Godthab": new TimeZone("America/Godthab", "WGT", "WGST", {}, 201),
	"America/Miquelon": new TimeZone("America/Miquelon", "PMST", "PMDT", {}, 205),
	"America/Argentina/Buenos_Aires": new TimeZone("America/Argentina/Buenos_Aires", "ART", "ART", {}, 562),
	"America/Montevideo": new TimeZone("America/Montevideo", "UYT", "UYST", {}, 206),
	"America/Sao_Paulo": new TimeZone("America/Sao_Paulo", "BRT", "BRST", {}, 210),
	"America/Noronha": new TimeZone("America/Noronha", "FNT", "FNT", {}, 214),
	"Atlantic/Azores": new TimeZone("Atlantic/Azores", "AZOT", "AZOST", {}, 219),
	"Atlantic/Cape_Verde": new TimeZone("Atlantic/Cape_Verde", "CVT", "CVT", {}, 220),
	"UTC": new TimeZone("UTC", "GMT", "GMT", {}, 266),
	"Europe/London": new TimeZone( "Europe/London", "WET", "WEST", {}, 257),
	"Europe/Berlin": new TimeZone("Europe/Berlin", "CET", "CEST", {}, 293),
	"Europe/Helsinki": new TimeZone("Europe/Helsinki", "EET", "EEST", {}, 350),
	"Africa/Lagos": new TimeZone("Africa/Lagos", "WAT", "WAT", {}, 276),
	"Africa/Windhoek": new TimeZone("Africa/Windhoek", "WAT", "WAST", {}, 284),
	"Asia/Beirut": new TimeZone("Asia/Beirut", "EET", "EEST", {}, 336),
	"Asia/Amman": new TimeZone("Asia/Amman", "AST", "AST", {}, 335),
	"Asia/Jerusalem": new TimeZone("Asia/Jerusalem", "IST", "IDT", {}, 340),
	"Asia/Damascus": new TimeZone("Asia/Damascus", "EET", "EEST", {}, 337),
	"Africa/Cairo": new TimeZone("Africa/Cairo", "EET", "EET", {}, 324),
	"Asia/Gaza": new TimeZone("Asia/Gaza", "EET", "EEST", {}, 338),
	"Europe/Minsk": new TimeZone("Europe/Minsk", "FET", "FET", {}, 354),
	"Africa/Johannesburg": new TimeZone("Africa/Johannesburg", "SAST", "SAST", {}, 327),
	"Europe/Moscow": new TimeZone("Europe/Moscow", "MSK", "MSK", {}, 384),
	"Asia/Baghdad": new TimeZone("Asia/Baghdad", "AST", "AST", {}, 377),
	"Asia/Tehran": new TimeZone("Asia/Tehran", "IRST", "IRDT", {}, 395),
	"Asia/Dubai": new TimeZone("Asia/Dubai", "GST", "GST", {}, 399),
	"Asia/Yerevan": new TimeZone("Asia/Yerevan", "AMT", "AMT", {}, 403),
	"Asia/Baku": new TimeZone("Asia/Baku", "AZT", "AZST", {}, 398),
	"Asia/Kabul": new TimeZone("Asia/Kabul", "AFT", "AFT", {}, 410),
	"Asia/Yekaterinburg": new TimeZone("Asia/Yekaterinburg", "YEKT", "YEKT", {}, 419),
	"Asia/Karachi": new TimeZone("Asia/Karachi", "PKT", "PKT", {}, 416),
	"Asia/Kolkata": new TimeZone("Asia/Kolkata", "IST", "IST", {}, 596),
	"Asia/Kathmandu": new TimeZone("Asia/Kathmandu", "NPT", "NPT", {}, 597),
	"Asia/Dhaka": new TimeZone("Asia/Dhaka", "BST", "BST", {}, 432),
	"Asia/Omsk": new TimeZone("Asia/Omsk", "OMST", "OMST", {}, 434),
	"Asia/Rangoon": new TimeZone("Asia/Rangoon", "MMT", "MMT", {}, 441),
	"Asia/Krasnoyarsk": new TimeZone("Asia/Krasnoyarsk", "KRAT", "KRAT", {}, 447),
	"Asia/Jakarta": new TimeZone("Asia/Jakarta", "WIB", "WIB", {}, 446),
	"Asia/Shanghai": new TimeZone("Asia/Shanghai", "CST", "CST", {}, 469),
	"Asia/Irkutsk": new TimeZone("Asia/Irkutsk", "IRKT", "IRKT", {}, 461),
	"Australia/Perth": new TimeZone("Australia/Perth", "AWST", "AWST", {}, 476),
	"Australia/Eucla": new TimeZone("Australia/Eucla", "ACWST", "ACWST", {}, 582),
	"Asia/Yakutsk": new TimeZone("Asia/Yakutsk", "YAKT", "YAKT", {}, 489),
	"Asia/Tokyo": new TimeZone("Asia/Tokyo", "JST", "JST", {}, 488),
	"Australia/Darwin": new TimeZone("Australia/Darwin", "ACST", "ACST", {}, 498),
	"Australia/Adelaide": new TimeZone("Australia/Adelaide", "ACST", "ACDT", {}, 496),
	"Australia/Brisbane": new TimeZone("Australia/Brisbane", "AEST", "AEST", {}, 507),
	"Asia/Vladivostok": new TimeZone("Asia/Vladivostok", "VLAT", "VLAT", {}, 505),
	"Australia/Sydney": new TimeZone("Australia/Sydney", "AEST", "AEDT", {}, 514),
	"Australia/Lord_Howe": new TimeZone("Australia/Lord_Howe", "LHST", "LHDT", {}, 524),
	"Asia/Kamchatka": new TimeZone("Asia/Kamchatka", "PETT", "PETT", {}, 537),
	"Pacific/Noumea": new TimeZone("Pacific/Noumea", "NCT", "NCT", {}, 530),
	"Pacific/Norfolk": new TimeZone("Pacific/Norfolk", "NFT", "NFT", {}, 533),
	"Pacific/Auckland": new TimeZone("Pacific/Auckland", "NZST", "NZDT", {}, 542),
	"Pacific/Fiji": new TimeZone("Pacific/Fiji", "FJT", "FJST", {}, 543),
	"Pacific/Majuro": new TimeZone("Pacific/Tarawa", "GILT", "GILT", {}, 546),
	"Pacific/Chatham": new TimeZone("Pacific/Chatham", "CHAST", "CHADT", {}, 552),
	"Pacific/Tongatapu": new TimeZone("Pacific/Tongatapu", "TOT", "TOT", {}, 555),
	"Pacific/Kiritimati": new TimeZone("Pacific/Kiritimati", "LINT", "LINT", {}, 557)
};

/**
 * Global TimeZone object which will store the timezone information from where MPages is viewed.
 */
var MP_Timezone = {};//eslint-disable-line no-unused-vars
MP_Timezone = timezones.mapping[jstz.determine().name()];//eslint-disable-line no-undef

/**
 * This function determines the DST transition switches for a timezone for any particular year.
 * For example, consider we are in America/Chicago timezone in year 2015 then the DST switches correct to 1 second of difference
 * will be returned as an Object.
	{
		first: {
			from: Sun Mar 08 2015 01:59:59 GMT-0600 (Central Standard Time)
			to: Sun Mar 08 2015 03:00:00 GMT-0500 (Central Daylight Time)
		},
		second: {
			from: Sun Nov 01 2015 01:59:59 GMT-0500 (Central Daylight Time)
			to: Sun Nov 01 2015 01:00:00 GMT-0600 (Central Standard Time)
		}
	}
 * More info can be found here: http://www.codeproject.com/Articles/58728/JavaScript-code-to-determine-when-DayLight-Savings
 * @param {Number} year The year for which the DST transition switches are to be found.
 * @returns {Object} The two DST switches date time for a particular year
 */
/*eslint-disable space-infix-ops, key-spacing, no-unused-expressions */ 
TimeZone.prototype.getDstSwitches = function(year) {
	var p=1000, 
	tzo=function(n){
		return new Date(n*p).getTimezoneOffset();
	},
	f = function (a, b){
		return tzo(a) !== tzo(b);
	}, 
	search,
	dec = new Date(year-1,11,21,12)/p, 
	jun = new Date(year,5,21,12)/p;

	if (!f(dec, jun)){
		return null;
	}

	search = function (a,b) {
		var m;
		while(b-a>1){
			m=a+(b-a>>1);
			f(m,b)?a=m:b=m;
		}
		return {from:a*p,to:b*p};
	};
	return { first: search(dec,jun), second: search(jun,new Date(year,11,21,12)/p) };
};
/*eslint-enable space-infix-ops, key-spacing, no-unused-expressions */ 
/**
 * This function will determine the ambiguous end time frames of a timezone for a particular year.
 * It will return an Object denoting the last one hour time frame of Daylight time and starting one hour time frame of Standard time
 * when the time repeats itself.
 * For example, if we are in America/Chicago timezone in 2015 year,then we get the following in return on calling this function.
	{
		dst_trans_day_start: 1st Nov 1.00:00 am CDT,
		dst_trans_day_end: 1st Nov 1:59:59 am CDT,
		dst_trans_std_start: 1st Nov 1:00:00 am CST,
		dst_trans_std_end: 1st Nov 1:59:59 CST
	}
 * @param {Object} dstSwitches The two DST switches date time for a particular year
 * @returns {Object} The one hour end and start time frame of Daylight time and Standard time when DST ends.
 */
TimeZone.prototype.getAmbiguousEndDates = function(dstSwitches) {
	if(dstSwitches){
		/**
		 * Find the difference in offset between the DST transition dates once when they move ahead by one hour
		 * and once when they fall back by one hour.
		 */
		var firstDiff = (new Date(dstSwitches.first.from).getTimezoneOffset() - new Date(dstSwitches.first.to).getTimezoneOffset());
		var secondDiff = (new Date(dstSwitches.second.from).getTimezoneOffset() - new Date(dstSwitches.second.to).getTimezoneOffset());
		var daylightStart = new Date();
		var daylightEnd = new Date();
		var standardStart = new Date();
		var standardEnd = new Date();
		/**
		 * dstSwitches.first will store the transition date within the first half of the year.
		 * dstSwitches.second will store the transition date within the second half of the year.
		 * If first difference is less than second then the timezone is in Southern Hemisphere(i.e. dstSwitches.first is the end date)
		 * and if second difference is less then the timezone is in Northern Hemisphere(i.e. dstSwitches.second is the end date)
		 * (59*61*1000) is added or subtracted to get the respective one hour time frame of Daylight and Standard Time when DST ends.
		 * (59*61*1000) was arrived from 59mins 59secs. In milliseconds they will be obtained by simplifying(59*60*1000+59*1000).
		 */
		if(firstDiff < secondDiff){
			daylightStart = new Date().setTime(new Date(dstSwitches.first.from).getTime() - (59 * 61 * 1000));
			standardEnd = new Date().setTime(new Date(dstSwitches.first.to).getTime() + (59 * 61 * 1000));
			daylightEnd = new Date().setTime(dstSwitches.first.from);
			standardStart = new Date().setTime(dstSwitches.first.to);
		}
		else if(firstDiff > secondDiff){
			daylightStart = new Date().setTime(new Date(dstSwitches.second.from).getTime() - (59 * 61 * 1000));
			standardEnd = new Date().setTime(new Date(dstSwitches.second.to).getTime() + (59 * 61 * 1000));
			daylightEnd = new Date().setTime(dstSwitches.second.from);
			standardStart = new Date().setTime(dstSwitches.second.to);
		}
		return { dst_trans_day_start: daylightStart, dst_trans_day_end: daylightEnd, dst_trans_std_start: standardStart, dst_trans_std_end: standardEnd };
	}
};

/**
 * This function will return the correct abbreviation to be displayed for DST observing timezones.
 * @param {Date} date The date for which timezone information has to be retrieved
 * @param {String} formatMask The date format masks for which timezones need to be calculated.
 * @returns {String} The timezone abbreviation
 */
TimeZone.prototype.getTimeZone = function(date, formatMask){
	var dateTime = new Date();
	//If no mask is provided, then "default" mask should be used just like what dateFormat does.
	var mask = (formatMask) ? formatMask : "default";
	var validMask = false;
	if (date) {
		dateTime = date;
	}
	var supportedDSTMasks = {
		"longDateTime2": 1,
		"longDateTime3": 1,
		"shortTime": 1,
		"mediumTime": 1,
		"militaryTime": 1,
		"default": 1,
		"shortdatetime": 1,
		"mediumdatetime": 1,
		"longdatetime": 1,
		"timewithseconds": 1,
		"timenoseconds": 1,
		"shortdatetimenosec": 1,
		//custom time format used in Meds WF
		"mmmm dd, yyyy HH:MM": 1
	};
	//Supported date formats for which timezones will be displayed.
	//ISO Formats have been removed from supported list as they are meant to be used for information exchange and shouldnt have any extra details appended to them.
	if((mask.indexOf("isoTime") < 0 && mask.indexOf("isoDateTime") < 0 && mask !== "isoUtcDateTime" ) && (mask in supportedDSTMasks || mask.indexOf("HH:mm") >= 0 || mask.indexOf("HH:MM") >= 0)) {
		validMask = true;
	}
	var yr = dateTime.getFullYear();
	/**
	 * Check if DST indicator is set for that particular year. If yes the DST information for that year has already been calculated and no
	 * need to calculate again. If it not set then enter the if block. This block will be entered only once for a year.
	 */
	if (!this.m_dst_info[yr + "_dst_ind"]) {
		this.setDSTInfo(yr + "_dst_ind", this.isDSTObserved(yr));
		/**
		 * If DST transition information hasn't been calculated yet go ahead and calculate it
		 * If DST indicator is 0(i.e. timezone does not observe DST) then directly return "" as timezone abbreviation.
		 * This block too will be entered only once for an year in DST enabled zones.
		 */
		if (!this.m_dst_info[yr] && this.m_dst_info[yr + "_dst_ind"]) {
			var dstSwitchDates = this.getDstSwitches(yr);
			if (dstSwitchDates) {
				this.setDSTInfo(yr, this.getAmbiguousEndDates(dstSwitchDates));
			}
		}
		else{
			//If DST is not observed directly return null as we wont show those timezone values.
			return "";
		}
	}
	if(validMask){
		if (date >= this.m_dst_info[yr].dst_trans_day_start && date <= this.m_dst_info[yr].dst_trans_day_end) {
			//If date falls within Daylight end 1 hour time frame return DST abbreviation
			return this.m_dst_abbr;
		}
		else if (date >= this.m_dst_info[yr].dst_trans_std_start && date <= this.m_dst_info[yr].dst_trans_std_end) {
			//If date falls within Standard start 1 hour time frame return STD abbreviation
			return this.m_abbr;
		}
	}
	return "";
};

/**
 * To check whether the timezone observes DST for an particular year
 * @param {Number} year The year for which we need to check if DST is on or off
 * @returns {Number} 0 if daylight savings time is NOT observed and 1 if daylight savings time is observed.
 */
TimeZone.prototype.isDSTObserved = function(year) {
	var curYearJanDate = new Date(year, 0, 1, 0, 0, 0, 0);
	var strCurYearJanUTCDate = curYearJanDate.toUTCString();
	var curYearJanUTCDate = new Date(strCurYearJanUTCDate.substring(0, strCurYearJanUTCDate.lastIndexOf(" ") - 1));
	var std_time_offset = (curYearJanDate - curYearJanUTCDate) / (1000 * 60 * 60);

	var curYearJuneDate = new Date(year, 6, 1, 0, 0, 0, 0);
	var strCurYearJuneUTCDate = curYearJuneDate.toUTCString();
	var curYearJuneUTCDate = new Date(strCurYearJuneUTCDate.substring(0, strCurYearJuneUTCDate.lastIndexOf(" ") - 1));
	var daylight_time_offset = (curYearJuneDate - curYearJuneUTCDate) / (1000 * 60 * 60);

	if (std_time_offset === daylight_time_offset) {
		return 0; // daylight savings time is NOT observed
	}
	else {
		return 1; // daylight savings time is observed
	}
};
// eslint global flags
/* global i18n, MP_Util, $:, CapabilityTimer, MPagesOAuth */
// this is disabled because we can't really control the json structure from the HealtheLife service
/* eslint no-underscore-dangle: 0 */

/**
 * @namespace
 * The VideoVisit namespace contains functionality to look up video visit appointments
 * between the provider and patient, retrieve video session links from the HealtheLife service
 * to display a banner enabling a provider to join and complete the video visit session
 * within an MPage Viewpoint.
 */
var VideoVisit = {
    criterion: null,
    appointmentId: 0,
    eventId: 0,
    patientCheckedInStatus: false,
    visitCompleted: false,
    $header: null,
    visitURL: "",
    videoPlayerURL: "",
    videoPlayerURLWithAuth: "",
    loadTimer: null
};

/*
 * This function initiates a ScriptRequest to mp_vv_get_portal_link
 * which makes a HTTP request to the HealtheLife service to load the links
 * to join and complete this video visit session.
 * The response handler is VideoVisit.displayBanner
 * @returns {undefined}
 */
VideoVisit.loadPortalLink = function() {
    VideoVisit.loadTimer = new RTMSTimer("ENG:MPG Load Video Visits", VideoVisit.criterion.CATEGORY_MEAN);
    VideoVisit.loadTimer.start();
    logger.logMessage("Initializing Video Visit...");
    var request = new ScriptRequest();

    request.setArtifactInfo({
        artifactId: "mpage-video-visits",
        functionName: "loadPortalLink"
    });

    request.setProgramName("mp_vv_get_portal_link");
    var sexDisplay = "";
    if (VideoVisit.criterion.PERSON_INFO.SEX_CD) {
        sexDisplay = MP_Util.GetValueFromArray(VideoVisit.criterion.PERSON_INFO.SEX_CD, MP_Util.LoadCodeListJSON(VideoVisit.criterion.CODES)).display; // eslint-disable-line new-cap
    }

    request.setParameterArray([ "^MINE^", VideoVisit.criterion.PERSON_ID + ".00", VideoVisit.criterion.ENCNTRS[0].ENCNTR_ID + ".00", VideoVisit.criterion.PRSNL_ID + ".00", VideoVisit.eventId + ".00", VideoVisit.appointmentId + ".00", "^" + sexDisplay + "^" ]);
    request.setResponseHandler(VideoVisit.displayBanner);
    request.performRequest();
};

/*
 * This function handles replies from the mp_vv_get_portal_link ScriptRequest
 * Any queries that don't find data will return the script with a Z status, and is considered a failure state
 * Any non success response codes will also set the status to F, another failure state
 * This function will set up the banner text, with the Join Session link and patient status
 * (waiting for patient or patient has arrived). The Join link is opened through APPLINK().
 * Clicking the Join Session link will show the Complete Session link on the banner.
 * CLicking the Complete Session link will hide the banner and call VideoVisit.completeSession
 * @param {object} reply - the ScriptReply object that is passed in from the ScriptRequest
 * @returns {undefined}
 */
VideoVisit.displayBanner = function(reply) { // eslint-disable-line complexity
    if (!reply) {
        logger.logMessage("No reply object provided to the display banner handler.");
        VideoVisit.loadTimer.fail();
        return;
    }

    var status = reply.getStatus();
    var data = reply.getResponse();

    if (status !== "S") {
        logger.logError("Video Visits -- " + data.RESPONSETEXT + ". Operation Failure in " + data.STATUS_DATA.SUBEVENTSTATUS[0].OPERATIONNAME);
        VideoVisit.loadTimer.fail();
        return;
    }

    var serviceReply = JSON.parse(data.RESPONSEBODY);
    VideoVisit.visitCompleted = serviceReply.completed;
    if (VideoVisit.visitCompleted) {
        logger.logMessage("Video Visit has already been completed.");
        VideoVisit.loadTimer.stop();
        return;
    }

    VideoVisit.videoPlayerURL = "";
    VideoVisit.thirdPartyVideoPlayer = false;
    VideoVisit.visitURL = serviceReply._links.self.href;
    var participant = "";
    for (var i = serviceReply._embedded.participants.length; i--;) {
        participant = serviceReply._embedded.participants[i];
        // Multiple providers may be returned in the list, so we need to ensure we save the correct link to the specific provider.
        // However, if a provider wants to join a conference over an unknown third-party video player or is a visit that is provisioned
        // by VVS, then skip the uniqueness check.
        if (participant.participant_type === "PROVIDER") {
            if (participant._links.player.third_party) {
                VideoVisit.thirdPartyVideoPlayer = true;
                VideoVisit.videoPlayerURL = participant._links.player.href;
                break;
            } else if (participant.unique_id && parseFloat(participant.unique_id) === VideoVisit.criterion.PRSNL_ID) {
                VideoVisit.videoPlayerURL = participant._links.player.href;
                break;
            }
        }
    }

    // If for some reason that video player URL is not present, then do not show the banner.
    if (!VideoVisit.videoPlayerURL) {
        logger.logMessage("Video Visit URL does not exist for participant id: " + VideoVisit.criterion.PRSNL_ID);
        return;
    }

    logger.logMessage("Video Visit URL without authentication: " + VideoVisit.videoPlayerURL);

    var icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAAM1BMVEUAAAD////////y8vL////////39/fe3t7y8vL09PTv7+/Z2dnu7u7u7u7w8PDz8/P///+tUKSkAAAAEHRSTlMAJn+OkZ6ut7zHyM3W3+jwf8O1WgAAAXZJREFUeAHsllFOxDAMRGOXTQNk27n/aflYLDRCKlnJzP74HcDzannUtKIoiqIoiqIICvNM7On47Y5M5nMK5icYrYIN/Ad91cA+AKWB4PuD24qB3YBg7hncgcAXBBzfDHfLKvSMmQsTN15XDtbXV3BQfrbB9teyPhvvKg17fNhhl/ETaLGqbDwGX8aHwGlqAfMB/AjsTStg3gG9AJ2oVODi16cXMD8AvQCfvl6A4vUC3LygT6lANC8YbrtUwPqv95pMgJsX8UoBbt7xiNcJ8OmfEa8SeIt4eqcKBd4p3q1JBZgR8WIBPn29AMfrBbh5egFunl4gmvdCgf7Vrh0SAACAMBCU9G9Mgukz/wkmYfv9bh08SgvgAxSgAAUoQAEK4A8Sf5L5o9Sd5f4x8a+Zf079e+4LCl/R+JLK13S+qORVLS+rcV3vBws/2fjRys92frj0060fr/18zwUGrnBwiYVrPFxk8iqXl9m8zueFRql0RkRERETEAxuDn9tJFgriAAAAAElFTkSuQmCC";
    VideoVisit.$header = $("<div/>").addClass("vv-banner").attr("id", "vidvisBanner");
    VideoVisit.$header.html("<img src='" + icon + "' />&nbsp;&nbsp;<a class='vv-player'>" + i18n.innov.videoVisit.JOIN_SESSION + "</a><a class='vv-complete-session'>" + i18n.innov.videoVisit.COMPLETE_SESSION + "</a><span class='vv-patient-status'></span>");

    VideoVisit.updatePatientStatus();

    VideoVisit.$header.find(".vv-player").on("click", function() {
        (new CapabilityTimer("CAP:MPG Launch Video Visit")).capture();
        var videoPlayerURL = VideoVisit.videoPlayerURL;

        // If a provider wants to join a conference over an external third-party video player or is a visit that is provisioned
        // by VVS, then do not add the OAuth tokens.
        if (!VideoVisit.thirdPartyVideoPlayer) {
            // In case the user needs to click "Join Session" more than once,
            // we need to reset the videoPlayerURLWithAuth to the original videoPlayerURL,
            // and we go and grab the integrated authentication tokens again.
            VideoVisit.videoPlayerURLWithAuth = videoPlayerURL;
            // Retrieve token
            MPagesOAuth.getAuthenticationValue().then(function(authToken) {
                VideoVisit.videoPlayerURLWithAuth += "?authentication=" + authToken;
                videoPlayerURL = VideoVisit.videoPlayerURLWithAuth;
            }).catch(function() {
                logger.logError("Unable to retrieve Millennium integrated auth information.");
            }).finally(function() {
                logger.logMessage("Video Visit URL: " + videoPlayerURL);
                APPLINK(100, videoPlayerURL, ""); // eslint-disable-line new-cap
            });
        }
        else {
            logger.logMessage("Video Visit URL: " + videoPlayerURL);
            APPLINK(100, videoPlayerURL, ""); // eslint-disable-line new-cap
        }
        VideoVisit.$header.find(".vv-patient-status").text("");
        VideoVisit.$header.find(".vv-complete-session").show();
    });

    VideoVisit.$header.find(".vv-complete-session").on("click", function() {
        (new CapabilityTimer("CAP:MPG Complete Video Visit")).capture();
        VideoVisit.$header.slideUp();
        VideoVisit.$header = null;
        $(window).trigger("resize", [ true ]);
        VideoVisit.completeSession();
    });

    $("body").prepend(VideoVisit.$header);
    $(window).trigger("resize", [ true ]);
    VideoVisit.loadTimer.stop();
};

/*
 * This function will run the script mp_vv_get_user_status to determine
 * if the person has a 'checked in' status for the given appointment ID.
 * The response handler will set the status to patientCheckedInStatus and
 * will call VideoVisit.updatePatientStatus.
 * This will not execute if the visit has been marked as completed.
 * @returns {undefined}
 */
VideoVisit.getPatientStatus = function() {
    if (VideoVisit.visitCompleted) {
        return;
    }

    var request = new ScriptRequest();

    request.setArtifactInfo({
        artifactId: "mpage-video-visits",
        functionName: "getPatientStatus"
    });

    request.setProgramName("mp_vv_get_user_status");
    request.setParameterArray([ "^MINE^", VideoVisit.eventId + ".00" ]);
    request.setResponseHandler(function(statusReply) {
        var statusReplyData = statusReply.getResponse();
        VideoVisit.patientCheckedInStatus = parseInt(statusReplyData.PATIENT_CHECKED_IN, 10);
        VideoVisit.updatePatientStatus();
    });
    request.performRequest();
};

/*
 * This function handles the banner bar color and patient status text.
 * When a patient is checked in, the banner is vv-arrived (green) and text is Patient has Arrived.
 * When a patient is not checked in, the banner is vv-waiting (grey) and text is Waiting for Patient.
 * Additionally, if the patient is not checked in, this will fire off VideoVisit.getPatientStatus after a 15 second wait
 * @returns {undefined}
 */
VideoVisit.updatePatientStatus = function() {
    if (VideoVisit.patientCheckedInStatus) {
        VideoVisit.$header.addClass("vv-arrived").removeClass("vv-waiting");
        VideoVisit.$header.find(".vv-patient-status").text(i18n.innov.videoVisit.ARRIVED);
    }
    else {
        VideoVisit.$header.addClass("vv-waiting").removeClass("vv-arrived");
        VideoVisit.$header.find(".vv-patient-status").text(i18n.innov.videoVisit.WAITING);
        setTimeout(VideoVisit.getPatientStatus, 15000);
    }
};

/*
 * This function sets the visitCompleted property to true and fires a script request
 * to mp_vv_complete_session using the video session link from the HealtheLife portal.
 * @returns {undefined}
 */
VideoVisit.completeSession = function() {
    VideoVisit.visitCompleted = true;
    var request = new ScriptRequest();

    request.setArtifactInfo({
        artifactId: "mpage-video-visits",
        functionName: "completeSession"
    });

    request.setProgramName("mp_vv_complete_session");
    request.setParameterArray([ "^MINE^", "^" + VideoVisit.visitURL + "^" ]);
    request.setResponseHandler(function() {});
    request.performRequest();
};

/*
 * This is the reply handler script for mp_vv_get_appointment.
 * If the script returns without any qualifying appointment ID, the function exits
 * When a qualifying appointment is found, we will wait until the checkin window
 * (30 mins prior to scheduled start) to load the player links and display the banner
 * @param {object} reply - the ScriptReply object that is passed in from the ScriptRequest
 * @returns {undefined}
 */
VideoVisit.appointmentReplyHandler = function(reply) {
    if (!reply) {
        logger.logMessage("No reply object provided to the appointment reply handler.");
        return;
    }

    var data = reply.getResponse();
    if (data.APPOINTMENT_ID < 1) {
        logger.logMessage("No qualifying video visit appointment found.");
        return;
    }

    VideoVisit.appointmentId = data.APPOINTMENT_ID;
    VideoVisit.eventId = data.EVENT_ID;
    VideoVisit.patientCheckedInStatus = parseInt(data.PATIENT_CHECKED_IN, 10);
    VideoVisit.loadPortalLink();
};

/*
 * This getAppointment function loads criterion from CERN_Platform
 * and kicks off a script request to find a video visit appointment
 * between the current provider and person scheduled for today
 * @returns {undefined}
 */
VideoVisit.getAppointment = function() {
    VideoVisit.criterion = CERN_Platform.getCriterion().CRITERION;
    // Since this code is pulled into MPages 6.0+, there are instances at the organizer-level
    // of a slow performing script call because the person_id and encntr_id are both 0.
    // We fixed the issue on CR 1-12887414401 for MPages 6.7+ (https://github.cerner.com/MPages-Framework/mpage-viewpoint/pull/19#pullrequestreview-106645)
    // but we needed a fix for MPages 6.3-6.6. This if statement should make it so the script call is
    // never executed if the person_id and encntr_id are both 0.
    if (VideoVisit.criterion.PERSON_ID && VideoVisit.criterion.PERSON_ID > 0 && VideoVisit.criterion.ENCNTRS[0].ENCNTR_ID && VideoVisit.criterion.ENCNTRS[0].ENCNTR_ID > 0) {
        var request = new ScriptRequest();

        request.setArtifactInfo({
            artifactId: "mpage-video-visits",
            functionName: "getAppointment"
        });

        request.setProgramName("mp_vv_get_appointment");
        request.setParameterArray([ "^MINE^", VideoVisit.criterion.PERSON_ID + ".00", VideoVisit.criterion.PRSNL_ID + ".00", VideoVisit.criterion.ENCNTRS[0].ENCNTR_ID + ".00" ]);
        request.setResponseHandler(VideoVisit.appointmentReplyHandler);
        request.performRequest();
    }
};

/*
 * This initialization function loads criterion from CERN_Platform
 * and kicks off a script request to find a video visit appointment
 * between the current provider and person scheduled for today
 * @returns {undefined}
 */
VideoVisit.initialize = (function() {
    var init = VideoVisit.getAppointment;

    return function() {
        if (init) {
            init();
            init = null;
        }
    };
})();

!function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}var installedModules={};__webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.i=function(value){return value},__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{configurable:!1,enumerable:!0,get:getter})},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=2)}([function(module,__webpack_exports__,__webpack_require__){"use strict";Object.defineProperty(__webpack_exports__,"__esModule",{value:!0});var __WEBPACK_IMPORTED_MODULE_0__util_util__=__webpack_require__(1);window.MP_StringParser=__WEBPACK_IMPORTED_MODULE_0__util_util__.a,__webpack_exports__.default=__WEBPACK_IMPORTED_MODULE_0__util_util__.a},function(module,__webpack_exports__,__webpack_require__){"use strict";function _toArray(arr){return Array.isArray(arr)?arr:Array.from(arr)}var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{!_n&&_i.return&&_i.return()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),parseNumber=function(str){var decSep=MPAGE_LOCALE.decimalPoint,thouSep=MPAGE_LOCALE.thousandsSep,grouping=parseInt(MPAGE_LOCALE.grouping,10),numericStrMatcher=new RegExp("^([+-]?)([\\d"+thouSep+"]*\\"+decSep+"?\\d+)$"),result=numericStrMatcher.exec(str);if(result){var signChar=result[1],_result$2$split=result[2].split(decSep),_result$2$split2=_slicedToArray(_result$2$split,2),integerPart=_result$2$split2[0],_result$2$split2$=_result$2$split2[1],decimalPart=void 0===_result$2$split2$?"":_result$2$split2$,integerGroups=integerPart.split(thouSep),_integerGroups=_toArray(integerGroups),firstGroup=_integerGroups[0],restGroups=_integerGroups.slice(1);if(integerGroups.length>1&&firstGroup.length&&firstGroup.length<=grouping&&restGroups.every(function(group){return group.length===grouping})||1===integerGroups.length)return Number(""+signChar+integerGroups.join("")+"."+decimalPart)}return NaN};__webpack_exports__.a={parseNumber:parseNumber}},function(module,exports,__webpack_require__){module.exports=__webpack_require__(0)}]);
var HtmlSanitizer=function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}var installedModules={};return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{configurable:!1,enumerable:!0,get:getter})},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=0)}([function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _dompurify=__webpack_require__(1),_dompurify2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_dompurify),_whitelist=__webpack_require__(2),defaultConfig={WHOLE_DOCUMENT:!0,ALLOWED_TAGS:_whitelist.ALLOWED_TAGS,ALLOWED_ATTR:_whitelist.ALLOWED_ATTR},HtmlSanitizer=function(){function HtmlSanitizer(){_classCallCheck(this,HtmlSanitizer),this.hooks={}}return HtmlSanitizer.prototype.addHook=function(hook,callback){this.hooks[hook]=this.hooks[hook]||[],this.hooks[hook].push(callback)},HtmlSanitizer.prototype.sanitize=function(dirtyHtml,config){var _this=this;if(!dirtyHtml||!dirtyHtml.length)throw new Error("sanitize function called with an invalid html string");return _dompurify2.default.setConfig(Object.assign({},defaultConfig,config)),_dompurify2.default.removeAllHooks(),Object.keys(this.hooks).forEach(function(key){return _this.hooks[key].forEach(function(callback){return _dompurify2.default.addHook(key,callback)})}),_dompurify2.default.sanitize(dirtyHtml)},HtmlSanitizer}();exports.default=HtmlSanitizer},function(module,exports,__webpack_require__){!function(global,factory){module.exports=factory()}(0,function(){"use strict";function addToSet(set,array){for(var l=array.length;l--;)"string"==typeof array[l]&&(array[l]=array[l].toLowerCase()),set[array[l]]=!0;return set}function clone(object){var newObject={},property=void 0;for(property in object)Object.prototype.hasOwnProperty.call(object,property)&&(newObject[property]=object[property]);return newObject}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2}return Array.from(arr)}function createDOMPurify(){var window=arguments.length>0&&void 0!==arguments[0]?arguments[0]:getGlobal(),DOMPurify=function(root){return createDOMPurify(root)};if(DOMPurify.version="1.0.5",DOMPurify.removed=[],!window||!window.document||9!==window.document.nodeType)return DOMPurify.isSupported=!1,DOMPurify;var originalDocument=window.document,useDOMParser=!1,document=window.document,DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=void 0===_window$NamedNodeMap?window.NamedNodeMap||window.MozNamedAttrMap:_window$NamedNodeMap,Text=window.Text,Comment=window.Comment,DOMParser=window.DOMParser;if("function"==typeof HTMLTemplateElement){var template=document.createElement("template");template.content&&template.content.ownerDocument&&(document=template.content.ownerDocument)}var _document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,getElementsByTagName=_document.getElementsByTagName,createDocumentFragment=_document.createDocumentFragment,importNode=originalDocument.importNode,hooks={};DOMPurify.isSupported=implementation&&void 0!==implementation.createHTMLDocument&&9!==document.documentMode;var MUSTACHE_EXPR$$1=MUSTACHE_EXPR,ERB_EXPR$$1=ERB_EXPR,DATA_ATTR$$1=DATA_ATTR,ARIA_ATTR$$1=ARIA_ATTR,IS_SCRIPT_OR_DATA$$1=IS_SCRIPT_OR_DATA,ATTR_WHITESPACE$$1=ATTR_WHITESPACE,IS_ALLOWED_URI$$1=IS_ALLOWED_URI,ALLOWED_TAGS=null,DEFAULT_ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray(html),_toConsumableArray(svg),_toConsumableArray(svgFilters),_toConsumableArray(mathMl),_toConsumableArray(text))),ALLOWED_ATTR=null,DEFAULT_ALLOWED_ATTR=addToSet({},[].concat(_toConsumableArray(html$1),_toConsumableArray(svg$1),_toConsumableArray(mathMl$1),_toConsumableArray(xml))),FORBID_TAGS=null,FORBID_ATTR=null,ALLOW_ARIA_ATTR=!0,ALLOW_DATA_ATTR=!0,ALLOW_UNKNOWN_PROTOCOLS=!1,SAFE_FOR_JQUERY=!1,SAFE_FOR_TEMPLATES=!1,WHOLE_DOCUMENT=!1,SET_CONFIG=!1,FORCE_BODY=!1,RETURN_DOM=!1,RETURN_DOM_FRAGMENT=!1,RETURN_DOM_IMPORT=!1,SANITIZE_DOM=!0,KEEP_CONTENT=!0,USE_PROFILES={},FORBID_CONTENTS=addToSet({},["audio","head","math","script","style","template","svg","video"]),DATA_URI_TAGS=addToSet({},["audio","video","img","source","image"]),URI_SAFE_ATTRIBUTES=addToSet({},["alt","class","for","id","label","name","pattern","placeholder","summary","title","value","style","xmlns"]),CONFIG=null,formElement=document.createElement("form"),_parseConfig=function(cfg){"object"!==(void 0===cfg?"undefined":_typeof(cfg))&&(cfg={}),ALLOWED_TAGS="ALLOWED_TAGS"in cfg?addToSet({},cfg.ALLOWED_TAGS):DEFAULT_ALLOWED_TAGS,ALLOWED_ATTR="ALLOWED_ATTR"in cfg?addToSet({},cfg.ALLOWED_ATTR):DEFAULT_ALLOWED_ATTR,FORBID_TAGS="FORBID_TAGS"in cfg?addToSet({},cfg.FORBID_TAGS):{},FORBID_ATTR="FORBID_ATTR"in cfg?addToSet({},cfg.FORBID_ATTR):{},USE_PROFILES="USE_PROFILES"in cfg&&cfg.USE_PROFILES,ALLOW_ARIA_ATTR=!1!==cfg.ALLOW_ARIA_ATTR,ALLOW_DATA_ATTR=!1!==cfg.ALLOW_DATA_ATTR,ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||!1,SAFE_FOR_JQUERY=cfg.SAFE_FOR_JQUERY||!1,SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||!1,WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||!1,RETURN_DOM=cfg.RETURN_DOM||!1,RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||!1,RETURN_DOM_IMPORT=cfg.RETURN_DOM_IMPORT||!1,FORCE_BODY=cfg.FORCE_BODY||!1,SANITIZE_DOM=!1!==cfg.SANITIZE_DOM,KEEP_CONTENT=!1!==cfg.KEEP_CONTENT,IS_ALLOWED_URI$$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI$$1,SAFE_FOR_TEMPLATES&&(ALLOW_DATA_ATTR=!1),RETURN_DOM_FRAGMENT&&(RETURN_DOM=!0),USE_PROFILES&&(ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray(text))),ALLOWED_ATTR=[],!0===USE_PROFILES.html&&(addToSet(ALLOWED_TAGS,html),addToSet(ALLOWED_ATTR,html$1)),!0===USE_PROFILES.svg&&(addToSet(ALLOWED_TAGS,svg),addToSet(ALLOWED_ATTR,svg$1),addToSet(ALLOWED_ATTR,xml)),!0===USE_PROFILES.svgFilters&&(addToSet(ALLOWED_TAGS,svgFilters),addToSet(ALLOWED_ATTR,svg$1),addToSet(ALLOWED_ATTR,xml)),!0===USE_PROFILES.mathMl&&(addToSet(ALLOWED_TAGS,mathMl),addToSet(ALLOWED_ATTR,mathMl$1),addToSet(ALLOWED_ATTR,xml))),cfg.ADD_TAGS&&(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS&&(ALLOWED_TAGS=clone(ALLOWED_TAGS)),addToSet(ALLOWED_TAGS,cfg.ADD_TAGS)),cfg.ADD_ATTR&&(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR&&(ALLOWED_ATTR=clone(ALLOWED_ATTR)),addToSet(ALLOWED_ATTR,cfg.ADD_ATTR)),cfg.ADD_URI_SAFE_ATTR&&addToSet(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR),KEEP_CONTENT&&(ALLOWED_TAGS["#text"]=!0),WHOLE_DOCUMENT&&addToSet(ALLOWED_TAGS,["html","head","body"]),Object&&"freeze"in Object&&Object.freeze(cfg),CONFIG=cfg},_forceRemove=function(node){DOMPurify.removed.push({element:node});try{node.parentNode.removeChild(node)}catch(err){node.outerHTML=""}},_removeAttribute=function(name,node){try{DOMPurify.removed.push({attribute:node.getAttributeNode(name),from:node})}catch(err){DOMPurify.removed.push({attribute:null,from:node})}node.removeAttribute(name)},_initDocument=function(dirty){var doc=void 0;if(FORCE_BODY&&(dirty="<remove></remove>"+dirty),useDOMParser)try{doc=(new DOMParser).parseFromString(dirty,"text/html")}catch(err){}if(!doc||!doc.documentElement){doc=implementation.createHTMLDocument("");var _doc=doc,body=_doc.body;body.parentNode.removeChild(body.parentNode.firstElementChild),body.outerHTML=dirty}return getElementsByTagName.call(doc,WHOLE_DOCUMENT?"html":"body")[0]};DOMPurify.isSupported&&function(){try{_initDocument('<svg><p><style><img src="</style><img src=x onerror=alert(1)//">').querySelector("svg img")&&(useDOMParser=!0)}catch(err){}}();var _createIterator=function(root){return createNodeIterator.call(root.ownerDocument||root,root,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,function(){return NodeFilter.FILTER_ACCEPT},!1)},_isClobbered=function(elm){return!(elm instanceof Text||elm instanceof Comment)&&!("string"==typeof elm.nodeName&&"string"==typeof elm.textContent&&"function"==typeof elm.removeChild&&elm.attributes instanceof NamedNodeMap&&"function"==typeof elm.removeAttribute&&"function"==typeof elm.setAttribute)},_isNode=function(obj){return"object"===(void 0===Node?"undefined":_typeof(Node))?obj instanceof Node:obj&&"object"===(void 0===obj?"undefined":_typeof(obj))&&"number"==typeof obj.nodeType&&"string"==typeof obj.nodeName},_executeHook=function(entryPoint,currentNode,data){hooks[entryPoint]&&hooks[entryPoint].forEach(function(hook){hook.call(DOMPurify,currentNode,data,CONFIG)})},_sanitizeElements=function(currentNode){var content=void 0;if(_executeHook("beforeSanitizeElements",currentNode,null),_isClobbered(currentNode))return _forceRemove(currentNode),!0;var tagName=currentNode.nodeName.toLowerCase();if(_executeHook("uponSanitizeElement",currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS}),!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]&&"function"==typeof currentNode.insertAdjacentHTML)try{currentNode.insertAdjacentHTML("AfterEnd",currentNode.innerHTML)}catch(err){}return _forceRemove(currentNode),!0}return!SAFE_FOR_JQUERY||currentNode.firstElementChild||currentNode.content&&currentNode.content.firstElementChild||!/</g.test(currentNode.textContent)||(DOMPurify.removed.push({element:currentNode.cloneNode()}),currentNode.innerHTML?currentNode.innerHTML=currentNode.innerHTML.replace(/</g,"&lt;"):currentNode.innerHTML=currentNode.textContent.replace(/</g,"&lt;")),SAFE_FOR_TEMPLATES&&3===currentNode.nodeType&&(content=currentNode.textContent,content=content.replace(MUSTACHE_EXPR$$1," "),content=content.replace(ERB_EXPR$$1," "),currentNode.textContent!==content&&(DOMPurify.removed.push({element:currentNode.cloneNode()}),currentNode.textContent=content)),_executeHook("afterSanitizeElements",currentNode,null),!1},_sanitizeAttributes=function(currentNode){var attr=void 0,value=void 0,lcName=void 0,idAttr=void 0,l=void 0;_executeHook("beforeSanitizeAttributes",currentNode,null);var attributes=currentNode.attributes;if(attributes){var hookEvent={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:ALLOWED_ATTR};for(l=attributes.length;l--;){attr=attributes[l];var _attr=attr,name=_attr.name;if(value=attr.value.trim(),lcName=name.toLowerCase(),hookEvent.attrName=lcName,hookEvent.attrValue=value,hookEvent.keepAttr=!0,_executeHook("uponSanitizeAttribute",currentNode,hookEvent),value=hookEvent.attrValue,"name"===lcName&&"IMG"===currentNode.nodeName&&attributes.id)idAttr=attributes.id,attributes=Array.prototype.slice.apply(attributes),_removeAttribute("id",currentNode),_removeAttribute(name,currentNode),attributes.indexOf(idAttr)>l&&currentNode.setAttribute("id",idAttr.value);else{if("INPUT"===currentNode.nodeName&&"type"===lcName&&"file"===value&&(ALLOWED_ATTR[lcName]||!FORBID_ATTR[lcName]))continue;"id"===name&&currentNode.setAttribute(name,""),_removeAttribute(name,currentNode)}if(hookEvent.keepAttr&&(!SANITIZE_DOM||"id"!==lcName&&"name"!==lcName||!(value in document||value in formElement))){if(SAFE_FOR_TEMPLATES&&(value=value.replace(MUSTACHE_EXPR$$1," "),value=value.replace(ERB_EXPR$$1," ")),ALLOW_DATA_ATTR&&DATA_ATTR$$1.test(lcName));else if(ALLOW_ARIA_ATTR&&ARIA_ATTR$$1.test(lcName));else{if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName])continue;if(URI_SAFE_ATTRIBUTES[lcName]);else if(IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1,"")));else if("src"!==lcName&&"xlink:href"!==lcName||0!==value.indexOf("data:")||!DATA_URI_TAGS[currentNode.nodeName.toLowerCase()]){if(ALLOW_UNKNOWN_PROTOCOLS&&!IS_SCRIPT_OR_DATA$$1.test(value.replace(ATTR_WHITESPACE$$1,"")));else if(value)continue}else;}try{currentNode.setAttribute(name,value),DOMPurify.removed.pop()}catch(err){}}}_executeHook("afterSanitizeAttributes",currentNode,null)}},_sanitizeShadowDOM=function _sanitizeShadowDOM(fragment){var shadowNode=void 0,shadowIterator=_createIterator(fragment);for(_executeHook("beforeSanitizeShadowDOM",fragment,null);shadowNode=shadowIterator.nextNode();)_executeHook("uponSanitizeShadowNode",shadowNode,null),_sanitizeElements(shadowNode)||(shadowNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(shadowNode.content),_sanitizeAttributes(shadowNode));_executeHook("afterSanitizeShadowDOM",fragment,null)};return DOMPurify.sanitize=function(dirty,cfg){var body=void 0,importedNode=void 0,currentNode=void 0,oldNode=void 0,returnNode=void 0;if(dirty||(dirty="\x3c!--\x3e"),"string"!=typeof dirty&&!_isNode(dirty)){if("function"!=typeof dirty.toString)throw new TypeError("toString is not a function");if("string"!=typeof(dirty=dirty.toString()))throw new TypeError("dirty is not a string, aborting")}if(!DOMPurify.isSupported){if("object"===_typeof(window.toStaticHTML)||"function"==typeof window.toStaticHTML){if("string"==typeof dirty)return window.toStaticHTML(dirty);if(_isNode(dirty))return window.toStaticHTML(dirty.outerHTML)}return dirty}if(SET_CONFIG||_parseConfig(cfg),DOMPurify.removed=[],dirty instanceof Node)body=_initDocument("\x3c!--\x3e"),importedNode=body.ownerDocument.importNode(dirty,!0),1===importedNode.nodeType&&"BODY"===importedNode.nodeName?body=importedNode:body.appendChild(importedNode);else{if(!RETURN_DOM&&!WHOLE_DOCUMENT&&-1===dirty.indexOf("<"))return dirty;if(!(body=_initDocument(dirty)))return RETURN_DOM?null:""}FORCE_BODY&&_forceRemove(body.firstChild);for(var nodeIterator=_createIterator(body);currentNode=nodeIterator.nextNode();)3===currentNode.nodeType&&currentNode===oldNode||_sanitizeElements(currentNode)||(currentNode.content instanceof DocumentFragment&&_sanitizeShadowDOM(currentNode.content),_sanitizeAttributes(currentNode),oldNode=currentNode);if(RETURN_DOM){if(RETURN_DOM_FRAGMENT)for(returnNode=createDocumentFragment.call(body.ownerDocument);body.firstChild;)returnNode.appendChild(body.firstChild);else returnNode=body;return RETURN_DOM_IMPORT&&(returnNode=importNode.call(originalDocument,returnNode,!0)),returnNode}return WHOLE_DOCUMENT?body.outerHTML:body.innerHTML},DOMPurify.setConfig=function(cfg){_parseConfig(cfg),SET_CONFIG=!0},DOMPurify.clearConfig=function(){CONFIG=null,SET_CONFIG=!1},DOMPurify.addHook=function(entryPoint,hookFunction){"function"==typeof hookFunction&&(hooks[entryPoint]=hooks[entryPoint]||[],hooks[entryPoint].push(hookFunction))},DOMPurify.removeHook=function(entryPoint){hooks[entryPoint]&&hooks[entryPoint].pop()},DOMPurify.removeHooks=function(entryPoint){hooks[entryPoint]&&(hooks[entryPoint]=[])},DOMPurify.removeAllHooks=function(){hooks={}},DOMPurify}var html=["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"],svg=["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","audio","canvas","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","video","view","vkern"],svgFilters=["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"],mathMl=["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmuliscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mpspace","msqrt","mystyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"],text=["#text"],html$1=["accept","action","align","alt","autocomplete","background","bgcolor","border","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","coords","crossorigin","datetime","default","dir","disabled","download","enctype","face","for","headers","height","hidden","high","href","hreflang","id","integrity","ismap","label","lang","list","loop","low","max","maxlength","media","method","min","multiple","name","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","type","usemap","valign","value","width","xmlns"],svg$1=["accent-height","accumulate","additivive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","tabindex","targetx","targety","transform","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"],mathMl$1=["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"],xml=["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"],MUSTACHE_EXPR=/\{\{[\s\S]*|[\s\S]*\}\}/gm,ERB_EXPR=/<%[\s\S]*|[\s\S]*%>/gm,DATA_ATTR=/^data-[\-\w.\u00B7-\uFFFF]/,ARIA_ATTR=/^aria-[\-\w]+$/,IS_ALLOWED_URI=/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,IS_SCRIPT_OR_DATA=/^(?:\w+script|data):/i,ATTR_WHITESPACE=/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},getGlobal=function(){return"undefined"==typeof window?null:window};return createDOMPurify()})},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var ALLOWED_TAGS=["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr","title"],ALLOWED_ATTR=["accept","action","align","alt","autocomplete","background","bgcolor","border","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","coords","crossorigin","datetime","default","dir","disabled","download","enctype","face","for","headers","height","hidden","high","href","hreflang","id","integrity","ismap","label","lang","list","loop","low","max","maxlength","media","method","min","multiple","name","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","summary","tabindex","title","type","usemap","valign","value","width","xmlns"];exports.ALLOWED_ATTR=ALLOWED_ATTR,exports.ALLOWED_TAGS=ALLOWED_TAGS}]);
!function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}var installedModules={};__webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{configurable:!1,enumerable:!0,get:getter})},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=2)}([function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.SCRIPT_RESPONSE_STATUS={SUCCESS:"S",FAILURE:"F",NO_DATA:"Z"},exports.EVENT_CKI_VALUE={WEIGHT:"CKI.EC!9515",HEIGHT:"CKI.EC!9516"},exports.MEASUREMENT_TYPE={WEIGHT:1,HEIGHT:2}},function(module,exports){module.exports=ScriptRequest},function(module,exports,__webpack_require__){module.exports=__webpack_require__(3)},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _logger=__webpack_require__(4),_logger2=_interopRequireDefault(_logger),_getConvertedUnitData=__webpack_require__(5),_getConvertedUnitData2=_interopRequireDefault(_getConvertedUnitData),_getCKI=__webpack_require__(6),_getCKI2=_interopRequireDefault(_getCKI),_unitConverterConstants=__webpack_require__(0),UnitConverter=function(){function UnitConverter(){_classCallCheck(this,UnitConverter),this._events={}}return UnitConverter.prototype._hasEvent=function(event){return event in this._events},UnitConverter.prototype._saveEventInObject=function(event,result,unitOfMeasure){this._events[event]={result:result,unitOfMeasure:unitOfMeasure}},UnitConverter.prototype._evaluateFormula=function(formulaStr){return formulaStr.split("*").reduce(function(accumulator,item){return accumulator*Number(item||1)},1)},UnitConverter.prototype.convertUnit=function(eventCode,unitValue,unitCode){var _this=this;if(this._hasEvent(unitCode)){var convertedValue=(this._events[unitCode].result*unitValue).toFixed(2);return Promise.resolve({result:convertedValue,unit:this._events[unitCode].unitOfMeasure})}return(0,_getCKI2.default)(eventCode).then(function(reply){if(reply.getStatus()===_unitConverterConstants.SCRIPT_RESPONSE_STATUS.SUCCESS){switch(reply.getResponse().CKI){case _unitConverterConstants.EVENT_CKI_VALUE.WEIGHT:return _this._callConversionService(unitValue,unitCode,_unitConverterConstants.MEASUREMENT_TYPE.WEIGHT);case _unitConverterConstants.EVENT_CKI_VALUE.HEIGHT:return _this._callConversionService(unitValue,unitCode,_unitConverterConstants.MEASUREMENT_TYPE.HEIGHT);default:return null}}return null}).catch(function(reply){return _logger2.default.logError("Artifact: mpage-unit-converter, FunctionName: convertUnit, script: getCKI, Failed to perform the request due to "+JSON.stringify(reply)),null})},UnitConverter.prototype._callConversionService=function(unitValue,unitCode,measurementType){var _this2=this;return(0,_getConvertedUnitData2.default)(unitCode,measurementType).then(function(reply){if(reply.getStatus()===_unitConverterConstants.SCRIPT_RESPONSE_STATUS.SUCCESS){var response=reply.getResponse(),formula=_this2._evaluateFormula(response.FORMULA),convertedValue=(formula*unitValue).toFixed(2);return _this2._saveEventInObject(unitCode,formula,response.RESULT_UNIT),{result:convertedValue,unit:response.RESULT_UNIT}}return null})},UnitConverter}();exports.default=UnitConverter,void 0===window.MP_UnitConverter&&(window.MP_UnitConverter=new UnitConverter)},function(module,exports){module.exports=logger},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _ScriptRequest=__webpack_require__(1),_ScriptRequest2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_ScriptRequest),_unitConverterConstants=__webpack_require__(0),getConvertedUnitData=function(fromUnitCD,measurementType){return new Promise(function(resolve,reject){(new _ScriptRequest2.default).setArtifactInfo({artifactId:"mpage-unit-converter",functionName:"getConvertedUnitData"}).setProgramName("mp_get_unit_code_formula").setParameterArray(["^MINE^",fromUnitCD,measurementType]).setResponseHandler(function(reply){return reply.getStatus()!==_unitConverterConstants.SCRIPT_RESPONSE_STATUS.FAILURE?resolve(reply):reject(reply.getResponse())}).performRequest()})};exports.default=getConvertedUnitData},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _ScriptRequest=__webpack_require__(1),_ScriptRequest2=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(_ScriptRequest),_unitConverterConstants=__webpack_require__(0),getCKI=function(eventCode){return new Promise(function(resolve,reject){(new _ScriptRequest2.default).setArtifactInfo({artifactId:"mpage-unit-converter",functionName:"getCKI"}).setProgramName("mp_get_cki_value").setParameterArray(["^MINE^",eventCode]).setResponseHandler(function(reply){return reply.getStatus()!==_unitConverterConstants.SCRIPT_RESPONSE_STATUS.FAILURE?resolve(reply):reject(reply.getResponse())}).performRequest()})};exports.default=getCKI}]);
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _logger = _interopRequireDefault(__webpack_require__(1));

var _CERN_Platform = _interopRequireDefault(__webpack_require__(2));

var _CapabilityTimer = _interopRequireDefault(__webpack_require__(3));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// eslint-disable-line camelcase
// eslint-disable-line camelcase

/**
 * @enum {Object} - Enum for COM object notifications
 * @type { {BLUR: Number, FOCUS: Number} }
 * @readOnly.
 */
var ACTION = {
  BLUR: 0,
  FOCUS: 5
};
/**
 * Delay for the debounce
 * @type {{ DELAY: Number }}
 * @readOnly.
 */

var DELAY = 500;
/**
 * The MP_ActivityTracking namespace houses all the functions needed to help track the time
 * spent within MPages. This namespace will be responsible for capturing the workflow performed
 * by the user.
 * @namespace
 */

/* eslint-disable camelcase */

var MP_ActivityTracking = function () {
  var timeout; // object for saving off the View specific details

  var viewObject = {}; // eslint-disable-line no-unused-vars

  /**
   * This function will be called when MPages Viewpoint framework initially loads.
   * @param {String} viewPointCategoryMean - Category Mean of the loaded Viewpoint.
   * @param {String} viewPointName - Name of the loaded Viewpoint.
   */

  var captureInitialViewpointLoad = function captureInitialViewpointLoad(viewPointCategoryMean, viewPointName) {
    // Trigger the Capability Timer when MPages Viewpoint framework initially loads.
    new _CapabilityTimer["default"]("CAP:MPG_INITIAL_VIEWPOINT_LOAD", viewPointCategoryMean).addMetaData("Viewpoint_Name", viewPointName).addMetaData("Browser_Context", _CERN_Platform["default"].inEdgeContext() ? "Edge" : "IE").capture();

    _logger["default"].logMessage(JSON.stringify({
      Timer: "CAP:MPG_INITIAL_VIEWPOINT_LOAD",
      Viewpoint_Name: viewPointName
    }));
  };
  /**
   * This function will be called when MPages View initially loads.
   * @param {String} viewCategoryMean - Category Mean of the loaded View.
   * @param {String} viewLabel - Label given to the view in the MPages View Bedrock Wizard.
   * @param {String} viewName - Name of the View as defined in the Bedrock Wizard.
   */


  var captureInitialMPagesViewLoad = function captureInitialMPagesViewLoad(viewCategoryMean, viewLabel, viewName) {
    // Trigger the Capability Timer when MPages View initially loads.
    new _CapabilityTimer["default"]("CAP:MPG_INITIAL_MPAGES_VIEW_LOAD", viewCategoryMean).addMetaData("MPages_View_Label", viewLabel).addMetaData("MPages_View_Name", viewName).capture();

    _logger["default"].logMessage(JSON.stringify({
      Timer: "CAP:MPG_INITIAL_MPAGES_VIEW_LOAD",
      MPages_View_Label: viewLabel,
      MPages_View_Name: viewName
    }));
  };
  /**
   * This function will be called when the MPages View is navigated away from. This can occur when users are -
   * 1) Navigating between views in a viewpoint or
   * 2) Navigating to another tab in PowerChart.
   * @param {String} viewCategoryMean - Category Mean of the loaded View.
   * @param {String} viewLabel - Label given to the view in the MPages View Bedrock Wizard.
   * @param {String} viewName - Name of the View as defined in the Bedrock Wizard.
   */


  var captureMPagesViewBlur = function captureMPagesViewBlur(viewCategoryMean, viewLabel, viewName) {
    // Trigger the Capability Timer when MPages View is navigated away from and the view is blurred.
    new _CapabilityTimer["default"]("CAP:MPG_MPAGES_VIEW_BLUR", viewCategoryMean).addMetaData("MPages_View_Label", viewLabel).addMetaData("MPages_View_Name", viewName).addMetaData("Viewpoint_Category_Mean", viewCategoryMean).capture();

    _logger["default"].logMessage(JSON.stringify({
      Timer: "CAP:MPG_MPAGES_VIEW_BLUR",
      MPages_View_Label: viewLabel,
      MPages_View_Name: viewName,
      Viewpoint_Category_Mean: viewCategoryMean
    }));
  };
  /**
   * This function will be called when the MPages View is navigated into. This can occur when users are -
   * 1) Navigating between views in a viewpoint or
   * 2) Navigating to another tab in PowerChart.
   * @param {String} viewCategoryMean - Category Mean of the loaded View.
   * @param {String} viewLabel - Label given to the view in the MPages View Bedrock Wizard.
   * @param {String} viewName - Name of the View as defined in the Bedrock Wizard.
   */


  var captureMPagesViewFocus = function captureMPagesViewFocus(viewCategoryMean, viewLabel, viewName) {
    // Trigger the Capability Timer when MPages View is navigated back or focused again.
    new _CapabilityTimer["default"]("CAP:MPG_MPAGES_VIEW_FOCUS", viewCategoryMean).addMetaData("MPages_View_Label", viewLabel).addMetaData("MPages_View_Name", viewName).addMetaData("Viewpoint_Category_Mean", viewCategoryMean).capture();

    _logger["default"].logMessage(JSON.stringify({
      Timer: "CAP:MPG_MPAGES_VIEW_FOCUS",
      MPages_View_Label: viewLabel,
      MPages_View_Name: viewName,
      Viewpoint_Category_Mean: viewCategoryMean
    }));
  };
  /**
   * This function sets the viewObject for saving off the view-specific details.
   * @param {String} categoryMean - Category Mean of the loaded View.
   * @param {String} viewLabel - Label given to the view in the MPages View Bedrock Wizard.
   * @param {String} viewName - Name of the View as defined in the Bedrock Wizard.
   */


  var setViewSpecificDetails = function setViewSpecificDetails(categoryMean, viewLabel, viewName) {
    viewObject.categoryMean = categoryMean;
    viewObject.viewLabel = viewLabel;
    viewObject.viewName = viewName;
  };
  /**
   * This function resets the viewObject. The viewObject resetting is required
   * in a scenario when the user arrives on viewSelection page and tries navigating
   * to a different tab. As the viewSelection page is not being tracked,
   * the object needs to be reset.
   */


  var resetViewSpecificDetails = function resetViewSpecificDetails() {
    viewObject.categoryMean = "";
    viewObject.viewLabel = "";
    viewObject.viewName = "";
  };
  /**
   * Gets the view object containing view-specific details.
   * @returns {Object} view object
   */


  var getViewObject = function getViewObject() {
    return viewObject;
  };
  /**
   * This function will be called when user switches in between the tabs.
   * @param {Number} action - 0 or 5 represents Hide or Show respectively.
   */


  var captureSwitchBetweenTabs = function captureSwitchBetweenTabs(action) {
    if (action === ACTION.BLUR) {
      captureMPagesViewBlur(viewObject.categoryMean, viewObject.viewLabel, viewObject.viewName);
    } else if (action === ACTION.FOCUS) {
      captureMPagesViewFocus(viewObject.categoryMean, viewObject.viewLabel, viewObject.viewName);
    }
  };
  /**
   * This is the registered callback function, which will be triggered on
   * tab switch. The function debounces and makes a call to captureSwitchBetweenTabs.
   * @param {Number} action - 0 or 5 represents Hide or Show respectively.
   */


  var tabSwitchListener = function tabSwitchListener(action) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      return captureSwitchBetweenTabs(action);
    }, DELAY);
  };
  /**
   * This function registers the tabSwitchListener as the callback function
   * to the PCNotifyShowComponent COM object when in Millennium context.
   */


  var registerTabSwitchListener = function () {
    // eslint-disable-line no-unused-vars
    if (_CERN_Platform["default"].inMillenniumContext() && "PCNotifyShowComponent" in external) {
      window.tabSwitchListener = tabSwitchListener;
      window.external.PCNotifyShowComponent("tabSwitchListener"); // eslint-disable-line new-cap
    } else {
      _logger["default"].logMessage("PCNotifyShowComponent is not available");
    }
  }();

  return {
    captureInitialViewpointLoad: captureInitialViewpointLoad,
    captureInitialMPagesViewLoad: captureInitialMPagesViewLoad,
    captureMPagesViewFocus: captureMPagesViewFocus,
    captureMPagesViewBlur: captureMPagesViewBlur,
    setViewSpecificDetails: setViewSpecificDetails,
    resetViewSpecificDetails: resetViewSpecificDetails,
    getViewObject: getViewObject,
    captureSwitchBetweenTabs: captureSwitchBetweenTabs
  };
}();

var _default = MP_ActivityTracking;
exports["default"] = _default;
window.MP_ACTIVITY_TRACKING = MP_ActivityTracking;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = logger;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = CERN_Platform;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = CapabilityTimer;

/***/ })
/******/ ]);
/* global CapabilityTimer, CheckpointTimer, AggregateTimer */
/**
 * Initialize the prior authorization MPage View.
 * @param {String} priorAuthStaticContentLocation - location of prior auth static content.
 * @constructor
 */
function PriorAuthMPageView(priorAuthStaticContentLocation) {
    this.priorAuthStaticContentLocation = priorAuthStaticContentLocation;
}

PriorAuthMPageView.prototype = new MPageView();
PriorAuthMPageView.prototype.constructor = MPageView;

PriorAuthMPageView.prototype.initializeView = function() {
    return true;
};

PriorAuthMPageView.prototype.loadViewSettings = function() {
    // No settings to load.
    return true;
};

PriorAuthMPageView.prototype.loadComponents = function() {
    // No components to load.
    return true;
};

PriorAuthMPageView.prototype.initializeComponents = function() {
    // No components to load.
    return true;
};

// No need for custom resize.
PriorAuthMPageView.prototype.resizeView = function() {};

/**
 * Adds an IFrame that will be populated with HTML in postProcessing method.
 * @returns {Boolean} : true if view is rendered successfully.
 */
PriorAuthMPageView.prototype.renderView = function() {
    var vwpContainerObj = $("#vwpBody");
    var containerObj = $("#" + this.getCategoryMean());
    this.setContainer(containerObj);

    var priorAuthArray = [];
    var desiredHeight = vwpContainerObj.css("height");
    var contentBodyStyleValue = "\"overflow-y:hidden; height:" + desiredHeight + ";\"";
    var iFrameId = "pa_iframe" + this.getCategoryMean();
    priorAuthArray.push("<div class=\"content-body\" style=" + contentBodyStyleValue + " >");
    priorAuthArray.push("<iframe id=\"" + iFrameId + "\" name=\"pa-iframe\" frameborder=\"0\" width=\"100%\" height=\"100%\" >");
    priorAuthArray.push("</iframe>");
    priorAuthArray.push("</div>");

    containerObj.html(priorAuthArray.join(""));

    return true;
};

/**
 * Adds the HTML content to the IFrame that was injected in the renderComponent call.
 * @returns {undefined} : undefined/void
 */
PriorAuthMPageView.prototype.postProcessing = function() {
    var self = this;
    var categoryMean = self.getCategoryMean();
    var iFrameId = "pa_iframe" + categoryMean;
    var iframe = document.getElementById(iFrameId);
    var iframeDoc = iframe.contentDocument;
    var iframeHTML = iframeDoc.getElementById(categoryMean + "html");

    // If html content for this prior auth mpage view already exists,
    // no need to do anything.
    if (iframeHTML && $(iframeHTML).hasClass("pa-form-open")){
        return;
    }

    var criterion = self.getCriterion();
    var priorAuthIFrameArray = [];
    // Use different base url when running from browser.
    // var baseUrl = "../../static_content/om_prior_auth/";
    var baseUrl = self.priorAuthStaticContentLocation;
    var paViewContainer = MP_Viewpoint.getViewContainerById(categoryMean);
    var activationData = {
        priorAuthorizationRecordId: paViewContainer.priorAuthRecordId,
        userId: criterion.provider_id,
        patientProviderRelationshipCodeValue: criterion.ppr_cd,
        facilityCodeValue: criterion.facility_cd
    };
    priorAuthIFrameArray.push("<DOCTYPE html>");
    priorAuthIFrameArray.push("<html id=\"" + categoryMean + "html\" class=\"pa-form-open\" dir=\"ltr\">");
    priorAuthIFrameArray.push("<head>");
    priorAuthIFrameArray.push("<script type=\"text/javascript\">");
    priorAuthIFrameArray.push("var CERN_params = { viewToLoad: 'priorauth/viewmodels/mainView', activationData : " + JSON.stringify(activationData) + "};");
    priorAuthIFrameArray.push("</script>");
    priorAuthIFrameArray.push("<meta charset=\"utf-8\" />");
    priorAuthIFrameArray.push("<meta content='XMLCCLREQUEST' name='discern'>");
    priorAuthIFrameArray.push("<link rel=\"stylesheet\" href=\"" + baseUrl + "lib/terra/css/terra.css\" />");
    priorAuthIFrameArray.push("<link rel=\"stylesheet\" href=\"" + baseUrl + "css/priorauth.css\" />");
    priorAuthIFrameArray.push("<script src=\"" + baseUrl + "lib/blackbird/js/blackbird.js\" type=\"text/javascript\"></script>");
    priorAuthIFrameArray.push("<script src=\"" + baseUrl + "lib/mpages/mpages_core.js\" type=\"text/javascript\"></script>");
    priorAuthIFrameArray.push("<script src=\"" + baseUrl + "i18n/en-us.js\" type=\"text/javascript\"></script>");
    priorAuthIFrameArray.push("<link href=\"" + baseUrl + "lib/toastr/css/toastr.min.css\" rel=\"stylesheet\" type=\"text/css\" />");
    priorAuthIFrameArray.push("<link type=\"text/css\" rel=\"Stylesheet\" href=\"" + baseUrl + "lib/blackbird/css/blackbird.css\" />");
    priorAuthIFrameArray.push("<link type=\"text/css\" rel=\"Stylesheet\" href=\"" + baseUrl + "lib/datetimepicker/jquery.datetimepicker.css\" />");
    priorAuthIFrameArray.push("<script src=\"" + baseUrl + "lib/require/require.js\" type=\"text/javascript\"></script>");
    priorAuthIFrameArray.push("<script src=\"" + baseUrl + "app/main-built.min.js\" type=\"text/javascript\"></script>");
    priorAuthIFrameArray.push("</head>");
    priorAuthIFrameArray.push("<body>");
    priorAuthIFrameArray.push("<div id=\"applicationHost\"></div>");
    priorAuthIFrameArray.push("</body>");
    priorAuthIFrameArray.push("</html>");
    var iFrameContent = priorAuthIFrameArray.join("");

    iframe.requireConfig = {
        baseUrl: baseUrl + "app",
        config: {
            "priorauth/services/dataContext": {
                inMillennium: CERN_Platform.inMillenniumContext(),
                isModal: false,
                Timers: {
                    CapabilityTimer: CapabilityTimer,
                    CheckpointTimer: CheckpointTimer,
                    AggregateTimer: AggregateTimer,
                    RTMSTimer: RTMSTimer
                },
                ErrorModalDialog: {
                    MP_ModalDialog: MP_ModalDialog,
                    MP_Util: MP_Util,
                    CERN_Platform: CERN_Platform,
                    ErrorButtonContinue: new ModalButton("continue"),
                    ErrorButtonOk: new ModalButton("ok")
                },
                tunnel: self.getEventNotifier()
            }
        }
    };

    iframeDoc.open();
    iframeDoc.writeln(iFrameContent);
    iframeDoc.close();
};

PriorAuthMPageView.eventNotifiers = {};

/**
 * Gets the event notifier used to communicate events between the PriorAuthMPageView and the
 * webapp it is hosting.
 * @returns {Element} The element used as an event notifier for the PriorAuthMPageView.
 */
PriorAuthMPageView.prototype.getEventNotifier = function(){
    var categoryMean = this.getCategoryMean();
    var eventNotifierElement = PriorAuthMPageView.eventNotifiers[categoryMean];
    if (!eventNotifierElement){
        eventNotifierElement = document.createElement("EPA_EVENT_HANDLER");
        PriorAuthMPageView.eventNotifiers[categoryMean] = eventNotifierElement;
    }

    return eventNotifierElement;
};

/* eslint-disable complexity */
/**
 * Customized logic for adding PriorAuthMPageView as a dynamic tab.
 * @param {ViewContainer} viewContainer - View container used to add the dynamic tab.
 * @returns {undefined} This function does not return a value.
 */
PriorAuthMPageView.prototype.addDynamicTab = function(viewContainer) {
    var self = this;
    var tabIndex = MP_Viewpoint.getViewpointObject().getViewpointTabList().getTabCount();
    var tabId = viewContainer.getId();
    var removeTabCallback = function(id) {
        if (id !== tabId) {
            return;
        }

        var $iframe = $(document.getElementById("pa_iframe" + id));
        if ($iframe.length === 0 ) {
            return;
        }

        var iFrameContentDoc = $iframe[0].contentDocument;
        var $iframeDoc = $(iFrameContentDoc);
        var $priorAuthHTML = $iframeDoc.find("#" + id + "html");
        var $saveButton = $iframeDoc.find("#prior-auth-save-button");
        var promise = $.Deferred().resolve(); // eslint-disable-line new-cap

        if ($saveButton.length > 0) {
            if ($saveButton.attr("disabled") === "disabled"){
                    // No unsaved data. trigger to close the form.
                var closeEvent = document.createEvent("Event");
                closeEvent.initEvent("dismiss", false, true);
                self.getEventNotifier().dispatchEvent(closeEvent);
            }
                else{
                    // unsaved data. Show the error dialog.
                promise = self.showUnsavedDataErrorDialog();
            }
        }

            // Remove open class so that form will be
            // rendered again if re-opened.
        $priorAuthHTML.removeClass("pa-form-open");
        promise.always(function(){
                // Clean up iframe memory.
            iFrameContentDoc.open();
            iFrameContentDoc.writeln("");
            iFrameContentDoc.close();
            $iframe[0].contentWindow.location.reload();
        });

        MP_Viewpoint.removeListener(MP_Viewpoint.EVENTS.REMOVE_TAB, removeTabCallback);
    };

    MP_Viewpoint.Tabs.addDynamicTab(viewContainer, tabIndex);
    MP_Viewpoint.on(MP_Viewpoint.EVENTS.REMOVE_TAB, removeTabCallback);
    MP_Viewpoint.Tabs.selectTab(tabId);
};

/**
 * Shows a modal dialog asking the user if they would like to save changes before closing.
 * @returns {Promise} Returns a promise that will be resolved when the dialog closes.
 */
PriorAuthMPageView.prototype.showUnsavedDataErrorDialog = function(){
    var self = this;
    var priorAuthI18n = i18n.orders.prior_auth_mpage;
    var message = priorAuthI18n.UNSAVED_CHANGES_MESSAGE;
    var saveButtonText = priorAuthI18n.SAVE;
    var doNotSaveButtonText = priorAuthI18n.DO_NOT_SAVE;
    var title = priorAuthI18n.UNSAVED_CHANGES_TITLE;
    var deferred = $.Deferred(); // eslint-disable-line new-cap

    var modalObj = MP_Util.generateModalDialogBody("epaUnsavedDataErrorDialog", "error", message, "");
    var modalButton = modalObj.getFooterButton("modalSaveBtn");
    if (!modalButton) {
        modalButton = new ModalButton("modalSaveBtn");
        modalButton.setText(saveButtonText);
        modalButton.setFocusInd(true);
        modalButton.setCloseOnClick(true);
        modalObj.addFooterButton(modalButton);
        modalObj.setShowCloseIcon(false);
    }

    modalButton.setOnClickFunction(function(){
        var saveAndForceCloseEvent = document.createEvent("Event");
        saveAndForceCloseEvent.initEvent("save-and-dismiss", false, true);
        self.getEventNotifier().dispatchEvent(saveAndForceCloseEvent);
        deferred.resolve();
    });

    modalButton = modalObj.getFooterButton("modalDoNotSaveBtn");
    if (!modalButton) {
        modalButton = new ModalButton("modalDoNotSaveBtn");
        modalButton.setText(doNotSaveButtonText);
        modalButton.setFocusInd(true);
        modalButton.setCloseOnClick(true);
        modalObj.addFooterButton(modalButton);
        modalObj.setShowCloseIcon(false);
    }

    modalButton.setOnClickFunction(function(){
        var closeEvent = document.createEvent("Event");
        closeEvent.initEvent("dismiss", false, true);
        self.getEventNotifier().dispatchEvent(closeEvent);
        deferred.resolve();
    });

    modalObj.setHeaderTitle(title);
    modalObj.setFooterButtonText("modalSaveBtn", saveButtonText);
    modalObj.setFooterButtonText("modalDoNotSaveBtn", doNotSaveButtonText);
    MP_ModalDialog.updateModalDialogObject(modalObj);
    MP_ModalDialog.showModalDialog("epaUnsavedDataErrorDialog");

    return deferred.promise();
};

/* globals CERN_Browser, MPageFusion, MP_PendingData, AggregateTimer, m_bedrockMpage, CERN_driver_mean, MPageUI, CapabilityTimer, DynamicFilterMappingComponent */

/**
 * A constructor used to create a new NavigatorSubsectionSummaryMPage object and initialize page level variables.
 * The implementation is wrapped in an anonymous function to allow private functions.
 * @constructor
 */
var NavigatorSubsectionSummaryMPage = (function () { //  eslint-disable-line no-unused-vars
    var WorkflowMPage = function () {
        // A flag which will determine if we should load all components or attempt to selectively load components as needed
        this.m_selectiveComponentLoadInd = false;

        // Set page level information
        this.setName("Navigator Subsection Summary MPage");

        // Set the category mean of the parent workflow page so component subtimers will be associated with the parent
        //  instead of the subsection
        this.m_parentWorkflowId = "";

        // Set the aggregate timer object that measures the page load time
        this.m_aggregateTimer = null;

        // Flag which will determine if the current view has been divided into two columns with the second column named
        //  Contextual View.
        this.m_isContextualViewActive = false;

        // Array to cache the instance of component in the second column/conxtextual view column
        this.m_componentsInContextualView = [];

        //  Legacy adapter root control for MPageFusion integration
        this.m_rootControl = null;
        // Feature Toggle Config
        this.m_featureToggleConfig = {};

    };

    //  Inheritance
    WorkflowMPage.prototype = new MPageView();
    WorkflowMPage.prototype.constructor = MPageView;

    /**
     * Dangerously returns the root control (legacy adapter) for MPageFusion integration. This function should NOT
     * be used unless absolutely necessary and without requesting permissions to do so.
     * @returns {MPageUI.LegacyAdapter.RootControl} The MPageFusion adapter control.
     */
    WorkflowMPage.prototype.dangerouslyGetRootControl = function () {
        return this.m_rootControl;
    };

    /**
     * Checkers
     */
    /**
     * Returns the flag which indicates if components should be loaded selectively.  If this flag is set to true the MPage
     * will not attempt to load any components upon initial render and will instead wait to load components when the
     * loadSelectedComponent function is called
     * @returns {boolean} The selective components loading indicator.
     */
    WorkflowMPage.prototype.selectivelyLoadComponents = function () {
        return this.m_selectiveComponentLoadInd;
    };

    /**
     * Getters
     */

    /**
     * This function will retrieve the aggregate timer object that measure the page load time.
     * @returns {AggregateTimer} The AggregateTimer object
     */
    WorkflowMPage.prototype.getAggregateTimer = function () {
        return this.m_aggregateTimer;
    };
    
    /**
     * Gets the featureToggle configuration property to load orion or mpage components based on these feature toggles
     * @returns {Object}
     */
    WorkflowMPage.prototype.getFeatureToggleConfig = function() {
        if(!this.m_featureToggleConfig){
            this.m_featureToggleConfig = {};
        }
        return this.m_featureToggleConfig;
    };
    /**
     * This function will retrieve the category_mean of the parent workflow MPage where this navigator subsection summary
     * MPage is being displayed.
     * @returns {string} The identifier of the parent Workflow MPage
     */
    WorkflowMPage.prototype.getParentWorkflowIdentifier = function () {
        return this.m_parentWorkflowId;
    };

    /**
     * Returns a flag indicating that the contextual view is active
     * @returns {Boolean}  The flag indicating that contextual view is active
     */
    WorkflowMPage.prototype.isContextualViewActive = function () {
        return this.m_isContextualViewActive;
    };
    /**
     * Setters
     */
    /**
     * Sets the featureToggleConfig property to load the components
     * @param {Object} featureToggleConfig - feature toggle configuration for the filter mean
     * @returns {undefined}
     */
    WorkflowMPage.prototype.setFeatureToggleConfig = function(featureToggleConfig) {
        this.m_featureToggleConfig = featureToggleConfig;
    };
    /**
     * This function will set the aggregate timer object that measure the page load time.
     * @param {AggregateTimer} aggregateTimer The AggregateTimer object
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.setAggregateTimer = function (aggregateTimer) {
        this.m_aggregateTimer = aggregateTimer;
    };

    /**
     * This function will set the category_mean of the parent Workflow MPage where this navigator subsection summary MPage
     * is being displayed. This will allow the components being displayed in this navigator subsection summary to log
     * timers that are associated with the parent Workflow MPage.
     * @param {string} parentWorkflowId The identifier associated with the parent Workflow MPage
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.setParentWorkflowIdentifier = function (parentWorkflowId) {
        this.m_parentWorkflowId = parentWorkflowId;
    };

    /**
     * Set the selective component load flag which determines if the MPage should allow for selective component loading.
     * This means the MPage will not attempt to load its components until explicitly told to do so using the
     * loadSelectedComponent function.
     * @param {boolean} selectiveLoad A boolean which will indicate if the MPages should allow for selective loading of
     *     components.
     * @returns {boolean} True if the selective component load indicator was set successfully, false otherwise
     */
    WorkflowMPage.prototype.setSelectiveComponentLoadInd = function (selectiveLoad) {
        if (typeof selectiveLoad === "boolean") {
            this.m_selectiveComponentLoadInd = selectiveLoad;
            return true;
        }
        return false;
    };

    /**
     * Set the contextual view active flag which determines if the MPage has contextual view.
     * @param {boolean} contextualViewActiveInd A boolean which will indicate if the MPage has contextual view active.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.setContextualViewActive = function (contextualViewActiveInd) {
        this.m_isContextualViewActive = contextualViewActiveInd;
    };

    /**
     * Helper functions
     */


    /**
     * This function overrides the base implementation of creating the MPage Timer object.  The timer for the
     * workflow views will be handled at the workflow level instead of the MPageView that is associated with
     * an individual subsection.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.createMPageTimerObject = function () {
    };


    /**
     * Create the agregate timer object to measure the page load time
     * It will choose the right timer name based on whether it is the initial page load or the user is switching to another
     * view.
     * @returns {AggregateTimer} the aggregate timer object
     */
    WorkflowMPage.prototype.createAggregateTimer = function () {
        var pageLoadTimerName = null;

        //  Retrieve the category mean from the parent Workflow container, because this subsection's category mean contains
        //  ssView_0
        var viewCategoryMean = this.getParentWorkflowIdentifier();

        // get the timer name depending on whether the view is loaded during the initial page load
        if (MP_Viewpoint.getInitialViewId() === viewCategoryMean) {
            // use the same timer as defined in mp_unified_driver
            pageLoadTimerName = "USR:MPG.MP_UNIFIED_DRIVER load entire page";
        }
        else {
            // use the timer name the measures the page load timer when the user switches the view
            pageLoadTimerName = "USR:MPG.VIEWPOINT load switch view";
        }

        return new AggregateTimer(pageLoadTimerName, viewCategoryMean);
    };

    /**
     * Load the component if it is displayable, it's not already
     * been loaded, and it's either:
     *    1. In a Millennium Context
     *    2. A Fusion Component
     *    3. The ViewportWidth is greater than the small breakpoint width
     * @function shouldLoadComponent
     * @param {MPageComponent} component
     * @returns {boolean}
     */
    var shouldLoadComponent = function (component) {
        var smallScreenWidth = 760;
        return component.isDisplayable()
            && !component.isLoaded()
            && (
                CERN_Platform.inMillenniumContext()
                || component.isFusionComponent
                || CERN_Browser.getViewportWidth() >= smallScreenWidth
            );
    };

    WorkflowMPage.prototype.loadSelectedComponent = function (component) {
        //   Ensure this component is actually an MPageComponent object
        if (!MPageComponent.prototype.isPrototypeOf(component)) {
            logger.logError("Invalid MPageComponent object passed into NavigatorSubsectionSummaryMPage.loadSelectedComponent");
            return false;
        }

        if (shouldLoadComponent(component)) {
            //   Mark the component as loaded and kick off the data retrieval
            component.setLoaded(true);
            component.startComponentDataRetrieval();
            return true;
        }
        else {
            return false;
        }
    };

    /**
     * This function creates the workflow render strategy for the components.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.createNewRenderStrategy = function () {
        return new MPageUI.LegacyAdapter.MPageUIRenderStrategy();
    };

    WorkflowMPage.prototype.postProcessing = function () {
    };

    /**
     * Initialize the NavigatorSubsectionSummaryMPage. Once the base function has completed the help file information is
     * loaded as well as the additional titleAnchor which gives the user the ability to start the discharge process.
     * @param {string} categoryMean The category mean for this MPageView
     * @param {Object} componentSettings The component settings for this MPageView
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.initializeView = function (categoryMean, componentSettings) {
        //  Use the Legacy Adapter to create a root control
        this.m_rootControl = new MPageUI.LegacyAdapter.RootControl();

        //  Set the categoryMean for this object if it has been passed in
        if (categoryMean) {
            this.setCategoryMean(categoryMean);
        }
        // Call the base initialize function to handle all of the basic setup
        MPageView.prototype.initializeView.call(this, null);
        //  Create the page settings for this Object so it can be used in the initializeComponents function
        if (componentSettings) {
            //  Check to make sure the components settings are not null before filtering. to prevent the undefined error
            //  Check to see if workspace is enabled. if enabled then remove dyndoc components.
            if (componentSettings.length && MP_Viewpoint.getViewpointObject().getWorkspaceInd()) {
                //  Removing all the components which are contextual view compatible. To prevent duplicate components when workspace is available
                var componentSetting = 0;
                for(componentSetting; componentSetting < componentSettings.length; componentSetting++) {
                    var component = componentSettings[componentSetting] && componentSettings[componentSetting].F_MN ? MP_Util.getObjectDefinitionMapping(componentSettings[componentSetting].F_MN) : ""; // F_MN is shorthand for Filter Mean
                    //  Check to remove all the components which are contextual view compatible when workspace is enabled to prevent duplicate components.
                    if( component && component.isContextualViewCompatible) {
                        componentSettings.splice(componentSetting--, 1);
                    }
                };
            }
            this.setViewSettings({
                C_MN: this.getCategoryMean(),
                BR_SET: {
                    CS: componentSettings
                }
            });
        }
    };

    /**
     * We have to override this because the bedrock settings can't handle the setting structure and we are hacking this to
     * get it to function for phase 0
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.loadViewSettings = function () {
        // Create a settings object for this View.  This is a hack so that we can utilize the existing bedrock component
        //  loading.
        m_bedrockMpage.MPAGE.push({
            SETTINGS: this.getViewSettings()
        });
    };
    /**
     * Method to check if the component is orion.
     * @param {featureToggleConfig} - the feature toggle configuration to make sure the feature toggles are defined for components
     * @param {componentFilterMean} - Component Bedrock filter mean
     * @param {componentOrionSettings} - Component Orion settings loaded from the workflow server specific to each component
     * @returns {boolean} This function returns true or false based on the result of toggle.
     */
    WorkflowMPage.prototype.isOrionComponent = function(featureToggleConfig, componentFilterMean, componentOrionSettings) {
        var isEnabled = false;
        isEnabled = featureToggleConfig && featureToggleConfig[componentFilterMean] ? featureToggleConfig[componentFilterMean] : isEnabled;
        return isEnabled || (componentOrionSettings && !componentOrionSettings.feature_toggle);
    };
    /**
     * Initialize the components which will be shown within this particular view.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.initializeComponents = function () {
        var component = null;
        var componentsArr = [];
        var componentCnt = 0;
        var compSettings = null;
        var criterion = null;
        var pageSettings = null;
        var x = 0;
        var orionMPageDynamicLoadingConfig = !window.DynamicComponentCatalog ? undefined : window.DynamicComponentCatalog.bedrockConfig;
        // Load the necessary components based on the component settings
        pageSettings = this.getViewSettings();
        criterion = this.getCriterion();
        // Update the criterion category_mean so that component will utilize the parent workflow id instead of the
        //  subsection generated id
        criterion.category_mean = this.getParentWorkflowIdentifier(); // eslint-disable-line mp-camelcase
        componentsArr = pageSettings.BR_SET.CS; // BR_SET is shorthand for Bedrock Settings and CS is shorthand for
        //  Component Settings
        componentCnt = componentsArr.length;
        var featureToggleConfig = this.getFeatureToggleConfig();
        // Initialize the components and add them to the Mpage
        for (x = 0; x < componentCnt; x++) {
            compSettings = componentsArr[x];
            var componentOrionSettings = orionMPageDynamicLoadingConfig ? orionMPageDynamicLoadingConfig[compSettings.F_MN] : null;
            //  Check if feature  toggle is enabled Or check if orion component but has no feature toggle associated then load orion component
            var isOrion = this.isOrionComponent(featureToggleConfig, compSettings.F_MN, componentOrionSettings);
            if (isOrion) {
                // Passing value to the react component for rendering
                var dynamicComponentDetails = componentOrionSettings ? {
                    WORKFLOW_IDENTIFIER: componentOrionSettings.workflow_identifier,
                    COMPONENT_TIMER: componentOrionSettings.timer,
                    BEDROCK_IDENTIFIER: compSettings.F_MN,
                    bedrockJson: compSettings
                } : undefined;

                //  Load orion component / web component
                component = new DynamicFilterMappingComponent(
                    criterion,
                    componentOrionSettings.workflow_identifier ,
                    dynamicComponentDetails
                );
            }
            else {
                //  Check if the mpage component or orion component and feature toggle disable then load mpage component
                // Create the component and prepare it for rendering
                component = this.createMPageComponentObject(compSettings.F_MN); // F_MN is shorthand for Filter Mean
            }
            if (component) {
                component.initializeComponent(criterion);
                // Set Component Preferences based on bedrock settings and user preferences
                component.loadComponentSettings(compSettings);
                component.loadDisplayFilters();
                component.setAlwaysExpanded(true);
                // Set the component type so we can perform any special actions base on the workflow type
                component.getStyles().setComponentType(CERN_COMPONENT_TYPE_WORKFLOW);
                // Move components defined for the second and third columns to the end of the first column.
                if (component.getColumn() > 1) {
                    // Using the * 100 to make sure the components are shown after the components defined to show
                    //  in the columns left of the current column.
                    component.setSequence(component.getColumn() * 100 + component.getSequence());
                    component.setColumn(1);
                }
                // Determine if the components should be displayed or not based on the view builder settings
                // Load component marked as Gap Check required even if it is set to off in the view builder settings
                if (component.getToggleStatus() === 0 && !component.getGapCheckCriteria()) {
                    component.setDisplayEnabled(false);
                }
                // Create the component menu
                component.createMainMenu();
                if (component.isDisplayable()) {
                    component.preProcessing();
                }
                // At this stage all FusionComponents have created the FusionComponentContent, add this instance as a child to the RootControl.
                // Doing this helps components fire events upstream to the RootControl to display or hide related DetailPanel.
                if (component.isFusionComponent && component.getFusionComponentContent()) {
                    this.dangerouslyGetRootControl().addMappedChild("component" + component.getComponentId(), component.getFusionComponentContent());
                }
                this.addComponent(component);
                this.addComponentId(componentsArr[x].R_ID); // R_ID is shorthand for Report Id(br_datamart_report_id)
            }
        }
    };

    /**
     * This function forces all the components into a single group and single column
     * @param {Array} components The list of components we are forcing into the single group, single column
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.forceComponentsIntoSingleColumn = function (components) {
        var numberComponents = components.length;
        // Force all components into a single column layout
        for (var x = 0; x < numberComponents; x++) {
            var component = components[x];
            component.setPageGroupSequence(1);
            component.setColumn(1);
        }
    };

    /**
     * This function will validate whether the current MPageView can have contextual view.
     * It uses Fusion core api to determine if the screen width is XL (1540 pixels).
     * @returns {Boolean} true if screen size is at least XL, else false
     */
    WorkflowMPage.prototype.canHaveContextualView = function () {
        return MPageFusion.coreAPI.base.mediaQuery.atLeast("XL");
    };

    /**
     * This function changes the layout of the current view with a different number of columns
     * @param {Number} newColCnt Number of columns of the new layout
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.changeLayout = function (newColCnt) {
        var $parentContainer = $("#" + this.m_parentWorkflowId).find(".wrkflw-views");
        var parentContainerHeight = $parentContainer.height();

        if (newColCnt === 1) {
            //  Remove the contextual view column
            $parentContainer.find(".ss-view-active")
                .removeClass("is-contextual-view-open")
                .find("[data-contextual-view='true']")
                .remove();

            this.m_isContextualViewActive = false;
        }
        else if (newColCnt === 2) {
            //  Append the contextual view column
            $parentContainer.find(".ss-view-active")
                .addClass("is-contextual-view-open")
                .append(
                    "<div class='mpageui-DetailPanelLayout' data-column='2' data-contextual-view='true'>" +
                    "<div class='mpageui-Components mpageui-DetailPanelLayout-content col2' style='height: " + parentContainerHeight + "px;'><div class='components-col-container'></div></div>" +
                    "</div>"
                );
        }
    };

    /**
     * Function that adds component to the m_componentsInContextualView array and prevents duplicates.
     * @param {MPageComponent} comp The instance of the component being moved from single column to the contextual view
     *     column.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.addComponentToContextualViewArray = function (comp) {
        if ($.inArray(comp, this.m_componentsInContextualView) === -1) {
            this.m_componentsInContextualView.push(comp);
        }
    };
    /**
     * Gets all the component in the contextual view.
     * @returns {Array} The array containing the components in contextual view.
     */
    WorkflowMPage.prototype.getComponentsInContextualViewArray = function () {
        return this.m_componentsInContextualView;
    };
    /**
     * Removes the component from the contextual view component array, called whenever a component is moved out of
     * contextual view.
     * @param  {MPageComponent} compObj Instance of component that is being moved between columns.
     * @returns {undefined} Does not return anything.
     */
    WorkflowMPage.prototype.removeComponentFromContextualViewArray = function (compObj) {
        var components = this.getComponentsInContextualViewArray();
        var component = null;
        for (var x = components.length; x--;) {
            component = components[x];
            if (component === compObj) {
                components.splice(x, 1);
                break;
            }
        }
    };

    /**
     * Function that filters active components present in contextual view.
     * @returns {Array}  The array of components that are present in the contextual view.
     */
    WorkflowMPage.prototype.filterActiveComponentsInContextualView = function () {
        var activeComponentsInContextualView = [];
        var components = this.getComponents();
        if (components.length) {
            activeComponentsInContextualView = $.grep(components, function (component) {
                return component.isAddedToContextualView() && component.isDisplayable();
            });
        }
        return activeComponentsInContextualView;
    };

    /**
     * Function that moves the component between the two column views. It gets called whenever the contextual view
     * control is clicked in the component header and when the resize is performed.
     * It has two code paths based on position of the component in contextual view.
     * @param  {MPageComponent} component Instance of component that is being moved between columns.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.moveComponentBetweenViews = function (component) {
        // Function that shuffles component nodes between the two columns.
        function changeComponentNodes(targetNode, activeNode) {
            var previousNode = $(targetNode).prev();
            var nextNode = $(targetNode).next();
            if (previousNode.length) {
                previousNode.after(activeNode);
            }
            else if (nextNode.length) {
                nextNode.before(activeNode);
            }
        }

        // The root component node
        var rootCompNode = component.getRootComponentNode();
        // The placeholder component node
        var placeholderCompNode = component.getRootPlaceholderComponentNode();

        var contextualViewContainer = this.getColumnContainer(2).find(".components-col-container");
        var placeholderView = null;
        // If the component is added to contextual and if contextual view is active,
        // replace the placeholder view of the component with the actual component
        // else create the placeholder view of component if not created and replace the actual component with it.
        if (component.isAddedToContextualView() && this.m_isContextualViewActive) {
            changeComponentNodes(placeholderCompNode, rootCompNode);
            $(placeholderCompNode).hide();
            component.setAddedToContextualView(false);
        }
        else {
            // On the initial call of this function the component is in the first column and would need to be replaced with
            //  its placeholder view Create the placeholder view, if not already created else just show it.
            if (!placeholderCompNode.length) {
                placeholderCompNode = component.createPlaceholderViewOfComponent();
            }
            else {
                $(placeholderCompNode).show();
            }
            // if the component is not loaded yet, load it  by calling the startComponentDataRetrieval
            if (component.isDisplayable() && !component.isLoaded()) {
                // Mark the component as loaded and kick off the data retrieval
                component.setLoaded(true);
                component.startComponentDataRetrieval();
            }
            // Call the helper function that has logic to change component nodes.
            changeComponentNodes(rootCompNode, placeholderCompNode);
            // Append the actual component node to the contextual view container.
            contextualViewContainer.append(rootCompNode);
            // This is the first instance of the placeholder view created and just rendered.
            // Set the callback to the control that adds the component to the contextual view.
            placeholderView = component.getPlaceholderView();
            if (!placeholderView.hasRendered()) {
                component.getContextualViewControlInPlaceholderView().setOnClickCallback(this.handleContextualViewControlFunction(component));
                component.getContextualViewControlInPlaceholderView().attachEvents();
            }
            placeholderView.setRendered(true);
            component.setAddedToContextualView(true);
            // Update the icon of the contextual view control in placeholder view and the actual component to move left.
            component.getContextualViewControlInPlaceholderView().setIcon(MPageUI.ICONS.ICON_MOVE_LEFT);
        }
    };

    /**
     * This function returns a function that would be used as a callback for the click on the MPageUI.Button instance for
     * the contextual view control. The callback will check whether the component is added to contextual view and would
     * activate the two column view by calling the changeLayout function else if not added to contextual view it would
     * remove the component from the contextual view and change the layout to single column.
     *
     * @param  {MPageComponent} component An instance of the MPageComponent
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.handleContextualViewControlFunction = function (component) {
        var categoryMean = this.getCategoryMean();
        var self = this;
        return function () {
            // Get the preferences object.
            var preferenceObj = component.getPreferencesObj();
            // If the component does not have az
            if (!preferenceObj) {
                preferenceObj = {
                    contextualViewPrefs: {}
                };
            }
            else {
                preferenceObj.contextualViewPrefs = {};
            }
            // Capability timer for the add action that moves this component to the contextual view.
            var addToContextualViewCapTimer = new CapabilityTimer("CAP:MPG COMPONENT CONTEXTUAL VIEW CONTROL CLICK", categoryMean);
            addToContextualViewCapTimer.addMetaData("component.reportMean", component.getReportMean());
            // If the component is not added to contextual view, add the component instance to the
            // array containing only contextual view components,
            //  change the layout to two column only once.
            if (!component.isAddedToContextualView()) {
                self.addComponentToContextualViewArray(component);
                preferenceObj.contextualViewPrefs.isAddedToContextualView = true;
                addToContextualViewCapTimer.addMetaData("action", "Added to Contextual View");
                if (!self.m_isContextualViewActive) {
                    self.m_isContextualViewActive = true;
                    self.changeLayout(2);
                }
            }
            else {
                // If the component is in the contextual view, remove the component instance from the
                // contextual view array and set the preference to false.
                self.removeComponentFromContextualViewArray(component);
                preferenceObj.contextualViewPrefs = null;
                addToContextualViewCapTimer.addMetaData("action", "Removed from Contextual View");
            }
            // Set the preference object at component level.
            component.setPreferencesObj(preferenceObj);
            // call the capture method on the CapabilityTimer
            addToContextualViewCapTimer.capture();
            // Call the moveComponentBetweenViews function that has logic to decide what to do with the
            // compoent, move it to contextual view or remove from it.
            self.moveComponentBetweenViews(component);
            // Update the preference for components in contextual view and change the layout to single column if there
            //  aren't any components in it.
            self.updateContextualViewCompPreferences();
            // Close the contextual view
            self.closeContextualView();
            // Once the layout of the view is changed, call the resizeComponents function.
            self.resizeComponents();
            // Call the UpdateAllCompPreferences method that would  update the preferences of all components.
            CERN_EventListener.fireEvent(null, component, EventListener.EVENT_COMPONENT_MOVED_FROM_CONTEXTUAL_VIEW, component);
            MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(self.getComponents(), true, true); // eslint-disable-line new-cap

            // Tells the component it was toggled in the contextual view
            component.toggledFromContextualView();
        };
    };
    /**
     * This function updates the preferences of all the components present in the Contextual view.
     * The preference that gets updated currently is the sequence of the component in the contextual view.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.updateContextualViewCompPreferences = function () {
        var contextualViewContainer = this.getColumnContainer(2).find(".components-col-container");
        // Get all the components in the contextual view. For all the components update their position,
        // if there aren't any change the layout to single column.
        var contextualViewCompArr = this.getComponentsInContextualViewArray();
        var contextualViewCompArrLen = contextualViewCompArr.length;
        // If there are any components update their sequence by looping
        for (var c = 0; c < contextualViewCompArrLen; c++) {
            var comp = contextualViewCompArr[c];
            var compId = comp.getStyles().getId();
            // Create the preference object if not already created.
            var preferenceObj = comp.getPreferencesObj();
            if (preferenceObj) {
                if (preferenceObj.contextualViewPrefs) {
                    preferenceObj.contextualViewPrefs.row_seq = contextualViewContainer.find("#" + compId).index(); // eslint-disable-line mp-camelcase
                }
            }
        }
    };
    /**
     * This function closes the contextual view if there are no more components left in contextual view column/second
     * column.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.closeContextualView = function () {
        // get the components in the Contextual view
        var contextualViewCompArr = this.getComponentsInContextualViewArray();
        var contextualViewCompArrLen = contextualViewCompArr.length;
        // If there are any components and if the contextual view is active change the layout to single column and set the
        //  isContextualViewActive flag to false;
        if (!contextualViewCompArrLen && this.m_isContextualViewActive) {
            this.changeLayout(1);
            this.m_isContextualViewActive = false;
        }
    };

    /**
     * Renders a column of components by mapping over each component and creating either
     * the placeholder view of the component or the actual view as created by the render strategy.
     * @param {Array<MPageComponent>} column - Array of component objects.
     * @param {boolean} canHaveContextualView - Whether this view can have contextual view.
     * @param {Function} createRenderStrategy - Creates a render strategy isntance for the
     * component.
     * @returns {Array<JQuery>} An array of JQuery views for the components.
     * @private
     */
    var _renderColumn = function (column, canHaveContextualView, createRenderStrategy) {     //  eslint-disable-line no-underscore-dangle
        return column.map(function (component) {
            //  Render strategy
            component.setRenderStrategy(createRenderStrategy());

            //  Handle contextual view
            if (component.isAddedToContextualView() && !component.getPlaceholderView() && canHaveContextualView) {
                return component.createPlaceholderViewOfComponent();
            }
            else {
                return component.getRenderStrategy().createComponentShell();
            }
        });
    };

    /**
     * Renders the layout of the NavigatorSubsectionSummaryMPage. There can really only be 2 columns in a Workflow.
     * The first column is the main workflow and the second is the contextual view.
     * @param {Array<Array<Object>>} columns - The array of columns in the Workflow.
     * @param {string} categoryMean - The category meaning of the current instance of the NavigatorSubsectionSummaryMPage.
     * @param {boolean} canHaveContextualView - Whether the Workflow can have contextual view.
     * @param {Function} createRenderStrategy - Function to create instances of the render strategy.
     * @returns {Array<JQuery>} Each column rendered as JQuery elements.
     * @private
     */
    var _renderLayout = function (columns, categoryMean, canHaveContextualView, createRenderStrategy) {      //  eslint-disable-line no-underscore-dangle
        /*
         * <div class="mpageui-DetailPanelLayout">
         *     <div class="mpageui-DetailPanelLayout-content">
         *         <div class="components-col-container">
         *             -> Components render here
         *         </div>
         *     </div>
         *     <div class="mpageui-DetailPanelLayout-panel">
         *         -> Detail Panel renders here
         *     </div>
         * </div>
         */
        return columns.map(function (column, i) {
            return $(
                "<div " +
                "id='" + categoryMean + "_detailPanelLayout' " +
                "class='mpageui-DetailPanelLayout' " +
                "data-column='" + (i + 1) + "' " +
                "data-contextual-view='" + (i > 0) +
                "'>"
            )
                .append($("<div class='mpageui-Components mpageui-DetailPanelLayout-content col" + (i + 1) + "'>")
                    .append($("<div class='components-col-container'>").append(
                        _renderColumn(column, canHaveContextualView, createRenderStrategy)
                    )))
                .append(
                    $("<div " +
                        "id='" + categoryMean + "_detailPanel' " +
                        "class='mpageui-DetailPanelLayout-panel'" +
                        ">")
                );
        });
    };

    /**
     * Helper to finalize contextual view components. This function only cares about the first column because it
     * is finalizing the contextual view functionality (placeholder) of components which only exist in the first
     * column.
     * @param {Array<Object>} firstColumn - The array of components in the first column.
     * @param {boolean} canHaveContextualView - Whether the Workflow can have contextual view.
     * @param {Function} handleContextualViewControl - A binding function that handles when contextual view is
     * clicked.
     * @returns {boolean} Returns boolean indicating if contextual view was finalized.
     * @private
     */
    var _finalizeContextualView = function (firstColumn, canHaveContextualView, handleContextualViewControl) {       //  eslint-disable-line no-underscore-dangle, no-unused-vars
        if (!canHaveContextualView) {
            return false;
        }
        firstColumn.filter(function (component) {
            return component.isAddedToContextualView();
        }).forEach(function (component) {    //  eslint-disable-line no-unused-vars
            component.setAddedToContextualView(true);
            component.getPlaceholderView().setRendered(true);
            component.toggleContextualView = handleContextualViewControl(component);
            var contextualViewControlInPlaceholderView = component.getContextualViewControlInPlaceholderView();
            contextualViewControlInPlaceholderView.setOnClickCallback(handleContextualViewControl(component));
            contextualViewControlInPlaceholderView.attachEvents();
        });
        return true;
    };

    /**
     * Helper to finalize the DetailPanel adapter in the RootControl.
     * @param {MPageUI.LegacyAdapter.RootControl} rootControl - The RootControl instance.
     * @param {string} categoryMean - The category meaning of the current instance of the NavigatorSubsectionSummaryMPage.
     * @returns {boolean} Boolean indicating if the root control successfully mounted the detail panel.
     * @private
     */
    var _prepareDetailPanel = function (rootControl, categoryMean) {     //  eslint-disable-line no-underscore-dangle
        if (!rootControl) {
            return false;
        }
        rootControl.mountDetailPanel(categoryMean + "_detailPanel");
        return true;
    };

    /**
     * Helper to mount the fusionComponentContent of all FusionComponents,
     * @param {Array<MPageComponent>} - Array of MPageComponents
     */

    var _prepareFusionComponentContent = function (components) {     //  eslint-disable-line no-underscore-dangle
        components.filter(function (component) {
            return component.isFusionComponent && component.isDisplayable();
        }).forEach(function (component) {
            //  Mount and render the contents of the component.
            component.getFusionComponentContent()
                .mount(component.getStyles().getId())
                .update();

            //  Lifecycle function after mount.
            component.afterMount();
        });
    };

    /**
     * This function overrides the parent implementation and forces the components into a single column,
     * then gets the active components in Contextual View and creates a two column layout using all the columns and
     * the new array of contextual view components.
     *
     * @param {Array} components A list of components that we are rendering
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.renderComponents = function (components) {
        // Helper function that sorts the components in contextual view based on their sequence in contextual view.
        function sortMPageComponentInContextualView(c1, c2) {
            if (c1.getSequenceInContextualView() < c2.getSequenceInContextualView()) {
                return -1;
            }
            if (c1.getSequenceInContextualView() > c2.getSequenceInContextualView()) {
                return 1;
            }
            return 0;
        }

        if (!Array.prototype.isPrototypeOf(components) || !components || !components.length) {
            logger.logError("No components were provided to the renderComponents() method");
            return;
        }
        //  Workflows render into a single column but can appear in a two-column layout due to contextual view.
        this.forceComponentsIntoSingleColumn(components);
        this.storeViewComponents(components);

        var componentGroupArray = MP_Util.GetComponentArray(components); // eslint-disable-line new-cap
        //  Get the components in the contextual view by using the filterActiveComponentsInContextualView method.
        //  Storing this array at the view level it will be used during resize.
        //  Sort the components by the sequence in contextual view.
        this.m_componentsInContextualView = this.filterActiveComponentsInContextualView()
            .sort(sortMPageComponentInContextualView);
        if (this.m_componentsInContextualView.length && this.canHaveContextualView()) {
            //  Use the array returned as the second array in the two dimensional column array to be used in two column
            //  layout.
            componentGroupArray[0].push(this.m_componentsInContextualView);
            this.m_isContextualViewActive = true;
        }
        var container = this.getContainer();
        var columns = componentGroupArray[0];

        //  If we have no columns, there is no point in rendering anything else
        if (!columns) {
            return;
        }

        if (this.isContextualViewActive()) {
            container.addClass("is-contextual-view-open");
        }

        //  Render the layout
        container.append(_renderLayout(
            columns,
            this.getCategoryMean(),
            this.canHaveContextualView(),
            this.createNewRenderStrategy.bind(this)
        ));

        //  Attaches the first column to be scrollable by the root control
        this.m_rootControl.setComponentScrollingContainer($(container).addBack().find("[data-contextual-view='false']").find(".mpageui-Components"));

        //  Prepare contextual view
        _finalizeContextualView(
            columns[0],
            this.canHaveContextualView(),
            this.handleContextualViewControlFunction.bind(this)
        );

        //  Prepare the DetailPanel adapter
        _prepareDetailPanel(this.dangerouslyGetRootControl(), this.getCategoryMean());
        // By now all the placeholders for FusionComponents have been added to the DOM by the fusion render stategy.
        //  Use the placeholders for all the FusionComponents to mount their FusionComponentContents.
        _prepareFusionComponentContent(components);
    };
    /**
     * Function to get the container of the column in the View
     * @param {number} colNum The column number whose container we would like to retrieve
     * @returns {jQuery} The jQuery object representing the column container in the View.
     **/
    WorkflowMPage.prototype.getColumnContainer = function (colNum) {
        return $("#" + this.getCategoryMean()).find(".col" + colNum);
    };

    WorkflowMPage.prototype.postProcessRenderStrategies = function () {
        this.getComponents()
            .filter(function (comp) {
                //  components without a render strategy were not initialized on the current view
                return comp.getRenderStrategy() !== undefined && comp.getRenderStrategy() !== null;
            })
            .forEach(function (comp) {
                if (comp.getRenderStrategy().postProcessing) {
                    comp.getRenderStrategy().setRootControl(this.m_rootControl);
                    comp.getRenderStrategy().postProcessing();
                }
            }.bind(this));
    };

    /**
     * This will need to be handled in this object since a lot of extraneous stuff will be stripped out.
     * It would get components added to contextual view in the previous session and load them all.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.renderView = function () {
        var component = null;
        var componentsArr = this.getComponents();
        var componentsCnt = componentsArr ? componentsArr.length : 0;
        var componentMenu = null;
        var menuItems = null;
        var x = 0;
        var contextualViewControl = null;   //  eslint-disable-line no-unused-vars

        // Create the aggregate timer object to measure page load time
        var aggregateTimer = this.createAggregateTimer();
        //  Mark the timer as started because it is already started either in the driver script or in ViewPoint before the
        //  view is initialized.
        aggregateTimer.markTimerStarted();
        this.setAggregateTimer(aggregateTimer);

        // Store the container, so we can easily access it later
        this.setContainer($("#" + this.getCategoryMean()));

        // Render the components in the layout using the render strategy
        this.renderComponents(componentsArr);

        this.postProcessRenderStrategies();

        // check if the current view can have contextual view and show it accordingly
        var viewpointState = $("#" + this.getCategoryMean());
        var $contextualViewControls = viewpointState.find(".hdr-contextual-view-control-container");
        if (!this.canHaveContextualView()) {
            $contextualViewControls.hide();
        }
        // Get the second column in the view, If it exists then set the height of the column to the height of the parent.
        var contextualViewColumn = this.getColumnContainer(2);
        if (contextualViewColumn.length) {
            contextualViewColumn.height(this.getContainer().parent().height());
        }
        // Additional page setup
        MP_Util.Doc.SetupCompFilters(componentsArr); // eslint-disable-line new-cap

        // Load the components and add the click events to the component menus
        function createMenuClickEvent(compObj) {
            return function () {
                MP_MenuManager.showMenu("mainCompMenu" + compObj.getStyles().getId());
            };
        }

        // the number of all displayable components
        var initialComponentCount = 0;

        /* Load the components that should be displayed within this MPages View*/
        // Check the selective component loading flag to see if we should allow the components to retrieve their data
        var renderAllComponents = !this.selectivelyLoadComponents();
        for (x = 0; x < componentsCnt; x++) {
            component = componentsArr[x];
            if (component.isDisplayable() && !component.isLoaded()) {
                // Update the click event on the menu to launch this menu when clicked now that the component shells are
                //  rendered
                componentMenu = component.getMenu();
                if (componentMenu && Menu.prototype.isPrototypeOf(componentMenu)) {
                    menuItems = componentMenu.getMenuItemArray();
                    // Check to see if any menu items have been added to the main component menu
                    if ((!menuItems || !menuItems.length) && component.getStyles().getId().indexOf("cust") !== 0) {
                        // Disable the menu for this component and unbind all click events
                        $("#" + componentMenu.getAnchorElementId()).addClass("opts-menu-empty").unbind("click");
                    }
                    else {
                        // Add the click event to the menu anchor
                        $("#" + componentMenu.getAnchorElementId()).unbind("click").click(createMenuClickEvent(component));
                    }
                }
                // Check to see if we should load all components or skip the loading based on the selective component
                //  loading flag
                if (renderAllComponents) {
                    component.setLoaded(true);
                    //  register the component in the aggregate timer before data retrieval begins
                    aggregateTimer.registerTask(component.getStyles()
                        .getId());
                    //  pass the reference of the aggregate timer to the component, so it will notify the timer when it
                    //  finishes loading
                    component.setAggregateTimer(aggregateTimer);

                    // Increment the component count because it will start loading, and it be used for the AggregateTimer
                    //  meta data
                    initialComponentCount++;

                    component.startComponentDataRetrieval();
                }
                else if (component.isAddedToContextualView() && this.canHaveContextualView()) {
                    // For all the components in contextual view call startComponentDataRetrieval and reset the count in the
                    //  navigator.
                    component.setLoaded(true);
                    component.startComponentDataRetrieval();
                    CERN_EventListener.fireEvent(component, component, EventListener.EVENT_COUNT_UPDATE, {
                        count: null
                    });
                }
                // If the component is Contextual View compatible, get the control of the component for the contextual view,
                // set the callback for the control and attach the events.
                if (component.isContextualViewCompatible()) {
                    component.toggleContextualView = this.handleContextualViewControlFunction(component);
                }
                //  Add banners to let the users know about non-responsiveness of the components.
                if (!component.isFusionComponent && !CERN_Platform.inMillenniumContext()) {
                    var bannerDisplayMode = MPageUI.Fusion.composite.banner.BannerItem.DISPLAYMODE.COMPACT;
                    //  create a new alert banner and mount it on the element created for medium screens.
                    var nonResponsiveBanner = new MPageUI.Fusion.composite.banner.BannerItem();
                    nonResponsiveBanner.setProp("title", i18n.NON_RESPONSIVE_TITLE);
                    nonResponsiveBanner.setProp("description", i18n.NON_RESPONSIVE_DESC);
                    nonResponsiveBanner.setProp("moreDetailText", i18n.NON_RESPONSIVE_DETAIL);
                    nonResponsiveBanner.setProp("displayMode", bannerDisplayMode);
                    nonResponsiveBanner.setProp("enableDismissClick", false);
                    nonResponsiveBanner.mount("non-responsive-banner" + component.getStyles().getId()).update();

                    //  create a new alert banner and mount it on the element created for medium screens.
                    var nonResponsiveBannerSmall = new MPageUI.Fusion.composite.banner.BannerItem();
                    nonResponsiveBannerSmall.setProp("title", i18n.COMPONENT_HIDDEN_TITLE);
                    nonResponsiveBannerSmall.setProp("description", i18n.COMPONENT_HIDDEN_DESC);
                    nonResponsiveBannerSmall.setProp("moreDetailText", i18n.COMPONENT_HIDDEN_DETAIL);
                    nonResponsiveBannerSmall.setProp("displayMode", bannerDisplayMode);
                    nonResponsiveBannerSmall.setProp("enableDismissClick", false);
                    nonResponsiveBannerSmall.mount("non-responsive-banner-sm" + component.getStyles().getId()).update();
                }
            }
        }

        if (renderAllComponents) {
            // add the number of components to meta data
            aggregateTimer.addMetaData("component.count", componentsCnt);

            // add the number of initially loaded components to meta data (all components are loaded in initial load)
            aggregateTimer.addMetaData("component.initialLoadCount", initialComponentCount);

            //  Lock the registration when initial loading components are registered.
            aggregateTimer.lockRegistration();
        }

    };

    /**
     * This function is used to handle the window.resize events that are fired when the browser window is resized.  The
     * NavigatorSubsectionSummaryMPage overwrites the base class functionality since we may be selectively loading
     * components.  The base class functionality tells all displayable components to render, but based on selective
     * component loading we may have not loaded all of our components yet.  Therefore we only resize the components which
     * have already been loaded.
     * @returns {undefined} This function does not return a value
     */
    WorkflowMPage.prototype.resizeView = function () {
        var viewpointState = $("#" + this.getCategoryMean());
        var $contextualViewControls = viewpointState.find(".hdr-contextual-view-control-container");
        var contextualViewComponents = this.getComponentsInContextualViewArray();
        var self = this;
        var componentColumn = this.getColumnContainer(1);
        var contextualColumn = null;
        var vwpContainerHeight = $("#" + this.getParentWorkflowIdentifier()).height();
        // Resize the column
        componentColumn.height(vwpContainerHeight);
        // Resize the height of the second column if it is active.
        if (this.m_isContextualViewActive) {
            contextualColumn = this.getColumnContainer(2);
            contextualColumn.height(vwpContainerHeight);
        }

        /**
         * Helper function that calls the moveComponentBetweenViews function for all the components in contextual view.
         * @returns {undefined} This function does not return a value
         */
        function moveComponents() {
            for (var c = 0; c < contextualViewComponents.length; c++) {
                var comp = contextualViewComponents[c];
                self.moveComponentBetweenViews(comp);

            }
        }

        /**
         * Triggers the contextual view toggle on all contextual view components.
         * @returns {undefined}
         */
        function toggleComponents() {
            for (var c = 0; c < contextualViewComponents.length; c++) {
                var comp = contextualViewComponents[c];
                comp.toggledFromContextualView();
            }
        }

        // If the window width meets the criteria to have contextual view, update the commponent
        // to display the control for all components and change the layout to two column view if we have any component in
        //  contextual view. Else hide all those controls change the layout to single column.
        if (this.canHaveContextualView()) {
            $contextualViewControls.show();
            // If there were any components prior in contextual view prior to resize to a smaller view and if contextual
            //  view not already active change the layout to two column view and display the contextual view components by
            //  calling the moveComponents method.
            if (contextualViewComponents.length && !this.m_isContextualViewActive) {
                this.changeLayout(2);
                moveComponents();
                this.m_isContextualViewActive = true;
                toggleComponents();
            }
        }
        else if (!this.canHaveContextualView()) {
            // If the view is not wide enough for contextual view to fit in, hide all the controls for contextual view.
            // Change to single column layout only if the contextual view is active currently.
            $contextualViewControls.hide();
            if (contextualViewComponents.length && this.m_isContextualViewActive) {
                moveComponents();
                this.changeLayout(1);
                toggleComponents();
            }

        }
        // Call the resizeComponents function
        this.resizeComponents();
    };

    /**
     * This function will call the resizeComponent function on all the components that are currently displayed
     * and loaded.
     * @returns {undefined} This function does not return a value
     **/
    WorkflowMPage.prototype.resizeComponents = function () {
        // Resize all the components after the columns containing them have resized.
        var compObj = null;
        var components = this.getComponents();
        for (var x = components.length; x--;) {
            compObj = components[x];
            if (compObj.isDisplayable() && compObj.isLoaded()) {
                compObj.resizeComponent();
            }
        }
    };

    /**
     * This function will create the component selection menu object for the workflow page menu.  It will
     * examine the toggle status of each component and mark it appropriately.  All user interactions for the
     * component selection menu are also defined within this function.
     * @returns {Menu} The Menu object that will be used within the page menu
     **/
    WorkflowMPage.prototype.loadComponentSelection = function () {
        var self = this;
        var addMenu = false;
        var component = null;
        var componentArr = null;
        var componentCnt = 0;
        var componentToggled = false;
        var compSelMenu = null;
        var menuItem = null;
        var toggleStatus = 0;
        var x = 0;

        /**
         * Returns an Array index of a Component by ID.
         * @param {number} componentId Unique Identification number of a Component.
         * @returns {number} index of a Component
         */
        var findIndexOfByComponentId = function (componentId) {
            return componentArr.findIndex(function (componentObj) {
                return componentObj.getComponentId() === componentId || false;
            });
        };

        /**
         * This function is used to reset the toggle status of each component in the current view.
         * @returns {undefined} does not return any value.
         */
        var resetToggledComponentsState = function () {
            var categoryMean = this.getCriterion().category_mean;
            var summarySubsection = this;
            MP_Core.AppUserPreferenceManager.GetPreferences(categoryMean).then( //  eslint-disable-line new-cap
                function (pageLevelPrefs) {
                    /**
                     * updates the Component Menu selection item's toggle state to previous.
                     * @param {number} componentId component's unique ID.
                     * @param {number} toggleStatus 1: to display the component, 0: not to display.
                     * @returns {undefined} does not return any value.
                     */
                    function resetComponentSelectionState(componentId, toggleStatus) {//  eslint-disable-line no-shadow
                        var pageMenu = MP_MenuManager.getMenuObject("pageMenu" + categoryMean);
                        var componentSelectionMenuItems = pageMenu.getMenuItemArray()[0].getMenuItemArray();
                        //  loop through all the component menu items and toggle selection state to previous state.
                        componentSelectionMenuItems.forEach(function (componentObj) {
                            if (!componentObj.isDisabled() && (parseInt(componentObj.getId(), 10) === componentId)) {
                                componentObj.setIsSelected(!!toggleStatus);
                            }
                        });
                        MP_MenuManager.updateMenuObject(pageMenu);
                        componentToggled = false;
                    }
                    //  get the user preferences if available and update the components toggle status to the previous state.
                    if (pageLevelPrefs && pageLevelPrefs.user_prefs.page_prefs.components.length) {
                        pageLevelPrefs.user_prefs
                            .page_prefs
                            .components
                            .forEach(function (componentObj) {
                                var indexOfComponent = findIndexOfByComponentId(componentObj.id);
                                if (indexOfComponent !== -1) {
                                    componentArr[indexOfComponent].setToggleStatus(componentObj.toggleStatus);
                                    resetComponentSelectionState(componentArr[indexOfComponent].getComponentId(), componentObj.toggleStatus);
                                }
                            });
                    }
                    else {
                        //  else get the original component list copy and update the component selection status to previous state.
                        var components = summarySubsection.getComponents().slice(0);
                        components.forEach(function (componentObj) {
                            resetComponentSelectionState(componentObj.getComponentId(), componentObj.getToggleStatus());
                        });
                    }
                }
            );
        };

        /**
         * Updates the User Preferences and refreshes the Active View.
         * @returns {undefined} does not return any value.
         */
        var refreshView = function () {
            // Show the cursor as busy
            $("body").css("cursor", "wait");
            // This call is used to update all of the component's settings before refreshing the page.
            MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(componentArr) // eslint-disable-line new-cap
                .then(function () {
                    // Refresh the active view when we'll do soft refresh.
                    MP_Viewpoint.refreshActiveView();
                    // Show the cursor as default after refreshing the active view.
                    $("body").css("cursor", "default");
                    componentToggled = false;
                });
        };

        /**
         * rejects to refresh the active view
         * @returns{undefined} does not return any value
         */
        var rejectRefreshView = function () {
            //  reset the Components toggle status in order to
            //  revert to the previous View level Menu's component list state.
            resetToggledComponentsState.bind(this)();
        };

        // This function is used to sort the available component in alphabetical order based on the component Label
        var componentSort = function (a, b) {
            var aName = a.getLabel().toUpperCase();
            var bName = b.getLabel().toUpperCase();
            if (aName < bName) {
                return -1;
            }
            else if (aName > bName) {
                return 1;
            }
            else {
                return 0;
            }
        };

        // This function is used to toggle the component on/off and make the necessary updates to all of the component
        //  sequences
        var toggleComponent = function (componentId, activateComp) {
            // 1 - on, 0 - off
            var toggleStat = activateComp ? 1 : 0;
            // Set the toggle status for the component selected from the component selection menu
            // Locate the component we are toggling and updates its location
            var toggleComp = componentArr.find(function (comp) {
                return comp.getComponentId() === componentId;
            });
            if (!toggleComp) {
                logger.logWarning("No component to toggle matching " + componentId);
                return;
            }
            toggleComp.setToggleStatus(toggleStat);
            if (activateComp) {
                // Add the component as the first component in the left most column
                // If the component is an organizer level component, column 99, do not update the column
                if (toggleComp.getColumn() !== 99) {
                    toggleComp.setColumn(1);
                }
                toggleComp.setSequence(0);
                // Check to see if user preferences exist and if not create the blank object
                MP_Core.AppUserPreferenceManager.GetPreferences(toggleComp.criterion.category_mean).then( // eslint-disable-line new-cap
                    function (preferences) {
                        if (!preferences) {
                            MP_Core.AppUserPreferenceManager.SetPreferences("{\"user_prefs\":{\"page_prefs\":{\"components\":[]}}}", toggleComp.criterion.category_mean); // eslint-disable-line new-cap
                        }
                        // Update the sequences/rows for all of the components in the same colgroup and column as the toggled component.
                        var pageGroupSeq = toggleComp.getPageGroupSequence();
                        componentArr.forEach(function (comp) {
                            // Move all of the other components in the first column down one row
                            if (comp.getColumn() === 1 && comp.getPageGroupSequence() === pageGroupSeq && comp !== toggleComp) {
                                comp.setSequence(comp.getSequence() + 1);
                            }
                        });
                    }
                );
            }
        };

        // This function is used when an element is selected in the component selection menu.
        var createSelectionFunc = function (menuItemObj) {
            return function () {
                componentToggled = true;
                var menuItemId = menuItemObj.getId();
                var parsedId = parseFloat(menuItemObj.getId(), 10);
                // There are certain scenarios where the component Id has an alpha identifier appended to it in order to
                //  ensure uniqueness.  Hence we must utilize == to see whether the parsed ID is equivalent to the string
                //  version and take the appropriate action so that we can properly match the selected component based on
                //  the id.
                if (parsedId == menuItemId) { // eslint-disable-line eqeqeq
                    toggleComponent(parsedId, menuItemObj.isSelected());
                }
                else {
                    toggleComponent(menuItemId, menuItemObj.isSelected());
                }

            };
        };


        // Create a local copy of the component array since we are reordering the component by label
        componentArr = this.getComponents().slice(0);
        componentCnt = componentArr.length;
        // Check to see if any of the components are available for toggle.
        for (x = componentCnt; x--;) {
            component = componentArr[x];
            toggleStatus = component.getToggleStatus();
            if (toggleStatus !== 2 && !component.isComponentFiltered()) {
                addMenu = true;
                break;
            }
        }
        // Return if all components are required.  No need for a menu option.
        if (!addMenu) {
            return null;
        }

        // Create the menu
        compSelMenu = new Menu("compSelection" + this.getCategoryMean());
        compSelMenu.setLabel(i18n.COMPONENTS);
        compSelMenu.setIsRootMenu(false);
        compSelMenu.setAnchorConnectionCorner(["top", "left"]);
        compSelMenu.setContentConnectionCorner(["top", "right"]);

        // Sort the components by name
        componentArr.sort(componentSort);
        // Add all of the component selection items to the menu
        for (x = 0; x < componentCnt; x++) {
            component = componentArr[x];
            if (!component.isComponentFiltered()) {
                // Create the MenuSelector item for this component
                menuItem = new MenuSelection(component.getComponentId().toString());
                menuItem.setCloseOnClick(false);

                // Add the HTML for the element and the click event if it can be toggled
                // lock the required components in the menu so that they cannot be removed from the view
                if (component.getRequiredInd()) {
                    menuItem.setLabel(component.getLabel() + " (" + i18n.LOCKED + ")");
                    menuItem.setIsDisabled(true);
                    menuItem.setIsSelected(true);
                }
                else {
                    menuItem.setLabel(component.getLabel());
                    menuItem.setIsSelected(component.getToggleStatus() === 1);
                    menuItem.setClickFunction(createSelectionFunc(menuItem));
                }
                compSelMenu.addMenuItem(menuItem);
            }
        }

        // Add the close menu function so the preferences are saved if the user toggles a component
        compSelMenu.setCloseFunction(function () {
            if (componentToggled) {
                MP_PendingData.launchPendingDataDialog(
                    MP_PendingData.requestLevel.VIEW,
                    refreshView,
                    null,
                    MP_Viewpoint.getActiveViewId(),
                    rejectRefreshView.bind(self)
                );
            }
        });

        return compSelMenu;
    };

    WorkflowMPage.prototype.componentOrderChanged = function () {
        this.m_rootControl.componentOrderChanged();
    };

    return WorkflowMPage;
})();
/* globals CERN_driver_mean, MPageUI, NavigatorSubsectionSummaryMPage, SummaryRenderStrategy CERN_COMPONENT_TYPE_SUMMARY*/
/**
 * A constructor used to create a new NavigatorSubsectionSummaryMPage object and initialize page level variables.
 * The implementation is wrapped in an anonymous function to allow private functions.
 * @constructor
 */
var ComponentContainer = (function() { // eslint-disable-line no-unused-vars
    var ComponentContainerShell = function() {
        /**
         * This element is used to control various flex options of the content within the
         * component container.  The values below are tue current uses
         * 0x01 = Hide the component headers/shell (only works for Workflow Components)
         * 0x02 = Unused
         * 0x04 = Unused
         * 0x08 = Unused
         * etc...
         */
        this.configOptionsBitmask = 0;

        // This flag determines whether or not to hide or show the shell of the component
        this.hideComponentShell = false;

        // Make sure all components are rendered when the page loads
        this.m_selectiveComponentLoadInd = false;

        // Flag to help us identify if we are loading workflow components or not
        this.loadingWorkflowComponents = false;
    };

    ComponentContainerShell.prototype = new NavigatorSubsectionSummaryMPage();
    ComponentContainerShell.prototype.constructor = NavigatorSubsectionSummaryMPage;

    /**
     * This function is used to selectively create the render strategy we would like to
     * utilize based on the components being rendered in the shell
     * @returns {RenderStrategy} An implementation of a RenderStrategy object
     */
    ComponentContainerShell.prototype.createNewRenderStrategy = function() {
        // Need to determine the types of components being dealt with
        if(this.loadingWorkflowComponents) {
            return new MPageUI.LegacyAdapter.MPageUIRenderStrategy();
        }
        else {
            return new SummaryRenderStrategy();
        }
    };

    /**
     * Since the parent is expecting to get the parent workflow id (category mean) we will
     * just provide it directly here.
     * @returns {string} The category mean of the 'workflow' which in our case is just the
     * category mean of the ComponentContainer.
     */
    ComponentContainerShell.prototype.getParentWorkflowIdentifier = function() {
        return this.getCategoryMean();
    };

    /**
     * This function is being overwritten to allow consumers of this MPagesView to optionally pass
     * in settings rather than having to modify the global object where settings are parsed from.
     * @returns {boolean} True if the view settings were retrieved and parsed correctly
     */
    ComponentContainerShell.prototype.getViewSettingsObject = function(){
        // If the view settings have already been provided we can just return those setttings
        var settings = this.getViewSettings();
        if(settings){
            return settings;
        }

        // Since settings are not already available, allow the base MPages View to grab them from the global
        return MPageView.prototype.getViewSettingsObject.call(this);
    };

    /**
     * This function is used to control specific component options when rendering
     * @returns {undefined} This function does not return a value.
     */
    ComponentContainerShell.prototype.initializeComponents = function() {
        // Allow the parent to initialize the component
        NavigatorSubsectionSummaryMPage.prototype.initializeComponents.call(this);

        // For each component, if it is a Fusion component, hide the header
        var components = this.getComponents();
        var component;
        for(var x = components.length; x--; ){
            component = components[x];
            // If we are dealing with Workflow components this is where we need to hide the component header
            if(this.loadingWorkflowComponents){
                if(component.isFusionComponent){
                    if (this.hideComponentShell || component.alwaysHideHeader()) {
                        component.setHeaderShown(false);
                    }
                }
                // Hiding of the non-fusion workflow component header will happen in the
                // ComponentContainerShell.prototype.postProcessRenderStrategies function
            }
            else{
                // We need to allow the non-workflow components to expand and collapse
                component.setAlwaysExpanded(false);
                // We need to set component type to CERN_COMPONENT_TYPE_SUMMARY for non-workflow components
                component.getStyles().setComponentType(CERN_COMPONENT_TYPE_SUMMARY);
            }
        }
    };

    /**
     * Here we are overriding the functionality of the NaviagtorSubsectionSummaryMPage with
     * the base MPagesView settings retrieval.  In addition we are determining if we are loading
     * workflow components or not.
     * @returns {undefined} This function does not return a value.
     */
    ComponentContainerShell.prototype.loadViewSettings = function(){
        MPageView.prototype.loadViewSettings.call(this);

        // Determine what type of components we are loading and take specific actions based on
        // what we find
        if(this.getViewType() === "WF_STD"){
            // This is a standard Workflow view so we are loading workflow components
            this.loadingWorkflowComponents = true;
            logger.logWarning("Rendering Workflow Components");
        }
        else if(this.getViewType() === "SUM_STD"){
            // This is a standard Summary view so we are loading summary components
            this.loadingWorkflowComponents = false;
            logger.logWarning("Rendering Summary Components");
        }
        else {
            logger.logWarning("Attempting to identify if WF components are present");
            // We can't easily identify the view type so we must examine the components.  Any component prefixed with "WF_"
            // will be a workflow component.
            var viewSettings = this.getViewSettings();
            var components = viewSettings.BR_SET.CS;
            for(var x = components.length; x--; ){
                // Check to see if the componetns filter mean matches our WF regex
                if(/^WF_/.test(components[x].F_MN.toUpperCase())){
                    logger.logWarning("WF components are present");
                    this.loadingWorkflowComponents = true;
                    break;
                }
            }
        }
    };


    ComponentContainerShell.prototype.postProcessRenderStrategies = function(){
        this.getComponents()
            .forEach(function(comp) {
                var renderStrategy = comp.getRenderStrategy();
                if (!renderStrategy || !renderStrategy.postProcessing) {
                    return;
                }

                // This is where the header for the non-fusion workflow components will be hidden or shown
                if (!(this.hideComponentShell || comp.alwaysHideHeader())) {
                    renderStrategy.setRootControl(this.m_rootControl);
                    renderStrategy.postProcessing();
                }
            }.bind(this));
    };

    /**
     * This function will handle the actual rendering of the view depending on what type
     * of view is being loaded.
     * @returns {undefined} This function does not return a value.
     */
    ComponentContainerShell.prototype.renderView = function(){
        NavigatorSubsectionSummaryMPage.prototype.renderView.call(this);

        if(this.loadingWorkflowComponents){
            // Add specialized classes to the parent container for styling purposes
            $("#" + this.getCategoryMean()).addClass("wf");
        }
        else {
            // Call some additional setup which will render the components expand collapse, menu and filters
            MP_Util.Doc.SetupExpandCollapse(this.getCategoryMean()); // eslint-disable-line new-cap
            MP_Util.Doc.SetupCompFilters(this.getComponents());
            MP_Util.Doc.CreateCompMenus(this.getComponents(), false); // eslint-disable-line new-cap
        }
    };

    /**
     * This function is used to set the options bitmask and in turn set the individual
     * flags that control the options of the component container
     * @param {number} options The bumerical bitmask which controls individual options
     * @returns {undefined} This function does not return a value.
     */
    ComponentContainerShell.prototype.setOptionsBitmask = function(options){
        // Save off the configuration options that have been passed to the view.
        this.configOptionsBitmask = options;
        this.hideComponentShell = (this.configOptionsBitmask & 0x01) === 1;
    };

    /**
     * Override the ability to turn selective loading on.  We always want to laod all components.
     * @returns {undefined} This function does not return a value.
     */
    ComponentContainerShell.prototype.setSelectiveComponentLoadInd = function() {
        // Do nothing, we want all components to load always.
    };

    return ComponentContainerShell;
})();

/**
 * A constructor used to create a new ViewBuilderMPage object and initialize page level variables.
 * @constructor
 */
var ViewBuilderMPage = function() { // eslint-disable-line no-redeclare
	//Log info for debugger
    logger.logMessage("Rendering View Builder MPages View");

	//Set page level information
    this.setName("MPages View");
};
/**
 * Setup the prototype and constructor to inherit from the base MPagesView
 */
ViewBuilderMPage.prototype = new MPageView();
ViewBuilderMPage.prototype.constructor = MPageView;

/**
 * This function will call the base class initializeComponent, so that all the components are initialized correctly.  Once that
 * returns the components which have a toggleStatus of 0 (off), are set to not display in the MPageView.
 * @returns {undefined} This function does not return a value
 */
ViewBuilderMPage.prototype.initializeComponents = function() {
    var component = null;
    var componentArr = null;
    var componentCnt = 0;
    var x = 0;

    //Call the base function to initialize the components.
    MPageView.prototype.initializeComponents.call(this, null);

    //Filter out the components based on the component toggle settings.
    componentArr = this.getComponents();
    componentCnt = componentArr.length;
    for (x = componentCnt; x--;) {
        component = componentArr[x];
        if (component.getToggleStatus() === 0) {
            component.setDisplayEnabled(false);
        }
    }
};
/**
 * Implementation for loading the component selection menu.  Components with a toggle status of 0(off) or 1(on) will
 * be added to the component selection menu.
 * @returns {Menu} The Menu item created for the component selection menu
 */
ViewBuilderMPage.prototype.loadComponentSelection = function() {
    var addMenu = false;
    var component = null;
    var componentArr = null;
    var componentCnt = 0;
    var componentToggled = false;
    var compSelMenu = null;
    var menuItem = null;
    var toggleStatus = 0;
    var x = 0;

    //This function is used to sort the available component in alphabetical order based on the component Label
    var componentSort = function(a, b) {
        var aName = a.getLabel().toUpperCase();
        var bName = b.getLabel().toUpperCase();
        if (aName < bName) {
            return -1;
        }
        else if (aName > bName) {
            return 1;
        }
        else {
            return 0;
        }
    };

    //This function is used to toggle the component on/off and make the necessary updates to all of the component sequences
    var toggleComponent = function(componentId, activateComp) {
        var pageGroupSeq = null;
        //1 - on, 0 - off
        toggleStatus = activateComp ? 1 : 0;
        //Set the toggle status for the component selected from the component selection menu
        //Locate the component we are toggling and updates its location
        var toggleComp = componentArr.find(function(comp){
            return comp.getComponentId() === componentId;
        });
        if (!toggleComp) {
            logger.logWarning("No component to toggle matching " + componentId);
            return;
        }
        toggleComp.setToggleStatus(toggleStatus);
        if (activateComp) {
            //Add the component as the first component in the left most column
            //If the component is an organizer level component, column 99, do not update the column
            if (toggleComp.getColumn() !== 99) {
                toggleComp.setColumn(1);
            }
            toggleComp.setSequence(0);
            MP_Core.AppUserPreferenceManager.GetPreferences(toggleComp.criterion.category_mean).then(
                function(preferences){
                    if (!preferences) {
                        MP_Core.AppUserPreferenceManager.SetPreferences('{"user_prefs":{"page_prefs":{"components":[]}}}', toggleComp.criterion.category_mean);
                    }
                    //Update the sequences/rows for all of the components in the same colgroup and column as the toggled component.
                    pageGroupSeq = toggleComp.getPageGroupSequence();
                    //Move all of the other components in the first column down one row
                    componentArr.forEach(function(comp){
                        if (comp.getColumn() === 1 && comp.getPageGroupSequence() === pageGroupSeq && comp !== toggleComp) {
                            comp.setSequence(comp.getSequence() + 1);
                        }
                    });
                }
            );
        }

    };

    //This function is used when an element is selected in the component selection menu.
    var createSelectionFunc = function(menuItemObj) {
        return function() {
            componentToggled = true;
            toggleComponent(parseFloat(menuItemObj.getId(), 10), menuItemObj.isSelected());
        };
    };

    //Check to see if any of the components are available for toggle.
    componentArr = this.getComponents();
    componentCnt = componentArr.length;
    for (x = componentCnt; x--;) {
        component = componentArr[x];
        toggleStatus = component.getToggleStatus();
        if (toggleStatus !== 2 && !component.isComponentFiltered()) {
            addMenu = true;
            break;
        }
    }
    //Return if all components are required.  No need for a menu option.
    if (!addMenu) {
        return null;
    }

    //Create the menu
    compSelMenu = new Menu("compSelection" + this.getCategoryMean());
    compSelMenu.setLabel(i18n.COMPONENTS);
    compSelMenu.setIsRootMenu(false);
    compSelMenu.setAnchorConnectionCorner([ "top", "left" ]);
    compSelMenu.setContentConnectionCorner([ "top", "right" ]);

    //Sort the components by name
    componentArr.sort(componentSort);
    //Add all of the component selection items to the menu
    for (x = 0; x < componentCnt; x++) {
        component = componentArr[x];
        if (!component.isComponentFiltered()) {
            toggleStatus = component.getToggleStatus();
            //Create the MenuSelector item for this component
            menuItem = new MenuSelection(component.getComponentId().toString());
            menuItem.setCloseOnClick(false);

            //Add the HTML for the element and the click event if it can be toggled
            if (toggleStatus === 2) {
                menuItem.setLabel(component.getLabel() + " (" + i18n.LOCKED + ")");
                menuItem.setIsDisabled(true);
                menuItem.setIsSelected(true);
            }
            else {
                menuItem.setLabel(component.getLabel());
                menuItem.setIsSelected(toggleStatus === 1 ? true : false);
                menuItem.setClickFunction(createSelectionFunc(menuItem));
            }
            compSelMenu.addMenuItem(menuItem);
        }
    }

    //Add the close menu function so the preferences are saved if the user toggles a component
    compSelMenu.setCloseFunction(function() {
        if (componentToggled) {
            //Show the cursor as busy
            $("body").css("cursor", "wait");

            //This call is used to update all of the component's settings before refreshing the page.
            MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(componentArr)
                .then(function(){
                    //Refresh the active view when we'll do soft refresh.
                    MP_Viewpoint.refreshActiveView();
                    //Show the cursor as default after refreshing the active view.
                    $("body").css("cursor", "default");
                    componentToggled = false;
                });
        }
    });

    return compSelMenu;
};

MP_Util.setObjectDefinitionMapping("SUM_STD", ViewBuilderMPage);
/* globals MenuItem, MenuSeparator, GapCheck, MPagesWeb, CapabilityTimer, XRPrint */

/**
 * The WorkflowView object
 * @constructor
 * @author Steven Lewis
 */
function WorkflowView() { // eslint-disable-line no-redeclare

    /* Variables */
    /* eslint-disable mp-camelcase */
    this.m_activeSubsection = null;
    this.m_navigatorSubsections = null;
    this.m_offsetPositionObj = null;
    this.m_$parentWorkflowContainer = null;
    this.m_$workflowContainer = null;
    this.m_$navContainer = null;
    this.m_$viewContainer = null;
    // This object stores that last view with an active view so that we can resize if necessary.
    this.m_lastActiveSubsectionWithView = null;
    this.m_isWebEnabled = true;
    this.m_xrPrintTemplates = null;
    /* eslint-enable mp-camelcase */
}

/* Inherit from the MPagesView object */
WorkflowView.prototype = new MPageView();
WorkflowView.prototype.constructor = MPageView;

/** Adders **/

/**
 * Adds a new NavigatorSubsection object to the listing of subsection objects.
 * @param {NavigatorSubsection} subsectionObj The NavigatorSubsection object to
 *     add to the array.
 * @returns {undefined} This function does not return a value
 **/
WorkflowView.prototype.addNavigatorSubsection = function(subsectionObj) {
    if(!this.m_navigatorSubsections) {
        this.m_navigatorSubsections = [];
    }
    this.m_navigatorSubsections.push(subsectionObj);
};

/**
 * This function is to scroll back to the actual offsets of the WorkflowView
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.applyOffsetPosition = function() {
    // Grab the currently active subsection and save its offset position
    var activeSubsection = this.getActiveSubsection();
    if(activeSubsection) {
        activeSubsection.applyViewOffsetPosition();
    }
};

/** Getters **/

/**
 * Gets the XR Printing indicator flag which determines if the MPage is intended to display "Create Report" menu item
 * @returns {Array}
 */
WorkflowView.prototype.getXRPrintTemplates = function() {
    if(!this.m_xrPrintTemplates){
        this.m_xrPrintTemplates = [];
    }
    return this.m_xrPrintTemplates;
};

/**
 * Gets the active NavigatorSubsection within the WorkflowView
 * @returns {NavigatorSubsection} The current active NavigatorSubsection
 */
WorkflowView.prototype.getActiveSubsection = function() {
    return this.m_activeSubsection;
};

/**
 * Returns the NavigatorSubsection object that should be loaded as the default
 * when this workflow is rendered. If there are no subsections, null will be
 * returned. Otherwise the cookie is read to return the previously active
 * subsection. If it wasn't found, the first subsection is returned as the
 * default.
 * @returns {NavigatorSubsection | null} The subsection that this workflow
 *     should render as a default.
 */
WorkflowView.prototype.getDefaultSubsection = function() {
    var savedSubsectionId = this.getSavedSubsectionIdFromCookie();
    var subsectionArr = this.m_navigatorSubsections;
    var subsectionCount = 0;
    var x = 0;
    if(subsectionArr && subsectionArr.length) {
        if(savedSubsectionId) {
            // Since we have a saved subsection look for it in our array of subsections
            subsectionCount = subsectionArr.length;
            for(x = 0; x < subsectionCount; x++) {
                if(subsectionArr[ x ].getSubsectionId() === savedSubsectionId) {
                    return subsectionArr[ x ];
                }
            }
        }

        // just return the first subsection if we dont have one stored for the session or it was removed
        return this.m_navigatorSubsections[ 0 ];
    }
    return null;
};

/**
 * Gets the array of NavigatorSubsection objects associated to this
 * WorkflowView.
 * @returns {NavigatorSubsection[]} An array of NavigatorSubsection objects
 */
WorkflowView.prototype.getNavigatorSubsections = function() {
    return this.m_navigatorSubsections;
};

/**
 * This function is to save the vertical scroll offsets of the currently active
 * subsection in the WorkflowView
 *  @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.saveOffsetPosition = function() {
    // Grab the currently active subsection and save its offset position
    var activeSubsection = this.getActiveSubsection();
    if(activeSubsection) {
        activeSubsection.saveViewOffsetPosition();
    }
};

/**
 * This function attempts to retrieve the last active subsection identifier
 * from the session cookie.
 * @returns {string} The last active subsection for this session or null
 */
WorkflowView.prototype.getSavedSubsectionIdFromCookie = function() {
    var criterion = this.getCriterion();
    var personId = criterion.person_id;
    var encounterId = criterion.encntr_id;
    return MP_Util.GetCookieProperty(this.getCategoryMean(), "LAST_ACTIVE_SUBSECTION|" + personId + "|" + encounterId); // eslint-disable-line new-cap
};

/** Setters **/

/**
 * Sets the flag which determines if the MPages is intended to display "Create Report" menu item
 * @param {Array} templates - A flag which determines if the Mpage is intended to display "Create Report" menu item
 * @returns {undefined}
 */
WorkflowView.prototype.setXRPrintTemplates = function(templates) {
    this.m_xrPrintTemplates = templates;
};

/**
 * This function saves the subsection id in a cookie so we can reactivate the
 * same subsection on reload.
 * @param {string} subsectionId The subsection object whose id we are storing.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.saveSubsectionIdInCookie = function(subsectionId) {
    var criterion = this.getCriterion();
    var personId = criterion.person_id;
    var encounterId = criterion.encntr_id;
    MP_Util.AddCookieProperty(this.getCategoryMean(), "LAST_ACTIVE_SUBSECTION|" + personId + "|" + encounterId, subsectionId); // eslint-disable-line new-cap
    MP_Util.WriteCookie(); // eslint-disable-line new-cap
};


/**
 * Sets the active NavigatorSubsection within the WorkflowView
 * @param {NavigatorSubsection} subsectionObj The navigatorSubsection object
 *     which is currently active
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.setActiveSubsection = function(subsectionObj) {
    this.m_activeSubsection = subsectionObj;
};

/**
 * Sets the array of NavigatorSubsection objects associated to this
 * WorkflowView.
 * @param {NavigatorSubsection[]} subsectionArr An array NavigatorSubsection
 *     objects to set for the WorkflowView.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.setNavigatorSubsections = function(subsectionArr) {
    this.m_navigatorSubsections = subsectionArr;
};

/** Workflow Setup Functions **/

/**
 * Creates and initializes the NavigatorSubsection objects which will be a part
 * of this Workflow View.  Once the subsections have been created they are
 * initialized with the associated settings and then the MPagesView which will
 * be associated with that subsection is created.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.initializeComponents = function() {
    var criterion = null;
    var subsectionArr = [];
    var subsectionCnt = 0;
    var subsection = null;
    var subsectionSettings = null;
    var viewSettings = this.getViewSettings();
    var x = 0;

    // Retrieve the subsection settings and criterion
    subsectionSettings = this.getComponentSettings(viewSettings);
    criterion = this.getCriterion();
    // Determine which subsections will be a part of this workflow and
    // instantiate them
    this.createNavigatorSubsectionObjects(viewSettings);
    subsectionArr = this.getNavigatorSubsections();
    subsectionCnt = subsectionArr.length;
    // Loop through each subsection and initialize it.
    for(x = 0; x < subsectionCnt; x++) {
        subsection = subsectionArr[ x ];
        // Initialize the subsections by passing all of the component settings
        // to the subsection.  The subsection will determine which components
        // to use.
        subsection.initializeSubsection(criterion);
        // Load the necessary MPageView settings for the subsection if needed
        if(subsection.hasAssociatedView()) {
            // Set the subsections view id so it can be used as the category
            // mean for the associated view
            subsection.setAssociatedViewElementId(this.getCategoryMean() + "_ssView_" + x);
            if(!subsectionSettings) {
                subsectionSettings = viewSettings;
            }
            subsection.createAssociatedMPageView(subsectionSettings);
        }
        // subsection will be rendered during the workflow loading
    }
};

/**
 * This function is to retrieve the component's view settings
 * @param {{}} viewSettings - Settings needed to render the components for the
 *     specified view
 * @returns {{} | null} viewSettings.BR_SET.CS if it exists, else null.
 */
WorkflowView.prototype.getComponentSettings = function(viewSettings) {
    if(viewSettings && viewSettings.BR_SET && viewSettings.BR_SET.CS.length) {
        // Retrieve the subsection settings and criterion
        return viewSettings.BR_SET.CS; // BR_SET is shorthand for Bedrock Settings and CS is shorthand for component settings
    }
    return null;
};

/**
 * Creates the overall HTML structure for the Workflow view.  Once the
 * structure has been created, HTML is created for each of the subsections
 * associated with this Workflow view.  Once all of the subsections have been
 * rendered, the active subsection is activated using the
 * WorkflowView.activeSubsection function.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.renderView = function() {
    /**
     * Opens the navigator element by adding the is-open class.
     * @param {jQuery} $navigator - The navigator element.
     * @returns {jQuery} The $navigator element.
     */
    var openNavigator = function($navigator) {
        return $navigator.addClass("is-open");
    };
    /**
     * Closes the navigator element by adding the is-open class.
     * @param {jQuery} $navigator - The navigator element.
     * @returns {jQuery} The $navigator element.
     */
    var closeNavigator = function($navigator) {
        return $navigator.removeClass("is-open");
    };
    /**
     * Toggles the open/closed state of the navigator element.
     * @param {jQuery} $navigator - The navigator jQuery element.
     * @returns {jQuery} The navigator element after opening or closing has
     * been applied.
     */
    var toggleNavigator = function($navigator) {
        return $navigator.toggleClass("is-open");
    };
    /**
     * Creates the navigator tab that can open the navigator. Note that it has
     * a single child element which will be styled as a chevron.
     * @param {jQuery} $navigator - The jQuery navigator element.
     * @returns {jQuery} The navigator tab element that was created.
     */
    var createNavigatorTab = function($navigator) {
        return $("<div class='mpageui-Navigator-tab'><div></div></div>")
            .on("mouseenter", function() {
                openNavigator($navigator);
            })
            .on("click", function() {
                toggleNavigator($navigator);
            });
    };
    /**
     * Creates the navigator pinning element. Note this currently uses fusion styles in order to maintain UI
     * consistency.
     * @returns {jQuery} The navigator pinning element.
     */
    var createNavigatorUtils = function() {
        return $(
            "<div class='mpageui-Navigator-utils'>" +
                "<button type='button' class='mpageui-Button mpageui-Button--link mpageui-Button--icon mpageui-Navigator-utils-pin mpageui-u-show-for-md'>" +
                    /* Pinned icon */
                    "<div title='" + i18n.discernabu.baseWorkflow.UNPIN_NAVIGATOR + "' aria-label='" + i18n.discernabu.baseWorkflow.UNPIN_NAVIGATOR + "' class='mpageui-Navigator-pin-icon--pinned' >" +
                        "<svg class='mpageui-SvgIcon' viewBox='0 0 48 48'>" +
                            "<path d='M35,29.9c0-3.8-1.6-7.4-4.4-10L30,19.4V6h2c1.1,0,2-0.9,2-2V2c0-1.1-0.9-2-2-2H16c-1.1,0-2,0.9-2,2v2c0,1.1,0.9,2,2,2h2v13.5L17.5,20c-2.8,2.6-4.5,6.2-4.5,10h9.5v18h3V30L35,29.9L35,29.9z' />" +
                        "</svg>" +
                    "</div>" +
                    /* Unpinned icon */
                    "<div title='" + i18n.discernabu.baseWorkflow.PIN_NAVIGATOR + "' aria-label='" + i18n.discernabu.baseWorkflow.PIN_NAVIGATOR + "' class='mpageui-Navigator-pin-icon--unpinned' >" +
                        "<svg class='mpageui-SvgIcon' viewBox='0 0 48 48'>" +
                            "<path d='M44,15.3L32.7,4c-0.8-0.8-2-0.8-2.8,0l-1.4,1.4c-0.8,0.8-0.8,2,0,2.8l1.4,1.4l-9.5,9.5l-0.7,0c-3.8-0.2-7.5,1.2-10.2,3.9l6.7,6.7L3.4,42.5l2.1,2.1l12.7-12.7l6.7,6.7l0,0c2.7-2.7,4.1-6.4,3.9-10.1l0-0.8l9.5-9.5l1.4,1.4c0.8,0.8,2,0.8,2.8,0l1.4-1.4C44.8,17.3,44.8,16.1,44,15.3z' />" +
                        "</svg>" +
                    "</div>" +
                "</button>" +
            "</div>"
        );
    };
    /**
     * Adds the navigator tab to the navigator element.
     * @param {jQuery} $navigator - The navigator jQuery element.
     * the navigator.
     * @returns {jQuery} The navigator element.
     */
    var addNavigatorTab = function($navigator) {
        return $navigator.append(
            createNavigatorTab($navigator)
        );
    };
    /**
     * Adds the navigator pin to the navigator element.
     * @param {jQuery} $navigator - The navigator jQuery element.
     * @returns {jQuery} The navigator element.
     */
    var addNavigatorUtils = function($navigator) {
        return $navigator.append(
            createNavigatorUtils()
        );
    };
    /**
     * Temporary fix for the case where the more notes context menu is
     * triggering the "mouseleave" event on the navigator. This function
     * checks to see if the mouse went into the more notes menu when leaving
     * the navigator.
     * @param {Event} event - The mouseleave JavaScript event.
     * @returns {boolean} True if the mouse entered the more-notes-context-menu
     * element or a descendent.
     */
    var didMouseIntoMoreNotes = function(event) {
        return (
            event &&
            event.relatedTarget &&
            ($(event.relatedTarget).closest(".more-notes-context-menu").length > 0)
        );
    };
    /**
     * Creates the navigator element with all events bound.
     * @param {string} categoryMean - The workflow category mean (used for
     * creating ids).
     * @returns {jQuery} The navigator jQuery element.
     */
    var createNavigator = function(categoryMean) {
        return addNavigatorTab(
            addNavigatorUtils(
                $("<div id='wrkflwNav_" + categoryMean + "' class='mpageui-Navigator'></div>")
                    .on("mouseleave", function(event) {
                        // Temporary fix, don't close the navigator if the mouse
                        //      left the navigator for the more notes menu.
                        if(didMouseIntoMoreNotes(event)) {
                            return;
                        }
                        closeNavigator($(this));
                    })
            )
        );
    };

    var bodyId = "";
    // this buffer is used for the height of the view elements so we dont run
    // into ceil/floor issues in different browsers
    var buffer = 2;
    var categoryMean = this.getCategoryMean();
    var containerHeight = 0;
    var headerId = "";
    var self = this;
    var subsection = null;
    var subsectionArr = null;
    var subsectionElement = null;
    var subsectionElementId = "";
    var subsectionCnt = 0;
    var workflowContainer = null;
    var workflowViews = null;
    var x = 0;

    // Check to see if this view is even valid in the current context.
    if(!this.isContextValid()) {
        // The current context is not valid for this view so we need to show a
        // context error message
        this.displayInvalidContextMessage();
        return;
    }

    // Navigator
    var mpageNavigator = createNavigator(categoryMean);
    var mpageNavigatorContents = $("<div class='mpageui-Navigator-contents'>");
    mpageNavigator.append(mpageNavigatorContents);
    this.m_$navContainer = mpageNavigatorContents; // eslint-disable line mp-camelcase

    // A function used to create onclick functions for the subsection dom
    // elements.
    function createActivationFunction(subsectionObj) {
        return function() {
            // Active the new subsection
            self.activateSubsection(subsectionObj);
        };
    }

    workflowContainer = this.m_$workflowContainer = $("#" + this.getCategoryMean()); // eslint-disable-line mp-camelcase
    this.m_$parentWorkflowContainer = this.m_$workflowContainer.parent(); // eslint-disable-line mp-camelcase

    // Create the three main workflow html containers
    workflowViews = this.m_$viewContainer = $("<div id='wrkflwViews_" + categoryMean + "' class='mpageui-Content wrkflw-views wf'></div>"); // eslint-disable-line mp-camelcase

    // Loop through the subsections and render the HTMl for each
    subsectionArr = this.getNavigatorSubsections();
    subsectionCnt = subsectionArr.length;
    for(x = 0; x < subsectionCnt; x++) {
        subsection = subsectionArr[ x ];

        // Create the Navigator subsection element for this subsection
        subsectionElementId = categoryMean + "_ssContainer_" + x;
        subsection.setSubsectionElementId(subsectionElementId);
        subsectionElement = $("<div></div>").addClass("wrkflw-nav-subsec").attr("id", subsectionElementId);

        // Check to see if the subsection should always be expanded
        if(subsection.isAlwaysExpanded()) {
            subsectionElement.addClass("wrkflw-nav-subsec-always-expanded");
        }

        // Attach the activation function for the subsection
        subsectionElement.click(createActivationFunction(subsection));
        if(subsection.hasHeaderElement()) {
            // Encapsulate the header html so we can apply a workflow level
            // styling to it
            headerId = categoryMean + "_ssHead_" + x;
            subsection.setHeaderElementId(headerId);
            $(subsectionElement).append($("<div></div>").addClass("navi-subsec-header").attr("id", headerId).append(subsection.generateHeaderHTML()));

        }
        if(subsection.hasBodyElement()) {
            // Encapsulate the body html so we can apply a workflow level
            // styling to it
            bodyId = categoryMean + "_ssBody_" + x;
            subsection.setBodyElementId(bodyId);
            subsectionElement.append($("<div></div>").addClass("navi-subsec-body").attr("id", bodyId).append(subsection.generateBodyHTML()));
        }
        mpageNavigatorContents.append(subsectionElement);
        // Create the subsection's associated MPageView element if necessary
        if(subsection.hasAssociatedView()) {
            var assocViewId = categoryMean + "_ssView_" + x;
            workflowViews.append($("<div></div>").addClass("wrkflw-view").attr("id", assocViewId));
            // Let the subsection know where the associated view is located in
            // the DOM
            subsection.setAssociatedViewElementId(assocViewId);
        }
    }
    // Combine all of the workflow elements and add to the DOM
    workflowContainer.append(mpageNavigator).append(workflowViews);

    // Resize the workflow containers to fit the available screen size before
    // rendering the first subsection Force the DOM to render so we know for
    // sure the size of the container will be ready for us to key off of
    containerHeight = this.m_$parentWorkflowContainer.height();
    workflowViews.height(containerHeight - buffer);

    // Determine which subsection is active and make the calls to render its
    // Associated MPagesView
    subsection = self.getDefaultSubsection();
    setTimeout(function() {
        self.activateSubsection(subsection);
    }, 10);
};

/**
 * This function is used to resize certain containers for the workflow layout
 * in order to achieve scrolling on only the associated view of the
 * subsections.  A buffer of 2px is removed from the calculations to prevent
 * ceiling and floor variances in different browser versions.  Once the
 * containers have been resized, the applyNavigatorScrolling function is called
 * to apply the scrolling effect there if needed.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.resizeView = function() {
    var activeSubsection = null;
    var containerHeight = 0;
    var self = this;
    // this buffer is used for the height of the view elements so we dont run
    // into ceil/floor issues in different browsers
    var buffer = 2;

    if(this.m_$parentWorkflowContainer && this.m_$viewContainer) {
        // Get WorkflowView container and its height
        containerHeight = this.m_$parentWorkflowContainer.height();
        this.m_$viewContainer.height(containerHeight - buffer);

        // Fire the resize function for the currently active subsection
        setTimeout(function() {
            try {
                activeSubsection = self.getActiveSubsection();
                if(!activeSubsection) {
                    return;
                }

                // Resize the currently active subsection
                activeSubsection.resizeSubsection();
                if(!activeSubsection.hasAssociatedView() && self.m_lastActiveSubsectionWithView) {
                    // Since the currently active subsection doesn't have a view, notify the active view of the resize
                    self.m_lastActiveSubsectionWithView.resizeSubsection();
                }
            }
            catch (err) {
                logger.logJSError(err, null, "base-workflow-def.js", "resizeView - resizeSubsection");
            }
        }, 10);
    }
};

/**
 * This function is used to handle any processing that needs to take place
 * after all the subsections have been rendered. It individually calls the
 * postProcessing functions of each of the subsection.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.postProcessing = function() {
    var subsection = null;
    var subsectionArr = this.getNavigatorSubsections();
    var subsectionCnt = subsectionArr.length;
    for(var x = 0; x < subsectionCnt; x++) {
        subsection = subsectionArr[ x ];
        subsection.postProcessing();
    }
};

/* eslint-disable no-unused-vars */
/**
 * Each workflow will be responsible for creating its own NavigatorSubsections.
 *  The loading of these Subsections is currently hard coded in each
 * WorkflowView object since there is no standard way of setting up workflows.
 * Once a standard way of setting up wizards is developed the loading of
 * subsection should be generalized and handled in this base class.
 * @param {object} workflowSettings The workflow settings object
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.createNavigatorSubsectionObjects = function(workflowSettings) {

};
/* eslint-enable no-unused-vars */

/**
 * Activates the subsection which should be shown to the user.  If the
 * subsection has an associated view it will replace the previously active
 * view.  This function is called either on mouse click or when the workflow is
 * first loaded.
 * It also calls initializeGapCheck to initilaize the gap-check shared resource if gap-check is required for
 * at least one component in the view.
 * @param {NavigatorSubsection} subsectionObj The NavigatorSubsection object
 *     that should be activated
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.activateSubsection = function(subsectionObj) {
    var activeSubsection = null;
    var associatedViewDiv = null;

    // Make sure there is a subsection to activate
    if(!subsectionObj) {
        return;
    }

    // Make sure we don't attempt to reactive the existing active subsection
    activeSubsection = this.getActiveSubsection();
    if(subsectionObj === activeSubsection) {
        return;
    }

    // Deactivate the curently active subsection if it is available
    if(activeSubsection) {
        // If there is an associated view with the active subsection save the
        // offset position so we can go back to its scroll offset when we
        // reactivate.  Also save it so we can resize its view if necessary
        if(activeSubsection.hasAssociatedView()) {
            activeSubsection.saveViewOffsetPosition();
            this.m_lastActiveSubsectionWithView = activeSubsection;
        }

        // If the new subsection has an associated view remove active classes
        // from all other subsection bodies and views
        if(subsectionObj.hasAssociatedView()) {
            // Hide whatever subsection was previously shown
            this.m_$navContainer.find(".ss-active").removeClass("ss-active");
            // Find the currently active view and hide it
            this.m_$viewContainer.find(".ss-view-active").removeClass("ss-view-active");
        }

        // Remove this subsection as the active subsection
        this.setActiveSubsection(null);
    }

    // Activate the newly selected subsection
    this.setActiveSubsection(subsectionObj);

    // Apply the active classes to this subsection element if it isnt already
    // shown
    if(!subsectionObj.isAlwaysExpanded()) {
        $("#" + subsectionObj.getSubsectionElementId()).addClass("ss-active");
    }

    // Apply the active classes the the associate view element if it is available
    // Determine if this subsection has an associated view to render
    if(subsectionObj.hasAssociatedView()) {

        // Save off the subsection id for the newly active subsection so we can
        // make it the default on page refresh We only do this for subsections
        // that have an associated view
        this.saveSubsectionIdInCookie(subsectionObj.getSubsectionId());

        associatedViewDiv = $("#" + subsectionObj.getAssociatedViewElementId());
        associatedViewDiv.addClass("ss-view-active");
        // Tell the subsection to render itself if it hasn't already done so
        if(!subsectionObj.isSubsectionRendered()) {
            subsectionObj.renderSubsection();
            if(this.m_navigatorSubsections && this.m_navigatorSubsections[ 0 ] && this.m_navigatorSubsections[ 0 ].isGapCheckRequired()) {
                this.initializeGapCheck();
            }
        }
        else {
            // View is already rendered so we need to reset it to its previous
            // offset position
            subsectionObj.applyViewOffsetPosition();
        }
        // Tell the subsection to activate its Workflow page menu items since
        // the menu items are flexed based on the active subsection
        this.loadWorkflowPageMenu();
    }
};

/**
 * Loads the default Workflow View level filter mappings.  These mappings can
 * be overwritten by using the WorkflowView.setFilterMappingObject() function
 * with the same filter name as any of the existing filter mappings.  Filter
 * mappings can also be overridden by defining a loadFilterMappings function in
 * a WorkflowView prototyped object.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.loadFilterMappings = function() {
    this.addFilterMappingObject("VIEWPOINT_LABEL", {
        setFunction: this.setName,
        type: "String",
        field: "FTXT"
    });
    // A filter mapping used to set the printable report name.
    // The filter mean for this setting is named PREG_PRINT but it is not
    // isolated to just the Pregnancy Summary.  It also applies to the View
    // Builder Workflow pages as well and is a setting to call a printable
    // Discern report.
    this.addFilterMappingObject("PREG_PRINT", {
        setFunction: this.setPrintableReportName,
        type: "String",
        field: "FTXT"
    });

    // A filter mapping used to determine if MPage will display "Create Report menu item
    this.addFilterMappingObject("XR_PRINTING_TEMPLATES", {
        setFunction: this.setXRPrintTemplates,
        type: "ARRAY",
        field: "PARENT_ENTITY_ID"
    });
};

/**
 * If the xr print bedrock filter is set for the MPage then add the Create Report menu option to the page menu
 * @returns {Object|null} Returns a menu item object if bedrock filter is set else returns null
 */
WorkflowView.prototype.loadXRPrintMenuItem = function() {
    var printMenuItem = null;
    var criterion = this.getCriterion();
    // check for the xr print bedrock filter
    if (this.getXRPrintTemplates() && this.getXRPrintTemplates().length) {
        // create a menu item that will be added to the page level menu
        printMenuItem = new MenuSelection("xrPrintMenu" + this.getCategoryMean());
        printMenuItem.setLabel(i18n.discernabu.CREATE_REPORT);
        printMenuItem.setClickFunction(function() {
            new CapabilityTimer("CAP:MPG.Create_report_open_modal", criterion.category_mean).capture();
            XRPrint.launchXRPrint(criterion);
        });
    }
    return printMenuItem;
};

/**
 * Initializes the page level menu that is shared across all subsections in the
 * WorkflowView object.  All subsection menu items are removed before loading a
 * new subsection within the workflow.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.loadWorkflowPageMenu = function() {
    var activeSubsection = null;
    var categoryMean = this.getCategoryMean();
    var defaultMenuItemIds = "";
    var menuItem = null;
    var menuItemArr = null;
    var pageMenu = null;
    var x = 0;

    // See if the page menu already exists since we share it among multiple
    // subsection views
    pageMenu = MP_MenuManager.getMenuObject("pageMenu" + categoryMean);
    if(!pageMenu) {
        // Page menu does not already exist so we will create the default values
        pageMenu = new Menu("pageMenu" + categoryMean);
        pageMenu.setTypeClass("menu-page-menu");
        pageMenu.setIsRootMenu(true);
        pageMenu.setAnchorElementId("pageMenu" + categoryMean);
        pageMenu.setAnchorConnectionCorner([ "bottom", "right" ]);
        pageMenu.setContentConnectionCorner([ "top", "right" ]);

        // Load the Print report menu item
        menuItem = this.loadPrintableReportMenuItem();
        if(MenuItem.prototype.isPrototypeOf(menuItem)) {
            pageMenu.addMenuItem(menuItem);
        }

        // Add a separator
        pageMenu.addMenuItem(new MenuSeparator("separator"));

        // Create the clear preferences menu item
        menuItem = this.createClearPrefsMenuItem();
        if(MenuItem.prototype.isPrototypeOf(menuItem)) {
            pageMenu.addMenuItem(menuItem);
        }

        // Create the "Create Report" menu item
        if (!CERN_Platform.inMillenniumContext()) {
            menuItem = this.loadXRPrintMenuItem();
            if (MenuItem.prototype.isPrototypeOf(menuItem)) {
                pageMenu.addMenuItem(menuItem);
            }
        }

        // Add 'change password and logout' menu items only in web app context
        if (MPagesWeb.inContextOfWebApp()) {
            if (CERN_Platform.getChangePasswordMenuItem() !== null) {
                pageMenu.addMenuItem(CERN_Platform.getChangePasswordMenuItem());
            }
            pageMenu.addMenuItem(CERN_Platform.getLogoutMenuItem());
        }
    }
    else {
        // The workflow page menu is flexed between multiple views so we need to
        // remove the menuItems that are not defaults
        menuItemArr = pageMenu.getMenuItemArray();
        if (menuItemArr) {
            defaultMenuItemIds = "separator|";
            if (!CERN_Platform.inMillenniumContext() && this.getXRPrintTemplates().length) {
                defaultMenuItemIds += "printReport" + categoryMean + "|xrPrintMenu" + categoryMean + "|clearPrefs" + categoryMean;
            } else {
                defaultMenuItemIds += "printReport" + categoryMean + "|clearPrefs" + categoryMean;
            }
            if (MPagesWeb.inContextOfWebApp()) {
                if (CERN_Platform.getChangePasswordMenuItem() !== null) {
                    defaultMenuItemIds += "|changePasswordMenuItem";
                }
                defaultMenuItemIds += "|logOutMenuItem";
            }
            for (x = menuItemArr.length; x--;) {
                menuItem = menuItemArr[x];
                if (defaultMenuItemIds.indexOf(menuItem.getId()) < 0) {
                    menuItemArr.splice(x, 1);
                }
            }
        }
    }
    // Update/Add the menu to the collection so other objects will have access
    // to it
    MP_MenuManager.updateMenuObject(pageMenu);

    // Get the active subsection and have it load its page level menu items
    activeSubsection = this.getActiveSubsection();
    if(activeSubsection) {
        activeSubsection.loadWorkflowPageMenuItems("pageMenu" + categoryMean);
    }

    // Update the click event on the menu to launch this menu when clicked.
    $("#pageMenu" + categoryMean).unbind("click").click(function() {


        MP_MenuManager.showMenu("pageMenu" + categoryMean);
    });
};

/**
 * Initializes the gap-check instance that will be available across the view
 * This resource should be initialized only in this function.
 * The function also adds a listener for order placement/removal if a page-level synonym filter is set and
 * calls function to check for the placement of the mapped orders.
 * Fires event for gap-check discharge workflow if page-level synonym filter isn't set.
 * @returns {undefined} This function does not return a value
 */
WorkflowView.prototype.initializeGapCheck = function() {
    var gapCheckObj = null;
    var resourceName = this.m_categoryMean + "gapCheckResource";
    var gapCheckResource = MP_Resources.getSharedResource(resourceName);
    var gapCheckInitialized = true; // allows us to detect a soft refresh
    if(!gapCheckResource) {
        gapCheckResource = new SharedResource(resourceName);
        gapCheckObj = new GapCheck(this.getCriterion());
        gapCheckResource.setResourceData(gapCheckObj);
        gapCheckResource.setIsAvailable(true);
        MP_Resources.addSharedResource(resourceName, gapCheckResource);
        gapCheckObj.triggerInitializationTimer(this.m_navigatorSubsections[ 0 ].getAssociatedView().getComponents());
        gapCheckInitialized = false;
    }
    gapCheckObj = gapCheckResource.getResourceData();
    if(gapCheckResource.isResourceAvailable() && gapCheckObj) {
        var synonymArr = gapCheckObj.getMappedOrderSynonyms();
        if(synonymArr.length) {
            CERN_EventListener.addListener(gapCheckObj, EventListener.EVENT_ORDER_ACTION, gapCheckObj.checkForOrder, gapCheckObj);
            gapCheckObj.checkForOrder(null, gapCheckInitialized);
        }
        else {
            gapCheckObj.fireAdmitOrderEvent(gapCheckInitialized, 0);
        }
    }
};
/*globals DetailedReviewSubsection, CreateNoteSubsection, PMConvoSubsection, MP_FEATURE_TOGGLE */

/**
 * Implementation of the View Builder Workflow WorkflowView object
 */

/**
 * A constructor used to create a new ViewBuilderWorkflow object and initialize page level variables.
 * @constructor
 */
var ViewBuilderWorkflow = function () {
	//Set page level information
	this.setName('View Builder Workflow');

	//This flag determines if the detailed review subsection should selectively load components
	this.m_selectiveComponentLoadInd = true;
	this.m_featureToggleConfig = {};
};

/**
 * Setup the prototype and constructor to inherit from the base WorkflowView
 */
ViewBuilderWorkflow.prototype = new WorkflowView();
ViewBuilderWorkflow.prototype.constructor = WorkflowView;

/**
 * Returns the flag which indicates if components should be loaded selectively.  If this flag is set to true the Detailed Review
 * subsection will determine which components to load based on user input.
 * @returns {boolean} The selective components loading indicator.
 */

ViewBuilderWorkflow.prototype.selectivelyLoadComponents = function () {
	return this.m_selectiveComponentLoadInd;
};


/**
 * Getters
 */

/**
* Gets the featureToggle configuration property to load orion or mpage components based on these feature toggles
* @returns {Object}
*/
ViewBuilderWorkflow.prototype.getFeatureToggleConfig = function () {
	if (!this.m_featureToggleConfig) {
		this.m_featureToggleConfig = {};
	}
	return this.m_featureToggleConfig;
};


/**
 * Sets the featureToggleConfig property to load the components
 * @param {Object} featureToggleConfig - feature toggle configuration for the filter mean
 * @returns {undefined}
 */
ViewBuilderWorkflow.prototype.setFeatureToggleConfig = function (featureToggleConfig) {
	this.m_featureToggleConfig = featureToggleConfig;
};

/**
 * Set the selective component load flag which determines if the MPage should allow for selective component loading.  This means
 * the MPage will not attempt to load its components until explicitly told to do so using the loadSelectedComponent function.
 * @param {string} selectiveLoad A string which will be either "1" or "0" which will indicate if the MPages should allow for selective loading of components.
 * @returns {boolean} True if the selective component load indicator was set successfully, false otherwise
 */
ViewBuilderWorkflow.prototype.setSelectiveComponentLoadInd = function (selectiveLoad) {
	if (typeof selectiveLoad === 'string') {
		this.m_selectiveComponentLoadInd = selectiveLoad === '1';
		return true;
	}
	return false;
};

/**
 * Creates the subsections which will be a part of this particular workflow.
 * @param {JSON} workflowSettings The settings JSON for this workflow view
 * @returns {undefined} This function does not return a value
 */
/*eslint-disable no-unused-vars*/
ViewBuilderWorkflow.prototype.createNavigatorSubsectionObjects = function (workflowSettings) {
	var tempSubsection = null;
	var createNoteSubsection = null;
	var pmConvoSubsection = null;
	//The creation of these subsections is currently hardcoded since Bedrock does not currently
	//provide a way to setup Workflows.  Once that is available the loading of these subsections
	//should be dynamic.

	//Create the Detailed Review subsection
	tempSubsection = new DetailedReviewSubsection();
	//Setting the feature toggle settings to be passed to Navigation Subsection
	var featureToggleSettings = this.getFeatureToggleConfig();
	tempSubsection.setFeatureToggleConfig(featureToggleSettings);
	tempSubsection.setWorkflowViewId(this.getCategoryMean());
	//Add the selective component loading flag
	tempSubsection.setSelectiveComponentLoadInd(this.selectivelyLoadComponents());

	this.addNavigatorSubsection(tempSubsection);
	if (CERN_Platform.inMillenniumContext()) {
		//Adding Create Note Section
		createNoteSubsection = new CreateNoteSubsection();
		//Listening for events to get components
		createNoteSubsection.listenForComponentsInView();
		createNoteSubsection.setAlwaysExpanded(true);
		createNoteSubsection.setWorkflowViewId(this.getCategoryMean());
		createNoteSubsection.setSubsectionId('createNote' + this.getCategoryMean());
		this.addNavigatorSubsection(createNoteSubsection);
		//Add PMConvo links if bedrock page level filter is set and we are using Millenium solution.
		pmConvoSubsection = new PMConvoSubsection(this.getCategoryMean());
		if (pmConvoSubsection.isFilterSetToYes()) {
			pmConvoSubsection.setAlwaysExpanded(true);
			pmConvoSubsection.setHasBodyElement(true);
			this.addNavigatorSubsection(pmConvoSubsection);
		}
	}
};

/**
 * Loops through the nagivatorSubsection to get all the subsections enabled in workflow view
 * Invokes beforeDestroy function from MpageView if the subsection has associatedView
 * to clear all the references related to components in workflow view
 * @returns {undefined} This function does not return a value
 */
ViewBuilderWorkflow.prototype.beforeDestroy = function () {
	var subsectionArr = this.getNavigatorSubsections();
	subsectionArr.forEach(function (subsectionObj) {
		subsectionObj.beforeDestroy();
	});
};
/*eslint-enable no-unused-vars*/

/**
 * Loads the default Workflow View level filter mappings.  Calls the base functionality and l
 * @returns {undefined} This function does not return a value
 */
ViewBuilderWorkflow.prototype.loadFilterMappings = function () {
	//Call the base class definition of this function in order to load all of the default values
	WorkflowView.prototype.loadFilterMappings.call(this);
	//Selective component loading
	this.addFilterMappingObject('WF_SELECTIVE_COMP_LOADING_FLAG', {
		setFunction: this.setSelectiveComponentLoadInd,
		type: 'String',
		field: 'FTXT'
	});
};
/**
 * Checks the feature toggle status by calling the async method and check whether a feature toggle exists and if enabled
 * @param {componentOrionSettings} - a single component's orion settings containing the feature toggle
 * @returns {Promise} Return Promise True or false based on feature toggle state
 **/
function checkFeatureToggleStatus(componentOrionSettings) {
	if (componentOrionSettings && componentOrionSettings.feature_toggle) {
		return MP_FEATURE_TOGGLE.getToggleStatus(componentOrionSettings.feature_toggle).then(function (result) {
			return result.isEnabled;
		});
	}
	else {
		return Promise.resolve(false);
	}
};

/**
 * Adds loadViewSettings as an extention of current loadViewSettings deployment to call the
 * feature toggles api to get orion and mpage cloud dynamic component loading configuration
 * @param {Boolean} async - The async parameter will passed it will be true if the async is passed as true then load the async version otherwise load sync version
 * @returns {undefined} This function does not return a value
 **/
ViewBuilderWorkflow.prototype.loadViewSettings = function (async) {
	var self = this;
	if (!async) {
		return WorkflowView.prototype.loadViewSettings.call(this);
	}
	return WorkflowView.prototype.loadViewSettings.call(this, true).then(function () {
		//Retrieve and store the page level settings from the preference model
		return WorkflowView.prototype.getViewSettingsObject.call(self, true)
			.then(function (viewSettings) {
				if (!viewSettings) {
					throw new Error(i18n.VIEW_SETTINGS_UNAVAILABLE);
				}
				var componentsArr = viewSettings.BR_SET.CS; // BR_SET is shorthand for Bedrock Settings and CS is shorthand for Component Settings
				var orionMPageDynamicLoadingConfig = !window.DynamicComponentCatalog ? undefined : window.DynamicComponentCatalog.bedrockConfig;
				return componentsArr.reduce(function (promise, compSettings) {
					return promise.then(function () {
						var componentFilterMean = compSettings.F_MN;
						var componentOrionSettings = orionMPageDynamicLoadingConfig ? orionMPageDynamicLoadingConfig[componentFilterMean] : null;
						return checkFeatureToggleStatus(componentOrionSettings).then(function (result) {
							var settings = self.getFeatureToggleConfig();
							settings[componentFilterMean] = result;
							self.setFeatureToggleConfig(settings);
						});
					});
				}, Promise.resolve());
			});
	});
};

MP_Util.setObjectDefinitionMapping('WF_STD', ViewBuilderWorkflow);
/**
 * The NavigatorSubsection object
 * @constructor
 * @author Steven Lewis
 */
function NavigatorSubsection() {

    /*Variables*/
    this.m_criterion = null;
    this.m_filterMappingsObj = {};
    this.m_isSubsectionActive = false;
    this.m_isSubsectionRendered = false;
    this.m_subsectionSettings = null;
    this.m_subsectionId = 0.0;
    this.m_workflowViewId = "";

    /*Navigator Subsection*/
    this.m_bodyElementId = "";
    this.m_hasBodyElement = false;
    this.m_hasHeaderElement = false;
    this.m_headerElementId = "";
    this.m_headerElementText = "";
    this.m_subsectionElementId = "";
    this.m_subsectionName = "";
    this.m_subsectionIcon = "";
    this.m_alwaysExpanded = false;

    /*Associated MPageView*/
    this.m_hasAssociatedView = false;
    this.m_mpageViewElementId = "";
    this.m_associatedView = null;
    this.m_associatedViewElementId = "";
}

/**
 * Add a filter mapping object to the collection of mappings.  Filter mappings
 * are referenced by name, so if a filter already exists with the same name it
 * will be overwritten.
 * @param {string} filterName The name of the filter object to add.
 * @param {Object} filterObject The object containing all of the filter
 *     properties used when loading settings.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.addFilterMappingObject = function(filterName, filterObject) {
    this.m_filterMappingsObj[ filterName ] = filterObject;
};

/**
 * This function is used for clean up activities to avoid memmory leak
 * This function is called before component is removed from dom
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.beforeDestroy = function() {
    CERN_EventListener.removeAllListeners(this, this);
    if(this.hasAssociatedView() && typeof this.getAssociatedView().beforeDestroy === "function") {
        this.getAssociatedView().beforeDestroy();
    }
};

/**
 * Generates the HTML for the subsection header.  The base class implementation
 * just returns the HeaderElementText and requires the Workflow to style the
 * container for the header.
 * @returns {string} The HTML which will be inserted into the subsection header
 */
NavigatorSubsection.prototype.generateHeaderHTML = function() {
    return this.getHeaderText();
};

/**
 * Generate the HTML for the subsection body.  The base class implementation of
 * this function returns an empty string.  It is up to the individual
 * NavigatorSubsection objects to create their body HTML.
 * @returns {string} The HTML which will be inserted into the subsection body
 */
NavigatorSubsection.prototype.generateBodyHTML = function() {
    return "&nbsp;";
};

/**
 * Gets the MPageView object that is associated to this NavigatorSubsection
 * object.
 * @returns {MPageView} The MPageView object that is associated to this
 *     NavigatorSubsection
 */
NavigatorSubsection.prototype.getAssociatedView = function() {
    return this.m_associatedView;
};

/**
 * Gets the element id of the container for the associated View.
 * @returns {MPageView} The MPageView object that is associated to this
 *     NavigatorSubsection
 */
NavigatorSubsection.prototype.getAssociatedViewElementId = function() {
    return this.m_associatedViewElementId;
};

/**
 * Gets the id of the subsection body HTML element assigned to this subsection.
 * @returns {string} The id of the body element assigned to this subsection
 */
NavigatorSubsection.prototype.getBodyElementId = function() {
    return this.m_bodyElementId;
};

/**
 * Gets the criterion object of this NavigatorSubsection
 * @returns {Criterion} The criterion object for the NavigatorSubsection
 */
NavigatorSubsection.prototype.getCriterion = function() {
    return this.m_criterion;
};

/**
 * Gets the array of filter mapping objects used to apply Workflow View level
 * settings.
 * @returns {Object[]} An array of filter mapping objects.
 */
NavigatorSubsection.prototype.getFilterMappingsObj = function() {
    return this.m_filterMappingsObj;
};

/**
 * Gets the id of the subsection head HTML element assigned to this subsection.
 * @returns {string} The id of the head element assigned to this subsection
 */
NavigatorSubsection.prototype.getHeaderElementId = function() {
    return this.m_headerElementId;
};

/**
 * Gets the text/label to render in the subsection header element
 * @returns {string} The id of the head element assigned to this subsection
 */
NavigatorSubsection.prototype.getHeaderText = function() {
    return this.m_headerElementText;
};

/**
 * Gets the name of this NavigatorSubsection.
 * @returns {string} The name of the subsection
 */
NavigatorSubsection.prototype.getName = function() {
    return this.m_subsectionName;
};

/**
 * Gets the id of the subsection container HTML element assigned to this
 * subsection
 * @returns {string} the id of the container element assigned to this
 *     subsection
 */
NavigatorSubsection.prototype.getSubsectionElementId = function() {
    return this.m_subsectionElementId;
};

/**
 * Gets the filename of the icon to display for the subsection head.
 * @returns {string} The name of the icon used in the subsection head
 */
NavigatorSubsection.prototype.getSubsectionIcon = function() {
    return this.m_subsectionIcon;
};

/**
 * Gets the unique ID assigned to this NavigatorSubsection
 * @returns {Number}    The id of the subsection
 */
NavigatorSubsection.prototype.getSubsectionId = function() {
    return this.m_subsectionId;
};

/**
 * Gets the settings object used when loading the NavigatorSubsection object.
 * @returns {Object} The subsection settings object.
 */
NavigatorSubsection.prototype.getSubsectionSettings = function() {
    return this.m_subsectionSettings;
};

/**
 * Gets the workflow view id that this subsection is in.
 * @returns {string} the workflow view id
 */
NavigatorSubsection.prototype.getWorkflowViewId = function() {
    return this.m_workflowViewId;
};

/** Checkers **/

/**
 * Checks to see if this subsection has an associated MPageView object that
 * will be rendered along with the subsection element. Not all subsections may
 * need an associated MPageView object and performs some alternate
 * functionality.
 * @returns {boolean} True if the subsection has a header element, false
 *     otherwise.
 */
NavigatorSubsection.prototype.hasAssociatedView = function() {
    return this.m_hasAssociatedView;
};

/**
 * Checks to see if this subsection has a body element.  Not all subsections
 * may need a body and simply open the associated View object when selected.
 * @returns {boolean} True if the subsection has a header element, false
 *     otherwise.
 */
NavigatorSubsection.prototype.hasBodyElement = function() {
    return this.m_hasBodyElement;
};

/**
 * Checks to see if this subsection has a header element
 * @returns {boolean} True if the subsection has a header element, false
 *     otherwise.
 */
NavigatorSubsection.prototype.hasHeaderElement = function() {
    return this.m_hasHeaderElement;
};

/**
 * This function is used to check and see if the subsection body should always
 * be expanded
 * @returns {boolean} True if the subsection should always be expanded, false
 *     otherwise
 */
NavigatorSubsection.prototype.isAlwaysExpanded = function() {
    return this.m_alwaysExpanded;
};

/**
 * Checks to see if the sunsection is currently active
 * @returns {boolean} True if the subsection is active, false otherwise
 */
NavigatorSubsection.prototype.isSubsectionActive = function() {
    return this.m_isSubsectionActive;
};

/**
 * Checks to see if the sunsection has been rendered
 * @returns {boolean} True if the subsection has been rendered, false otherwise
 */
NavigatorSubsection.prototype.isSubsectionRendered = function() {
    return this.m_isSubsectionRendered;
};

/**
 * This function is used to apply the current offset position of the associated
 * view.  This is to allow the view to remain in the same position before and
 * after hiding the subsection content.  This function is intended on being
 * implemented by the specific implementation of NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.applyViewOffsetPosition = function() {
    //This functionality should be implemented at the instance level
};

/**
 * This function is used to save the current offset position of the associated
 * view.  This is to allow the view to remain in the same position before and
 * after hiding the subsection content.  This function is intended on being
 * implemented by the specific implementation of NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.saveViewOffsetPosition = function() {
    //This functionality should be implemented at the instance level
};

/**
 * This function is used to set the flag which determines if a subsection body
 * should always be expanded.
 * @param {boolean} alwaysExpanded A boolean which determines if the subsection
 *     should always be expanded or not
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setAlwaysExpanded = function(alwaysExpanded) {
    this.m_alwaysExpanded = alwaysExpanded;
};

/**
 * Sets the MPageView object that is associated to this NavigatorSubsection
 * object.
 * @param {MPageView} mpageViewObj The MPageView object that is associated to
 *     this NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setAssociatedView = function(mpageViewObj) {
    this.m_associatedView = mpageViewObj;
};

/**
 * Sets the id of the container for the associated View object.
 * @param {string} elementId The id of the DOM container for the associated
 *     view
 * @returns {MPageView} The MPageView object that is associated to this
 *     NavigatorSubsection
 */
NavigatorSubsection.prototype.setAssociatedViewElementId = function(elementId) {
    this.m_associatedViewElementId = elementId;
};

/**
 * Sets the id of the subsection body HTML element assigned to this subsection.
 * @param {string} elementId The id of the DOM container for the subsection
 *     body
 * @returns {boolean} True if the body element id was set successfully, false
 *     otherwise
 */
NavigatorSubsection.prototype.setBodyElementId = function(elementId) {
    if (elementId && typeof elementId === "string") {
        this.m_bodyElementId = elementId;
        return true;
    }
    return false;
};

/**
 * Sets the criterion object of this NavigatorSubsection object.
 * @param {Criterion} criterionObj A criterion object which will be used within
 *     the NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setCriterion = function(criterionObj) {
    this.m_criterion = criterionObj;
};

/**
 * Sets the filter mappings object which will be used when loading settings
 * from the preferences model.  The filterObj parameter must not be null.  If
 * it is null it will be ignored.
 * @param {Object} filterObj An object which contains the filter mappings of
 *     the WorkflowView object
 * @returns {boolean} True if the filter mappings were set successfully, false
 *     otherwise
 */
NavigatorSubsection.prototype.setFilterMappingsObj = function(filterObj) {
    if (filterObj) {
        this.m_filterMappingsObj = filterObj;
        return true;
    }
    return false;
};

/**
 * Sets the hasAssociatedView flag which determines if this subsection will
 * have an Associated MPageView object.
 * @param {boolean} hasView A boolean indicating if the subsection has an
 *     associated view
 * @returns {boolean} True if the head element id was set successfully, false
 *     otherwise
 */
NavigatorSubsection.prototype.setHasAssociatedView = function(hasView) {
    if (typeof hasView === "boolean") {
        this.m_hasAssociatedView = hasView;
        return true;
    }
    return false;
};

/**
 * Sets the hasBodyElement flag which determines if this subsection will have a
 * body portion rendered.
 * @param {boolean} hasBody A boolean indicating if the subsection has a body
 * @returns {boolean} True if the head element id was set successfully, false
 *     otherwise
 */
NavigatorSubsection.prototype.setHasBodyElement = function(hasBody) {
    if (typeof hasBody === "boolean") {
        this.m_hasBodyElement = hasBody;
        return true;
    }
    return false;
};

/**
 * Sets the hasHeadElement flag which determines if this subsection will have a
 * head portion rendered.
 * @param {boolean} hasHead A boolean indicating if the subsection has a header
 * @returns {boolean} True if the has head element flag was set successfully,
 *     false otherwise
 */
NavigatorSubsection.prototype.setHasHeaderElement = function(hasHead) {
    if (typeof hasHead === "boolean") {
        this.m_hasHeaderElement = hasHead;
        return true;
    }
    return false;
};

/**
 * Sets the id of the subsection head HTML element assigned to this subsection.
 * @param {string} elementId The id of the DOM element where the header is
 *     rendered
 * @returns {boolean} True if the head element id was set successfully, false
 *     otherwise
 */
NavigatorSubsection.prototype.setHeaderElementId = function(elementId) {
    if (elementId && typeof elementId === "string") {
        this.m_headerElementId = elementId;
        return true;
    }
    return false;
};

/**
 * Sets the text to be used used when rendering the subsection head HTML
 * element assigned to this subsection.
 * @param {string} headerText The text to place in the header element
 * @returns {boolean} True if the head element id was set successfully, false
 *     otherwise
 */
NavigatorSubsection.prototype.setHeaderText = function(headerText) {
    if (headerText && typeof headerText === "string") {
        this.m_headerElementText = headerText;
        return true;
    }
    return false;
};

/**
 * Sets the name of this NavigatorSubsection.
 * @param {string} subsectionName The name of the subsection
 * @returns {boolean} True if the NavigatorSubsection name was set
 *     successfully, false otherwise
 */
NavigatorSubsection.prototype.setName = function(subsectionName) {
    if (subsectionName && typeof subsectionName === "string") {
        this.m_subsectionName = subsectionName;
        return true;
    }
    return false;
};

/**
 * Sets the flag indicating if the subsection is currently active.
 * @param {boolean} activeInd A boolean which signifies the subseciton as being
 *     active
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setSubsectionActive = function(activeInd) {
    this.m_isSubsectionActive = activeInd;
};

/**
 * Sets the id of the subsection container HTML element assigned to this
 * subsection.
 * @param {string} elementId The id of the DOM Elemenet that contains the
 *     subsection
 * @returns {boolean} True if the container element id was set successfully,
 *     false otherwise
 */
NavigatorSubsection.prototype.setSubsectionElementId = function(elementId) {
    if (elementId && typeof elementId === "string") {
        this.m_subsectionElementId = elementId;
        return true;
    }
    return false;
};

/**
 * Sets the name of the icon to display for the subsection.
 * @param {string} iconFileName The file name of the icon to use next to the
 *     subsection header
 * @returns {string} The name of the icon used in the subsection header
 */
NavigatorSubsection.prototype.setSubsectionIcon = function(iconFileName) {
    if (iconFileName && typeof iconFileName === "string") {
        this.m_subsectionIcon = iconFileName;
        return true;
    }
    return false;
};

/**
 * Sets the unique ID assigned to the NavigatorSubsection.
 * @param {Number} subsectionId    The id of the subsection
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setSubsectionId = function(subsectionId) {
    this.m_subsectionId = subsectionId;
};

/**
 * Sets the flag which indicates if the subsection has been rendered
 * @param {boolean} renderedInd A flag indicating that the subsection has
 *     already been rendered
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setSubsectionRendered = function(renderedInd) {
    this.m_isSubsectionRendered = renderedInd;
};

/**
 * Set the settings object for this particular NavigatorSubsection.
 * @param {Object} settingsObj The object which contains all of the settings
 *     needed for the NavigatorSubsection.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.setSubsectionSettings = function(settingsObj) {
    this.m_subsectionSettings = settingsObj;
};

/**
 * Sets the workflow view id that this subsection is in.
 * @param {String} viewId The id of the parent workflow view
 * @returns {boolean} true if the id was successfully set, otherwise false
 */
NavigatorSubsection.prototype.setWorkflowViewId = function(viewId) {
    if (viewId && typeof viewId === "string") {
        this.m_workflowViewId = viewId;
        return true;
    }
    return false;
};

/** NavigatorSubsection Setup Functions **/

/**
 * Initializes the NavigatorSubsection element with the necessary information.
 * @param {Criterion} criterion The criterion object which will be used within
 *     this NavigatorSubsection object
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.initializeSubsection = function(criterion) {
    //Set the criterion object for later use
    this.setCriterion(criterion);
};

/**
 * Renders the Subsection and it's associated MPagesView.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.renderSubsection = function() {
    var associatedMPage = null;

    //Render the subsections body if needed
    if (this.hasAssociatedView()) {
        //Call the renderView function of the associated MpageView Object
        associatedMPage = this.getAssociatedView();
        if (MPageView.prototype.isPrototypeOf(associatedMPage)) {
            associatedMPage.renderView();
        }
    }
    this.setSubsectionRendered(true);
};

/*eslint-disable no-unused-vars*/
/**
 * Any post processing that needs to be completed by the NavigatorSubsection
 * object will be completed in this function.  No functionality has been
 * implemented at this time for the base function, but this can be overridden
 * in objects which prototype the NavigatorSubsection object.
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.postProcessing = function() {

};
/*eslint-enable no-unused-vars*/

/**
 * Perform any special logic necessary for resizing an associated MPagesView
 * object
 * @returns {undefined} This function does not return a value
 */
NavigatorSubsection.prototype.resizeSubsection = function() {
    var associatedMPage = null;

    //Resize the associated MPagesView object if necessary
    if (this.hasAssociatedView()) {
        //Call the resizeView function of the associated MpageView Object
        associatedMPage = this.getAssociatedView();
        if (MPageView.prototype.isPrototypeOf(associatedMPage)) {
            associatedMPage.resizeView();
        }
    }
};

/**
 * Creates and initializes the MPagesView object which will be associated with
 * this subsection.  Each NavigatorSubsection Object is responsible for
 * extracting the necessary Component settings and creating the associated View
 * object
 * @param {object} allComponentSettings An object which contains the settings
 *     for all of the Components shown within this workflow.
 * @returns {undefined} This function does not return a value
 */
/*eslint-disable no-unused-vars*/
NavigatorSubsection.prototype.createAssociatedMPageView = function(allComponentSettings) {
    //This functionality should be implemented at the instance level
};
/*eslint-enable no-unused-vars*/

/**
 * Extracts the component settings that will be used in the associated
 * MPagesView object and sets them using the setSubsectionSettings function.
 * This function should be implemented in each NavigatorSubsection object
 * otherwise it will just return the settings for all components.
 * @param {Object[]} settingsObj An object array which contains components
 *     settings
 * @returns {Object[]} An array of object containing component settings
 */
NavigatorSubsection.prototype.extractComponentSettings = function(settingsObj) {
    //This has to be implemented by the NavigatorSubsection objects because
    // they know which components to pull otherwise all component settings are
    // returned
    return settingsObj;
};

/**
 * Injects the menu items into the Workflow Page Menu.  There is currently no
 * implementation at the base level for this function. All menu items will be
 * determined by the individual implementation of each NavigatorSubsection
 * object. This function should be implemented in each NavigatorSubsection
 * object.
 * @param {String} pageMenuId The id of the menu where menu items should be
 *     injected
 * @returns {undefined} This function does not return a value
 */
/*eslint-disable no-unused-vars*/
NavigatorSubsection.prototype.loadWorkflowPageMenuItems = function(pageMenuId) {
    //This function should be implemented by each NavigatorSubsection that
    // utilizes the Workflow page level menu
};
/*eslint-enable no-unused-vars*/
/* globals NavigatorSubsection, NavigatorSubsectionSummaryMPage, CapabilityTimer, GapCheck, MPageFusion, CERN_Platform */
/* eslint-disable mp-camelcase */
/**
 * A constructor used to create a new DetailedReviewSubsection object and
 * initialize subsection level variables.
 * @constructor
 */
var DetailedReviewSubsection = function() {

    // A reference to the detailed review subsection DOM element for quick access
    this.m_subsectionBodyElement = null;

    // This timeout reference is used to keep track of the timeout associated
    // with the selective component loading It is stored at the instance level
    // so that it can be canceled in certain scenarios.
    this.m_componentLoadTimeout = null;

    // This flag is used to determine if the current value set for the
    // m_componentLoadTimeout should block any future requests to clear the
    // existing timeout until after it has finished.
    this.m_blockingComponentLoadTimeout = false;

    // This value will determine how many component will be loaded selectively.
    // The value will be based on the associated view's container and the
    // minimum height of a workflow component.
    this.m_componentsToLoad = 0;

    // This value represents the height of an empty component in pixels.  It is
    // used to calculate, based on a worst-case scenario, how many components
    // will be able to fit inside the viewing pane of the workflow MPage.
    this.m_emptyComponentHeightInPixels = 120;

    // This flag determines if the associated MPage should allow the detailed
    // review subsection to selectively load the components
    this.m_selectiveComponentLoadInd = true;

    /* eslint-disable mp-camelcase */
    // This caches the padding element that is added to the bottom of the view
    this.m_$paddingPlaceholder = null;
    // This caches the container that holds all the components
    this.m_$contentObject = null;
    // This caches the root element of the last component in the workflow view
    this.m_$lastComponentElement = null;
    // This caches the id of the last component
    this.m_lastComponentId = 0;
    // This caches the view element which contains the scrollbar
    this.m_$viewElementObject = null;
    // This caches the last offset position of the view, which is used for
    // returnin to the same offset position upon displaying the view again
    this.m_viewScrollOffset = 0;
    /* eslint-enable mp-camelcase */

    // This caches the height of the last component in the view since the last
    // padding adjustment
    this.m_lastComponentHeight = 0;
    // This caches the height of the padding element in the view since the last
    // padding adjustment
    this.m_lastPaddingHeight = 0;

    // Set page level information
    this.setName("Detailed Review");
    // Let the architecture know that we want to render a body portion for our
    // subsection element
    this.setHasBodyElement(true);
    // Let the architecture know we have an associated MPageView object that we
    // want to show
    this.setHasAssociatedView(true);
    // Let the architecture know that at least there is one component that is
    // marked as required in the view
    this.m_gapCheckInd = null;
    // Feature Toggle Config
    this.m_featureToggleConfig = {};
};

/**
 * Setup the prototype and constructor to inherit from the base
 * NavigatorSubsection
 */
DetailedReviewSubsection.prototype = new NavigatorSubsection();
DetailedReviewSubsection.prototype.constructor = NavigatorSubsection;

/**
 * Returns the flag which indicates if components should be loaded selectively.
 *  If this flag is set to true the Detailed Review subsection will determine
 * which components to load based on user input.
 * @returns {boolean} The selective components loading indicator.
 */
DetailedReviewSubsection.prototype.selectivelyLoadComponents = function() {
    return this.m_selectiveComponentLoadInd;
};

 /**
 * Gets the featureToggle configuration property to load orion or mpage components based on these feature toggles
 * @returns {Object}
 */
DetailedReviewSubsection.prototype.getFeatureToggleConfig = function() {
    return this.m_featureToggleConfig;
};


/**
 * Sets the featureToggleConfig property to load the components
 * @param {Object} featureToggleConfig - feature toggle configuration for the filter mean
 * @returns {undefined}
 */
DetailedReviewSubsection.prototype.setFeatureToggleConfig = function(featureToggleConfig) {
    this.m_featureToggleConfig = featureToggleConfig;
};

/**
 * Set the selective component load flag which determines if the MPage should
 * allow for selective component loading. This means the MPage will not attempt
 * to load its components until explicitly told to do so using the
 * loadSelectedComponent function.
 * @param {boolean} selectiveLoad A boolean which will indicate if the MPages
 *     should allow for selective loading of components.
 * @returns {boolean} True if the selective component load indicator was set
 *     successful, false otherwise
 */
DetailedReviewSubsection.prototype.setSelectiveComponentLoadInd = function(selectiveLoad) {
    if (typeof selectiveLoad === "boolean") {
        this.m_selectiveComponentLoadInd = selectiveLoad;
        return true;
    }
    return false;
};

/**
 * Creates and initializes the MPagesView object which will be associated with
 * this subsection.  Each NavigatorSubsection is responsible for extracting the
 * necessary Component settings for use in the MPagesView object.
 * @param {object} allComponentSettings An object which contains the settings
 *     for all of the Components shown within this workflow.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.createAssociatedMPageView = function(allComponentSettings) {
    var newMPage = null;

    // Create the MPageView instance and prepare it for rendering for the
    // subsection
    newMPage = new NavigatorSubsectionSummaryMPage();
    newMPage.setFeatureToggleConfig(this.getFeatureToggleConfig());
    // Let the page know the identifier of the parent workflow page
    newMPage.setParentWorkflowIdentifier(this.getWorkflowViewId());
    // Inform the page that the detailed review subsection will let it know
    // which components to load
    newMPage.setSelectiveComponentLoadInd(this.m_selectiveComponentLoadInd);
    // Only attempt to load the component settings if they are available.  It is
    // possible they will be retrieved at the time this subsection is
    // activated.
    if (allComponentSettings) {
        newMPage.initializeView(this.getAssociatedViewElementId(), allComponentSettings);
        newMPage.loadViewSettings();
        newMPage.initializeComponents();
    }

    this.setAssociatedView(newMPage);
    // Checking for the components in view to fire event for Create Note
    // Subsection.
    this.fireComponentsInViewEvent();
};

/**
 * This function checks whether any dyn doc component is present in the view.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.fireComponentsInViewEvent = function() {
    var components = this.getAssociatedView().getComponents();
    var workflowViewId = this.getWorkflowViewId();
    // Firing event for the Create Note subsection to retrieve the components
    CERN_EventListener.fireEvent(this, this, EventListener.EVENT_COMPONENTS_IN_VIEW, {
        "componentsInView": components,
        "workflowViewId": workflowViewId
    });
};

/**
 * Changes the background color and adds the right white arrow to the component
 * link in the navigator.
 * @param {MpageComponent} component Can be a reference to an MpageComponent or
 *     an object which has its own dummy versions of
 *     getStyles().getComponentId()
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.highlightNavigator = function(component) {
    var navigatorEle = null;
    if (component) {
        navigatorEle = this.m_subsectionBodyElement;
        // Remove the highlight from the current component
        navigatorEle.find(".dr-selected")
            .removeClass("dr-selected");
        // Highlight the newly selected element
        navigatorEle.find("#drNavi" + component.getStyles()
                .getId())
            .addClass("dr-selected");
    }
};

/**
 * This function is used to apply the current offset position of the associated
 * view.  This is to allow the view to remain in the same position before and
 * after hiding the subsection content.  This function is intended on being
 * implemented by the specific implementation of NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.applyViewOffsetPosition = function() {
    // This functionality should be implemented at the instance level
    if(this.m_$viewElementObject)
        this.m_$viewElementObject.scrollTop(this.m_viewScrollOffset);
};

/**
 * This function is used to save the current offset position of the associated
 * view.  This is to allow the view to remain in the same position before and
 * after hiding the subsection content.  This function is intended on being
 * implemented by the specific implementation of NavigatorSubsection
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.saveViewOffsetPosition = function() {
    // This functionality should be implemented at the instance level
    if(this.m_$viewElementObject)
        this.m_viewScrollOffset = this.m_$viewElementObject.scrollTop();
};

/**
 * This function is fired on EventListener.EVENT_COUNT_UPDATE and is used to
 * update the count displayed next to the component's navigator element.
 * @param {MPageComponent} component The component which fired the event.
 * @param {Object} args An object which contains the necessary elements to
 *     update the component count.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onCountUpdate = function(component, args) {
    try {
        var compNavEle = this.m_subsectionBodyElement.find("#drNavi" + component.getStyles().getId());
        // Update the count for this element
        if (compNavEle.length) {
            if (args.count !== null && compNavEle.find(".dr-error").hasClass("hidden")) {
                compNavEle.find(".dr-count").html("(" + args.count + ")").removeClass("hidden");
            }
            else {
                compNavEle.find(".dr-count").html("(null)").addClass("hidden");
            }
        }
    }
    catch (err) {
        logger.logJSError(err, component, "detailed-review.js", "onCountUpdate");
    }
};

/**
 * This function is fired on EventListener.EVENT_SCROLL - when user clicks
 * Checkout component label.
 * @param {MPageComponent} checkoutComponent A reference to the Checkout
 *     component.
 * @param {String} namespace component name space.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onCheckoutScroll = function(checkoutComponent, namespace) {
    var componentCnt = 0;
    var components = null;
    var assocView = this.getAssociatedView();
    if (!assocView) {
        return;
    }
    var viewEle = $("#" + this.getAssociatedViewElementId())
        .find(".col1");
    /*
     * This would be unique checkout component id across
     * different views.
     */
    var uniqueCheckoutComponentViewId = viewEle.find("#" + checkoutComponent.getStyles()
            .getId());

    /*
     * uniqueCheckoutComponentViewId.length would be '0'
     * for other checkout components set in other views.
     * The same is true if check out component is not
     * configured in other views as well.
     */

    if (uniqueCheckoutComponentViewId.length) {
        components = assocView.getComponents();
        componentCnt = components.length;
        var throwError = true;

        for (var x = 0; x < componentCnt; x++) {

            if (components[ x ].getStyles()
                    .getNameSpace() === namespace && components[ x ].isDisplayable()) {
                // Scroll the component to the top of the view
                if (viewEle.length) {
                    var component = viewEle.find("#" + components[ x ].getStyles()
                            .getId());
                    if (component.length) {
                        throwError = false;
                        this.scrollToComponent(component);
                    }
                }
            }

        }
        /*
         * Fire an event when corresponding component is missing in navigator.
         */
        if (throwError) {
            CERN_EventListener.fireEvent(checkoutComponent, checkoutComponent, EventListener.EVENT_NAVIGATOR_ERR, namespace);
        }

    }
    else {
        // do nothing- return
        return;
    }

};

/**
 * This function is fired on EventListener.EVENT_CRITICAL_UPDATE and is used to
 * show the critical icon displayed next to the component's navigator element.
 * @param {MPageComponent} component The component which fired the event.
 * @param {Object} args An object which contains the necessary elements to
 *     update the component critical indicator.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onCriticalUpdate = function(component, args) {
    try {
        var compNavEle = this.m_subsectionBodyElement.find("#drNavi" + component.getStyles()
                .getId());
        // Update the count for this element
        if (compNavEle.length) {
            if (args.critical !== null && $(compNavEle)
                    .find(".dr-error")
                    .hasClass("hidden")) {
                compNavEle.find(".dr-critical")
                    .removeClass("hidden");
            }
            else {
                compNavEle.find(".dr-critical")
                    .addClass("hidden");
            }
        }
    }
    catch (err) {
        logger.logJSError(err, component, "detailed-review.js", "onCriticalUpdate");
    }
};

/**
 * This function is used to update the required or complete icons displayed next to a component's navigator
 * element.
 * @param {MPageComponent} component The component which fired the event.
 * @param {Object} args An object which contains the necessary elements to
 *     update the indicator.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.updateNavigatorGapCheckIcons = function(component, args) {
    if (this.m_subsectionBodyElement) {
        var compNavEle = this.m_subsectionBodyElement.find("#drNavi" + component.getStyles().getId());
        if (compNavEle.length) {
            if (!component.getGapCheckRequiredInd()) {
                // Gap-check isn't required for this comp; so remove icons for it from the navigator
                compNavEle.find(".dr-gc-icon").removeClass("dr-required").removeClass("dr-satisfied");
                return;
            }
            // Mark the component as satisfied or not based on the status
            if ((args.satisfied || component.getSatisfiedInd()) && compNavEle.find(".dr-error").hasClass("hidden")) {
                compNavEle.find(".dr-gc-icon").removeClass("dr-required").addClass("dr-satisfied");
            }
            else {
                compNavEle.find(".dr-gc-icon").addClass("dr-required").removeClass("dr-satisfied");
            }
        }
    }
};

/**
 * This function is fired on EventListener.EVENT_ERROR_UPDATE and is used to
 * show the error icon displayed next to the component's navigator element.
 * This element is added on the fly since the probability for error is much
 * less than for a critical or count element.
 * @param {MPageComponent} component The component which fired the event.
 * @param {Object} args An object which contains the necessary elements to
 *     update the component critical indicator.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onErrorUpdate = function(component, args) {
    try {
        var compNavEle = this.m_subsectionBodyElement.find("#drNavi" + component.getStyles()
                .getId());
        // Update the count for this element
        if (compNavEle.length) {
            if (args.error) {
                // Show the error icon and hide the count and critical elements
                compNavEle.find(".dr-error").removeClass("hidden");
                compNavEle.find(".dr-count").html("(null)").addClass("hidden");
                compNavEle.find(".dr-critical").addClass("hidden");
            }
            else {
                compNavEle.find(".dr-error").addClass("hidden");
            }
        }
    }
    catch (err) {
        logger.logJSError(err, component, "detailed-review.js", "onErrorUpdate");
    }
};

/**
 * This funciton handles the event of a user wanting to move a component to the
 * contextual view.
 * @param {DOMEvent} event The event that is fired when
 * @param {MPageComponent} component The component which is being moved in/out
 *     of contextual view
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.onContextualViewMoveUpdate = function(event, component) {
    // If the compoent is removed from contextual view focus the component in
    // the first column, else bring the placeholder view.
    var compIndex = -1;
    if (component.isAddedToContextualView()) {
        compIndex = component.getRootPlaceholderComponentNode().index();
    }
    else {
        compIndex = $(component.getRootComponentNode()).index();
    }

    // Cache the last compnent incase this is the last component in navigator
    // and its height is being changed by moving between the two views.
    this.cacheLastVisibleComponent();
    this.generateNavigatorLinkClickFunction(component, compIndex);
};


/**
 * This function is used to generate click events for the navigator portion of
 * the detailed review subsection
 * @param {MPageComponent} componentObj This component associated to the link
 *     that is being created.
 * @param {number} componentIndex The index of the component within the array
 *     of components which will be used when selectively loading components.
 * @returns {function} The function that will be executed when the user clicks
 *     one of the navigator elements
 */
DetailedReviewSubsection.prototype.generateNavigatorLinkClickFunction = function(componentObj, componentIndex) {
    var self = this;
    return function() {
        // The actual column div that contains the components
        var actualColumnDiv = $("#" + self.getAssociatedViewElementId()).find(".col1");
        var component = null;
        // Scroll the component to the top of the view
        if (actualColumnDiv.length) {
            // If the component is added to contextual view, get the placeholder
            // view instead of the actual component
            if (componentObj.isAddedToContextualView() && MPageFusion.coreAPI.base.mediaQuery.atLeast("XL")) {
                component = actualColumnDiv.find("#" + componentObj.getStyles().getId() + "PlaceholderView");
            }
            else {
                component = actualColumnDiv.find("#" + componentObj.getStyles().getId());
            }
            if (component.length) {
                // Selectively load the selected component and make sure the
                // call is blocking so the scroll function doesn't start
                // loading components as well
                if (self.m_selectiveComponentLoadInd) {
                    self.loadSelectiveComponents(componentIndex, true, 0);
                }
                self.scrollToComponent(component);
            }
        }
        // Scrolling the component to the top triggers the scroll handler so we
        // need to wait for a bit and then highlight the component link that
        // was clicked.
        setTimeout(function() {
            // Highlight the component link
            self.highlightNavigator(componentObj);
            // Capture Capability timer
            self.captureCapabilityTimer(componentObj);
        }, 0);
    };
};

/**
 * This function is used to capture the cap timer of the detailed review
 * subsection elements on clicking navigation bar.
 * @param {MPageComponent} componentObj This component associated to the link
 *     that is being created.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.captureCapabilityTimer = function(componentObj) {
    var capTimer = new CapabilityTimer("CAP:MPG Detailed Review Subsection - Click Navigator Link", componentObj.getCriterion().category_mean);
    capTimer.addMetaData("rtms.legacy.metadata.1", componentObj.getReportMean());
    capTimer.capture();
};

/**
 * This method will scroll to a component in the view. If the component is
 * towards the bottom, we must still allow the component to be scrolled to the
 * top, thus some additional space needs to be added to the bottom of the view.
 * @param {Object} $componentElementObject - The component root level element
 *     that will be scrolled into view.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.scrollToComponent = function($componentElementObject) {
    this.attemptPaddingAdjustment();
    var viewElementObject = this.m_$viewElementObject.scrollTop($componentElementObject.position().top);
    if (viewElementObject && viewElementObject.scrollTop) {
        // save this.m_viewScrollOffset value right after the first scrollTop call
        // thus allowing the second call to navigate to the right location.
        this.m_viewScrollOffset = viewElementObject.scrollTop();
    }
};

/**
 * This method will find the last visible component in the view and cache the
 * root level element.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.cacheLastVisibleComponent = function() {
    var assocView = this.getAssociatedView();
    var components = assocView.getComponents();
    var componentCount = components.length;
    var isScreenSizeXL = MPageFusion.coreAPI.base.mediaQuery.atLeast("XL");

    for (var i = componentCount; i--;) {
        var component = components[ i ];
        if (component.isDisplayable()) {
            if (component.isAddedToContextualView() && isScreenSizeXL) {
                this.m_$lastComponentElement = $(component.getRootPlaceholderComponentNode());
            }
            else {
                this.m_$lastComponentElement = $(component.getRootComponentNode());
            }

            this.m_lastComponentId = component.m_componentId;

            return;
        }
    }
};

/**
 * This method will find if at least one component is marked as required in the
 * view and sets the gap check indicator.
 * @returns {boolean} The function will return true if there is a required
 *     component in the view else returns false
 */
DetailedReviewSubsection.prototype.isGapCheckRequired = function() {
    if (this.m_gapCheckInd === null) {
        var components = this.getAssociatedView().getComponents();
        var componentCount = components.length;
        // Initially set it to false
        this.m_gapCheckInd = false;
        for (var i = 0; i < componentCount; i++) {
            if (components[ i ].getGapCheckCriteria()) {
                this.m_gapCheckInd = true;
                break;
            }
        }
    }
    return this.m_gapCheckInd;
};

/**
 * This method will find the first visible component in the view and return its
 * index. If no component is visible, it will return -1.
 * @returns {number} The index of the first visible component
 */
DetailedReviewSubsection.prototype.getFirstVisibleComponentIndex = function() {
    var components = this.getAssociatedView().getComponents();
    var componentCount = components.length;
    for (var i = 0; i < componentCount; i++) {
        if (components[ i ].isDisplayable()) {
            return i;
        }
    }
    return -1;
};

/**
 * Store the latest dimensions used in the padding adjustment functionality. We
 * store the last component height so that we only adjust the padding when the
 * height of the last component has changed. We store the last padding height
 * because it is used in calculating the new padding value since it is now
 * included in the total view height.
 * @param {Number} lastComponentHeight - The height (in pixels) of the last
 *     component in the view since the last padding adjustment.
 * @param {Number} paddingHeight - The height (in pixels) of the padding
 *     element in the view since the last padding adjustment.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.storeLatestElementDimensions = function(lastComponentHeight, paddingHeight) {
    this.m_lastComponentHeight = lastComponentHeight;
    this.m_lastPaddingHeight = paddingHeight;
};

/**
 * This method adjusts the padding element at the bottom of the workflow to
 * ensure the component is able to be scrolled to the top of the workflow.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.attemptPaddingAdjustment = function() {
    var currentLastComponentHeight = null;
    var contentHeight = 0;
    var viewportHeight = 0;
    var componentPosition = 0;
    var lastComponentObj = null;
    // If we have not yet cached the last component root element, do that now
    if (!this.m_$lastComponentElement) {
        this.cacheLastVisibleComponent();
    }
    if (!this.m_$viewElementObject) {
        this.m_$viewElementObject = $("#" + this.getAssociatedViewElementId()).find(".col1");
    }
    // Let the content object be the actual column containing the components.
    if (!this.m_$contentObject && this.m_$lastComponentElement) {
        this.m_$contentObject = this.m_$lastComponentElement.closest(".components-col-container");
    }
    if (!this.m_$paddingPlaceholder && this.m_$contentObject) {
        this.m_$paddingPlaceholder = $("<div class='padding-placeholder'></div>").appendTo(this.m_$contentObject);
    }
    // Extra padding since we are missing an actual component being replaced
    // with placeholder placeholder.
    if (this.m_$lastComponentElement) {
        currentLastComponentHeight = $(this.m_$lastComponentElement).outerHeight();
        componentPosition = this.m_$lastComponentElement.position().top;
        lastComponentObj = MP_Util.GetCompObjById(this.m_lastComponentId); // eslint-disable-line
                                                                           // new-cap
    }

    // If the last component is added to contextual view then the actual
    // component is replaced by the placeholder which has a static height. This
    // would prevent the height of the padding placeholder from changing while
    // scrolling down. In order to avoid this a check on height of the last
    // component  is added along with a check  whether the last component was
    // not added to contextual view.
    if (this.m_lastComponentHeight === currentLastComponentHeight && !lastComponentObj.isAddedToContextualView()) {
        return;
    }
    if (this.m_$contentObject) {
        contentHeight = this.m_$contentObject.outerHeight();
    }

    if (this.m_$viewElementObject) {
        viewportHeight = $(this.m_$viewElementObject).outerHeight();
    }

    // This checks to see if there is enough space below the component that
    // would allow it to be scrolled to the top of the view. If not, adjust the
    // padding element such that the component can be scrolled into view.
    var paddingHeight = Math.max(viewportHeight - contentHeight + componentPosition + this.m_lastPaddingHeight, this.m_lastPaddingHeight);
    if (this.m_$paddingPlaceholder) {
        this.m_$paddingPlaceholder.css({
            "height": paddingHeight + "px"
        });
    }

    // Store the current dimensions so we can use them later for calculations
    // and comparisons
    this.storeLatestElementDimensions(currentLastComponentHeight, paddingHeight);
};

/**
 * Generate the HTML for the subsection body.  This implementation takes the
 * associated view and determines the components which will be displayed.  It
 * uses that list of components to render a navigator within the subsection
 * body.
 * @returns {String} The HTML which will be inserted into the subsection body
 */
DetailedReviewSubsection.prototype.generateBodyHTML = function() {
    var assocView = null;
    var component = null;
    var componentCnt = 0;
    var components = null;
    var navEle = null;
    var self = this;
    var subSecBodyEle = null;
    var x = 0;
    var requiredContentHtml = "";
    var offsetClass = "";
    try {
        // Determine which components are shown and in what order
        assocView = this.getAssociatedView();
        if (!assocView) {
            return null;
        }
        components = assocView.getComponents();
        componentCnt = components.length;
        if (componentCnt) {
            // Order the components by the comp_seq so we know before they are
            // rendered what order they will be in
            components.sort(function(a, b) {
                var aSeq = a.getSequence();
                var bSeq = b.getSequence();
                if (aSeq < bSeq) {
                    return -1;
                }
                // No two sequences will be the same so we already know bSeq >
                // aSeq at this point.
                return 1;
            });

            // Create the list of components for the subsection body
            subSecBodyEle = $("<div></div>");
            if (this.isGapCheckRequired()) {
                requiredContentHtml = "<span class='dr-gc-icon'>&nbsp;</span>";
            }
            offsetClass = "dr-gc-offset";
            for (x = 0; x < componentCnt; x++) {
                component = components[ x ];
                if (component.isDisplayable()) {
                    // Create the component navigation elements for each
                    // component
                    if (this.m_selectiveComponentLoadInd) {
                        navEle = $("<div id='drNavi" + component.getStyles().getId() + "' class='dr-comp-link' title='" + i18n.discernabu.detailed_review.COMPONENT_NOT_LOADED + "'>" + requiredContentHtml + "<span class='" + offsetClass + "'><div class='dr-error hidden'>&nbsp;</div>" + component.getLabel() + "<span class='dr-count'>...</span><span class='dr-critical hidden'>&nbsp;</span></span></div>");
                    }
                    else {
                        navEle = $("<div id='drNavi" + component.getStyles().getId() + "' class='dr-comp-link'>" + requiredContentHtml + "<span class='" + offsetClass + "'><div class='dr-error hidden'>&nbsp;</div>" + component.getLabel() + "<span class='dr-count'>&nbsp;</span><span class='dr-critical hidden'>&nbsp;</span></span></div>");
                    }

                    // Add the click event to the element and add to the list
                    navEle.click(this.generateNavigatorLinkClickFunction(component, x));
                    $(subSecBodyEle).append(navEle);
                }
            }

            // Add an event listener for the critical updates and the count
            // updates We can just use the last component as the listener
            // object since all components will share the same object
            // definition
            CERN_EventListener.addListener(component, EventListener.EVENT_COUNT_UPDATE, this.onCountUpdate, this);
            CERN_EventListener.addListener(component, EventListener.EVENT_CRITICAL_UPDATE, this.onCriticalUpdate, this);
            CERN_EventListener.addListener(component, EventListener.EVENT_ERROR_UPDATE, this.onErrorUpdate, this);
            CERN_EventListener.addListener(component, EventListener.EVENT_SCROLL, this.onCheckoutScroll, this);
            // Change the required Icon if the component is satisfied
            CERN_EventListener.addListener(component, EventListener.EVENT_SATISFIER_UPDATE, this.updateNavigatorGapCheckIcons, this);
            // When a component is added to or removed from the contextual  view
            // add focus to the component in the view.
            CERN_EventListener.addListener(component, EventListener.EVENT_COMPONENT_MOVED_FROM_CONTEXTUAL_VIEW, this.onContextualViewMoveUpdate, this);
            CERN_EventListener.addListener(this, EventListener.EVENT_ADMT_ORDER_PLACED + this.getCriterion().category_mean, this.flexGapCheck, this);
            // Add drag and drop support
            subSecBodyEle.sortable({
                axis: "y",
                containment: subSecBodyEle,
                distance: 5,
                items: ".dr-comp-link",
                placeholder: "dr-comp-link-placeholder",
                tolerance: "pointer",
                update: function(ev, ui) {
                    try {
                        var compEle = null;
                        var compId = "";
                        var compLinkEle = null;
                        var prevEle = null;
                        var prevEleId = "";
                        var columnEle = null;

                        // Get the component before the sorted component
                        compLinkEle = $(ui.item);
                        compId = compLinkEle.attr("id").replace("drNavi", "");
                        prevEle = compLinkEle.prev();
                        // Get the container that contains the component in the
                        // column.
                        columnEle = $("#" + self.getAssociatedViewElementId() + " .col1").find(".components-col-container");
                        // Checking for the placeholder view of the component if
                        // it exists.
                        compEle = columnEle.find("#" + compId).length ? columnEle.find("#" + compId) : columnEle.find("#" + compId + "PlaceholderView");

                        if (prevEle.length) {
                            // Component is not at the beginning of the list
                            prevEleId = prevEle.attr("id").replace("drNavi", "");
                            prevEle = columnEle.find("#" + prevEleId);
                            // If the actual component could not be found in the
                            // column, then we have it is placeholder view.
                            if (!prevEle.length) {
                                prevEle = columnEle.find("#" + prevEleId + "PlaceholderView");
                            }
                            compEle.insertAfter(prevEle);
                        }
                        else {
                            // Component is now at the beginning of the list
                            columnEle.prepend(compEle);
                        }

                        // Call the functions to update the component
                        // preferences for this workflow page
                        MP_Core.AppUserPreferenceManager.UpdateAllCompPreferences(components, true, true); // eslint-disable-line new-cap

                        // Resort the components since their sequence has
                        // changed.
                        components.sort(function(a, b) {
                            var aSeq = a.getSequence();
                            var bSeq = b.getSequence();
                            if (aSeq < bSeq) {
                                return -1;
                            }
                            // No two sequences will be the same so we already
                            // know bSeq > aSeq at this point.
                            return 1;
                        });
                        // Loop through the components and re-attach their click
                        // functions and trigger any action that needs to be
                        // done post location change of the component that was
                        // dragged
                        for (x = 0; x < componentCnt; x++) {
                            component = components[ x ];
                            if (component.isDisplayable()) {
                                subSecBodyEle.find("#drNavi" + component.getStyles().getId()).unbind("click").click(self.generateNavigatorLinkClickFunction(component, x));
                                if (component.getStyles().getId() === compId) {
                                    // save the component reference since the
                                    // 'component' variable could change in a
                                    // loop.
                                    var movedComponent = component;
                                    setTimeout(function() {
                                        movedComponent.postDOMLocationChange();
                                    }, 0);
                                }
                            }
                        }
                    }
                    catch (err) {
                        logger.logJSError(err, null, "detailed-review.js", "scrolling: update");
                    }
                },

                start: function(ev, ui) {
                    // Add these classes so if the cursor no longer hovers over
                    // the elements it retains its styling
                    var item = $(ui.item);
                    if (item.hasClass("dr-selected")) {
                        item.addClass("dr-link-selected-sorting");
                    }
                    else {
                        item.addClass("dr-link-sorting");
                    }
                },

                stop: function(ev, ui) {
                    var item = $(ui.item);
                    // Remove any styling added when sorting
                    item.removeClass("dr-link-selected-sorting dr-link-sorting");
                    // Since the components have been reordered, the last
                    // component element must be re-obtained
                    self.cacheLastVisibleComponent();
                    // Highlight and navigate to the component
                    item.click();
                    var capTimer = new CapabilityTimer("CAP:MPG Workflow Navigator Component Sort", assocView.getCriterion().category_mean);
                    capTimer.capture();

                    // send a message to the associated view that component order might have changed
                    if (self.getAssociatedView().componentOrderChanged) {
                        self.getAssociatedView().componentOrderChanged();
                    }
                }

            });

            return subSecBodyEle;
        }
        else {
            // No components to show so we can just return a space
            return "&nbsp;";
        }
    }
    catch (error) {
        logger.logJSError(error, null, "detailed-review.js", "generateBodyHTML");
    }
};

/**
 * This function is used to selectively load components as they are
 * selected/scrolled to in the navigator. If the caller passes in the
 * blockingTimeout flag set to true the function will prevent all future calls
 * to this function from processing until the initial call has completed. This
 * function will return true if it has created a timeout function for
 * selectively loading the component.  However there is no guarantee that the
 * function will execute unless the blockingTimeout flag passed in is true and
 * there currently isn't a blocking timeout active.
 * @param {number} startIndx The starting index in the componentArr where
 *     components should be notified that they can begin data retrieval
 * @param {boolean} blockingTimeout The flag that indicates whether the
 *     function will prevent all future calls to this function from processing
 *     until the initial call has completed
 * @param {number} timespan The timeout to apply before
 * @param {boolean} registerTimerInd The flag that indicates whether the
 *     components should be registered in the aggregate timer. This flag should
 *     be only true when the view is being rendered and starting data retrieval
 *     for the first few components.
 * @returns {boolean} True if components will attempt to be selectively loaded,
 *     false if the call is going to be ignored
 */
DetailedReviewSubsection.prototype.loadSelectiveComponents = function(startIndx, blockingTimeout, timespan, registerTimerInd) {
    var self = this;
    // Check to see if there is an existing blocking timeout
    blockingTimeout = blockingTimeout || false;
    if (this.m_blockingComponentLoadTimeout) {
        return false;
    }

    // Set the blocking timeout flag if we need to
    if (blockingTimeout) {
        this.m_blockingComponentLoadTimeout = true;
    }

    // Wrap the contents of this function in a timeout so we don't rapidly fire
    // it
    clearTimeout(this.m_componentLoadTimeout);
    this.m_componentLoadTimeout = setTimeout(function() {
        var associatedMPage = self.getAssociatedView();
        var component = null;
        var componentArr = associatedMPage.getComponents();
        var componentCount = componentArr.length;
        var componentsToLoad = self.m_componentsToLoad;
        var navigatorBody = self.m_subsectionBodyElement;
        var x = 0;

        // retrieve the aggregate timer created from the associated View
        var aggregateTimer = associatedMPage.getAggregateTimer();

        // the number of the components loaded in the initial page load
        var initialComponentCount = 0;

        // Start loading the components until we hit our quota or we run out of
        // components
        for (x = startIndx; x < componentCount; x++) {
            component = componentArr[ x ];
            // Load the component if it is displayable
            if (component.isDisplayable()) {
                if (!component.isLoaded() && ((componentsToLoad > 0) || component.getGapCheckCriteria())) {
                    if (registerTimerInd) {
                        // register the component in the aggregate timer before
                        // data retrieval begins
                        aggregateTimer.registerTask(component.getStyles().getId());
                        // pass the reference of the aggregate timer to the
                        // component, so it will notify the timer when it
                        // finishes loading
                        component.setAggregateTimer(aggregateTimer);
                    }

                    // count the component because it will be loaded
                    initialComponentCount++;
                    associatedMPage.loadSelectedComponent(component);
                    // Remove the hover(title) of the component since it has
                    // been loaded
                    navigatorBody.find("#drNavi" + component.getStyles().getId()).attr("title", "");
                    // Remove the (...) from the component to show that it is
                    // being loaded
                    self.onCountUpdate(component, {
                        count: null
                    });
                }
                componentsToLoad--;
            }
        }

        if (registerTimerInd) {
            // add the number of components to meta data
            aggregateTimer.addMetaData("component.count", componentCount);

            // add the number of initially loaded components to meta data (all
            // components are loaded in initial load)
            aggregateTimer.addMetaData("component.initialLoadCount", initialComponentCount);

            // add the browser context to meta data
            aggregateTimer.addMetaData("browserContext", CERN_Platform.inEdgeContext() ? "Edge" : "IE");

            // Lock the registration when initial loading components are
            // registered.
            aggregateTimer.lockRegistration();
        }

        // Blindly clear the blocking timeout flag
        self.m_blockingComponentLoadTimeout = false;
    }, timespan);
    return true;
};

/**
 * This function is used to handle the special processing required when the
 * user scrolls the contents of the MPages View associated with this Detailed
 * Review subsection.  When then user scrolls the page this function will
 * highlight the correct component in the navigator so the user can visually
 * keep track of where they are in context of the entire page. With the
 * addition of contextual view and components being replaced with placeholder
 * views, the component would not load rather display the placeholder view.
 * @returns {undefined} This function does not return a value
 */
DetailedReviewSubsection.prototype.associatedViewScrollHandler = function() {
    var component = null;
    var components = this.getAssociatedView().getComponents();
    var componentsCnt = components.length;
    var componentEle = null;
    var componentOffset = 0;
    var pixelProximity = 75;
    var x = 0;
    // Checking in the first column now since we have assigned the scroll
    // handler to it.
    var firstColumnDiv = $("#" + this.getAssociatedViewElementId() + " .col1");
    // Check each component and see if it is close to the top of the view
    // container
    for (x = 0; x < componentsCnt; x++) {
        component = components[ x ];
        var compId = component.getStyles().getId();
        var actualCompDiv = firstColumnDiv.find("#" + compId);
        componentEle = actualCompDiv.length ? actualCompDiv : firstColumnDiv.find("#" + compId + "PlaceholderView");
        if (componentEle.length) {
            componentOffset = componentEle.offset().top;

            // If the component is too far scrolled up just continue
            if (componentOffset < 0 && (componentOffset + pixelProximity < 0)) {
                continue;
            }
            // If the component is still within our proximity or it is the next
            // visible component highlight it
            if ((Math.abs(this.m_viewElementOffsetTop - componentOffset) < pixelProximity) || componentOffset > 0) {
                this.attemptPaddingAdjustment();
                // Highlight this component in the navigator
                this.highlightNavigator(component);
                if (this.m_selectiveComponentLoadInd) {
                    this.loadSelectiveComponents(x, false, 250, false);
                }
                break;
            }
        }
    }
};


/**
 * This function renders the View element associated with this subsection.  In
 * addition to rendering that view it also attaches scroll detection to the
 * view and highlights the first component link in the navigation section
 * @returns {undefined} This function does not return a value.
 */
DetailedReviewSubsection.prototype.renderSubsection = function() {
    var self = this;

    // Save off a reference to the subsection body for later use
    this.m_subsectionBodyElement = $("#" + this.getBodyElementId());

    // Call the base class definition of this function
    NavigatorSubsection.prototype.renderSubsection.call(this);
    var viewDiv = $("#" + this.getAssociatedViewElementId());
    // Get the parent container
    var parentViewDiv = viewDiv.parent();
    // Since the first column in the layout contains all the components removing
    // the scroll event handler from the parent container to the first column
    // in the view would prevent shifting of the control from parent to this
    // column when the contextual view is added.
    var firstColumnDiv = viewDiv.find(".col1");
    if (firstColumnDiv.length) {
        firstColumnDiv.height(parentViewDiv.height());
        // Cache the view element offset so we dont have to grab it during the
        // scroll function call
        this.m_viewElementOffsetTop = firstColumnDiv.offset().top;
        // Determine how many components we should attempt to selectively load
        // based on the height of the viewable area
        this.m_componentsToLoad = Math.ceil(firstColumnDiv.height() / this.m_emptyComponentHeightInPixels);
        firstColumnDiv.scroll(function() {
            self.associatedViewScrollHandler();
        });


        // Find the index of the first visible component
        var componentIndex = this.getFirstVisibleComponentIndex();
        if (componentIndex > -1) {
            this.attemptPaddingAdjustment();

            // Highlight the first visible component in the navigator
            var components = this.getAssociatedView().getComponents();
            var component = components[ componentIndex ];
            this.highlightNavigator(component);

            // load the first batch of components and fire the page load timer.
            // It blocks subsequent component loading until the first batch is
            // started.
            this.loadSelectiveComponents(0, true, 0, true);
        }
    }
};

/**
 * Loads the necessary page level menu items based on the content of the
 * detailed review subsection
 * @param {string} pageMenuId The id of the page level menu container element
 *     where the menu items should be injected.
 * @returns {undefined} This function does not return a value.
 **/
DetailedReviewSubsection.prototype.loadWorkflowPageMenuItems = function(pageMenuId) {
    var menuIndex = 0;

    // Have the view create the component selection menu item
    var menuItem = this.getAssociatedView().loadComponentSelection();
    
    // Insert the menu item into the appropriate location
    var pageMenu = MP_MenuManager.getMenuObject(pageMenuId);

    if (pageMenu) {
        if (menuItem && !pageMenu.containsMenuItem(menuItem.getId())) {
            // Insert the component selection menu since it doesn't already exist
            pageMenu.insertMenuItem(menuItem, menuIndex);
        }
        MP_MenuManager.updateMenuObject(pageMenu);
    }
};

/**
 * Perform the resize logic for the detailed review subsection.  Initially the
 * base functionality is called in order to continue the resize calls down to
 * the associated view.  Once that call returns, a new calculation is made in
 * order determine how many components to selectively load within the
 * associated view.
 * @returns {undefined} This function does not return a value.
 */
DetailedReviewSubsection.prototype.resizeSubsection = function() {
    // Call the base class functionality and let it handle the main logic
    NavigatorSubsection.prototype.resizeSubsection.call(this);

    // Determine the number of components to load based on the column containing
    // the components.
    var componentColumnDiv = $("#" + this.getAssociatedViewElementId()).find(".col1");
    if (componentColumnDiv.length) {
        // Determine how many components we should attempt to selectively load
        // based on the height of the viewable area
        this.m_componentsToLoad = Math.ceil(componentColumnDiv.height() / this.m_emptyComponentHeightInPixels);
        componentColumnDiv.scroll();
    }
};
/* eslint-enable mp-camelcase */
/**
 * This function is responsible for flexing the gap-check of components in the associated view of the current detailed review section.
 * If required order is placed it enables gap-checking for admit required components, if those component have their gap-check disabled.
 * If required order is not placed it enables gap-checking for discharge required components, if those
 * component have their gap-check disabled.
 * @param {object} e Event that triggered the function
 * @param {number} isOrderPlaced Flag representing whether required admit order is placed or not.
 * @returns {undefined} This function does not return a value.
 */
/* eslint-disable complexity */
DetailedReviewSubsection.prototype.flexGapCheck = function(e, isOrderPlaced) {
    var components = this.getAssociatedView().getComponents();
    var orderPlaced = isOrderPlaced ? true : false; // eslint-disable-line no-unneeded-ternary
    for(var indx = 0; indx < components.length; indx++){
        if(components[indx].getGapCheckCriteria() === GapCheck.CRITERIA.DISCHARGE && components[indx].getGapCheckRequiredInd() === orderPlaced){
            // discharge required comps. Their requirement for gap-check is inversly related to the order placement.
            components[indx].setGapCheckRequiredInd(!orderPlaced);
            components[indx].updateComponentRequiredIndicator(!orderPlaced);
            this.updateNavigatorGapCheckIcons(components[indx], {});
        }
        else if(components[indx].getGapCheckCriteria() === GapCheck.CRITERIA.ADMIT && components[indx].getGapCheckRequiredInd() === !orderPlaced){
            // admit required comps. Their requirement for gap-check is directly related to the order placement.
            components[indx].setGapCheckRequiredInd(orderPlaced);
            components[indx].updateComponentRequiredIndicator(orderPlaced);
            this.updateNavigatorGapCheckIcons(components[indx], {});
        }
        else if(components[indx].getGapCheckCriteria() === GapCheck.CRITERIA.ALL && !components[indx].getGapCheckRequiredInd()){
            // Always required comps. Their requirement for gap-check is independent to the order placement.
            components[indx].setGapCheckRequiredInd(true);
            components[indx].updateComponentRequiredIndicator(true);
            this.updateNavigatorGapCheckIcons(components[indx], {});
        }
    }
};
/* eslint-enable no-unused-vars*/
/* globals NavigatorSubsection, CapabilityTimer, ContextMenu, MpageDocumentationComponent, BroadcastDispatcher*/

/**
 * A constructor used to create a new Create Note Subsection object and
 * initialize subsection level variables.
 * @constructor
 */
var CreateNoteSubsection = function() {
    this.setName("Create Note");
    this.setHasAssociatedView(false);
    this.m_subsectionBodyElement = null;
    this.m_createNoteSecEnabled = null;
    this.m_filterObj = null;
    this.m_noteTypeFilterObj = null;
    this.m_noteTypeGrouperObj = null;
    this.m_noteTypesArr = null;
    this.m_components = null;
    this.associationLinkTimer = null;
    this.m_duplicateDocTable = null;
    this.m_noteId = null;
    this.m_existingNoteDetails = null;
    this.m_gapCheckInd = null;
    this.m_isSectionEnabled = false;
    this.m_isOrderPlaced = null;
    this.m_isDocumentationInView = false;
};
/**
 * Setup the prototype and constructor to inherit from the base NavigatorSubsection
 */
CreateNoteSubsection.prototype = new NavigatorSubsection();
CreateNoteSubsection.prototype.constructor = NavigatorSubsection;
/**
 * Adds two listeners. First one for listeners populating a list of components in current view and
 * second one for updating create-note display depending stability of CKEditors of DynDoc components
 * @returns {undefined} The function does not return a value
 */
CreateNoteSubsection.prototype.listenForComponentsInView = function() {
    CERN_EventListener.addListener(this, EventListener.EVENT_COMPONENTS_IN_VIEW, this.setComponentsInView, this);
    CERN_EventListener.addListener(this, EventListener.EVENT_DYN_DOC_COMP_CKEDITOR_STABLE, this.updateDynDocStabilityStatus, this);
    CERN_EventListener.addListener(this, EventListener.EVENT_DOCUMENTATION_COMPONENTS_IN_VIEW, this.enableDocumentationComponentsInView, this);
};
/**
 * Sets the components in view after listening the event fired from the DetailedReviewSubsection
 * @param {Object} event -  The event fired from detailedReviewSubsection to get the components
 * @param {Object} args - The argument attached to the event
 * @returns {undefined} The function does not return a value
 */
CreateNoteSubsection.prototype.setComponentsInView = function(event, args) {
    if (args.workflowViewId === this.getWorkflowViewId()) {
        // We do not filter in Dyn doc components as gap-check might need the rest of them.
        this.m_components = args.componentsInView;
    }
};
/**
 * Indicates that there are documentation components that must be saved before creating a new note
 */
CreateNoteSubsection.prototype.enableDocumentationComponentsInView = function() {
    this.m_isDocumentationInView = true;
};
/**
 * This function overrides the hasBodyElement function of NavigatorSubsection.
 * It first checks whether dyndoc is enabled in the domain. If not, then it returns false.
 * If true it checks for the notetype/template pair filter and if any dyndoc components are present in the view.
 * If either of the two conditions satisfies then it returns true.
 * @returns {boolean} True if the subsection has a body element, false otherwise.
 */
CreateNoteSubsection.prototype.hasBodyElement = function() {
    if (!CERN_Platform.inMillenniumContext()) {
        return false;
    }
    if (this.isTemplateAssociationPresent() || this.isDynDocComponentPresent()) {
        return true;
    }
    return false;
};
/**
 * This function checks whether any dyn doc component is present in the view.
 * @returns {boolean} True if any component is present, false otherwise.
 */
CreateNoteSubsection.prototype.isDynDocComponentPresent = function() {
    // If the MpageDocumentationComponent isn't defined we don't have any DynDoc components
    if (typeof MpageDocumentationComponent === "undefined") {
        return false;
    }

    // Check if orion components are present in the view
    if (this.m_isDocumentationInView) {
        return true;
    }

    // Check if dynamic documentation components are present in the view
    return this.m_components.some(function(component) {
        return (component instanceof MpageDocumentationComponent && component.isDisplayable());
    });
};
/* eslint-disable complexity*/
/**
 * This function checks whether a notetype/template association is present as selected in the bedrock filter
 * @returns {boolean} True if notetype/template association is present, false otherwise.
 */
CreateNoteSubsection.prototype.isTemplateAssociationPresent = function() {
    var criterion = this.getCriterion();
    var filterObj = null;
    var isTemplateConfigured = false;
    // Retrieve page level filters
    var resourceName = criterion.category_mean + "pageLevelFilters";
    var pageLevelFilters = MP_Resources.getSharedResource(resourceName);
    // If filters are present then check for notetype/template associations
    if (pageLevelFilters && pageLevelFilters.isResourceAvailable()) {
        var plFilters = pageLevelFilters.getResourceData();
        var plFiltersLen = plFilters.length;
        if (plFiltersLen > 0) {
            // At this point, the codes are already available, so get the data
            for (var index = 0, filterCount = 0; index < plFiltersLen; index++) {
                filterObj = plFilters[index];
                switch(filterObj.F_MN) {
                    case "WF_NOTE_TYPE_ALERT":
                    // Passes the filter object to the global variable to be used for rendering later.
                        this.m_noteTypeFilterObj = filterObj;
                        filterCount++;
                        break;
                    case "WF_NOTE_TEMPLATE_PAIR":
                    // Passes the filter object to the global variable to be used for rendering later.
                        this.m_filterObj = filterObj;
                        filterCount++;
                        isTemplateConfigured = true;
                        break;
                    case "WF_NOTE_TEMPLATE_PAIR_SEQ":
                        this.m_noteTypeGrouperObj = filterObj;
                        filterCount++;
                        break;
                }
                if(filterCount > 2) {
                    break;
                }
            }
        }
    }
    return isTemplateConfigured;
};
 /**
 * Convert/Format the date and time to a required displayable format using the dateFormat function
 * @param {string} dateValue The date which needs to be formatted.  Passed in as a ISO8601 formatted string
 * @param {string} dateFormat The date format which needs to be displayed
 * @param {string} timeFormat The HH::MM time format which needs to be displayed
 * @returns {string} The date formatted based on the locale
 */
CreateNoteSubsection.prototype.formatDateTime = function(dateValue, dateFormat, timeFormat) {
    var dateTime = new Date();
    dateTime.setISO8601(dateValue);
    return dateTime.format(dateFormat) + "  " + dateTime.format(timeFormat);
};
/**
 * Creates the warning banner that will be displayed in the Duplicate DynDoc Validation window, when user clicks on a associated notetype which has already got existed instance for encounter.
 * @param {string}  alertbannerSecText the value of secondary warning.
 * @returns {Object}  The alert banner object with warning indication and warning text needed.
 */
CreateNoteSubsection.prototype.createWarningBanner = function(alertbannerSecText) {
    var dynDocDialogi18n = i18n.discernabu.create_note_i18n;
    var alertBanner = new MPageUI.AlertBanner(); // eslint-disable-line no-undef
    alertBanner.setType(MPageUI.ALERT_OPTIONS.TYPE.WARNING); // eslint-disable-line no-undef
    alertBanner.setPrimaryText(dynDocDialogi18n.ALERT_WARNING_PRIMARY_TEXT);
    alertBanner.setSecondaryText(alertbannerSecText);
    return alertBanner.render();
};


/**
 * Creates the DynDoc Validation Modal dialog with three action buttons
 * @param {object} existingDocDetails : Holds the reply object having details of last actioned document for encounter.
 * @param {function} callBackHandler : the function actually intended to be called on the click event.
 * @returns {undefined}  This function does not return a value.
 */
CreateNoteSubsection.prototype.launchDuplicateDocumentAlertDialog = function(existingDocDetails, callBackHandler) {
    var self = this;
    var criterion = self.getCriterion();
    var categoryMean = criterion.category_mean;
    var modalDialogId = "DynDocAlertModalDlg" + categoryMean;
    var continueBtnId = "continueExisting" + categoryMean;
    var continueBtn = null;
    var createNotei18n = i18n.discernabu.create_note_i18n;
    var documentAlertDialog = MP_ModalDialog.retrieveModalDialogObject(modalDialogId);
    var alertbannerText = null;
    var alertHeaderText = null;
    if (!documentAlertDialog) {
        documentAlertDialog = new ModalDialog(modalDialogId).setLeftMarginPercentage(13).setTopMarginPercentage(10).setRightMarginPercentage(13).setIsBodySizeFixed(false).setIsFooterAlwaysShown(true);
        documentAlertDialog.setShowCloseIcon(true);
        // Create the modal Continue button
        continueBtn = new ModalButton(continueBtnId);
        continueBtn.setFocusInd(true).setText(createNotei18n.ALERT_CONTINUEDOC_BTN);
        documentAlertDialog.addFooterButton(continueBtn);
        var cancelBtn = new ModalButton("cancelOverrideModal" + categoryMean);
        cancelBtn.setCloseOnClick(true).setText(createNotei18n.ALERT_CANCEL_BTN);
        documentAlertDialog.addFooterButton(cancelBtn);
    }
    if(existingDocDetails.length > 1){
        alertbannerText = createNotei18n.ALERT_WARNING_GROUPED_SECONDARY_TEXT;
        alertHeaderText = createNotei18n.ALERT_MSG_HEADER_GROUPED_NOTES;
    }
    else{
        alertbannerText = createNotei18n.ALERT_WARNING_SECONDARY_TEXT;
        alertHeaderText = createNotei18n.ALERT_MSG_HEADER;
    }
    documentAlertDialog.setHeaderTitle(alertHeaderText);
    documentAlertDialog.setBodyDataFunction(function(modalObj) {
        var dialogBodyHtml = [];
        var alertbannerHTML = self.createWarningBanner(alertbannerText);
        dialogBodyHtml.push(alertbannerHTML);
        var existingDocArr = self.processDuplicateDocTableResults(existingDocDetails);
        var duplicateDocTable = self.createDuplicateDocTable(existingDocArr);
        self.m_duplicateDocTable = duplicateDocTable;
        dialogBodyHtml.push("<div class='create-note-dupdoc-table wf' id='" + categoryMean + "createNoteDupdocTable'>" + duplicateDocTable.render() + "</div>");
        dialogBodyHtml.push("<br/><dl>");
        dialogBodyHtml.push("<dd class='create-note-dupdoc-alert-message'>" + createNotei18n.ALERT_MSG_CONTINUE_EXIS_BODY + "</dd><dd class='create-note-dupdoc-alert-message create-note-dupdoc-alert-message-bottom'>" + createNotei18n.ALERT_MSG_CREATE_NEW_BODY + "</dd></dl>");
        dialogBodyHtml.push("</div>");
        modalObj.setBodyHTML(dialogBodyHtml.join(""));
        duplicateDocTable.finalize();
    });
    continueBtn = documentAlertDialog.getFooterButton(continueBtnId);
    continueBtn.setOnClickFunction(function() {
        var existingNoteTimer = new CapabilityTimer("CAP:MPG.CREATE_NOTE_DUPLICATE_DOCUMENTS_ALERT_CONTINUE", categoryMean);
        var existingnotesArr = self.processDuplicateDocResults();
        existingNoteTimer.addMetaData("rtms.legacy.metadata.1", "Existing Notes count: " + existingnotesArr.noteIds.length);
        existingNoteTimer.capture();
        callBackHandler("continueExisting", existingnotesArr);
    });
    // Create/launch Modal Dialog Box
    MP_ModalDialog.updateModalDialogObject(documentAlertDialog);
    MP_ModalDialog.showModalDialog(modalDialogId);
    self.resizeDuplicateDocAlertTable();
    $("#DynDocAlertModalDlg" + categoryMean + "header").css("border-bottom", "0");
    $("#DynDocAlertModalDlg" + categoryMean + "body").css("margin", "0");
    $("#DynDocAlertModalDlg" + categoryMean + "body .alert-msg").css("padding", "0");
    $("#DynDocAlertModalDlg" + categoryMean + "body .alert-icon").addClass("create-note-alert-iconAlign");
};
/**
 * Process and stores dulicate documents selected in modified state
 * @returns {object}  Returns an objects with existing notetype details.
 */
CreateNoteSubsection.prototype.processDuplicateDocResults = function(){
    var self = this;
    var criterion = self.getCriterion();
    var categoryMean = criterion.category_mean;
    var openExistingNoteObj = $("#DynDocAlertModalDlg" + categoryMean + "body").find(".open-existing-note-button");
    var existingDocObj = {
        eventIds: [],
        noteIds: []
    };
    // iterating through the list of modified radio buttons
    openExistingNoteObj.each(function(){
        var currentObj = $(this);
        if (currentObj.prop("checked")) {
            existingDocObj.eventIds.push(currentObj.attr("event-id"));
            existingDocObj.noteIds.push(currentObj.attr("note-type-id"));
        }
    });
    return existingDocObj;
};

/**
 * Process the existingDocDetails object and store it in array , to be used by duplicate doc component table
 * @param {object} existingDocDetails : Holds the reply object having details of last actioned document for encounter.
 * @returns {array}  returns the currentNoteArr
 */
CreateNoteSubsection.prototype.processDuplicateDocTableResults = function(existingDocDetails) {
    var self = this;
    var createNotei18n = i18n.discernabu.create_note_i18n;
    var existingDocArr = [];
    for (var x = 0; x < existingDocDetails.length; x++) {
        var data = existingDocDetails[x];
        if (data && data.EVENT_ID !== 0.0) {
            var existingDocObj = {};
            var actionsHTML = "<div class='search-button'><input  class='open-existing-note-button create-note-radio-buttons' note-type-id='" + data.NOTE_TYPE_ID + "' event-id='" + data.EVENT_ID + "'  type='radio' name='open-existing-note" + x + "'  value='openExistingNote' checked><span class='duplicate-doc-actions-name'>" + createNotei18n.ALERT_EXISTDOC_BTN + "</span><span class='create-note-button-spacing'></span><input  class='create-newnote-button create-note-radio-buttons' type='radio' name='open-existing-note" + x + "'  value='createNewNote'><span class='duplicate-doc-actions-name'>" + createNotei18n.ALERT_NEWDOC_BTN + "</span></div>";
            var lastUpdateDtTm = self.formatDateTime(data.CLINSIG_UPDT_DT_TM, "mediumDate", "shortTime");
            existingDocObj.UPDT_DT_TM = lastUpdateDtTm;
            existingDocObj.DOCUMENT_TYPE = data.DOCUMENT_TYPE;
            existingDocObj.AUTHOR = data.AUTHOR;
            existingDocObj.ACTIONS = actionsHTML;
            existingDocArr.push(existingDocObj);
        }
    }
    return existingDocArr;
};
CreateNoteSubsection.prototype.resizeDuplicateDocAlertTable = function() {
    var self = this;
    var criterion = self.getCriterion();
    var categoryMean = criterion.category_mean;
    var dynDocAlertModalDlgBody = $("#DynDocAlertModalDlg" + categoryMean + "body");
    var duplicateDocTable;
    var maxHeight;
    var searchTableHeight = 105 + "px";
    duplicateDocTable = $("#" + categoryMean + "createNoteDupdocTable");
    maxHeight = searchTableHeight;
    if (dynDocAlertModalDlgBody.length && self.m_duplicateDocTable) {
        duplicateDocTable.find(".content-body").css({
            "max-height": maxHeight,
            "overflow-y": "auto",
            "box-sizing": "border-box"
        });
        self.m_duplicateDocTable.updateAfterResize();
    }
};
/**
 * Creates the Dupicate document notes table to be displayed in alert dialog
 * @param {object} existingDocArr : Holds the details of last modified notetypess.
 * @returns {object}  returns the duplicateDocTable object
 */
CreateNoteSubsection.prototype.createDuplicateDocTable = function(existingDocArr){
    var criterion = this.getCriterion();
    var categoryMean = criterion.category_mean;
    var createNotei18n = i18n.discernabu.create_note_i18n;
    // setup the table
    var duplicateDocTable = new ComponentTable();
    duplicateDocTable.setNamespace(categoryMean + "duplicateDocTable");
    var duplicateNote = new TableColumn();
    duplicateNote.setColumnId("duplicateNote");
    duplicateNote.setCustomClass("create-note-dup-doc-duplicate-note");
    duplicateNote.setColumnDisplay(createNotei18n.DUPLICATE_NOTE);
    duplicateNote.setRenderTemplate("<span>${DOCUMENT_TYPE} </span>");

    var lastUpdated = new TableColumn();
    lastUpdated.setColumnId("lastUpdated");
    lastUpdated.setCustomClass("create-note-dupdoc-last-updated");
    lastUpdated.setColumnDisplay(createNotei18n.LAST_UPDATED);
    lastUpdated.setRenderTemplate("<span>${UPDT_DT_TM} </span>");

    var lastUpdatedBy = new TableColumn();
    lastUpdatedBy.setColumnId("lastUpdatedBy");
    lastUpdatedBy.setCustomClass("create-note-dupdoc-last-updated-by");
    lastUpdatedBy.setColumnDisplay(createNotei18n.LAST_UPDATED_BY);
    lastUpdatedBy.setRenderTemplate("<span> ${AUTHOR} </span>");

    var actionsCol = new TableColumn();
    actionsCol.setColumnId("actionsCol");
    actionsCol.setCustomClass("create-note-dupdoc-actions");
    actionsCol.setColumnDisplay(createNotei18n.ACTIONS);
    actionsCol.setRenderTemplate("<span> ${ACTIONS} </span>");

    // add columns to table
    duplicateDocTable.addColumn(duplicateNote);
    duplicateDocTable.addColumn(lastUpdated);
    duplicateDocTable.addColumn(lastUpdatedBy);
    duplicateDocTable.addColumn(actionsCol);

    // set the table to the provided Json
    duplicateDocTable.bindData(existingDocArr);
    return duplicateDocTable;
};

/**
 * Gets the last action details of Duplicate notetype validated from bedrock.
 * @param {Number} noteId : Holds the value of NoteType sequenceId of NoteType links clicked from Associated links.
 * @param {Function} callBackHandler:  The function to be called upon a request returning.
 * @returns {undefined}  This function does not return a value.
 */
CreateNoteSubsection.prototype.getDuplicateNote = function(noteId, callBackHandler) {
    var self = this;
    var criterion = this.getCriterion();
    var personId = criterion.person_id;
    var encounterId = criterion.encntr_id;
    var mappedNoteTypes = this.m_noteTypeFilterObj;
    var notesLength = mappedNoteTypes.VALS.length;
    var eventSetCds = [];
    for (var index = 0; index < notesLength; index++) {
        eventSetCds.push(mappedNoteTypes.VALS[index].PE_ID);
    }
    var selectedNotes = this.m_noteTypesArr[noteId];
    var noteTypeIds = [];
    // Filtering out duplicate notetype ids
    if (selectedNotes) {
        for (var i = 0; i < selectedNotes.values.length; i++) {
            var noteTypeId = selectedNotes.values[i].PE_ID;
            if (noteTypeIds.indexOf(noteTypeId) === -1) {
                noteTypeIds.push(noteTypeId);
            }
        }
    }
    var existingDocumentDetails = [];
    var noteTypeIdArr = MP_Util.CreateParamArray(noteTypeIds, 1);  // eslint-disable-line new-cap
    var mappedEventCds = MP_Util.CreateParamArray(eventSetCds, 1); // eslint-disable-line new-cap
    var sendAr = [ "^MINE^", personId, encounterId, mappedEventCds, noteTypeIdArr ];
    var scriptRequest = new ScriptRequest().setProgramName("mp_validate_duplicate_document");
    scriptRequest.setParameterArray(sendAr);
    scriptRequest.setResponseHandler(function(reply) {
        if (reply.getStatus() === "S") {
            existingDocumentDetails = reply.getResponse().EXISTING_NOTES;
        }
        if (existingDocumentDetails.length) {
            self.launchDuplicateDocumentAlertDialog(existingDocumentDetails, callBackHandler);
        }
        else{
            callBackHandler("openNew");
        }
    });
    scriptRequest.performRequest();
};
/* eslint-enable complexity*/
/**
 * Generate the HTML for the subsection body.
 * @returns {jQuery} The HTML which will be inserted into the subsection body
 */
CreateNoteSubsection.prototype.generateBodyHTML = function() {
    var createNotei18n = i18n.discernabu.create_note_i18n;
    var subSectionId = this.getSubsectionId();
    // The jQuery element for Create Note label
    var createNoteEle = $("<div class='create-note-label'>" + createNotei18n.CREATE_NOTE + "</div>");
    this.m_noteTypesArr = [];
    // creating note type filters from grouped notetype and single note typeglobal variable
    this.createNoteTypesFilter(this.m_noteTypeGrouperObj, true);
    this.createNoteTypesFilter(this.m_filterObj, false);

    // jQuery element for Select Other Note link
    CERN_EventListener.addListener(this, EventListener.EVENT_ADMT_ORDER_PLACED + this.getCriterion().category_mean, this.setOrderStatus, this);
    this.m_subsectionBodyElement = $("<div class='create-note' id='" + subSectionId + "'></div>");
    this.m_subsectionBodyElement.append(createNoteEle);
    this.displayAllTemplateAssociations();
    return this.m_subsectionBodyElement;
};
/**
 * Processs the noteTypeAssociation object and assign it to m_noteTypesArr for creating the notetype sequence.
 * @param {object} filterObj : Holds the value of NoteType noteTypeAssociation or NoteType Group.groupedInd
 * @param {boolean} groupedInd : Holds the grouped indicator value.
 * @returns {undefined}  This function does not return a value.
 */
CreateNoteSubsection.prototype.createNoteTypesFilter = function(filterObj, groupedInd) {
    if(filterObj) {
        var i = 0;
        var filterObjCount = 0;
        var filters = null;
        var filter = null;
        filterObjCount = filterObj.VALS.length;
        filters = filterObj.VALS;
        var allNoteTypes = this.m_noteTypesArr;
        var noteTypesLength = allNoteTypes.length;
        for ( i = 0; i < filterObjCount; i++ ){
            if ( !allNoteTypes[((noteTypesLength - 1) + filters[i].G_SQ)]) {
                var arrPosIndex = ((noteTypesLength - 1 ) + filters[i].G_SQ);
                filter = {
                    id: arrPosIndex,
                    displayName: filters[i].FTXT,
                    values: [],
                    isGrouped: groupedInd
                };
                allNoteTypes[arrPosIndex ] = filter;
            }
            else {
                filter = allNoteTypes[(noteTypesLength - 1) + filters[i].G_SQ];
            }
            filter.values.push(filters[i]);
        }
    }
};
/**
 * Displays the Create Note subsection along with notetype/template associations and Groups defined in bedrock.
 * @returns {undefined} This function does not return a value
 */
 /* eslint-disable complexity*/
CreateNoteSubsection.prototype.displayAllTemplateAssociations = function() {
    var categoryMean = this.getCriterion().category_mean;
    var subSectionId = this.getSubsectionId();
    var totalNoteTypes = this.m_noteTypesArr;
    var count = totalNoteTypes.length;
    this.associationLinkTimer = new CapabilityTimer("CAP:MPG_CREATE_NOTE_SELECT_TEMPLATE_ASSOCIATION", categoryMean);
    var createNotei18n = i18n.discernabu.create_note_i18n;
    var selectOtherNoteEle = null;
    var faceUpLinksCount = 5;
    var patternEle = null;
    var groupedFlag = false;
    var displayLength = count < faceUpLinksCount ? count : faceUpLinksCount;
    for (var i = 0; i < displayLength; i++) {
        if (totalNoteTypes[i].isGrouped) {
            groupedFlag = true;
            patternEle = $("<div class='create-note-assoc-link create-note-disabled create-note-ptrnEle' id='" + totalNoteTypes[i].id + "'><span class='create-note-grouper-icon-space create-note-grouper-icon'></span><span class='create-note-grouper-margin'>" + totalNoteTypes[i].displayName + "</span></div>");
        }
        else if (groupedFlag) {
            patternEle = $("<div class='create-note-assoc-link create-note-disabled create-note-ptrnEle ' id='" + totalNoteTypes[i].id + "'><span class='create-note-grouper-icon-space'></span><span class='create-note-grouper-margin'>" + totalNoteTypes[i].displayName + "</span></div>");
        }
        else {
            patternEle = $("<div class='create-note-assoc-link create-note-disabled create-note-ptrnEle ' id='" + totalNoteTypes[i].id + "'>" + totalNoteTypes[i].displayName + "</div>");
        }
        this.m_subsectionBodyElement.append(patternEle);
    }
    // If notetype/template associations are more than the value of faceUpLinksCount then a context menu is added otherwise Select Other Note link is displayed below the notetype/template associations
    if (count > faceUpLinksCount) {
        var moreEle = null;
        if (groupedFlag) {
            moreEle = $("<div id = 'createMoreNotesContextMenu" + categoryMean + "' class='create-note-more-link create-note-disabled'><span class='create-note-grouper-icon-space'></span><span class='create-note-grouper-margin'>" + createNotei18n.MORE + "</span><span class='create-note-more-down-link'></span></div>");
        }
        else {
            moreEle = $("<div id = 'createMoreNotesContextMenu" + categoryMean + "' class='create-note-more-link create-note-disabled'>" + createNotei18n.MORE + "<span class='create-note-more-down-link'></span></div>");
        }
        this.m_subsectionBodyElement.append(moreEle);
        return;
    }
    if (groupedFlag){
        selectOtherNoteEle = $("<div class='create-note-assoc-link create-note-disabled' id='" + subSectionId + "selOtherNote'><span class='create-note-grouper-icon-space'></span><span class='create-note-grouper-margin'>" + createNotei18n.SELECT_OTHER_NOTE + "</span></div>");
    }
    else{
        selectOtherNoteEle = $("<div class='create-note-assoc-link create-note-disabled' id='" + subSectionId + "selOtherNote'>" + createNotei18n.SELECT_OTHER_NOTE + "</div>");
    }
    this.m_subsectionBodyElement.append(selectOtherNoteEle);
};
/**
 * Enables the subsection if-
 * -> it already hasn't been enabled and,
 * -> there are no Dyn Doc components present and displayable in current view, or if they are, all are stable and,
 * -> either Gap-check is not required in current view, or if it is required, orderPlaced flag has been updated.
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.enableSubsection = function() {
    if(!this.m_isSectionEnabled &&
        (!this.isDynDocComponentPresent() || this.areAllDynDocComponentsStable()) &&
        (!this.isGapCheckRequired() || this.m_isOrderPlaced !== null)) {

        // Before attaching the events, clear the previous events.
        this.removeClickHandlers();
        this.attachListeners();
        $("#" + this.getSubsectionId()).children().removeClass("create-note-disabled");
        this.m_isSectionEnabled = true;
    }
};
/**
 * Disables the subsection and sets the corresponding flag to false.
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.disableSubsection = function() {
    this.removeClickHandlers();
    $("#" + this.getSubsectionId()).children().addClass("create-note-disabled");
    this.m_isSectionEnabled = false;
};
/**
 * Updates the flag representing whether the admit order mapped in page level filter is placed on patient profile or not. Attempts to enable the subsection after setting of the flag.
 * @param {object} e - The event that fired the function
 * @param {number} isOrderPlaced - Number indicating whether required order is placed or not (0-No, 1-Yes)
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.setOrderStatus = function(e, isOrderPlaced){
    this.m_isOrderPlaced = isOrderPlaced;
    this.enableSubsection();
};
/**
 * Loops through the components array and checks if the CKEditors of all Dyn Doc components are stable or not.
 * @returns {Boolean} Returns true if all CKeditors in current view are stable; false if at least one CKEditor is unstable.
 */
CreateNoteSubsection.prototype.areAllDynDocComponentsStable = function() {
    var componentArray = this.m_components;
    var compObj = null;
    var editor = null;
    for (var componentIndex = componentArray.length; componentIndex--; ) {
        compObj = componentArray[ componentIndex ];
        if (compObj instanceof MpageDocumentationComponent) {
            editor = compObj.getEditorInstance();
            if(editor && editor.refreshState && editor.refreshState !== "stable"){
                return false;
            }
        }
    }
    return true;
};
/**
 * Handler for enabling/disabling the create-note section depending on CKEditor stability state of dyn doc component(s).
 * @param {object} e - The event that fired the function
 * @param {Boolean} isStable - Flag indicating whther the CKEditor of the component that fired this event is stable or not.
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.updateDynDocStabilityStatus = function(e, isStable) {
    // If the current CKEditor is not stable disable the section.
    if(!isStable){
        this.disableSubsection();
        return;
    }
    this.enableSubsection();
};
/**
 * Attempts to enable the subsection.
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.postProcessing = function() {
    this.enableSubsection();
};
/**
 * Attaches click listeners for the subsection links.
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.attachListeners = function() {
    var self = this;
    var faceUpLinksCount = 5;
    var selectedNoteTypeId = 0;
    var categoryMean = this.getCriterion().category_mean;
    var subSectionId = this.getSubsectionId();
    // Click function of Select Other Note link
    $("#" + subSectionId + "selOtherNote").click(function() {
        self.createNewNote(null);
    });

    if (this.m_noteTypesArr && this.m_noteTypesArr.length) {
        $( "#" + subSectionId ).on( "click", ".create-note-ptrnEle", function(){
            selectedNoteTypeId = $(this).attr("id");
            self.createNewNote(selectedNoteTypeId);
        });
    }
    $("#createMoreNotesContextMenu" + categoryMean).click(function() {
        self.createMoreNotesContextMenu(faceUpLinksCount, $(this), self.m_noteTypesArr);
    });
};
/**
 * Removes all click listeners from the create-note section.
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.removeClickHandlers = function() {
    var subSectionId = this.getSubsectionId();
    $("#" + subSectionId + "selOtherNote").off("click");
    $( "#" + subSectionId ).off( "click", ".create-note-ptrnEle");
    $("#createMoreNotesContextMenu" + this.getCriterion().category_mean).off("click");
};

/* eslint-disable complexity*/
/**
 * Saves dirty DocumentationBase components within current create note subsection
 * @param {number} noteId - The current selected notetype/grouper sequence
 * @param {Array<object>} dirtyComponents- The dirty components that needs to be saved
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.saveDirtyComponents = function(noteId, dirtyComponents) {
    var self = this;
    var dirtyDatai18n = i18n.discernabu.create_note_i18n;
    var saveModal = null;
    var staleModal = null;
    var cancelModalBtn = null;
    var saveModalBtn = null;
    var okModalBtn = null;
    var gapCheckStatus = self.isGapCheckRequired();
    var saveComponentRequests = [];
    var unsavedComponents = "";
    var failedResponses = [];
    var failedDueToStaleWorkflowComponents = [];
    var unsavedComponentsArray = [];
    // Update Modal box to saving in progress state
    saveModal = MP_Util.generateModalDialogBody("DirtyDataDialog", "busy", dirtyDatai18n.SAVING, "");
    saveModal.setHeaderTitle(dirtyDatai18n.UNSAVED_DOCUMENTATION);
    // Create the modal save (retry) button if it isn't already defined
    if (!saveModal.getFooterButton("saveDirtyModal")) {
        saveModalBtn = new ModalButton("saveDirtyModal");
        saveModalBtn
            .setFocusInd(true)
            .setCloseOnClick(false)
            .setText(dirtyDatai18n.SAVE_BTN);
        saveModalBtn.setOnClickFunction(function() {
            self.saveDirtyComponents(noteId, dirtyComponents);
        });
        saveModal.addFooterButton(saveModalBtn);
    }
    // Create the modal cancel button if it isn't already defined
    if (!saveModal.getFooterButton("cnlModal")) {
        cancelModalBtn = new ModalButton("cnlModal");
        cancelModalBtn.setText(dirtyDatai18n.CANCEL_BTN);
        saveModal.addFooterButton(cancelModalBtn);
    }
    MP_ModalDialog.updateModalDialogObject(saveModal);
    MP_ModalDialog.showModalDialog("DirtyDataDialog");
    saveComponentRequests = dirtyComponents.map(function(dirtyComponent) {
        return new Promise(function(callback) {
            dirtyComponent.save(callback);
        });
    });
    Promise.all(saveComponentRequests).then(function(componentSaveResponses) {
        failedResponses = componentSaveResponses.filter(function(componentSaveResponse) {
            return componentSaveResponse.status !== "S";
        });

        if (failedResponses.length === 0) {
            MP_ModalDialog.closeModalDialog("DirtyDataDialog");
            if (gapCheckStatus) {
                self.triggerGapChecking(noteId);
            }
            else {
                self.openDynDocEditor(noteId);
            }
        }
        else {
            failedDueToStaleWorkflowComponents = failedResponses.filter(function(componentSaveResponse) { // filter components that have failed due to stale data
                return componentSaveResponse.isStaleWorkflow === true;
            });

            if(failedResponses.length === failedDueToStaleWorkflowComponents.length) { // all the components have failed due to stale data
                // get the names of the components that have failed
                unsavedComponentsArray = failedDueToStaleWorkflowComponents.map(function(staleWorkflowComponent) {
                    return staleWorkflowComponent.component.getLabel();
                });
                unsavedComponents = "<br>" + unsavedComponentsArray.join("<br>");

                MP_ModalDialog.closeModalDialog("DirtyDataDialog");
                // error Dialog box saying something didn't save correctly
                staleModal = MP_Util.generateModalDialogBody("StaleDataDialog", "", dirtyDatai18n.FAILED_TO_SAVE_MSG_HEADER_STALE_DATA + unsavedComponents + "<br>" + dirtyDatai18n.FAILED_TO_SAVE_MSG_BODY_STALE_DATA);
                staleModal.setHeaderTitle(dirtyDatai18n.FAILED_TO_SAVE_STALE_DATA);
                // Create the modal OK button if it isn't already defined
                if (!staleModal.getFooterButton("okModal")) {
                    okModalBtn = new ModalButton("okModal");
                    okModalBtn.setText(dirtyDatai18n.OK);
                    staleModal.addFooterButton(okModalBtn);
                }
                MP_ModalDialog.updateModalDialogObject(staleModal);
                MP_ModalDialog.showModalDialog("StaleDataDialog");
            }
            else { // atleast one component has failed due to service
                saveModal = MP_Util.generateModalDialogBody("DirtyDataDialog", "", dirtyDatai18n.FAILED_TO_SAVE_MSG_HEADER_SERVICE, dirtyDatai18n.FAILED_TO_SAVE_MSG_BODY_SERVICE);
                saveModal.setFooterButtonText("saveDirtyModal", dirtyDatai18n.RETRY_BTN);
                saveModal.setHeaderTitle(dirtyDatai18n.FAILED_TO_SAVE_SERVICE);
                saveModal.setFooterButtonDither("saveDirtyModal", false);
                // Create/launch Modal Dialog Box
                MP_ModalDialog.updateModalDialogObject(saveModal);
                MP_ModalDialog.showModalDialog("DirtyDataDialog");
            }
        }
    });
};

/* eslint-enable complexity*/
/**
 * This function is used to gather the dynamic documentation components which are dirty;
 * @returns {Array} dirtyComps Array of dirty MpageDocumentationComponent instances associated to current subsection view
 */
CreateNoteSubsection.prototype.gatherDirtyComponents = function() {
    var editor = null;

    // If the MpageDocumentationComponent isn't defined we don't have any DynDoc components
    if (typeof MpageDocumentationComponent === "undefined") {
        return [];
    }

    return this.m_components
        .filter(function(component) {
            return (component instanceof MpageDocumentationComponent);
        })
        .filter(function(dynDocComponents) {
            editor = dynDocComponents.getEditorInstance();
            return (editor !== null && typeof editor.getAutosaveData !== "undefined"
                && typeof editor.isEditorDirty !== "undefined" && editor.isEditorDirty());
        });
};

/**
 * This method will find if at least one component is marked as required in the view and sets the gap check indicator.
 * @returns {boolean} The function will return true if there is a required component in the view else returns false
 */
CreateNoteSubsection.prototype.isGapCheckRequired = function() {
    if (this.m_gapCheckInd === null) {
        var components = this.m_components;
        var componentCount = components.length;
        // Initially set it to false
        this.m_gapCheckInd = false;
        for (var i = 0; i < componentCount; i++) {
            if (components[ i ].getGapCheckCriteria()) {
                this.m_gapCheckInd = true;
                break;
            }
        }
    }
    return this.m_gapCheckInd;
};
/**
 * The triggerGapChecking function is the click function responsible for triggering the Gap Check verification * by calling GapCheck.prototype.performGapCheck function.
 * Throws error is the gap-check shared resource wasn't properlyinitialized
 * @param {number} noteId - The current sequence of notetype/grouper selected
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.triggerGapChecking = function(noteId) {
    var self = this;
    var components = this.m_components;
    var resourceName = this.getWorkflowViewId() + "gapCheckResource";
    var gapCheckResourceData = null;
    var gapCheckResource = MP_Resources.getSharedResource(resourceName);
    if (gapCheckResource && gapCheckResource.isResourceAvailable() && gapCheckResource.getResourceData()) {
        gapCheckResourceData = gapCheckResource.getResourceData();
        gapCheckResourceData.performGapCheck(components, this.m_isOrderPlaced, function() { // eslint-disable-line new-cap
            self.openDynDocEditor(noteId);
        });
    }
    else{
        var err = new Error("Gap check shared resource not available or properly initialized");
        logger.logError(err);
        throw err;
    }
};
/**
 * The createNewNote function is responsible for gathering the dynamic documentation component content
 * from the associated view along with the association of templateId and noteTypeId and sending that content to the Dynamic Documentation COM object. If it is determined
 * that any of the components has not yet saved data, the autosave functionality will be executed prior to launching
 * the Dynamic Documentation editor.
 * @param {number} selectedNoteTypeId - The current sequence id of notetype/grouper selected
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.createNewNote = function(selectedNoteTypeId) {
    // Capturing clicks on notetype/template associations
    if (selectedNoteTypeId) {
        this.associationLinkTimer.capture();
    }
    this.saveAndOpenEditor(selectedNoteTypeId);
};
/**
 * The createMoreNotesContextMenu function creates the context menu for the More option in the Navigator
 * and adds click functionality to each of the menu items. Also, it adds "Select Other Note" item at the end of all association links.
 * @param  {number} faceUpLinksCount - The count of associations displayed face up.
 * @param  {object} moreEle - The HTML element of More option
 * @param {object} allNoteTypes - The object of total note types filters
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.createMoreNotesContextMenu = function(faceUpLinksCount, moreEle, allNoteTypes) {
    var moreNotesContextMenu = null;
    var i = 0;
    var criterion = this.getCriterion();
    var categoryMean = criterion.category_mean;
    var groupedFlag = false;
    moreNotesContextMenu = MP_MenuManager.getMenuObject("moreNotesContextMenu" + categoryMean);
    if (!moreNotesContextMenu) {
        // https://jira2.cerner.com/browse/DISCERNABU-29592
        // The "more" menu needs to be updated in the future to be a child
        //      of the navigator to prevent the "mouseleave" from being
        //      triggered when hovering over the menu.
        moreNotesContextMenu = new ContextMenu()
            .setId("moreNotesContextMenu" + categoryMean)
            .setTypeClass("more-notes-context-menu")
            .setIsRootMenu(true)
            .setAnchorElementId(moreEle.attr("id"))
            .setAnchorConnectionCorner([ "bottom", "left" ])
            .setContentConnectionCorner([ "top", "left" ]);
        var pattenEle = null;
        for (i = faceUpLinksCount; i < allNoteTypes.length; i++) {
            if(allNoteTypes[ i ].isGrouped){
                groupedFlag = true;
                pattenEle = "<span class='create-note-grouper-icon-space create-note-grouper-icon'></span><span class='create-note-grouper-margin'>" + allNoteTypes[ i ].displayName + "</span>";
            }
            else if(groupedFlag){
                pattenEle = "<span class='create-note-grouper-icon-space'></span><span class='create-note-grouper-margin'>" + allNoteTypes[ i ].displayName + "</span>";
            }
            else{
                pattenEle = "<span>" + allNoteTypes[ i ].displayName + "</span>";
            }
            moreNotesContextMenu.addMenuItem(this.createMoreNotesMenuItem(pattenEle, allNoteTypes[ i ].id));
        }
        this.displayMoreNotesContextMenu(moreNotesContextMenu, groupedFlag);
        MP_MenuManager.addMenuObject(moreNotesContextMenu);
    }
    // Show context menu
    MP_MenuManager.showMenu(moreNotesContextMenu.getId());
};
/**
 * The displayMoreNotesContextMenu function displays the context menu below the association links.
 * @param  {Object} moreNotesContextMenu - The context menu created with the association links.
 * @param  {boolean} groupedFlag - groupedFlag indicator indicating any existing notetypes group
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.displayMoreNotesContextMenu = function(moreNotesContextMenu, groupedFlag) {
    var createNotei18n = i18n.discernabu.create_note_i18n;
    var self = this;
    var contextMenuOtherSelectionItem = null;
    var selectOtherElem = null;
    if (groupedFlag) {
        selectOtherElem = "<span class='create-note-grouper-icon-space'></span><span class='create-note-grouper-margin'>" + createNotei18n.SELECT_OTHER_NOTE + "</span>";
    }
    else {
        selectOtherElem = "<span>" + createNotei18n.SELECT_OTHER_NOTE + "</span>";
    }
    contextMenuOtherSelectionItem = new MenuSelection(selectOtherElem).setLabel(selectOtherElem);
    contextMenuOtherSelectionItem.setClickFunction(function() {
        self.createNewNote(null);
    });
    moreNotesContextMenu.addMenuItem(contextMenuOtherSelectionItem);
};
/**
 * The create more note menu item function generates the menu items opened inside the context menu on clicking the More option.
 * @param  {string} title - Label of the menu item.
 * @param {number} noteId - The noteType sequence Id of the association/grouper
 * @returns {object} This function returns a menu item
 */
CreateNoteSubsection.prototype.createMoreNotesMenuItem = function(title, noteId) {
    var contextMenuSelectionItem = new MenuSelection(title).setLabel(title);
    var self = this;
    contextMenuSelectionItem.setClickFunction(function() {
        self.saveAndOpenEditor(noteId);
    });
    return contextMenuSelectionItem;
};
/**
 * Saves any dirty workflow components and fires an event to save the workspace if the workspace is in view.
 * @param {number} noteId - The noteType sequence Id of the association/grouper
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.saveAndOpenEditor = function(noteId) {
    var self = this;

    /**
     * Save fusion components and open the DynDoc Editor
     */
    var saveAndOpen = function() {
        CERN_EventListener.removeListener({}, EventListener.EVENT_DOCUMENTATION_SAVED, saveAndOpen);

        var gapCheckStatus = self.isGapCheckRequired();
        // Gather all the dirty components that apply
        var dirtyComponents = self.gatherDirtyComponents();

        if (dirtyComponents.length > 0) {
            // Autosave dirty components before navigating to Dyn Doc
            self.saveDirtyComponents(noteId, dirtyComponents);
        }
        else if (gapCheckStatus) {
            self.triggerGapChecking(noteId);
        }
        else {
            // Navigate to Dyn Doc if no editors are dirty
            self.openDynDocEditor(noteId);
        }
    };

    // If there are documentation components in view they must be saved before creating a new note
    CERN_EventListener.addListener({}, EventListener.EVENT_DOCUMENTATION_SAVED, saveAndOpen);
    if (this.m_isDocumentationInView) {
        CERN_EventListener.fireEvent(null, this, EventListener.EVENT_SAVE_DOCUMENTATION);
    }
    else {
        saveAndOpen();
    }
};
/**
 * Refreshes the existing and available workflow shared resource.
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.refreshWorkflowInformation = function(){
    var workflowResource = MP_Resources.getSharedResource("createNoteWorkflow");
    if(workflowResource && workflowResource.isResourceAvailable()){
        workflowResource.setResourceData(null);
        workflowResource.setIsAvailable(false);
    }
};
/* eslint-disable complexity*/
/**
 * Navigate to CreateNewNote functionality of DYNDOC API inside Win32 Dynamic Documentation Editor
 * if templateId and noteTypeId are not null.
 * If null then navigate to Win32 Dynamic Documentation Editor
 * @param {number} noteId - Selected notetype/grouper sequence id from navigator
 * @param {String} alertEvent - Notifier string intended to notify event occured
 * @returns {undefined} This function does not return a value
 */
CreateNoteSubsection.prototype.openDynDocEditor = function(noteId, alertEvent) {
    var self = this;
    var sendAr = null;
    var criterion = this.getCriterion();
    var data = null;
    var personId = criterion.person_id;
    var encounterId = criterion.encntr_id;
    var workflowId = 0;
    var eventCds = 0;
    var dynDocObj = CERN_Platform.getWrappedDiscernObject("DYNDOC");
    var workflowResource = MP_Resources.getSharedResource("createNoteWorkflow");
    var dynDocObjPromise = Promise.resolve();

    self.m_noteId = noteId;
    if(!alertEvent && self.m_noteTypeFilterObj !== null && noteId !== null){
        var callBackHandler = function(alertEventId, existingDocDetails) {
            self.m_existingNoteDetails = (alertEventId === "continueExisting") ? existingDocDetails : null;
            self.openDynDocEditor(noteId, alertEventId);
        };
        self.getDuplicateNote(noteId, callBackHandler);
        return;
    }
    // This function is used to handle the data received from the event listener
    var handleResponse = function(event, dataString) {
        // Removing the listener for the availability of Create Note workflow which was initialized when Create Note subsection was first opened. This is done to enable the Create Note functionality
        // when the views are changed.
        var i = 0;
        CERN_EventListener.removeListener(self, "createNoteWorkflowAvailable", handleResponse, self);
        var existingNotes = self.m_existingNoteDetails;
        if (self.m_noteId !== null) {
            var selectedNotes = self.m_noteTypesArr[noteId];
            var noteListData = null;
            var existingNoteIds = existingNotes ? existingNotes.noteIds : null;
            if(selectedNotes) {
                noteListData = [];
                var currentNotesArray = [];
                var newNoteTypeIds = [];
                // filtering out notetype ids which are in modified state
                for( i = 0; i < selectedNotes.values.length; i++){
                    var noteTypeId = selectedNotes.values[i].PE_ID;
                    if (!existingNoteIds || existingNoteIds.indexOf(noteTypeId.toString()) === -1) {
                        var tempObj = {};
                        tempObj.NOTETYPE_ID = selectedNotes.values[i].PE_ID;
                        tempObj.TEMPLATE_ID = selectedNotes.values[i].PE_ID2;
                        newNoteTypeIds.push(selectedNotes.values[i].PE_ID);
                        currentNotesArray.push(tempObj);
                    }
                }
                if(newNoteTypeIds.length) {
                    dynDocObjPromise = new Promise(function(resolve) {
                        var newNoteTypeIdsArr = MP_Util.CreateParamArray(newNoteTypeIds, 1);// eslint-disable-line new-cap
                        sendAr = [ "^MINE^", newNoteTypeIdsArr ];
                        var getEventCdRequest = new ScriptRequest()
                            .setProgramName("mp_get_event_cd_by_note_type")
                            .setParameterArray(sendAr)
                            .setResponseHandler(function(reply) {
                                if (reply.getStatus() === "S") {
                                    eventCds = reply.getResponse().EVENT_CDS;
                                    for (i = 0; i < eventCds.length; i++) {
                                        noteListData.push("{" +
                                            "\"reference_template_id\":" + currentNotesArray[i].TEMPLATE_ID + "," +
                                            "\"event_cd\":" + eventCds[i].EVENT_CD + "," +
                                            "\"workflow_id\":" + 0.0 +
                                            "}");
                                    }
                                }
                                else {
                                    logger.logError("mp_get_event_cd_by_note_type failed: unable to get response");
                                    resolve();
                                }
                                self.m_noteId = null;
                                dynDocObj.isAvailable().then(function(isAvailable) {
                                    dynDocObj.supports("CreateNewNote").then(function(isSupported) {
                                        if (isAvailable && isSupported && noteListData && noteListData.length) {
                                            // Create note Json structure  for opening multiple notes simultaneously
                                            var createNoteJSON = "{" +
                                                "\"person_id\":" + personId + "," +
                                                "\"encounter_id\":" + encounterId + "," +
                                                "\"note_list\":[" +
                                                noteListData.join(",") + "]}";
                                            noteListData = null;
                                            dynDocObj.invoke("CreateNewNote", [ createNoteJSON ]).then(resolve);
                                        }
                                        else {
                                            resolve();
                                        }
                                    });
                                });
                            });
                        getEventCdRequest.performRequest();
                    });
                }
            }
        }
        else {
            if (dataString) { // eslint-disable-line no-lonely-if
                data = JSON.parse(dataString);
                data = data.RECORD_DATA;
                workflowId = data.WORKFLOW_ID;
                dynDocObjPromise = dynDocObj.isAvailable().then(function(isAvailable) {
                    return dynDocObj.supports("OpenDynDocByWorkflowId").then(function(isSupported) {
                        if (isAvailable && isSupported) {
                            return dynDocObj.invoke("OpenDynDocByWorkflowId", [ personId, encounterId, workflowId ]);
                        }
                    });
                });
            }
        }

        dynDocObjPromise.then(function() {
            if(existingNotes && existingNotes.eventIds.length){
                dynDocObj.isAvailable().then(function(isAvailable) {
                    dynDocObj.supports("ModifyExistingDocumentByEventId").then(function(isSupported) {
                        if (isAvailable && isSupported) {
                            var eventIds = existingNotes.eventIds;
                            eventIds.reduce(function(currentPromise, eventId) {
                                return currentPromise.then(function(){
                                    return dynDocObj.invoke("ModifyExistingDocumentByEventId", [ personId, encounterId, eventId ]);
                                });
                            }, Promise.resolve());
                        }
                    });
                });
            }

            self.m_existingNoteDetails = null;
        });
    };
    if (workflowResource) {
        // Adding the listener for the availability of Create Note workflow to enable Create Note functionality in multiple views.
        CERN_EventListener.addListener(self, "createNoteWorkflowAvailable", handleResponse, self);
        if (workflowResource.isResourceAvailable()) {
            handleResponse(null, workflowResource.getResourceData());
        }
        else {
            // The workflowId isn't available yet so start the data retrieval and register for the response
            workflowResource.retrieveSharedResourceData();
        }
    }
    else {
        // We need to create the Shared Resource, kick off data retrieval and register for the response
        sendAr = [ "^MINE^", criterion.person_id + ".0", criterion.encntr_id + ".0", criterion.provider_id + ".0" ];
        workflowResource = MP_Resources.createSharedResourceObj("createNoteWorkflow", self, "MP_GET_WORKFLOW", sendAr, "createNoteWorkflowAvailable");
        if (workflowResource) {
            workflowResource.retrieveSharedResourceData();
            CERN_EventListener.addListener(self, "createNoteWorkflowAvailable", handleResponse, self);
            // Subscribe to the Dyn Doc refresh broadcast message and reset the component when this occurs.
            if (this.isDynDocComponentPresent() && BroadcastDispatcher && (typeof BroadcastDispatcher.subscribe === "function")) {
                BroadcastDispatcher.subscribe(BroadcastDispatcher.DYN_DOC_REFRESH, function() {
                    self.refreshWorkflowInformation();
                });
            }
        }
    }
};
/* eslint-enable complexity*/
/**
 * This function adds the More option if the number of associations selected in the
 * bedrock filter are more than 5. It then makes a call to displayMoreNotesContextMenu function to
 * create a context menu with the associations
 * @param {number} faceUpLinksCount - The count of associations to be displayed face up
 * @param {object} filterObj - The object of page level filters
 * @returns {undefined} - This function does not return a value
 */
CreateNoteSubsection.prototype.addMoreNotesContextMenu = function(faceUpLinksCount, filterObj) {
    var moreEle = null;
    var patternEle = null;
    var categoryMean = this.getCriterion().category_mean;
    var createNotei18n = i18n.discernabu.create_note_i18n;
    var i = 0;
    var subSectionId = this.getSubsectionId();
    for (i = 0; i < faceUpLinksCount; i++) {
        patternEle = $("<div class='create-note-assoc-link create-note-disabled create-note-ptrnEle' note-type-id='" + filterObj.VALS[ i ].PE_ID + "' data-template-id='" + filterObj.VALS[ i ].PE_ID2 + "' id='" + subSectionId + "ptrnEle" + i + "'>" + filterObj.VALS[ i ].FTXT + "</div>");
        this.m_subsectionBodyElement.append(patternEle);
    }
    moreEle = $("<div id = 'createMoreNotesContextMenu" + categoryMean + "' class='create-note-more-link create-note-disabled'>" + createNotei18n.MORE + "<span class='create-note-more-down-link'></span></div>");
    this.m_subsectionBodyElement.append(moreEle);
};
/* global NavigatorSubsection, CapabilityTimer */
/**
 * A constructor used to create a new PMConvoSubsection object and
 * initialize subsection level variables.
 * @param {string} categoryMean - The id identifying the current view.
 * @constructor
 */
/* eslint-disable brace-style*/
var PMConvoSubsection = function(categoryMean) {
    this.setName("PM Conversation");
    this.setHasAssociatedView(false);
    this.setWorkflowViewId(categoryMean);
    this.setSubsectionId(categoryMean + "pmConvo");
    // flag indicating if the subsection display logic has been executed or not.
    this.m_sectionDisplayHandled = false;
    // flag indicating if the discharge/transfer process is running or not
    this.m_isDTProcessRunning = false;
    this.listenForComponentsInView();
    this.m_components = [];
    this.m_gapCheckInd = null;
    // End visit conversation types
    this.m_dischargeConversationType = 400;
    this.m_transferConversationType = 300;
    this.m_hasValidBedrockEndVisitSettings = false;
    // Bedrock End Visit Page level discharge settings
    this.m_hasValidBedrockDischargeSettings = false;
    this.m_dischargeActionLabel = null;
    this.m_dischargeRegistrationActionId = 0;
    this.m_dischargeRegistrationKey = "";
    this.m_dischargeConservationId = 0;
    this.m_dischargeCheckOut = 0;
    this.m_dischargeDoNotCheckOut = 0;
    // Bedrock End Visit Page level transfer settings
    this.m_hasValidBedrockTransferSettings = false;
    this.m_transferActionLabel = null;
    this.m_transferConservationId = 0;
    this.m_transferRegistrationActionId = 0;
    this.m_transferRegistrationKey = "";
    this.m_transferCheckOut = 0;
    this.m_transferDoNotCheckOut = 0;
    // Bedrock End Visit Page level common settings
    this.m_EDWorkflow = 0;
    this.m_IVHardStop = 0;
    this.m_promptDisposition = 0;
    this.m_CAIntegration = 0;
    // pagefilters script
    this.m_pageFilters = "pageLevelFilters";
    // css class name  for discharge
    this.m_pmConvoDischarge = "pm-convo-discharge";
     // css class name  for transfer
    this.m_pmConvoTransfer = "pm-convo-transfer";
    // css class name for disbaled links
    this.m_pmConvoDisabled = "pm-convo-disabled";
    // css class name for pm convo check mark icons
    this.m_pmConvoCheckMarkIcons = "pm-convo-check-mark-icons";
};

/**
 * Setup the prototype and constructor to inherit from the base NavigatorSubsection
 */
PMConvoSubsection.prototype = new NavigatorSubsection();
PMConvoSubsection.prototype.constructor = NavigatorSubsection;

/**
 * Checks if the PM Converation filter is set to yes.
 * @returns {Boolean} value indicating whether filter is set to yes(true) or no(false)
 */
 /* eslint-disable complexity */
PMConvoSubsection.prototype.isFilterSetToYes = function() {
    var filterObj = null;
    var pageLevelFiltersResource = this.getWorkflowViewId() + this.m_pageFilters;
    var pageLevelFilters = MP_Resources.getSharedResource(pageLevelFiltersResource); // eslint-disable-line new-cap
    if (pageLevelFilters && pageLevelFilters.isResourceAvailable()) {
        var plFilters = pageLevelFilters.getResourceData();
        if (plFilters) {
            var plFiltersLen = plFilters.length;
            for (var index = 0; index < plFiltersLen; index++) {
                filterObj = plFilters[index];
                if (filterObj.F_MN === "PM_CONVERSATION" && filterObj.VALS[0].FTXT === "1") {
                    return true;
                }
            }
        }
    }
    return false;
};

/**
 * The listenForComponentsInView function should be called to get the components in the view
 * from the detailedReviewSubsection including a flag to check for dyn doc components in view.
 * @returns {undefined} The function does not return a value
 */
PMConvoSubsection.prototype.listenForComponentsInView = function() {
    CERN_EventListener.addListener(this, EventListener.EVENT_COMPONENTS_IN_VIEW, this.setComponentsInView, this);
};

/**
 * Sets the components in view after listening the event fired from the DetailedReviewSubsection
 * @param {Object} event -  The event fired from detailedReviewSubsection to get the components
 * @param {Object} args - The argument attached to the event
 * @returns {undefined} The function does not return a value
 */
PMConvoSubsection.prototype.setComponentsInView = function(event, args) {
    if (args.workflowViewId === this.getWorkflowViewId()) {
        this.m_components = args.componentsInView;
    }
};

/* eslint-enable complexity */
/**
 * Generates the HTML for the subsection body.
 * @returns {String} The HTML which will be inserted into the subsection body
 */
PMConvoSubsection.prototype.generateBodyHTML = function() {
    var pmConvi18n = i18n.discernabu.pm_conversation;
    var subSectionId = this.getSubsectionId();
    return "<div id='" + subSectionId + "'><div class='pm-convo-hdr'>" + pmConvi18n.END_VISIT + "</div><ul><li class='pm-convo-item " + this.m_pmConvoDisabled + "' id='" + subSectionId + this.m_pmConvoDischarge + "'>" + pmConvi18n.DISCHARGE + "</li><li class='pm-convo-item " + this.m_pmConvoDisabled + "' id='" + subSectionId + this.m_pmConvoTransfer + "'>" + pmConvi18n.TRANSFER + "</li></ul></div>";
};

/**
* This function reads the bedrock settings for end-visit section for both discharge and transfer filters.
* If the Bedrock settings are valid then calls the enableSubsection function.
* Else if the Bedrock settings are invalid then hide both discharge and transfer subsections.
* @returns {undefined} This function does not return a value.
*/
PMConvoSubsection.prototype.postProcessing = function() { // eslint-disable-line
    var subSectionId = this.getSubsectionId();
    // Read bedrock settings for end-visit section for both discharge and transfer filters
    this.endVisitPageLevelSettings();
    // Call the enableSubsection function if Bedrock filters are valid.
    if (this.m_hasValidBedrockEndVisitSettings) {
        // If registration id configured get the registration keys
        if ((this.m_dischargeRegistrationActionId || this.m_transferRegistrationActionId)) {
            this.retrieveRegistrationDetails();
        }
        else {
            this.enableSubsection();
        }
    }
    else { // if Bedrock filters are not valid hide the links
        $("#" + subSectionId + this.m_pmConvoDischarge).hide();
        $("#" + subSectionId + this.m_pmConvoTransfer).hide();
    }
};

/**
 * Enables the Discharge/Transfer subsection if valid bedrock settings are available for discharge/transfer action
 * and launches respective conversations else hide discharge/transfer subsections.
 * @returns {undefined} This function does not return a value.
 */
/* eslint-disable complexity */
PMConvoSubsection.prototype.enableSubsection = function() {
    var self = this;
    var subSectionId = this.getSubsectionId();
    // If valid Discharge settings are made in Bedrock
    if (self.m_hasValidBedrockDischargeSettings) {
        // overridding the discharge action label set in bedrock with the default label set in generateBodyHTML
        var departActionName = (self.m_dischargeActionLabel);
        if (departActionName) {
            $("#" + subSectionId + self.m_pmConvoDischarge).text(departActionName);
        }
    }
    else { // If no valid Discharge settings are made in Bedrock
        $("#" + subSectionId + self.m_pmConvoDischarge).hide();
    }
    // If valid Transfer settings are made in Bedrock
    if (self.m_hasValidBedrockTransferSettings) {
        // overridding the transfer action label set in bedrock with the default label set in generateBodyHTML
        var transferActionName = (self.m_transferActionLabel);
        if (transferActionName) {
            $("#" + subSectionId + self.m_pmConvoTransfer).text(transferActionName);
        }
    }
    else {
        // If no valid Transfer settings are made in Bedrock
        $("#" + subSectionId + self.m_pmConvoTransfer).hide();
    }

    // Earlier was checking for both valid trackingdbtool settings and bedrock, now only checking for only valid bedrock
    if (self.m_hasValidBedrockEndVisitSettings) {
        self.pmConvoEnable();
        self.onClickDischargeLink();
        self.onClickTransferLink();
    }
    self.m_sectionDisplayHandled = true;
};

/**
 * When the user switch between views, we need to maintain the previous state.
 * When discharge/transfer sub sections are already disabled with check mark, do not remove the disabled class.
 * @returns {undefined} This function does not return a value.
*/
PMConvoSubsection.prototype.pmConvoEnable = function() {
    var self = this;
    var subSectionId = this.getSubsectionId();
    if (!($("#" + subSectionId + self.m_pmConvoDischarge).hasClass(self.m_pmConvoCheckMarkIcons) || $("#" + subSectionId + self.m_pmConvoTransfer).hasClass(self.m_pmConvoCheckMarkIcons))) {
        $("#" + subSectionId + " ." + self.m_pmConvoDisabled).removeClass(self.m_pmConvoDisabled).css("cursor", "pointer");
    }
};

/**
 * On Click of Discharge Link, the function checks the discharge sub section link has the  css class 'pm-convo-check-mark-icons'.
 * If true, stop action by return statement
 * Else launch the action available
 * @returns {undefined} This function does not return a value.
*/
PMConvoSubsection.prototype.onClickDischargeLink = function() {
    var self = this;
    var subSectionId = this.getSubsectionId();
    var gapCheckStatus = self.isGapCheckRequired();
    $("#" + subSectionId + self.m_pmConvoDischarge).click(function() {
        if (!self.m_isDTProcessRunning) {
            if ($("#" + subSectionId + self.m_pmConvoDischarge).hasClass(self.m_pmConvoCheckMarkIcons)) {
                return;
            }
            if (gapCheckStatus) {
                self.triggerGapChecking(self.m_dischargeConversationType, 0);
                return;
            }
            self.launchActionAvailable(self.m_dischargeConversationType);
        }
    });
};

/**
 * On Click of Transfer Link, the function checks the transfer sub section link has the  css class 'pm-convo-check-mark-icons'.
 * If true, stop action by return statement.
 * Else launch the action available
 * @returns {undefined} This function does not return a value.
*/
PMConvoSubsection.prototype.onClickTransferLink = function() {
    var self = this;
    var subSectionId = this.getSubsectionId();
    var gapCheckStatus = self.isGapCheckRequired();
    $("#" + subSectionId + self.m_pmConvoTransfer).click(function() {
        if (!self.m_isDTProcessRunning) {
            if ($("#" + subSectionId + self.m_pmConvoTransfer).hasClass(self.m_pmConvoCheckMarkIcons)) {
                return;
            }
            if (gapCheckStatus) {
                self.triggerGapChecking(self.m_transferConversationType, 1);
                return;
            }
            self.launchActionAvailable(self.m_transferConversationType);
        }
    });
};

/**
 * This method will find if at least one component is marked as required in the view and sets the gap check indicator.
 * @returns {boolean} The function will return true if there is a required component in the view else returns false
 */
PMConvoSubsection.prototype.isGapCheckRequired = function() {
    if (this.m_gapCheckInd === null) {
        var components = this.m_components;
        var componentCount = components.length;
        // Initially set it to false
        this.m_gapCheckInd = false;
        for (var i = 0; i < componentCount; i++) {
            if (components[i].getGapCheckCriteria()) {
                this.m_gapCheckInd = true;
                break;
            }
        }
    }
    return this.m_gapCheckInd;
};

/**
 * The triggerGapChecking function is the click function responsible for triggering the Gap Check verification * by calling GapCheck.prototype.performGapCheck function.
 * Throws error is the gap-check shared resource wasn't properlyinitialized
 * @param {number} convoType - The converastion type to be launched.
 * @param {number} wfCriteria - Number indicating which link was clicked - 0 implies discharge, 1 implies admit
 * @returns {undefined} This function does not return a value
 */
PMConvoSubsection.prototype.triggerGapChecking = function(convoType, wfCriteria) {
    var self = this;
    var components = this.m_components;
    var resourceName = this.getWorkflowViewId() + "gapCheckResource";
    var gapCheckResourceData = null;
    var gapCheckResource = MP_Resources.getSharedResource(resourceName);
    if (gapCheckResource && gapCheckResource.isResourceAvailable() && gapCheckResource.getResourceData()) {
        gapCheckResourceData = gapCheckResource.getResourceData();
        gapCheckResourceData.performGapCheck(components, wfCriteria, function() { // eslint-disable-line new-cap
            self.launchActionAvailable(convoType);
        });
    }
    else {
        var err = new Error("Gap check shared resource not available or properly initialized");
        logger.logError(err);
        throw err;
    }
};

/**
 * @description Launches PM/Registration Conversation's specific to the link clicked. On success disable the link section with check mark icon.
 * @param {object} convoType - The converastion type to be launched.
 * @returns {undefined} This function does not return a value.
 */
PMConvoSubsection.prototype.launchActionAvailable = function(convoType) {
    var capTimer = new CapabilityTimer("CAP:MPG.PM_CONVO - LAUNCH END_VISIT");
    var personId = this.getCriterion().person_id;
    var encntrId = this.getCriterion().encntr_id;
    var dpObject = CERN_Platform.getWrappedDiscernObject("DISCHARGEPROCESS"); // eslint-disable-line
    var isDischargeConvoType = (convoType === this.m_dischargeConversationType);
    var self = this;
    self.m_isDTProcessRunning = true;
    self.isLaunchRegistrationActionAvailable(dpObject).then( function(result) {
        if (result) {
            dpObject.invoke("LaunchRegistrationAction", [
                personId,
                encntrId,
                isDischargeConvoType ? self.m_dischargeRegistrationKey : self.m_transferRegistrationKey,
                convoType,
                self.m_CAIntegration,
                self.m_promptDisposition,
                self.m_IVHardStop,
                isDischargeConvoType ? self.m_dischargeCheckOut : self.m_transferCheckOut,
                isDischargeConvoType ? self.m_dischargeDoNotCheckOut : self.m_transferDoNotCheckOut,
                self.m_EDWorkflow ]).then( function(successRes) {
                    capTimer.addMetaData("settings", "Honored Bedrock for RC conversations")
                    .capture();
                    if (successRes === 3) {
                        self.disableLinkWithCheckMark(convoType);
                    }
                    self.m_isDTProcessRunning = false;
                });
        } else {
            self.isLaunchConversationAvailable(dpObject).then( function(result) { // eslint-disable-line no-shadow
                if (result) {
                    dpObject.invoke("LaunchConversation", [
                        personId,
                        encntrId,
                        isDischargeConvoType ? self.m_dischargeConservationId : self.m_transferConservationId,
                        convoType,
                        self.m_CAIntegration,
                        self.m_promptDisposition,
                        self.m_IVHardStop,
                        isDischargeConvoType ? self.m_dischargeCheckOut : self.m_transferCheckOut,
                        isDischargeConvoType ? self.m_dischargeDoNotCheckOut : self.m_transferDoNotCheckOut,
                        self.m_EDWorkflow ]).then( function(successRes) {
                            capTimer.addMetaData("settings", "Honored Bedrock for PM conversations")
                            .capture();
                            if (successRes === 3) {
                                self.disableLinkWithCheckMark(convoType);
                            }
                            self.m_isDTProcessRunning = false;
                        });
                }
            });
        }
    }).catch(function(err) {
        self.m_isDTProcessRunning = false;
        logger.logJSError(err, null, "pm-conversation.js", "launchActionAvailable");
    });
};

/**
 * This function makes a script call to retrieve the registration actions List.
 * Filters out the registration action keys for the provided action ids for both discharge and transfer
 * @returns {undefined} This function does not return a value.
 */
PMConvoSubsection.prototype.retrieveRegistrationDetails = function() {
    try {
        var self = this;
        var scriptRequest = new MP_Core.ScriptRequest(this, "");
        scriptRequest.setProgramName("MP_GET_REGISTRATION_ACTIONS");
        scriptRequest.setParameters([ "^MINE^" ]);
        scriptRequest.setArtifactInfo({
            artifactId: "pm-conversation",
            functionName: "retrieveRegistrationDetails"
        });
        MP_Core.XMLCCLRequestCallBack(null, scriptRequest, function(reply) { // eslint-disable-line
            var parsedReply = reply.getResponse();
            if (reply.getStatus() !== "F") {
                var matchFound = 0;
                for (var i = 0; i < parsedReply.REGISTRATION_ACTIONS.length; i++) {
                    if (parsedReply.REGISTRATION_ACTIONS[i].REGISTRATION_ACTION_ID === self.m_dischargeRegistrationActionId) {
                        self.m_dischargeRegistrationKey = parsedReply.REGISTRATION_ACTIONS[i].KEY;
                        ++matchFound;
                    }
                    if (parsedReply.REGISTRATION_ACTIONS[i].REGISTRATION_ACTION_ID === self.m_transferRegistrationActionId) {
                        self.m_transferRegistrationKey = parsedReply.REGISTRATION_ACTIONS[i].KEY;
                        ++matchFound;
                    }
                    if (matchFound === 2) {
                        break;
                    }
                }
                self.enableSubsection();
            }
        });
    }
    catch (err) {
        logger.logJSError(err, "pm-conversation.js: retrieveRegistrationDetails: Failed script request for java conversations");
    }
};

/**
 * This function calls the page level filters script for End Visit MPage -level Bedrock settings.
 * This function sets the End Visit MPage -level Bedrock settings into constructor level.
 * The Bedrock filters are valid only when any one the discharge/transfer conversation or discharge/transfer checkout or discharge/transfer do not conversation are set to yes.
 * If Bedrock filters are valid then sets m_hasValidBedrockEndVisitSettings to true.
 * @returns {undefined} This function does not return a value.
 */
PMConvoSubsection.prototype.endVisitPageLevelSettings = function() {
    var pageLevelFiltersResource = this.getWorkflowViewId() + this.m_pageFilters;
    var pageLevelFilters = MP_Resources.getSharedResource(pageLevelFiltersResource); // eslint-disable-line new-cap
    if (pageLevelFilters && pageLevelFilters.isResourceAvailable()) {
        var filterMeans = pageLevelFilters.getResourceData();
        for (var key = 0; key < filterMeans.length; key++) {
            var filterObj = filterMeans[key];
            switch (filterObj.F_MN) {
                case "PM_CON_DIS_ACTION_LABEL":
                    this.m_dischargeActionLabel = CERN_Platform.encoding.htmlDecode(filterObj.VALS[0].FTXT);
                    break;
                case "PM_CON_TRNSFR_ACT_LABEL":
                    this.m_transferActionLabel = CERN_Platform.encoding.htmlDecode(filterObj.VALS[0].FTXT);
                    break;
                case "PM_CON_DIS_ACT":
                    this.m_dischargeConservationId = filterObj.VALS[0].PE_ID;
                    this.m_hasValidBedrockEndVisitSettings = true;
                    this.m_hasValidBedrockDischargeSettings = true;
                    break;
                case "PM_CON_DIS_ACT_CHKUT":
                    this.m_dischargeCheckOut = filterObj.VALS[0].FTXT;
                    this.m_hasValidBedrockEndVisitSettings = true;
                    if (this.m_dischargeCheckOut === "1") {
                        this.m_hasValidBedrockDischargeSettings = true;
                    }
                    break;
                case "PM_CON_DIS_ACT_DO_NOT_CHKUT":
                    this.m_dischargeDoNotCheckOut = filterObj.VALS[0].FTXT;
                    this.m_hasValidBedrockEndVisitSettings = true;
                    if (this.m_dischargeDoNotCheckOut === "1") {
                        this.m_hasValidBedrockDischargeSettings = true;
                    }
                    break;
                case "PM_CON_TRNSFR_ACTION":
                    this.m_transferConservationId = filterObj.VALS[0].PE_ID;
                    this.m_hasValidBedrockEndVisitSettings = true;
                    this.m_hasValidBedrockTransferSettings = true;
                    break;
                case "PM_CON_TRNSFR_ACT_CHKUT":
                    this.m_transferCheckOut = filterObj.VALS[0].FTXT;
                    this.m_hasValidBedrockEndVisitSettings = true;
                    if (this.m_transferCheckOut === "1") {
                        this.m_hasValidBedrockTransferSettings = true;
                    }
                    break;
                case "PM_CON_TRNFR_ACT_DO_NOT_CHKUT":
                    this.m_transferDoNotCheckOut = filterObj.VALS[0].FTXT;
                    this.m_hasValidBedrockEndVisitSettings = true;
                    if (this.m_transferDoNotCheckOut === "1") {
                        this.m_hasValidBedrockTransferSettings = true;
                    }
                    break;
                case "PM_CON_CHRGE_ASST_INTGTION":
                    this.m_CAIntegration = filterObj.VALS[0].FTXT;
                    break;
                case "PM_CON_IVSTOPTIMES_HARD_STP":
                    this.m_IVHardStop = filterObj.VALS[0].FTXT;
                    break;
                case "PM_CON_PROMPT_DISPOSITION":
                    this.m_promptDisposition = filterObj.VALS[0].FTXT;
                    break;
                case "PM_CON_ED_WORKFLOW_MPAGE":
                    this.m_EDWorkflow = filterObj.VALS[0].FTXT;
                    break;
                case "PM_CON_DIS_REG_ACT":
                    this.m_dischargeRegistrationActionId = filterObj.VALS[0].PE_ID;
                    this.m_hasValidBedrockEndVisitSettings = true;
                    this.m_hasValidBedrockDischargeSettings = true;
                    break;
                case "PM_CON_TRAN_REG_ACT":
                    this.m_transferRegistrationActionId = filterObj.VALS[0].PE_ID;
                    this.m_hasValidBedrockEndVisitSettings = true;
                    this.m_hasValidBedrockTransferSettings = true;
            }
        }
    }
};

/**
 * @description this function adds the tick marks to the link and sets the link to dithered state.
 * @param {object} convoType - The conversation type to be launched.
 * @returns {undefined} this function does not return any value.
 */
PMConvoSubsection.prototype.disableLinkWithCheckMark = function(convoType) {
    var sectionId = this.getSubsectionId();
    var actionType = (convoType === this.m_dischargeConversationType) ? this.m_pmConvoDischarge : this.m_pmConvoTransfer;
    $("#" + sectionId + actionType).addClass(this.m_pmConvoCheckMarkIcons + " " + this.m_pmConvoDisabled);
};

/**
 * @description this function checks  has valid Bedrock filters and LaunchConversation API is available or not.
 * @param {*} dpObject CERN_Platform discharge process API
 * @returns {Boolean} this function Boolean value.
 */
PMConvoSubsection.prototype.isLaunchConversationAvailable = function(dpObject) {
    var self = this;
    return Promise.all([ dpObject.isAvailable(), dpObject.supports("LaunchConversation") ]).then(function(results){
        return (results && results[0] && results[1] && (self.m_hasValidBedrockEndVisitSettings && (self.m_hasValidBedrockDischargeSettings || self.m_hasValidBedrockTransferSettings)));     // eslint-disable-line valid-typeof
    });
};

/**
 * @description this function checks  has valid Bedrock filters and LaunchRegistrationAction API is available or not.
 * @param {*} dpObject CERN_Platform discharge process API
 * @returns {Boolean} this function Boolean value.
 */
PMConvoSubsection.prototype.isLaunchRegistrationActionAvailable = function(dpObject) {
    var self = this;
    // !! will convert the string value into boolean value
    return Promise.all([ dpObject.isAvailable(), dpObject.supports("LaunchRegistrationAction") ]).then(function(results){
        return (results && results[0] && results[1] && self.m_hasValidBedrockEndVisitSettings && !!(self.m_dischargeRegistrationKey || self.m_transferRegistrationKey));     // eslint-disable-line valid-typeof
    });
};
/**
 * The Document Base Component is to allow for other 'document' based components to share the same
 * look and feel without having to duplicate the logic for retrieval of documents.
 *
 * @class
 *
 */
function DocumentBaseComponent() {
	this.m_resultStatusCodes = null;
	//meanings is used to allow loading of the status codes
	//when needed aka 'lazy loading'.  Hence why the retrieval of
	//meanings is not exposed to the consumer.  Only retrieval of codes
	//is available.
	this.m_resultStatusMeanings = null;
	this.m_includeHover = true;
	this.m_pcnFavorites = true;

	this.setIncludeLineNumber(true);

	DocumentBaseComponent.method("InsertData", function() {
		if(this.getGrouperFilterEventSets()) {
			CERN_DOCUMENT_BASE_O1.RefreshDocumentsTable(this, this.getGrouperFilterLabel(), this.getGrouperFilterEventSets());
		}
		else {
			CERN_DOCUMENT_BASE_O1.GetDocumentsTable(this);
		}
	});
	DocumentBaseComponent.method("setResultStatusCodes", function(value) {
		this.m_resultStatusCodes = value;
	});
	DocumentBaseComponent.method("addResultStatusCode", function(value) {
		if(!this.m_resultStatusCodes) {
			this.m_resultStatusCodes = [];
		}
		this.m_resultStatusCodes.push(value);
	});
	DocumentBaseComponent.method("getResultStatusCodes", function() {
		if(this.m_resultStatusCodes) {
			return this.m_resultStatusCodes;
		}
		else {
			if(this.m_resultStatusMeanings) {
				//load up codes from meanings
				var resStatusCodeSet = MP_Util.GetCodeSet(8, false);
				if(this.m_resultStatusMeanings && this.m_resultStatusMeanings.length > 0) {
					for(var x = this.m_resultStatusMeanings.length; x--; ) {
						var code = MP_Util.GetCodeByMeaning(resStatusCodeSet, this.m_resultStatusMeanings[x]);
						if(code) {
							this.addResultStatusCode(code.codeValue);
						}
					}
				}
			}
		}
		return this.m_resultStatusCodes;
	});
	DocumentBaseComponent.method("addResultStatusMeaning", function(value) {
		if(!this.m_resultStatusMeanings) {
			this.m_resultStatusMeanings = [];
		}
		this.m_resultStatusMeanings.push(value);
	});
	DocumentBaseComponent.method("setResultStatusMeanings", function(value) {
		this.m_resultStatusMeanings = value;
	});
	DocumentBaseComponent.method("isHoverEnabled", function() {
		return this.m_includeHover;
	});
	DocumentBaseComponent.method("setHoverEnabled", function(value) {
		this.m_includeHover = value;
	});
	DocumentBaseComponent.method("isPcnFavEnabled", function() {
		return this.m_pcnFavorites;
	});
	DocumentBaseComponent.method("setPcnFavEnabled", function(value) {
		this.m_pcnFavorites = value;
	});
	DocumentBaseComponent.method("FilterRefresh", function(label, esArray) {
		CERN_DOCUMENT_BASE_O1.RefreshDocumentsTable(this, label, esArray);
	});
	DocumentBaseComponent.method("HandleSuccess", function(recordData) {
		CERN_DOCUMENT_BASE_O1.RenderComponent(this, recordData);
	});
}

DocumentBaseComponent.inherits(MPageComponent);

/**
 * Base Document methods
 * @namespace
 */
var CERN_DOCUMENT_BASE_O1 = function() {
	
	function getLatestParticipation(doc) {
		var returnPart = null;
		for(var x = doc.ACTION_PROVIDERS.length; x--; ) {
			var part = doc.ACTION_PROVIDERS[x];
			if(!returnPart || part.DATE > returnPart.DATE) {
				returnPart = part;
			}
		}
		return (returnPart);
	}

	function DocumentSorter(a, b) {
		var aPart = getLatestParticipation(a);
		var bPart = getLatestParticipation(b);
		var aDate = "";
		var bDate = "";
		if(aPart) {
			aDate = aPart.EFFECTIVE_DT_TM;
		}
		if(bPart) {
			bDate = bPart.EFFECTIVE_DT_TM;
		}

		if(aDate > bDate) {
			return -1;
		}
		else if(aDate < bDate) {
			return 1;
		}
		else {
			return 0;
		}
	}

	function getAuthorParticipant(doc) {
		//the author of a document, according to doc services, will be on the Contribution object.  It's the PERFORM action in the participation list.
		var returnPart = null, type_cd = null, status_cd = null, part = null, strPerform = "PERFORM", strCompleted = "COMPLETED";
		for(var y = doc.ACTION_PROVIDERS.length; y--; ) {
			part = doc.ACTION_PROVIDERS[y];
			type_cd = part.TYPE_CD_MEANING;
			status_cd = part.STATUS_CD_MEANING;
			if((type_cd === strPerform) && (status_cd === strCompleted)) {
				returnPart = part;
				break;
			}
		}
		return (returnPart);
	}

	//below are the functions for favorites
	function appendDropDown(preSec, component, pcnFav, contentPath) {
		if(preSec != "doc") {
			return;
		}
		pre = component.getStyles().getId();
		if(_g(pre + "Drop") && _g(pre + "Menu")) {
			return;
			//already defined
		}
		var img = Util.cep("img", {
			'src' : contentPath + '/images/3943_16.gif'
		});
		var link = Util.cep("a", {
			'className' : 'drop-Down',
			'id' : pre + 'Drop'
		});
		var menu = Util.cep("div", {
			'id' : pre + 'Menu',
			'className' : 'form-menu menu-hide'
		});
		Util.ac(img, link);
		var sec = _g(component.getStyles().getId());

		var secCL = Util.Style.g("sec-hd", sec, "h2");
		var secSpan = secCL[0];
		Util.ac(link, secSpan);
		Util.ac(menu, secSpan);
		pcnFavLoad(pcnFav, component);
	}

	function pcnFavLoad(pcnFav, component) {
		//load documents
		var jsonPcnFav = pcnFav;
		var docDropId = component.getStyles().getId() + "Drop";
		var docDrop = _g(docDropId);
		//d1 "docDrop"
		var htmlPcnFav = [];
		var numId = 0;
		var pcn = jsonPcnFav.PRE_COMPLETED;
		pcn.sort(function(obj1, obj2) {
			function checkStrings(s1, s2) {
				return (s1 === s2) ? 0 : ((s1 > s2) ? 1 : -1);
			}

			return checkStrings(obj1.DISPLAY.toUpperCase(), obj2.DISPLAY.toUpperCase());
		});
		if(!pcn[0]) {
			htmlPcnFav.push('<div>', i18n.discernabu.documents_base_o1.DOCUMENT_FAVS, '<span class="favHidden" id="docCKI', numId, '">', i18n.DOCUMENT_FAVS, '</span></div>');
		}
		else {
			var crit = component.getCriterion();
			//person_id
			for(var j = 0, l = pcn.length; j < l; j++) {
				var pcNote = pcn[j];
				numId = numId + 1;
				htmlPcnFav.push('<div><a id="doc', numId, '" href="#">', pcNote.DISPLAY, '</a>', '<span class="favHidden" id="docCKI', numId, '">', pcNote.SOURCE_IDENTIFIER, '</span>', '<span class="favHidden" id="docStyleID', numId, '">', component.getStyles().getId(), '</span>', '</div>');
			}
		}

		var pcnArray = htmlPcnFav.join('');
		var newSpan = Util.cep('span');
		newSpan.innerHTML = pcnArray;
		var docMenuId = component.getStyles().getId() + "Menu";
		var docMenu = _g(docMenuId);
		//m1 "docMenu"
		Util.ac(newSpan, docMenu);

		//doc more add options
		var docMenuList = _gbt('a', docMenu);
		var dmLen = docMenuList.length;
		for(var i = dmLen; i--; ) {
			Util.addEvent(docMenuList[i], "click", addDocDet);
			//docMenuList[i], component
		}
		//set up menu close
		closeMenuInit(docMenu, component.getStyles().getId());
		//set up doc flyout menu
		Util.addEvent(docDrop, "click", function() {
			if(Util.Style.ccss(Util.gns(this), "menu-hide")) {
				_g(component.getStyles().getId()).style.zIndex = 2;
				//'doc'
				Util.preventDefault();
				Util.Style.rcss(Util.gns(this), "menu-hide");
			}
			else {
				_g(component.getStyles().getId()).style.zIndex = 1;
				//'doc'
				Util.Style.acss(Util.gns(this), "menu-hide");
			}

		});
	}

	//end epath load

	function addDocDet() {
		try {
			var PowerNoteMPageUtils = window.external.DiscernObjectFactory("POWERNOTE");
			MP_Util.LogDiscernInfo(null, "POWERNOTE", "documentbase.js", "addDocDet");
			var comp = {};
			if(PowerNoteMPageUtils) {
				var menuVal = Util.gns(this);
				var cki = menuVal.firstChild.data;
				var spanDocStyleID = Util.gns(menuVal);
				for(var x = 0, xl = CERN_MPageComponents.length; x < xl; x++) {
					comp = CERN_MPageComponents[x];
					var styles = comp.getStyles();
					if(styles.getId() == spanDocStyleID.firstChild.data) {
						break;
					}
				}
				var crit = comp.getCriterion();
				PowerNoteMPageUtils.BeginNoteFromPrecompletedNote(crit.person_id + ".0", crit.encntr_id + ".0", cki + ".0");
				CERN_DOCUMENT_BASE_O1.GetDocumentsTable(comp);
			}
		}
		catch (err) {
			alert('An error has occured calling DiscernObjectFactory("POWERNOTE"): ' + err.name + ' ' + err.message);
			return;
		}
	}

	function closeMenuInit(inMenu, compId) {
		var menuId;
		var docMenuId = compId + "Menu";
		
		function menuLeave(e) {
			if(!e) {
				var e = window.event;
			}
			var relTarg = e.relatedTarget || e.toElement;
			if(e.relatedTarget.id == inMenu.id) {
				Util.Style.acss(inMenu, "menu-hide");
				_g(menuId).style.zIndex = 1;
			}
			e.stopPropagation();
			Util.cancelBubble(e);
		}
		
		if(inMenu.id == docMenuId) {//m2 'docMenu'
			menuId = compId;
		}
		if(!e) {
			var e = window.event;
		}
		if(window.attachEvent) {
			Util.addEvent(inMenu, "mouseleave", function() {
				Util.Style.acss(inMenu, "menu-hide");
				_g(menuId).style.zIndex = 1;
			});
		}
		else {
			Util.addEvent(inMenu, "mouseout", menuLeave);
		}
	}	
	
	return {
		GetDocumentsTable : function(component) {
			var mgr = new MP_Core.XMLCCLRequestThreadManager(CERN_DOCUMENT_BASE_O1.RenderReply, component, false);
			var sendAr = [];
			var request = null;
			var thread = null;
			var criterion = component.getCriterion();
			var groups = component.getGroups();
			var codes = component.getResultStatusCodes();
			var events = (groups && groups.length > 0) ? groups[0].getEventSets() : null;
			var results = (codes && codes.length > 0) ? codes : null;

			var encntrOption = (component.getScope() === 2) ? (criterion.encntr_id + ".0") : "0.0";
			sendAr.push("^MINE^", criterion.person_id + ".0", encntrOption, criterion.provider_id + ".0", component.getLookbackUnits());
			sendAr.push(MP_Util.CreateParamArray(events, 1));
			sendAr.push(MP_Util.CreateParamArray(results, 1));
			var unitType = component.getLookbackUnitTypeFlag();
			sendAr.push(criterion.ppr_cd + ".0", unitType);
			request = new MP_Core.ScriptRequest(component, "ENG:MPG.DOC.O1 - load documents");
			request.setArtifactInfo({
				artifactId: "document-base-o1",
				functionName: "GetDocumentsTable"
			});
			request.setProgramName("MP_RETRIEVE_DOCUMENTS_JSON");
			request.setParameters(sendAr);
			request.setAsync(true);
			thread = new MP_Core.XMLCCLRequestThread("GetDocumentData", component, request);
			mgr.addThread(thread);

			if(component.isPlusAddEnabled()) {
				sendAr = [];
				sendAr.push("^MINE^", criterion.provider_id);
				request = new MP_Core.ScriptRequest(component, "ENG:MPG.DOC.O1 - load PCN Favs");
				request.setArtifactInfo({
					artifactId: "document-base-o1",
					functionName: "GetDocumentsTable"
				});
				request.setProgramName("MP_GET_DOCUMENT_FAVORITES");
				request.setParameters(sendAr);
				request.setAsync(true);
				thread = new MP_Core.XMLCCLRequestThread("GetPcnFavorites", component, request);
				mgr.addThread(thread);
			}
			mgr.begin();
		},
		RefreshDocumentsTable : function(component, filterLabel, filterESArray) {
			var mgr = new MP_Core.XMLCCLRequestThreadManager(CERN_DOCUMENT_BASE_O1.RenderReply, component, false);
			var sendAr = [];
			var request = null;
			var thread = null;
			var criterion = component.getCriterion();
			var codes = component.getResultStatusCodes();
			var encntrOption = (component.getScope() == 2) ? (criterion.encntr_id + ".0") : "0.0";
			sendAr.push("^MINE^", criterion.person_id + ".0", encntrOption, criterion.provider_id + ".0", component.getLookbackUnits());
			sendAr.push(MP_Util.CreateParamArray(filterESArray, 1));
			sendAr.push(MP_Util.CreateParamArray(codes, 1));
			var unitType = component.getLookbackUnitTypeFlag();
			sendAr.push(criterion.ppr_cd + ".0", unitType);
			request = new MP_Core.ScriptRequest(component, "ENG:MPG.DOC.O1 - load documents");
			request.setArtifactInfo({
				artifactId: "document-base-o1",
				functionName: "RefreshDocumentsTable"
			});
			request.setProgramName("MP_RETRIEVE_DOCUMENTS_JSON");
			request.setParameters(sendAr);
			request.setAsync(true);
			thread = new MP_Core.XMLCCLRequestThread("GetDocumentData", component, request);
			mgr.addThread(thread);
			if(component.isPlusAddEnabled()) {
				sendAr = [];
				sendAr.push("^MINE^", criterion.provider_id);
				request = new MP_Core.ScriptRequest(component, "ENG:MPG.DOC.O1 - load PCN Favs");
				request.setArtifactInfo({
					artifactId: "document-base-o1",
					functionName: "RefreshDocumentsTable"
				});
				request.setProgramName("MP_GET_DOCUMENT_FAVORITES");
				request.setParameters(sendAr);
				request.setAsync(true);
				thread = new MP_Core.XMLCCLRequestThread("GetPcnFavorites", component, request);
				mgr.addThread(thread);
			}
			mgr.begin();
		},
		RenderReply : function(replyAr, component) {
			var timerRenderComponent = MP_Util.CreateTimer(component.getComponentRenderTimerName());
			var countText = "";
			var compNS = component.getStyles().getNameSpace();
			var errMsg = [];

			try {
				for(var repCnt = replyAr.length; repCnt--; ) {
					var reply = replyAr[repCnt];
					var repStatus = reply.getStatus();
					switch (reply.getName()) {
						case "GetPcnFavorites":
							var favData = reply.getResponse();
							if(repStatus == "S") {
								appendDropDown(compNS, component, favData, component.getCriterion().static_content);
							}
							break;
						case "GetDocumentData":
							if(repStatus == "F") {
								errMsg.push(reply.getError());
								MP_Util.Doc.FinalizeComponent(MP_Util.HandleErrorResponse(component.getStyles().getNameSpace(), errMsg.join("<br />")), component, "");
							}
							else {
								if(repStatus == "S") {
									var recordData = reply.getResponse();
									var sHTML = "";
									sHTML = CERN_DOCUMENT_BASE_O1.RenderComponent(component, recordData);
									countText = MP_Util.CreateTitleText(component, recordData.DOCS.length);
									MP_Util.Doc.FinalizeComponent(sHTML, component, countText);
									if(component.isScrollingEnabled() && (recordData.DOCS.length >= component.getScrollNumber())) {
										var xNode = Util.Style.g(compNS + "-info-hdr", document.body, "DL");
										if(xNode[0]) {
											Util.Style.acss(xNode[0], "hdr-scroll");
										}
									}
								}
								else {
									countText = (component.isLineNumberIncluded() ? "(0)" : "");
									MP_Util.Doc.FinalizeComponent(MP_Util.HandleNoDataResponse(component.getStyles().getNameSpace()), component, countText);
								}
							}
							break;
					}
				}

			}
			catch (err) {
				if(timerRenderComponent) {
					timerRenderComponent.Abort();
					timerRenderComponent = null;
				}
				throw (err);
			}
			finally {
				if(timerRenderComponent) {
					timerRenderComponent.Stop();
				}
			}
		},
		RenderComponent : function(component, recordData) {

			var compNS = component.getStyles().getNameSpace();
			var DocI18n = i18n.discernabu.documents_base_o1;
			var df = new mp_formatter.DateTimeFormatter(MPAGE_LOCALE);
			var sHTML = "";
			var countText = "";
			var jsHTML = [];

			jsHTML.push("<div class='content-hdr'><dl class='", compNS, "-info-hdr hdr'><dd class='", compNS + "-cat-hd'><span></span></dd>");
			jsHTML.push("<dd class='", compNS, "-auth-hd'><span>", DocI18n.AUTHOR, "</span></dd>");

			if(PathologyComponent && ( component instanceof PathologyComponent)) {
				jsHTML.push("<dd class='", compNS, "-dt-hd'><span>", DocI18n.DATE, "</span></dd>");
			}
			else {
				jsHTML.push("<dd class='", compNS, "-dt-hd'><span>", DocI18n.DATE_TIME, "</span></dd>");
			}
			if(component.getDateFormat() == 3) {////1 = date only,2= date/time and 3 = elapsed time
				jsHTML.push("<dd class='", compNS + "-cat-hd'><span></span></dd><dd class='", compNS, "-auth-hd'><span></span></dd><dd class='", compNS, "-dt-hd'><span>", DocI18n.WITHIN, "</span></dd>");
			}
			jsHTML.push("</dl></div>");
			recordData.DOCS.sort(DocumentSorter);

			jsHTML.push("<div class='", MP_Util.GetContentClass(component, recordData.DOCS.length), "'>");
			for(var x = 0, xl = recordData.DOCS.length; x < xl; x++) {
				var dtHvr = "", lastPrsnl = "";
				var author = DocI18n.UNKNOWN;
				var docObj = recordData.DOCS[x];
				var patId = docObj.PERSON_ID + ".0";
				var enctrId = docObj.ENCNTR_ID + ".0";
				var evntId = docObj.EVENT_ID + ".0";
				var docStatus = docObj.RESULT_STATUS_CD_MEAN;
				var doc = docObj.EVENT_CD_DISP;
				var parentEventId = docObj.PARENT_EVENT_ID + ".0";
				var viewerType = docObj.VIEWER_TYPE;
				var dateOfService = null;
				var withinDateDos = null;
				var dateTime = new Date();

				//FACE UP DATE
				if(docObj.EFFECTIVE_DT_TM) {
					dateTime.setISO8601(docObj.EFFECTIVE_DT_TM);
					dateOfService = MP_Util.DisplayDateByOption(component, dateTime);
					withinDateDos = MP_Util.CalcWithinTime(dateTime);

				}
				else {
					dateOfService = DocI18n.UNKNOWN;
					withinDateDos = DocI18n.UNKNOWN;
				}

				//info related to participation
				var recentPart = getLatestParticipation(docObj);
				var authorPart = getAuthorParticipant(docObj);

				if(authorPart) {
					author = authorPart.PRSNL_NAME;
				}

				if(recentPart && recentPart.PRSNL_NAME !== "") {
					lastPrsnl = recentPart.PRSNL_NAME;
					var dtTm = new Date();
					if(recentPart.DATE !== "") {
						dtTm.setISO8601(recentPart.DATE);
						dtHvr = df.format(dtTm, mp_formatter.DateTimeFormatter.FULL_DATE_TIME_4YEAR);
					}
					else {
						dtHvr = DocI18n.UNKNOWN;
					}
				}
				else {
					lastPrsnl = DocI18n.UNKNOWN;
					dtHvr = DocI18n.UNKNOWN;
				}
				jsHTML.push("<dl class='", compNS, "-info'><dd class='", compNS + "-cat'><span>", MP_Util.CreateClinNoteLink(patId, enctrId, evntId, doc, viewerType, parentEventId), "</span>");
				if(docStatus === "MODIFIED" || docStatus === "ALTERED") {
					jsHTML.push("<span class='res-modified'>&nbsp;</span>");
				}
				jsHTML.push("</dd>");
				jsHTML.push("<dd class='", compNS, "-auth'><span>", author, "</span></dd>");
				if(component.getDateFormat() == 3) {//1 = date only,2= date/time and 3 = elapsed time
					jsHTML.push("<dd class='", compNS, "-dt'><span class='date-time'>", withinDateDos, "</span></dd>");
				}
				else {
					jsHTML.push("<dd class='", compNS, "-dt'><span class='date-time'>", dateOfService, "</span></dd>");
				}
				//retrieve document images
				jsHTML.push("<dd class='", compNS, "-image'>");
				if(docObj.IMAGE_URL !== "") {
					var urlParam = 'javascript:MPAGES_SVC_EVENT("' + docObj.IMAGE_URL + '",^MINE,$PAT_PersonId$^)';
					jsHTML.push("<a class='", compNS, "-image-found' href='", urlParam, "'>&nbsp;</a>");
				}
				else {
					jsHTML.push("&nbsp;");
				}
				jsHTML.push("</dd></dl>");
				//Build the hover
				if(component.isHoverEnabled()) {
					jsHTML.push("<h4 class='det-hd'><span>", DocI18n.DOCUMENTATION_DETAILS, "</span></h4><div class='hvr'><dl class='", compNS, "-det'><dt><span>", DocI18n.NAME, ":</span></dt><dd class='", compNS, "-det-name'><span>", doc, "</span></dd><dt><span>", DocI18n.SUBJECT, ":</span></dt><dd class='", compNS, "-det-subj'><span>", docObj.SUBJECT, "</span></dd><dt><span>", DocI18n.STATUS, ":</span></dt><dd class='", compNS, "-det-status'><span>", docObj.RESULT_STATUS_CD_DISP, "</span></dd><dt><span>", DocI18n.LAST_UPDATED, ":</span></dt><dd class='", compNS, "-det-dt'><span>", dtHvr, "</span></dd><dt><span>", DocI18n.LAST_UPDATED_BY, ":</span></dt><dd class='", compNS, "-det-dt'><span>", lastPrsnl, "</span></dd></dl></div>");
				}

			}
			jsHTML.push("</div>");
			sHTML = jsHTML.join("");

			return sHTML;
		}
	};
}();
/**
 * The MeasurementBaseComponent is a component that utilizes retrieval of data via the retrieve_n_results service.
 * @param criterion  The criterion containing the information about the requested information
 * @class
 */
function MeasurementBaseComponent(criterion){
	this.m_resultCount = 0;
	this.m_isEventSetInfo = false;
	this.m_isComment = false;
	/**
	 * Sets the number of results to retrieve
	 * @param value Integer value representing the number of results to retrieve
	 * @public
	 */
	MeasurementBaseComponent.method("setResultCount", function(value){
		this.m_resultCount = value;
	});
	MeasurementBaseComponent.method("getResultCount", function(){
		return (this.m_resultCount);
	});
    MeasurementBaseComponent.method("setIncludeEventSetInfo", function (value) {
        this.m_isEventSetInfo = value;
    });
    MeasurementBaseComponent.method("includeEventSetInfo", function () {
        return (this.m_isEventSetInfo);
    });
    MeasurementBaseComponent.method("setIncludeComments", function (value) {
        this.m_isComment = value;
    });
    MeasurementBaseComponent.method("includeComments", function () {
        return (this.m_isComment);
    });
	MeasurementBaseComponent.method("InsertData", function(){
		var timerLoadComponent = MP_Util.CreateTimer(this.getComponentLoadTimerName(), this.getCriterion().category_mean);
		try{
		getMeasurementData(this);
		}catch (err) {
			if (timerLoadComponent) {
				timerLoadComponent.Abort();
				timerLoadComponent = null;
			}
		}
		finally {
			if (timerLoadComponent) 
				timerLoadComponent.Stop();
		}
    });
	
	/**
	 * Executes the retrieval of each group data per a thread.
	 * @param component  The Component being rendered
	 */
	function getMeasurementData(component){
		var groups = component.getGroups();
		if (groups && groups.length > 0){
            var mgr = new MP_Core.XMLCCLRequestThreadManager(component.HandleSuccess, component, true);
            var criterion = component.getCriterion();
            var programName = "MP_RETRIEVE_N_RESULTS_JSON";

			for (var x = 0, xl = groups.length; x < xl; x++){
                var group = groups[x];
                var sEventSets = "0.0", sEventCodes = "0.0";
                var sBeginDate = "^^";
                var sEndDate = "^^";
                var esInfo = (component.includeEventSetInfo()) ? 1 : 0;
                var commentInfo = (component.includeComments()) ? 1 : 0;
                var sendAr = [];
                var request = null;
                var thread = null;
                var sEncntr = (component.getScope() === 2) ? criterion.encntr_id + ".0" : "0.0";

                if (group instanceof MPageEventSetGroup){
					sEventSets = MP_Util.CreateParamArray(group.getEventSets(), 1);
				}
				else if (group instanceof MPageEventCodeGroup){
					sEventCodes = MP_Util.CreateParamArray(group.getEventCodes(), 1);					
				}
                else if (group instanceof MPageSequenceGroup) {
                    var mapItems = group.getMapItems();
                    sEventSets = MP_Util.CreateParamArray(MP_Util.GetValueFromArray("CODE_VALUE", mapItems), 1);
                }
                else if (group instanceof MPageGrouper) {
                    var g = group.getGroups();
                    var ec = [];
                    for (var y = 0, yl = g.length; y < yl; y++) {
                        if (g[y] instanceof MPageEventCodeGroup) {
                            ec = ec.concat(g[y].getEventCodes());
                        }
                    }
                    sEventCodes = MP_Util.CreateParamArray(ec, 1);
                }
                else {
                    continue;
                }

                sendAr.push("^MINE^", criterion.person_id + ".0", sEncntr, criterion.provider_id + ".0", 
                        criterion.ppr_cd + ".0", component.getResultCount(), "^^", sEventSets, sEventCodes, 
                        component.getLookbackUnits(), component.getLookbackUnitTypeFlag(), esInfo, 
                        sBeginDate,sEndDate,commentInfo);

                request = new MP_Core.ScriptRequest(component, "ENG:MPG.MEASBASE.O1 - load " + group.getGroupName());

                request.setArtifactInfo({
                    artifactId: "measurement-base-o1",
                    functionName: "getMeasurementData"
                });

                request.setProgramName(programName);
                request.setParameters(sendAr);
                request.setAsync(true);

                thread = new MP_Core.XMLCCLRequestThread(group.getGroupName(), component, request);
                mgr.addThread(thread);
            }
			mgr.begin();
		}
		else {
			MP_Core.CreateSimpleError(component, i18n.discernabu.measurement_base_o1.ERROR_MISSING_ES_EC);
		}
	}
}
MeasurementBaseComponent.inherits(MPageComponent);

/**
 * Base Measurement methods
 * @namespace 
 */
var CERN_MEASUREMENT_BASE_O1 = function(){
        
        /* Private funtion to retrieve measure data */        
        function getMeasurementDataArray(recordData, personnelArray, codeArray){
            var measureArray = [];
            if (!codeArray){
            	codeArray = MP_Util.LoadCodeListJSON(recordData.CODES);
            }
            if (!personnelArray){
            	personnelArray = MP_Util.LoadPersonelListJSON(recordData.PRSNL);
            }
            var results = recordData.RESULTS;
            for (var i = 0, il = results.length; i < il; i++) {
            	var result = results[i];
                if (result.CLINICAL_EVENTS.length > 0) {
                    for (var j = 0, jl = result.CLINICAL_EVENTS.length; j < jl; j++) {
                        var meas = result.CLINICAL_EVENTS[j];
                        for (var k = 0, kl = meas.MEASUREMENTS.length; k < kl; k++) {
                            var measurement = new MP_Core.Measurement();
                            measurement.initFromRec(meas.MEASUREMENTS[k], codeArray);
                            measureArray.push(measurement);
                        }
                    }
                }
            }
            return measureArray;
        }
    return {
    	/**
    	 * Loads the retrieved measurement data into a map
    	 * @param recordData  The retrieved JSON to parse into Measurement Objects
    	 * @param personnelArray  The list of personnel to utilize within the Measurement Objects
    	 * @param codeArray  The list of codes to utilize within the Measurement Objects
    	 * @param sortOption  The sort method to utilize when sorting the results in the Array.
    	 */
        LoadMeasurementDataMap: function(recordData, personnelArray, codeArray, sortOption){
            var mapObjects = [];
            var results = recordData.RESULTS;
            if (!codeArray) {
            	codeArray = MP_Util.LoadCodeListJSON(recordData.CODES);
            }
            if (!personnelArray) {
            	personnelArray = MP_Util.LoadPersonelListJSON(recordData.PRSNL);
            }
            for (var i = 0, il = results.length; i < il; i++) {
            	var result = results[i];
                if (result.CLINICAL_EVENTS.length > 0) {
                    for (var j = 0, jl = result.CLINICAL_EVENTS.length; j < jl; j++) {
                        var measureArray = [];
                        var mapObject = null;
                        if (result.EVENT_CD > 0) {
                            mapObject = new MP_Core.MapObject(result.EVENT_CD, measureArray);
                        }
                        else {
                            mapObject = new MP_Core.MapObject(result.EVENT_SET_NAME, measureArray);
                        }
                        var meas = result.CLINICAL_EVENTS[j];
                        for (var k = 0, kl = meas.MEASUREMENTS.length; k < kl; k++) {
                            var measurement = new MP_Core.Measurement();
                            measurement.initFromRec(meas.MEASUREMENTS[k], codeArray);
                            measureArray.push(measurement);
                        }
                        
                        if (measureArray.length > 0) {
							if (sortOption) {
								measureArray.sort(sortOption);
							} else {
								measureArray.sort(CERN_MEASUREMENT_BASE_O1.SortByEffectiveDateDesc);
							}
							mapObjects.push(mapObject);
						}
                    }
                }
            }
            return mapObjects;
        },
    	/**
    	 * Loads the retrieved measurement data into a Array
    	 * @param recordData  The retrieved JSON to parse into Measurement Objects
    	 * @param personnelArray  The list of personnel to utilize within the Measurement Objects
    	 * @param codeArray  The list of codes to utilize within the Measurement Objects
    	 * @param sortOption  The sort method to utilize when sorting the results in the Array.
    	 */
        LoadMeasurementDataArray: function(recordData, personnelArray, codeArray, sortOption){
            var measureArray = getMeasurementDataArray(recordData, personnelArray, codeArray);
            if (measureArray.length > 0) {
				if (sortOption) {
					measureArray.sort(sortOption);
				} else {
					measureArray.sort(CERN_MEASUREMENT_BASE_O1.SortByEffectiveDateDesc);
				}
			}
            return measureArray;
        },
    	/**
    	 * Loads the retrieved measurement data into a Array
    	 * @param recordData  The retrieved JSON to parse into Measurement Objects
    	 * @param personnelArray  The list of personnel to utilize within the Measurement Objects
    	 * @param codeArray  The list of codes to utilize within the Measurement Objects
    	 */        
    	LoadMeasurementDataArrayNoSort: function(recordData, personnelArray, codeArray){
    	    return getMeasurementDataArray(recordData,personnelArray, codeArray);
    	},
        /**
         * Sorts the list of Measurement Objects by the end effective date and time descending
         * @param a Measurement Object 1 to compare
         * @param b Measurement Object 2 to compare
         * @return Integer denoting the position to place a
         */
        SortByEffectiveDateDesc: function(a,b){
    		if (a.getDateTime() > b.getDateTime()) {
    			return -1;
    		} else if (a.getDateTime() < b.getDateTime()) {
    			return 1;
    		}
    		return 0;
        }
    };
}();
var CERN_DEMO_BANNER_O1 = function() {
	
	/**
	 * Initialize certain hovers in the demographics banner
	 * @param trg The CSS class applied to the HTML elements which will have hovers set up.
	 * @param par The DOM element which contains the elements to setup hovers for.
	 */
	function initHoversDemoBanner(trg, par) {
		gen = Util.Style.g(trg, par, "SPAN");
		for(var i = 0, l = gen.length; i < l; i++) {
			var m = gen[i];
			if(m) {
				var nm = Util.gns(Util.gns(m));
				if(nm) {
					if(Util.Style.ccss(nm, "hvr")) {
						hs(m, nm);
					}
				}
			}
		}
	}
	
	return {
		/*
		 * Retrieve the patient demographics and format the information for display in the patient demo banner.
		 * @param demoBanner The DOM element where the demographic information will be inserted
		 * @param criterion The criterion object which contains important patient contextual information
		 * @return null
		 */
		GetPatientDemographics : function(demoBanner, criterion) {
			//  Call the ccl progam and send the parameter string
			var sendAr = ["^MINE^", criterion.person_id + ".0", criterion.encntr_id + ".0"];

			//Initialize a request that doesn't use the component load timer. Ascync is true by default
			var request = new MP_Core.ScriptRequest(null, "USR:MPG.DEMO_BANNER.O1 - load component");
			request.setArtifactInfo({
				artifactId: "demo-banner-o1",
				functionName: "GetPatientDemographics"
			});
			request.setProgramName("MP_GET_PATIENT_DEMO");
			request.setParameters(sendAr);
			//Update the status. When the script is done, it reloads the component
			MP_Core.XMLCCLRequestCallBack(null, request, function(replyObj) {
				MP_Util.LogScriptCallInfo(null, this, "demobanner.js", "GetPatientDemographics");
				var recordData = replyObj.getResponse();
				//When request comes back unsuccessfully, it will return immediately
				if(!recordData){
					return;
				}
				try {
					var timer = MP_Util.CreateTimer("ENG:MPG.DEMO_BANNER.O1 - render component");
					var age = "";
					var birthDate = "";
					var birthDtTm = new Date();
					var codeArray = null;
					var deceasedDate = "";
					var deceasedDtTm = new Date();
					var enCodeArray = [];
					var finNbr = "";
					var i = 0;
					var isolation = "";
					var j = 0;
					var jsHTML = [];
					var localBirthDtTm = new Date();
					var localDeceasedDtTm = new Date();
					var mrnNbr = "";
					var nameFull = "";
					var patInfo = null;
					var ptCodeArray = [];
					var sexDisp = "";
					var sexObj = null;
					var visitReason = "";

					codeArray = MP_Util.LoadCodeListJSON(recordData.CODES);
					patInfo = recordData.DEMOGRAPHICS.PATIENT_INFO;
					nameFull = patInfo.PATIENT_NAME.NAME_FULL;

					//Determine the patient's age based on the absolute date stored in the DB or the calculated date and time
					if(patInfo.ABS_BIRTH_DT_TM !== "") {
						var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";
						var d = patInfo.ABS_BIRTH_DT_TM.match(new RegExp(regexp));
						birthDtTm = new Date(d[1], d[3] - 1, d[5], d[7], d[8], d[10]);
						birthDate = birthDtTm.format("shortDate2");
					} else if(patInfo.BIRTH_DT_TM !== "") {
						birthDtTm.setISO8601(patInfo.BIRTH_DT_TM);
						birthDate = birthDtTm.format("shortDate2");
					}

					//Check the deceased date of the patient and populate if available
					if(patInfo.DECEASED_DT_TM !== "") {
						deceasedDtTm.setISO8601(patInfo.DECEASED_DT_TM);
						deceasedDate = deceasedDtTm.format("shortDate2");
					}

					//Calculate the correct age of the patient based on the local time of birth and death
					if(patInfo.LOCAL_DECEASED_DT_TM && patInfo.LOCAL_BIRTH_DT_TM) {
						localBirthDtTm.setISO8601(patInfo.LOCAL_BIRTH_DT_TM);
						localDeceasedDtTm.setISO8601(patInfo.LOCAL_DECEASED_DT_TM);
						age = MP_Util.CalcAge(localBirthDtTm, localDeceasedDtTm);
					} else if(patInfo.LOCAL_BIRTH_DT_TM) {
						localBirthDtTm.setISO8601(patInfo.LOCAL_BIRTH_DT_TM);
						age = MP_Util.CalcAge(localBirthDtTm);
					}

					//codeObject.display - will give the display name associated with the code value
					var encntrInfo = recordData.DEMOGRAPHICS.ENCOUNTER_INFO;
					for(j = 0, e = encntrInfo.length; j < e; j++) {
						visitReason = encntrInfo[j].REASON_VISIT;
						for(i = 0, l = encntrInfo[j].ALIAS.length; i < l; i++) {
							enCodeArray[i] = MP_Util.GetValueFromArray(encntrInfo[j].ALIAS[i].ALIAS_TYPE_CD, codeArray);
							if(enCodeArray[i].meaning == "FIN NBR") {
								finNbr = encntrInfo[j].ALIAS[i].FORMATTED_ALIAS;
							}
							if(enCodeArray[i].meaning == "MRN") {
								mrnNbr = encntrInfo[j].ALIAS[i].FORMATTED_ALIAS;
							}
						}
						if(encntrInfo[j].ISOLATION_CD > 0) {
							var isoObj = MP_Util.GetValueFromArray(encntrInfo[j].ISOLATION_CD, codeArray);
							isolation = isoObj.display;
						}
					}
					//If did not find MRN look in Patient ALIAS
					aliasArry = recordData.DEMOGRAPHICS.PATIENT_INFO.ALIAS;
					if(mrnNbr === "") {
						for(i = 0, l = aliasArry.length; i < l; i++) {
							ptCodeArray[i] = MP_Util.GetValueFromArray(aliasArry[i].ALIAS_TYPE_CD, codeArray);
							if(ptCodeArray[i].meaning == "MRN") {
								mrnNbr = aliasArry[i].FORMATTED_ALIAS;
							}
						}
					}

					//Retrieve the sex display
					sexObj = MP_Util.GetValueFromArray(patInfo.SEX_CD, codeArray);
					sexDisp = (sexObj) ? sexObj.display : i18n.UNKNOWN;

					//Populate the Demo Banner HTML
					jsHTML.push("<div id='demobanner'", criterion.category_mean, "><dl class='dmg-info'><dt class='dmg-pt-name-lbl'><span>", i18n.NAME, "</span></dt><dd class='dmg-pt-name'><span>", nameFull, "</span></dd><dt class='dmg-sex-lbl'><span>", i18n.SEX, " ", "</span></dt><dd class='dmg-sex'><span>", sexDisp, " ", "</span></dd><dt class='dmg-age-lbl'><span>", i18n.AGE, "</span></dt>");
					if(deceasedDate !== "") {
						jsHTML.push("<span class='dmg-deceased'>", age, "</span><h4 class='det-hd'><span class='dmg-info'>", i18n.AGE, "</span></h4><div class='hvr'><dl class='dmg-info'><dt class='dmg-info'><span >", i18n.DECEASED, ":</span></dt><dd class='dmg-info'><span>", deceasedDate, "</span></dd></dl></div>");
					} else {
						jsHTML.push("<dd class='dmg-age'><span>", age, "</span></dd>");
					}
					jsHTML.push("<dt><span>", i18n.DOB, ":</span></dt><dd class='dmg-dob'><span>", birthDate, "</span></dd><dt><span>", i18n.MRN, ":</span></dt><dd class='dmg-mrn'><span>", mrnNbr, "</span></dd><dt><span>", i18n.FIN, ":</span></dt><dd class='dmg-fin'><span>", finNbr, "</span></dd><dt><span>", i18n.ISOLATION, ":</span></dt><dd class='dmg-isolation'><span>", isolation, "</span></dd><dt><span>", i18n.VISIT_REASON, ":</span></dt><dd class='dmg-rfv'><span>", visitReason, "</span></dd></dl></div>");

					demoBanner.innerHTML = jsHTML.join("");
					initHoversDemoBanner("dmg-deceased", _g("demobanner" + criterion.category_mean));
				} catch(err) {
					MP_Util.LogJSError(err, null, "demobanner.js", "GetPatientDemographics");
					if(timer) {
						timer.Abort();
						timer = null;
					}
				} finally {
					if(timer) {
						timer.Stop();
					}
				}
			});
		}
	};

}();
/* globals  CERN_EventListener,PregnancyUtils*/
/* eslint "new-cap":[2, {"capIsNewExceptions": ["LoadDeliveryData","Stop","CreateTimer","ReopenPregnancy","AddPregnancy","AddCustomizeLink","AddPageTitle","GetDeliveryData","XMLCCLRequestCallBack","LoadPregnancyData","LogDiscernInfo","DiscernObjectFactory","LogJSError","LogError","GetDateFormatter","GetPregnancyData"]}]*/
/* eslint complexity: 0*/
/* eslint-disable deprecated-functions*/
/* eslint-disable no-undef*/
/* eslint-disable eqeqeq*/
/* eslint-disable consistent-return*/
/* eslint-disable one-var*/
/**
 * The pregnancyInfo object is used to store information about a specific
 * pregnancy.
 * @returns {undefined}
 */
function PregnancyInfo() {
    /** @private */
    /* eslint-disable no-unused-vars*/
    /* eslint-disable mp-camelcase*/
    /* eslint-disable valid-jsdoc*/
    var m_criterion = null;
    // had to make this a global so that the inline function, addOrReopenPregnancy could consume it
    /** @private */
    var m_delGesAge = 0;
    /** @private */
    var m_deliveryDt = 0;
    /** @private */
    var m_eddDt = 0;
    /** @private */
    var m_eddId = 0.0;
    /** @private */
    var m_gesAge = 0;
    /** @private */
    var m_label = "";
    /** @private */
    var m_lookBack = 0;
    // based on today minus onset date
    /** @private */
    var m_onsetDate = null;
    /** @private */
    var m_pregId = 0.0;
    /** @private */
    var m_reopenPregInd = 0;
    /** @private */
    var m_rtLookBack = 0;
    /** @private */
    var m_patientDelivered = 0;
    /** @private */
    var m_calculatedEga = 0;
    // based on gestational age at delivery plus (today minus delivery date)

    /** Getters **/
    this.getDelGesAge = function() {
        return m_delGesAge;
    };
    this.getDeliveryDate = function() {
        return m_deliveryDt;
    };
    this.getEddId = function() {
        return m_eddId;
    };
    this.getEstDeliveryDate = function() {
        return m_eddDt;
    };
    this.getGesAge = function() {
        return m_gesAge;
    };
    this.getLookBack = function() {
        return m_lookBack;
    };
    this.getOnsetDate = function() {
        return m_onsetDate;
    };
    this.getPregnancyId = function() {
        return m_pregId;
    };
    this.getReopenPregInd = function() {
        return m_reopenPregInd;
    };
    this.getRtLookBack = function() {
        return m_rtLookBack;
    };
    /**
     * This function indicates whether patient has delivered
     * all the babies.
     *
     * @returns m_patientDelivered {boolean} -  Returns true if
     * the patient has delivered all the babies.
     */
    this.isPatientDelivered = function() {
        return m_patientDelivered;
    };
    /**
     * This functions returns the calculated EGA based on
     * whether patient is delivered or not.
     * @returns m_patientDelivered {int} -  Returns the
     * EGA for the patient
     */
    this.getCalculatedEga = function() {
        return m_calculatedEga;
    };
    /** Setters **/
    this.setDelGesAge = function(delgesAge) {
        m_delGesAge = delgesAge;
    };
    this.setDeliveryDate = function(deliveryDt) {
        m_deliveryDt = deliveryDt;
    };
    this.setEddId = function(eddId) {
        m_eddId = eddId;
    };
    this.setEstDeliveryDate = function(eddDt) {
        m_eddDt = eddDt;
    };
    this.setGesAge = function(gesAge) {
        m_gesAge = gesAge;
    };
    this.setLookBack = function(lookBack) {
        m_lookBack = lookBack;
    };
    this.setOnsetDate = function(onsetDate) {
        m_onsetDate = onsetDate;
    };
    this.setPregnancyId = function(pregId) {
        m_pregId = pregId;
    };
    this.setReopenPregInd = function(reopenInd) {
        m_reopenPregInd = reopenInd;
    };
    this.setRtLookBack = function(rtLookBack) {
        m_rtLookBack = rtLookBack;
    };
    /* This function sets patient delivery indicator.
     *
     * @param patientDeliveredInd {int} - indicates whether
     * all babies are delivered
     */
    this.setIsPatientDelivered = function(patientDelivered) {
     /* eslint-disable no-unneeded-ternary*/
        m_patientDelivered = patientDelivered > 0 ? true : false;
    };
    /* This function calculates the current EGA for the patient
     * based on whether patient has single baby or multiple babies.
     *
     * Mutiple Babies:
     * The CURRENT_GEST_AGE continues to calculate until all the babies
     * are delivered. Once all the babies are delivered, the CURRENT_GEST_AGE
     * is set to the latest GEST_AGE_AT_DELIVERY.
     *
     * Single Baby:
     * CURRENT_GEST_AGE will be zero and GEST_AGE_AT_DELIVERY will be having
     * delivery gestational age in days.
     *
     */
    this.setCalculatedEga = function() {
        m_calculatedEga = (this.getGesAge() === 0) ? this.getDelGesAge() : this.getGesAge();
    };
}

/* The Pregnancy Base Component is to allow for other 'pregnancy' based
 * components to share the same data. */
function PregnancyBaseUtilComponentStyle() {
    this.initByNamespace("pregbase");
}

PregnancyBaseUtilComponentStyle.inherits(ComponentStyle);
var PREGNANCY_BASE_UTIL_O1 = function() {
    this.m_retrievingData = false;
    this.m_label = "PregnancyBaseUtil";
    this.m_componentId = 0.0;
    this.m_criterion = null;
    this.m_deliveryData = null;

    function GetDeliveryData(reply) {
        var replyError = reply.getError();
        if(replyError === "" && replyError.length === 0) {
            var recordData = reply.getResponse();
            var replyStatus = recordData.STATUS_DATA.STATUS;
            if(replyStatus !== "F") {// success
                this.m_deliveryData = recordData;
                return this.m_deliveryData;
            }
        }
        return null;
    }
    function fmtDt(dt, mask) {
        if (dt) {
            var dateTime = new Date();
            dateTime.setISO8601(dt);
            if (mask) {
                return dateTime.format(mask);
            }
            else {
                return dateTime.format("longDateTime3");
            }
        }
        else {
            return "^^";
        }
    }
    return {
        /**
         * loads the pregnancy data into a shared resource
         * @param {Object} criterion - the criterion JSON data
         * @param {Boolean} asynch - whether the data should be accessed via asynchronous call
         * @param {function} resolve - promise resolve for async API
         */
        LoadPregnancyData: function(criterion, asynch, resolve) {
            var request = null;
            var sendArr = [];
            var callbackFunc = null;
            // set default value of asynch parameter
            /* eslint-disable quotes*/
            asynch = typeof asynch !== 'undefined' ? asynch : true;
            // Store the criterion object for later use
            this.m_criterion = criterion;

            // Check to see if the data is currently being retrieved
            if(this.m_retrievingData) {
                // Data already being retrieved
                return;
            }

            // Indicate that data is being retrieved
            this.m_retrievingData = true;
            sendArr.push("^MINE^", criterion.person_id + ".0", criterion.encntr_id + ".0", criterion.provider_id + ".0", criterion.ppr_cd + ".0", criterion.position_cd + ".0" );
            request = new MP_Core.ScriptRequest(PREGNANCY_BASE_UTIL_O1, "ENG:MPG.PregnancyBaseUtil.O1 - LoadPregnancyData");
            request.setProgramName("MP_GET_EGA_DATA");
            request.setParameters(sendArr);
            request.setAsync(asynch);
            callbackFunc = function(recordData) {
                PREGNANCY_BASE_UTIL_O1.GetPregnancyData(recordData, true);
				if (typeof resolve === "function") {
					resolve();
				}
            };
            MP_Core.XMLCCLRequestCallBack(PREGNANCY_BASE_UTIL_O1, request, callbackFunc);
        },
        /**
         * loads the pregnancy data into a shared resource asynchronously
         * @param {Object} criterion - the criterion JSON data
         * @param {Boolean} asynch - whether the data should be accessed via asynchronous call
         * @returns {Promise}
         * */
        LoadPregnancyDataAsync: function(criterion, asynch) {
            return new Promise(function(resolve, reject) {
                PREGNANCY_BASE_UTIL_O1.LoadPregnancyData(criterion, asynch, resolve);
            });
        },
        LoadDeliveryData: function(sendVal, callback) {
            var request = new MP_Core.ScriptRequest(PREGNANCY_BASE_UTIL_O1, "ENG:MPG.PregnancyBaseUtil.O1 - LoadDeliveryData");
            request.setProgramName("MP_GET_DELIVERY_SUMMARY");
            request.setParameters(sendVal);
            request.setAsync(true);
            MP_Core.XMLCCLRequestCallBack(PREGNANCY_BASE_UTIL_O1, request, function(reply) {
                // The GetDeliveryData function returns the deliveryData information needed
                callback(GetDeliveryData(reply));
            });
        },
        CheckPregnancySummaryLoadRequirement: function(viewPointInd) {
            var patInfo = this.m_criterion.getPatientInfo();
            var errorString = "";
            var addButtonHTML = "";
            var reopenButtonHTML = "";
            var errorOccured = false;
            var helpFile, helpURL;
            var bodyHTML = "";

            var isfemale = false;
             // if female
            if (patInfo.getBirthSex()) {
                if (patInfo.getBirthSex().meaning === 'FEMALE') {
                    this.isfemale = true;
                }
            }
            // Checking if patient's admin sex is female
            if (patInfo.getAdminSex()) {
                if (patInfo.getAdminSex().meaning === 'FEMALE') {
                    this.isfemale = true;
                }
            }

            // Check to make sure the patient is a female with an active pregnancy
            if (this.isfemale === true ) {
                // check if the patient is pregnant -- pregnancy id -- if pregnancy id  < 0, show
                // error -- something went wrong
                if(m_pregId < 0) {
                    errorString = pregnancyBaseUtili18n.RETREIVING_PREG_ERROR;
                    errorOccured = true;
                }
                // pregnancy id -- if pregnancy id  == 0, show error need active preg
                else if(m_pregId === 0) {
                    errorString = pregnancyBaseUtili18n.NOACTIVE_PREG_ERROR;
                    addButtonHTML = '<input type="button" OnClick="PREGNANCY_BASE_UTIL_O1.addOrReopenPregnancy(0);" value="' + pregnancyBaseUtili18n.ADD_PREGNANCY + '">';
                    errorOccured = true;
                    if(m_reopenPregInd == 1) {
                        reopenButtonHTML = '<input type="button" OnClick="PREGNANCY_BASE_UTIL_O1.addOrReopenPregnancy(1);" value="' + pregnancyBaseUtili18n.REOPEN_PREGNANCY + '">';
                    }
                }
            }
            else {// else show not female error
                errorString = pregnancyBaseUtili18n.NOTFEMALE_ERROR;
                errorOccured = true;
            }
            if(errorOccured) {
                // add the help link
                if(this.m_criterion.help_file_local_ind == 1) {
                    helpFile = this.m_criterion.static_content + "pregnancysummary/index.html";
                }
                else {
                    helpURL = "https://wiki.ucern.com/display/r1mpagesHP/Pregnancy+Summary+Help";
                }

                // add the title
                if(viewPointInd) {
                    MP_Util.Doc.AddPageTitle(pregnancyBaseUtili18n.PREGNANCY_SUMMARY, document.body, this.m_criterion.debug_ind, true, null, helpFile, helpURL, this.m_criterion, this.m_criterion.category_mean);
                }
                else {
                    MP_Util.Doc.AddPageTitle(pregnancyBaseUtili18n.PREGNANCY_SUMMARY, document.body, this.m_criterion.debug_ind, true, null, helpFile, helpURL, this.m_criterion);
                }
                MP_Util.Doc.AddCustomizeLink(this.m_criterion);

                // store the current document body
                var demoHTML = [ "<div class='pregbase-error-content'><span class=pregbase-alert-icon title=", pregnancyBaseUtili18n.ALERT, ":></span><span class=pregbase-error-text>", errorString, "</span><span class=pregbase-addpreg-button>", addButtonHTML, "</span><span class=pregbase-reopenpreg-button>", reopenButtonHTML, "</span></div>" ];
                var demoarray = demoHTML.join('');

                if(viewPointInd) {
                    bodyHTML = _g(this.m_criterion.category_mean);
                    bodyHTML.innerHTML = bodyHTML.innerHTML + demoarray;
                }
                else {
                    bodyHTML = document.body.innerHTML;
                    document.body.innerHTML = bodyHTML + demoarray;
                }
            }

            return errorOccured;
        },
        addOrReopenPregnancy: function(addOrReOpenFlag) {
            var self = this;
            try {
                if(addOrReOpenFlag === 0) {
                    return PregnancyUtils.addPregnancy(self.m_criterion.person_id, self.m_criterion.encntr_id).then(function(){
                        PREGNANCY_BASE_UTIL_O1.LoadPregnancyData(self.m_criterion);
                        return true;
                    }).catch(function(){
                        MP_Util.LogError(i18n.discernabu.pregnancybaseutil_o1.PREG_FORM_OBJ_FAILURE);
                        return false;
                    });
                }
                else if(addOrReOpenFlag === 1) {
                    return PregnancyUtils.reopenPregnancy(self.m_criterion.person_id, self.m_criterion.encntr_id).then(function(){
                        PREGNANCY_BASE_UTIL_O1.LoadPregnancyData(self.m_criterion);
                        return true;
                    }).catch(function(){
                        MP_Util.LogError(i18n.discernabu.pregnancybaseutil_o1.PREG_FORM_OBJ_FAILURE);
                        return false;
                    });
                }
            }
            catch(error) {
                if(addOrReOpenFlag === 0) {
                    MP_Util.LogError(i18n.discernabu.pregnancybaseutil_o1.ADDPREGNANCY_EXCEPTION);
                }
                else {
                    MP_Util.LogError(i18n.discernabu.pregnancybaseutil_o1.REOPENPREGNANCY_EXCEPTION);
                }
            }
        },
        GetPregnancyData: function(reply, notifyConsumers) {
            var dateDiff = null;
            var daysOfLife = null;
            var deliveryDate = null;
            var pregDeliveredInd = null;
            var pregInfoObj = null;
            var pregResource = null;
            var replyError = null;
            var tempDate = null;
            var todayDate = null;

            // Update the date retrieval flags
            this.m_retrievingData = false;
            replyError = reply.getError();
            if(replyError === "" && replyError.length === 0) {
                var recordData = reply.getResponse();
                var replyStatus = recordData.STATUS_DATA.STATUS;
                if(replyStatus == "S") {// success
                    pregInfoObj = new PregnancyInfo();
                    pregInfoObj.setPregnancyId(recordData.GESTATION_INFO[0].PREGNANCY_ID);
                    pregInfoObj.setLookBack(recordData.LOOKBACK_DAYS);
                    pregInfoObj.setReopenPregInd(recordData.REOPEN_PREG_IND);
                    pregInfoObj.setGesAge(recordData.GESTATION_INFO[0].CURRENT_GEST_AGE);
                    pregInfoObj.setDelGesAge(recordData.GESTATION_INFO[0].GEST_AGE_AT_DELIVERY);
                    pregInfoObj.setCalculatedEga();
                    pregInfoObj.setEstDeliveryDate(recordData.GESTATION_INFO[0].EST_DELIVERY_DATE_FORMATTED);
                    pregInfoObj.setEddId(recordData.GESTATION_INFO[0].EDD_ID);
                    pregInfoObj.setIsPatientDelivered(recordData.GESTATION_INFO[0].PATIENT_DELIVERED_IND);
                    // Set the onset date information
                    if(recordData.ONSET_DATE) {
                        tempDate = new Date();
                        tempDate.setISO8601(recordData.ONSET_DATE);
                        pregInfoObj.setOnsetDate(tempDate);
                    }

                    // timeline lookback = gestational age if not delivered
                    pregDeliveredInd = recordData.GESTATION_INFO[0].DELIVERED_IND;
                    pregInfoObj.setRtLookBack(pregInfoObj.getCalculatedEga());
                    // Check whether patient is delivered
                    if(pregInfoObj.isPatientDelivered()) {
                        todayDate = new Date();
                        var deliveryDateFormatted = recordData.GESTATION_INFO[0].DELIVERY_DATE_FORMATTED;
                        pregInfoObj.setDeliveryDate(deliveryDateFormatted);
                        pregInfoObj.setRtLookBack(pregInfoObj.getDelGesAge());
                        deliveryDate = new Date();
                        deliveryDate.setISO8601(deliveryDateFormatted);
                        dateDiff = todayDate - deliveryDate;
                        daysOfLife = Math.round(dateDiff / (1000 * 60 * 60 * 24));
                        pregInfoObj.setRtLookBack(pregInfoObj.getRtLookBack() + daysOfLife);
                    }
                }
                else if(recordData.STATUS_DATA.STATUS == "Z") {// no pregnancy
                    pregInfoObj = new PregnancyInfo();
                    pregInfoObj.setPregnancyId(0);
                    pregInfoObj.setReopenPregInd(recordData.REOPEN_PREG_IND);
                    var mPageTimer = MP_Util.CreateTimer("CAP:MPG.Pregnancy Data Retrieval");
                    if(mPageTimer) {
                        mPageTimer.SubTimerName = "Patient Not Pregnant";
                        mPageTimer.Stop();
                    }
                }
            }
            else {
                pregInfoObj = new PregnancyInfo();
                pregInfoObj.setPregnancyId(-1);
            }

            // Create or update the Shared Resource for all pregnancy components to use.
            pregResource = MP_Resources.getSharedResource("pregnancyInfo");
            if(pregResource) {
                // Update the shared resource and notify consumers
                MP_Resources.setSharedResourceData("pregnancyInfo", pregInfoObj);
            }
            else {
                pregResource = new SharedResource("pregnancyInfo");
                pregResource.setResourceData(pregInfoObj);
                pregResource.setIsAvailable(true);
                pregResource.setIsBeingRetrieved(false);
                pregResource.setEventListenerFlag("pregnancyInfoAvailable");
                // Set to null so all MPages and Components receive the event
                pregResource.setEventListenerObject(new MPageComponent());
                MP_Resources.addSharedResource("pregnancyInfo", pregResource);
            }

            // Need to check this flag because this resource may be retrieved prior to
            // rendering the MPage and
            // notifying the consumers causes them to render.
            if(notifyConsumers) {
                pregResource.notifyResourceConsumers();
            }
        },
        getLabel: function() {
            return this.m_label;
        },
        getComponentId: function() {
            return this.m_componentId;
        },
        getDeliveryData: function(sendAr, callbackFunc) {
            if(!this.m_deliveryData) {
                PREGNANCY_BASE_UTIL_O1.LoadDeliveryData(sendAr, callbackFunc);
            }
            return this.m_deliveryData;
        },
        setCriterion: function(criterion) {
            this.m_criterion = criterion;
        }
    };
}();
